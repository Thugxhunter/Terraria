// Decompiled with JetBrains decompiler
// Type: Terraria.WorldGen
// Assembly: Terraria, Version=1.4.4.9, Culture=neutral, PublicKeyToken=null
// MVID: CD1A926A-5330-4A76-ABC1-173FBEBCC76B
// Assembly location: D:\SteamLibrary\steamapps\common\Terraria\Terraria.exe

using Microsoft.Xna.Framework;
using ReLogic.Utilities;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using Terraria.Audio;
using Terraria.Chat;
using Terraria.DataStructures;
using Terraria.Enums;
using Terraria.GameContent;
using Terraria.GameContent.Achievements;
using Terraria.GameContent.Biomes;
using Terraria.GameContent.Creative;
using Terraria.GameContent.Events;
using Terraria.GameContent.Generation;
using Terraria.GameContent.Tile_Entities;
using Terraria.GameContent.UI.States;
using Terraria.Graphics.Capture;
using Terraria.ID;
using Terraria.IO;
using Terraria.Localization;
using Terraria.Map;
using Terraria.ObjectData;
using Terraria.UI;
using Terraria.Utilities;
using Terraria.WorldBuilding;

namespace Terraria
{
  public class WorldGen
  {
    public static TownRoomManager TownManager = new TownRoomManager();
    private static Queue<Action<StructureMap>> _postGenActions = new Queue<Action<StructureMap>>();
    public static int tileReframeCount;
    public static bool noMapUpdate;
    public static int treeBG1;
    public static int treeBG2;
    public static int treeBG3;
    public static int treeBG4;
    public static int corruptBG;
    public static int jungleBG;
    public static int snowBG;
    public static int hallowBG;
    public static int crimsonBG;
    public static int desertBG;
    public static int oceanBG;
    public static int mushroomBG;
    public static int underworldBG;
    public static readonly int oceanDistance = 250;
    public static readonly int beachDistance = 380;
    public static readonly int shimmerSafetyDistance = 150;
    public static bool crimson;
    public static int[] tileCounts = new int[(int) TileID.Count];
    public static int totalEvil;
    public static int totalBlood;
    public static int totalGood;
    public static int totalSolid;
    public static int totalEvil2;
    public static int totalBlood2;
    public static int totalGood2;
    public static int totalSolid2;
    public static byte tEvil;
    public static byte tBlood;
    public static byte tGood;
    public static string currentWorldSeed;
    public static int totalX;
    public static int totalD;
    public static bool IsGeneratingHardMode;
    public static bool noTileActions;
    public static bool spawnEye;
    public static int spawnHardBoss;
    public static volatile bool gen;
    public static bool shadowOrbSmashed;
    public static int shadowOrbCount;
    public static int altarCount;
    public static bool spawnMeteor;
    public static bool loadFailed = false;
    public static bool loadSuccess = false;
    public static bool worldCleared;
    public static bool worldBackup;
    public static bool loadBackup = false;
    private static int lastMaxTilesX;
    private static int lastMaxTilesY;
    private static bool mergeUp;
    private static bool mergeDown;
    private static bool mergeLeft;
    private static bool mergeRight;
    private static bool stopDrops;
    public static bool noLiquidCheck;
    public static bool AllowedToSpreadInfections = true;
    [ThreadStatic]
    public static UnifiedRandom _genRand;
    [ThreadStatic]
    public static int _genRandSeed = -2;
    public static int _lastSeed;
    public static string statusText = "";
    public static bool destroyObject;
    public static int spawnDelay;
    public static int prioritizedTownNPCType;
    public static int numTileCount;
    public static int maxTileCount = 3500;
    public static int maxWallOut2 = 5000;
    public static Dictionary<Point, bool> CountedTiles = new Dictionary<Point, bool>(WorldGen.maxTileCount);
    public static int lavaCount;
    public static int iceCount;
    public static int sandCount;
    public static int rockCount;
    public static int shroomCount;
    public static int maxRoomTiles = 750;
    public static int numRoomTiles;
    public static int[] roomX = new int[WorldGen.maxRoomTiles];
    public static int[] roomY = new int[WorldGen.maxRoomTiles];
    public static int roomCeilingsCount;
    public static int[] roomCeilingX = new int[WorldGen.maxRoomTiles];
    public static int[] roomCeilingY = new int[WorldGen.maxRoomTiles];
    public static int roomX1;
    public static int roomX2;
    public static int roomY1;
    public static int roomY2;
    public static bool canSpawn;
    public static bool[] houseTile = new bool[(int) TileID.Count];
    public static int bestX;
    public static int bestY;
    public static int hiScore;
    private static bool roomTorch;
    private static bool roomDoor;
    private static bool roomChair;
    private static bool roomTable;
    private static bool roomOccupied;
    private static bool roomEvil;
    private static bool roomHasStinkbug;
    private static bool roomHasEchoStinkbug;
    public static int WorldGenParam_Evil = -1;
    public static readonly int cactusWaterWidth = 50;
    public static readonly int cactusWaterHeight = 25;
    public static readonly int cactusWaterLimit = 25;
    public static MysticLogFairiesEvent mysticLogsEvent = new MysticLogFairiesEvent();
    private static bool currentlyTryingToUseAlternateHousingSpot;
    private static int sharedRoomX;
    public static TownNPCRoomCheckFailureReason roomCheckFailureReason = TownNPCRoomCheckFailureReason.None;
    public const int WorldSizeSmallX = 4200;
    public const int WorldSizeSmallY = 1200;
    public const int WorldSizeMediumX = 6400;
    public const int WorldSizeMediumY = 1800;
    public const int WorldSizeLargeX = 8400;
    public const int WorldSizeLargeY = 2400;
    public const int InfectionAndGrassSpreadOuterWorldBuffer = 10;
    public static bool generatingWorld = false;
    private static int[,] trapDiag = new int[4, 2];
    private static bool[] gem = new bool[6];
    private static int[] mossType = new int[3];
    private static ushort neonMossType;
    private static int tileCounterNum;
    private static int tileCounterMax = 20;
    private static int[] tileCounterX = new int[WorldGen.tileCounterMax];
    private static int[] tileCounterY = new int[WorldGen.tileCounterMax];
    private static WorldGenerator _generator;
    public static int SmallConsecutivesFound = 0;
    public static int SmallConsecutivesEliminated = 0;
    public static bool tempRemixWorldGen = false;
    public static bool remixWorldGen = false;
    public static bool everythingWorldGen = false;
    public static bool noTrapsWorldGen = false;
    public static bool drunkWorldGen = false;
    public static bool getGoodWorldGen = false;
    public static bool tempTenthAnniversaryWorldGen = false;
    public static bool tenthAnniversaryWorldGen = false;
    public static bool dontStarveWorldGen = false;
    public static bool notTheBees = false;
    public static bool drunkWorldGenText = false;
    public static bool placingTraps = false;
    public const bool USE_FRAMING_SKIP_FOR_UNIMPORTANT_TILES_IN_WORLDGEN = false;
    private const int ItemSpawnProtectionTime = 18000;
    private static List<Color> _coatingColors = new List<Color>();
    private static int catTailDistance = 8;
    public static TreeTopsInfo TreeTops = new TreeTopsInfo();
    public static BackgroundChangeFlashInfo BackgroundsCache = new BackgroundChangeFlashInfo();
    private static int maxTreeShakes = 500;
    private static int numTreeShakes = 0;
    private static int[] treeShakeX = new int[WorldGen.maxTreeShakes];
    private static int[] treeShakeY = new int[WorldGen.maxTreeShakes];
    private static bool fossilBreak = false;
    public static Queue<Point> ExploitDestroyQueue = new Queue<Point>();
    private static bool growGrassUnderground = false;
    public const bool BUBBLES_SOLID_STATE_FOR_HOUSING = true;
    public static int grassSpread;
    private static Point[] heartPos = new Point[100];
    private static int heartCount;
    private const int strip_w = 200;
    private const int strip_h = 50;
    private static readonly Vertical64BitStrips bitStrip = new Vertical64BitStrips(202);
    public static bool noMapUpdateRefresh = false;
    private static bool skipFramingDuringGen = false;

    public static UnifiedRandom genRand
    {
      get
      {
        if (WorldGen._lastSeed != WorldGen._genRandSeed)
        {
          WorldGen._genRand = new UnifiedRandom(WorldGen._lastSeed);
          WorldGen._genRandSeed = WorldGen._lastSeed;
        }
        if (WorldGen._genRand == null)
        {
          WorldGen._genRand = new UnifiedRandom(WorldGen._lastSeed);
          WorldGen._genRandSeed = WorldGen._lastSeed;
        }
        return WorldGen._genRand;
      }
    }

    public static void SetupStatueList()
    {
      List<Point16> point16List = new List<Point16>();
      for (int Y = 0; Y < 44; ++Y)
        point16List.Add(new Point16(105, Y));
      point16List[34] = new Point16(349, 0);
      point16List[43] = new Point16(105, 50);
      point16List.Add(new Point16(105, 63));
      point16List.Add(new Point16(105, 64));
      point16List.Add(new Point16(105, 65));
      point16List.Add(new Point16(105, 66));
      point16List.Add(new Point16(105, 68));
      point16List.Add(new Point16(105, 69));
      point16List.Add(new Point16(105, 70));
      point16List.Add(new Point16(105, 71));
      point16List.Add(new Point16(105, 72));
      point16List.Add(new Point16(105, 73));
      point16List.Add(new Point16(105, 75));
      point16List.Add(new Point16(105, 51));
      point16List.Add(new Point16(105, 52));
      point16List.Add(new Point16(105, 53));
      point16List.Add(new Point16(105, 54));
      point16List.Add(new Point16(105, 55));
      point16List.Add(new Point16(105, 56));
      point16List.Add(new Point16(105, 57));
      point16List.Add(new Point16(105, 58));
      point16List.Add(new Point16(105, 59));
      point16List.Add(new Point16(105, 60));
      point16List.Add(new Point16(105, 61));
      point16List.Add(new Point16(105, 62));
      point16List.Add(new Point16(105, 77));
      point16List.Add(new Point16(105, 78));
      point16List.Add(new Point16(105, 67));
      point16List.Add(new Point16(105, 74));
      point16List.Add(new Point16(105, 37));
      point16List.Add(new Point16(105, 2));
      GenVars.statueList = point16List.ToArray();
    }

    public static void PlaceStatueTrap(int x, int y)
    {
      for (int index1 = -10; index1 <= 10; ++index1)
      {
        for (int index2 = -10; index2 <= 10; ++index2)
        {
          Tile testTile = Main.tile[x + index1, y + index2 + 1];
          Tile tile = Main.tile[x + index1, y + index2];
          if (!tile.active() && WorldGen.SolidTile2(testTile) && testTile.type != (ushort) 162)
          {
            WorldGen.PlaceTile(x + index1, y + index2, 135, true);
            if (tile.active() && tile.type == (ushort) 135)
            {
              WorldUtils.WireLine(new Point(x, y), new Point(x + index1, y + index2));
              return;
            }
          }
        }
      }
    }

    private static EntitySource_TileBreak GetProjectileSource_TileBreak(
      int x,
      int y)
    {
      return new EntitySource_TileBreak(x, y);
    }

    private static EntitySource_TileBreak GetNPCSource_TileBreak(int x, int y) => new EntitySource_TileBreak(x, y);

    public static EntitySource_ShakeTree GetNPCSource_ShakeTree(int x, int y) => new EntitySource_ShakeTree(x, y);

    private static EntitySource_ShakeTree GetProjectileSource_ShakeTree(
      int x,
      int y)
    {
      return new EntitySource_ShakeTree(x, y);
    }

    private static EntitySource_ShakeTree GetItemSource_ShakeTree(
      int x,
      int y)
    {
      return new EntitySource_ShakeTree(x, y);
    }

    private static IEntitySource GetProjectileSource_PlayerOrWires(
      int x,
      int y,
      bool fromWiring,
      Player player)
    {
      return fromWiring ? (IEntitySource) new EntitySource_Wiring(x, y) : (IEntitySource) new EntitySource_TileInteraction((Entity) player, x, y);
    }

    public static bool EmptyLiquid(int x, int y)
    {
      if (!WorldGen.InWorld(x, y))
        return false;
      Tile tile = Main.tile[x, y];
      if (tile == null)
        return false;
      int num = (int) tile.liquidType();
      if (tile.nactive() && Main.tileSolid[(int) tile.type] && !Main.tileSolidTop[(int) tile.type])
        return false;
      tile.Clear(TileDataType.Liquid);
      WorldGen.SquareTileFrame(x, y, false);
      if (Main.netMode != 0)
        NetMessage.sendWater(x, y);
      else
        Liquid.AddWater(x, y);
      return true;
    }

    public static bool PlaceLiquid(int x, int y, byte liquidType, byte amount)
    {
      if (!WorldGen.InWorld(x, y))
        return false;
      Tile tile = Main.tile[x, y];
      if (tile == null)
        return false;
      byte otherLiquidType = tile.liquidType();
      if (tile.nactive() && Main.tileSolid[(int) tile.type] && !Main.tileSolidTop[(int) tile.type])
        return false;
      if (tile.liquid == (byte) 0 || (int) liquidType == (int) otherLiquidType)
      {
        tile.liquidType((int) liquidType);
        if ((int) amount + (int) tile.liquid > (int) byte.MaxValue)
          amount = (byte) ((uint) byte.MaxValue - (uint) tile.liquid);
        tile.liquid += amount;
        WorldGen.SquareTileFrame(x, y);
        if (Main.netMode != 0)
          NetMessage.sendWater(x, y);
        return true;
      }
      int liquidMergeTileType = 0;
      bool waterNearby = otherLiquidType == (byte) 0;
      bool lavaNearby = otherLiquidType == (byte) 1;
      bool honeyNearby = otherLiquidType == (byte) 2;
      bool shimmerNearby = otherLiquidType == (byte) 3;
      int liquidMergeType = 0;
      Liquid.GetLiquidMergeTypes((int) liquidType, out liquidMergeTileType, out liquidMergeType, waterNearby, lavaNearby, honeyNearby, shimmerNearby);
      if (liquidMergeTileType == 0)
        return false;
      tile.liquid = (byte) 0;
      tile.liquidType(0);
      WorldGen.PlaceTile(x, y, liquidMergeTileType, true);
      WorldGen.SquareTileFrame(x, y);
      if (Main.netMode != 0)
        NetMessage.SendTileSquare(-1, x - 1, y - 1, WorldGen.GetLiquidChangeType((int) liquidType, (int) otherLiquidType));
      return true;
    }

    public static void PlayLiquidChangeSound(TileChangeType eventType, int x, int y, int count = 1)
    {
      switch (eventType)
      {
        case TileChangeType.LavaWater:
          SoundEngine.PlaySound(SoundID.LiquidsWaterLava, x * 16 + count * 8, y * 16 + count * 8);
          break;
        case TileChangeType.HoneyWater:
          SoundEngine.PlaySound(SoundID.LiquidsHoneyWater, x * 16 + count * 8, y * 16 + count * 8);
          break;
        case TileChangeType.HoneyLava:
          SoundEngine.PlaySound(SoundID.LiquidsHoneyLava, x * 16 + count * 8, y * 16 + count * 8);
          break;
        case TileChangeType.ShimmerWater:
          SoundEngine.PlaySound(19, x * 16 + count * 8, y * 16 + count * 8, 4);
          break;
        case TileChangeType.ShimmerLava:
          SoundEngine.PlaySound(19, x * 16 + count * 8, y * 16 + count * 8, 4);
          break;
        case TileChangeType.ShimmerHoney:
          SoundEngine.PlaySound(19, x * 16 + count * 8, y * 16 + count * 8, 4);
          break;
      }
    }

    public static TileChangeType GetLiquidChangeType(
      int liquidType,
      int otherLiquidType)
    {
      if (liquidType == 0 && otherLiquidType == 1 || liquidType == 1 && otherLiquidType == 0)
        return TileChangeType.LavaWater;
      if (liquidType == 0 && otherLiquidType == 2 || liquidType == 2 && otherLiquidType == 0)
        return TileChangeType.HoneyWater;
      if (liquidType == 1 && otherLiquidType == 2 || liquidType == 2 && otherLiquidType == 1)
        return TileChangeType.HoneyLava;
      if (liquidType == 0 && otherLiquidType == 3 || liquidType == 3 && otherLiquidType == 0)
        return TileChangeType.ShimmerWater;
      if (liquidType == 1 && otherLiquidType == 3 || liquidType == 3 && otherLiquidType == 1)
        return TileChangeType.ShimmerLava;
      return liquidType == 2 && otherLiquidType == 3 || liquidType == 3 && otherLiquidType == 2 ? TileChangeType.ShimmerHoney : TileChangeType.None;
    }

    public static bool MoveTownNPC(int x, int y, int n)
    {
      if (!WorldGen.StartRoomCheck(x, y))
      {
        string textValue = Lang.inter[40].Value;
        switch (WorldGen.roomCheckFailureReason)
        {
          case TownNPCRoomCheckFailureReason.TooCloseToWorldEdge:
            textValue = Language.GetTextValue("TownNPCHousingFailureReasons.TooCloseToWorldEdge");
            break;
          case TownNPCRoomCheckFailureReason.RoomIsTooBig:
            textValue = Language.GetTextValue("TownNPCHousingFailureReasons.RoomIsTooBig");
            break;
          case TownNPCRoomCheckFailureReason.RoomIsTooSmall:
            textValue = Language.GetTextValue("TownNPCHousingFailureReasons.RoomIsTooSmall");
            break;
          case TownNPCRoomCheckFailureReason.HoleInWallIsTooBig:
            textValue = Language.GetTextValue("TownNPCHousingFailureReasons.HoleInWallIsTooBig");
            break;
          case TownNPCRoomCheckFailureReason.RoomCheckStartedInASolidTile:
            textValue = Language.GetTextValue("TownNPCHousingFailureReasons.RoomCheckStartedInASolidTile");
            break;
        }
        Main.NewText(textValue, G: (byte) 240, B: (byte) 20);
        return false;
      }
      if (!WorldGen.RoomNeeds(WorldGen.prioritizedTownNPCType))
      {
        int index = 0;
        int length = (WorldGen.roomTorch ? 0 : 1) + (WorldGen.roomDoor ? 0 : 1) + (WorldGen.roomTable ? 0 : 1) + (WorldGen.roomChair ? 0 : 1);
        string[] strArray = new string[length];
        if (!WorldGen.roomTorch)
        {
          strArray[index] = Language.GetTextValue("Game.HouseLightSource");
          ++index;
        }
        if (!WorldGen.roomDoor)
        {
          strArray[index] = Language.GetTextValue("Game.HouseDoor");
          ++index;
        }
        if (!WorldGen.roomTable)
        {
          strArray[index] = Language.GetTextValue("Game.HouseTable");
          ++index;
        }
        if (!WorldGen.roomChair)
        {
          strArray[index] = Language.GetTextValue("Game.HouseChair");
          int num = index + 1;
        }
        Main.NewText(Language.GetTextValue("Game.HouseMissing_" + (object) length, (object[]) strArray), G: (byte) 240, B: (byte) 20);
        return false;
      }
      int npcTypeAskingToScoreRoom = WorldGen.prioritizedTownNPCType;
      if (n >= 0)
        npcTypeAskingToScoreRoom = Main.npc[n].type;
      bool flag = NPCID.Sets.IsTownPet[npcTypeAskingToScoreRoom];
      if (WorldGen.roomHasStinkbug && !flag)
      {
        Main.NewText(Language.GetTextValue("TownNPCHousingFailureReasons.RoomHasAStinkbug"), G: (byte) 240, B: (byte) 20);
        return false;
      }
      if (WorldGen.roomHasEchoStinkbug && !flag)
      {
        Main.NewText(Language.GetTextValue("TownNPCHousingFailureReasons.RoomHasAnEchoStinkbug"), G: (byte) 240, B: (byte) 20);
        return false;
      }
      WorldGen.ScoreRoom(npcTypeAskingToScoreRoom: npcTypeAskingToScoreRoom);
      if (WorldGen.hiScore <= 0)
      {
        if (WorldGen.roomOccupied)
          Main.NewText(Lang.inter[41].Value, G: (byte) 240, B: (byte) 20);
        else if (WorldGen.roomEvil)
          Main.NewText(Lang.inter[42].Value, G: (byte) 240, B: (byte) 20);
        else
          Main.NewText(Lang.inter[40].Value, G: (byte) 240, B: (byte) 20);
        return false;
      }
      if (n < 0 || WorldGen.CheckSpecialTownNPCSpawningConditions(Main.npc[n].type))
        return true;
      Main.NewText(Lang.inter[55].Value + " " + Main.npc[n].TypeName, G: (byte) 240, B: (byte) 20);
      return false;
    }

    public static void moveRoom(int x, int y, int n)
    {
      if (Main.netMode == 1)
      {
        NetMessage.SendData(60, number: n, number2: ((float) x), number3: ((float) y));
      }
      else
      {
        WorldGen.prioritizedTownNPCType = Main.npc[n].type;
        Main.npc[n].homeless = true;
        int num = (int) WorldGen.SpawnTownNPC(x, y);
        WorldGen.TownManager.SetRoom(Main.npc[n].type, Main.npc[n].homeTileX, Main.npc[n].homeTileY);
      }
    }

    public static bool IsNPCEvictable(int n)
    {
      if (n < 0)
        return false;
      Microsoft.Xna.Framework.Rectangle hitbox = Main.LocalPlayer.Hitbox;
      hitbox.Inflate(Main.LogicCheckScreenWidth / 2, Main.LogicCheckScreenHeight / 2);
      NPC npc = Main.npc[n];
      Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(npc.homeTileX * 16, npc.homeTileY * 16, 16, 16);
      return hitbox.Intersects(rectangle);
    }

    public static void kickOut(int n)
    {
      if (Main.netMode == 1)
      {
        NetMessage.SendData(60, number: n, number4: 1f);
      }
      else
      {
        Main.npc[n].homeless = true;
        WorldGen.TownManager.KickOut(Main.npc[n]);
      }
    }

    public static bool IsThereASpawnablePrioritizedTownNPC(
      int x,
      int y,
      ref bool canSpawnNewTownNPC)
    {
      if (WorldGen.CheckSpecialTownNPCSpawningConditions(WorldGen.prioritizedTownNPCType) && NPC.AnyNPCs(WorldGen.prioritizedTownNPCType))
      {
        canSpawnNewTownNPC = false;
        return true;
      }
      List<int> occupantsList = new List<int>();
      WorldGen.TownManager.AddOccupantsToList(x, y, occupantsList);
      for (int index1 = 0; index1 < occupantsList.Count; ++index1)
      {
        int index2 = occupantsList[index1];
        if (Main.townNPCCanSpawn[index2] && !NPC.AnyNPCs(index2) && WorldGen.CheckSpecialTownNPCSpawningConditions(index2))
        {
          WorldGen.prioritizedTownNPCType = index2;
          canSpawnNewTownNPC = true;
          return true;
        }
      }
      for (int index = 0; index < (int) NPCID.Count; ++index)
      {
        if (Main.townNPCCanSpawn[index] && WorldGen.CheckSpecialTownNPCSpawningConditions(index))
        {
          if (NPC.AnyNPCs(index))
          {
            Main.townNPCCanSpawn[index] = false;
          }
          else
          {
            if (WorldGen.TownManager.HasRoomQuick(index))
            {
              WorldGen.prioritizedTownNPCType = index;
              canSpawnNewTownNPC = true;
              return true;
            }
            if (!NPCID.Sets.IsTownPet[WorldGen.prioritizedTownNPCType] || NPCID.Sets.IsTownPet[index])
            {
              WorldGen.prioritizedTownNPCType = index;
              canSpawnNewTownNPC = true;
              return true;
            }
          }
        }
      }
      return false;
    }

    public static bool IsThereASpawnablePrioritizedTownNPC_Old(int x, int y)
    {
      if (WorldGen.CheckSpecialTownNPCSpawningConditions(WorldGen.prioritizedTownNPCType) && NPC.AnyNPCs(WorldGen.prioritizedTownNPCType))
        return true;
      List<int> occupantsList = new List<int>();
      WorldGen.TownManager.AddOccupantsToList(x, y, occupantsList);
      for (int index1 = 0; index1 < occupantsList.Count; ++index1)
      {
        int index2 = occupantsList[index1];
        if (Main.townNPCCanSpawn[index2] && !NPC.AnyNPCs(index2) && WorldGen.CheckSpecialTownNPCSpawningConditions(index2))
        {
          WorldGen.prioritizedTownNPCType = index2;
          return true;
        }
      }
      int num = -1;
      for (int index = 0; index < (int) NPCID.Count; ++index)
      {
        if (Main.townNPCCanSpawn[index] && WorldGen.CheckSpecialTownNPCSpawningConditions(index))
        {
          if (NPC.AnyNPCs(index))
            Main.townNPCCanSpawn[index] = false;
          else if (WorldGen.TownManager.HasRoomQuick(index))
          {
            if (num == -1)
              num = index;
          }
          else if (!NPCID.Sets.IsTownPet[WorldGen.prioritizedTownNPCType] || NPCID.Sets.IsTownPet[index])
          {
            WorldGen.prioritizedTownNPCType = index;
            return true;
          }
        }
      }
      if (num == -1)
        return false;
      WorldGen.prioritizedTownNPCType = num;
      return true;
    }

    public static bool CheckSpecialTownNPCSpawningConditions(int type)
    {
      if (type != 160)
        return true;
      if (!NPC.unlockedTruffleSpawn && (double) WorldGen.roomY2 > Main.worldSurface)
        return false;
      int startX;
      int endX;
      int startY;
      int endY;
      WorldGen.Housing_GetTestedRoomBounds(out startX, out endX, out startY, out endY);
      int num = 0;
      for (int index1 = startX + 1; index1 < endX; ++index1)
      {
        for (int index2 = startY + 2; index2 < endY + 2; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile.active() && (tile.type == (ushort) 70 || tile.type == (ushort) 71 || tile.type == (ushort) 72 || tile.type == (ushort) 528))
            ++num;
        }
      }
      return num >= SceneMetrics.MushroomTileThreshold;
    }

    public static void UnspawnTravelNPC()
    {
      int number = -1;
      for (int index = 0; index < 200; ++index)
      {
        if (Main.npc[index].active && Main.npc[index].type == 368)
        {
          number = index;
          break;
        }
      }
      if (number < 0)
        return;
      int num1 = (int) ((double) Main.npc[number].Center.X / 16.0);
      int num2 = (int) ((double) Main.npc[number].Center.Y / 16.0);
      bool flag = true;
      Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(num1 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num2 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
      for (int index = 0; index < (int) byte.MaxValue; ++index)
      {
        if (Main.player[index].active && new Microsoft.Xna.Framework.Rectangle((int) Main.player[index].position.X, (int) Main.player[index].position.Y, Main.player[index].width, Main.player[index].height).Intersects(rectangle))
        {
          flag = false;
          break;
        }
      }
      if (!flag)
        return;
      string fullName = Main.npc[number].FullName;
      switch (Main.netMode)
      {
        case 0:
          Main.NewText(Lang.misc[35].Format((object) fullName), (byte) 50, (byte) 125);
          break;
        case 2:
          ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[35].Key, (object) Main.npc[number].GetFullNetName()), new Color(50, 125, (int) byte.MaxValue));
          break;
      }
      Main.npc[number].active = false;
      Main.npc[number].netSkip = -1;
      Main.npc[number].life = 0;
      NetMessage.SendData(23, number: number);
    }

    public static void SpawnTravelNPC()
    {
      if (Main.eclipse || !Main.dayTime || Main.invasionType > 0 && Main.invasionDelay == 0 && Main.invasionSize > 0)
        return;
      for (int index = 0; index < 200; ++index)
      {
        if (Main.npc[index].active && Main.npc[index].type == 368)
          return;
      }
      Chest.SetupTravelShop();
      NetMessage.SendTravelShop(-1);
      int[] numArray = new int[200];
      int maxValue = 0;
      for (int index = 0; index < 200; ++index)
      {
        if (Main.npc[index].active && Main.npc[index].townNPC && Main.npc[index].type != 37 && !Main.npc[index].homeless)
        {
          numArray[maxValue] = index;
          ++maxValue;
        }
      }
      if (maxValue == 0)
        return;
      int index1 = numArray[Main.rand.Next(maxValue)];
      WorldGen.bestX = Main.npc[index1].homeTileX;
      WorldGen.bestY = Main.npc[index1].homeTileY;
      int minValue = WorldGen.bestX;
      int num1 = WorldGen.bestX;
      int bestY = WorldGen.bestY;
      for (int bestX = WorldGen.bestX; bestX > WorldGen.bestX - 10 && (WorldGen.SolidTile(bestX, bestY) || Main.tileSolidTop[(int) Main.tile[bestX, bestY].type]) && (!Main.tile[bestX, bestY - 1].active() || !Main.tileSolid[(int) Main.tile[bestX, bestY - 1].type] || Main.tileSolidTop[(int) Main.tile[bestX, bestY - 1].type]) && (!Main.tile[bestX, bestY - 2].active() || !Main.tileSolid[(int) Main.tile[bestX, bestY - 2].type] || Main.tileSolidTop[(int) Main.tile[bestX, bestY - 2].type]) && (!Main.tile[bestX, bestY - 3].active() || !Main.tileSolid[(int) Main.tile[bestX, bestY - 3].type] || Main.tileSolidTop[(int) Main.tile[bestX, bestY - 3].type]); --bestX)
        minValue = bestX;
      for (int bestX = WorldGen.bestX; bestX < WorldGen.bestX + 10 && (WorldGen.SolidTile(bestX, bestY) || Main.tileSolidTop[(int) Main.tile[bestX, bestY].type]) && (!Main.tile[bestX, bestY - 1].active() || !Main.tileSolid[(int) Main.tile[bestX, bestY - 1].type] || Main.tileSolidTop[(int) Main.tile[bestX, bestY - 1].type]) && (!Main.tile[bestX, bestY - 2].active() || !Main.tileSolid[(int) Main.tile[bestX, bestY - 2].type] || Main.tileSolidTop[(int) Main.tile[bestX, bestY - 2].type]) && (!Main.tile[bestX, bestY - 3].active() || !Main.tileSolid[(int) Main.tile[bestX, bestY - 3].type] || Main.tileSolidTop[(int) Main.tile[bestX, bestY - 3].type]); ++bestX)
        num1 = bestX;
      for (int index2 = 0; index2 < 30; ++index2)
      {
        int num2 = Main.rand.Next(minValue, num1 + 1);
        if (index2 < 20)
        {
          if (num2 < WorldGen.bestX - 1 || num2 > WorldGen.bestX + 1)
          {
            WorldGen.bestX = num2;
            break;
          }
        }
        else if (num2 != WorldGen.bestX)
        {
          WorldGen.bestX = num2;
          break;
        }
      }
      int index3 = WorldGen.bestX;
      int index4 = WorldGen.bestY;
      bool flag = false;
      if (!flag && (double) index4 <= Main.worldSurface)
      {
        for (int index5 = 20; index5 < 500; ++index5)
        {
          for (int index6 = 0; index6 < 2; ++index6)
          {
            index3 = index6 != 0 ? WorldGen.bestX - index5 * 2 : WorldGen.bestX + index5 * 2;
            if (index3 > 10 && index3 < Main.maxTilesX - 10)
            {
              int num3 = WorldGen.bestY - index5;
              double num4 = (double) (WorldGen.bestY + index5);
              if (num3 < 10)
                num3 = 10;
              if (num4 > Main.worldSurface)
                num4 = Main.worldSurface;
              for (int index7 = num3; (double) index7 < num4; ++index7)
              {
                index4 = index7;
                if (Main.tile[index3, index4].nactive() && Main.tileSolid[(int) Main.tile[index3, index4].type])
                {
                  if (Main.tile[index3, index4 - 3].liquid == (byte) 0 && Main.tile[index3, index4 - 2].liquid == (byte) 0 && Main.tile[index3, index4 - 1].liquid == (byte) 0 && !Collision.SolidTiles(index3 - 1, index3 + 1, index4 - 3, index4 - 1))
                  {
                    flag = true;
                    Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(index3 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, index4 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
                    for (int index8 = 0; index8 < (int) byte.MaxValue; ++index8)
                    {
                      if (Main.player[index8].active && new Microsoft.Xna.Framework.Rectangle((int) Main.player[index8].position.X, (int) Main.player[index8].position.Y, Main.player[index8].width, Main.player[index8].height).Intersects(rectangle))
                      {
                        flag = false;
                        break;
                      }
                    }
                    break;
                  }
                  break;
                }
              }
            }
            if (flag)
              break;
          }
          if (flag)
            break;
        }
      }
      int index9 = NPC.NewNPC(NPC.GetSpawnSourceForTownSpawn(), index3 * 16, index4 * 16, 368, 1);
      Main.npc[index9].homeTileX = WorldGen.bestX;
      Main.npc[index9].homeTileY = WorldGen.bestY;
      Main.npc[index9].homeless = true;
      if (index3 < WorldGen.bestX)
        Main.npc[index9].direction = 1;
      else if (index3 > WorldGen.bestX)
        Main.npc[index9].direction = -1;
      Main.npc[index9].netUpdate = true;
      string fullName = Main.npc[index9].FullName;
      if (Main.netMode == 0)
      {
        Main.NewText(Language.GetTextValue("Announcement.HasArrived", (object) fullName), (byte) 50, (byte) 125);
      }
      else
      {
        if (Main.netMode != 2)
          return;
        ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasArrived", (object) Main.npc[index9].GetFullNetName()), new Color(50, 125, (int) byte.MaxValue));
      }
    }

    public static TownNPCSpawnResult SpawnTownNPC(int x, int y)
    {
      if (Main.wallHouse[(int) Main.tile[x, y].wall])
        WorldGen.canSpawn = true;
      if (!WorldGen.canSpawn || !WorldGen.StartRoomCheck(x, y) || !WorldGen.RoomNeeds(WorldGen.prioritizedTownNPCType))
        return TownNPCSpawnResult.Blocked;
      int ahomelessNpc = WorldGen.FindAHomelessNPC();
      int index1 = WorldGen.prioritizedTownNPCType;
      if (ahomelessNpc != -1)
        index1 = Main.npc[ahomelessNpc].type;
      Point roomPosition1 = Point.Zero;
      bool flag1 = NPCID.Sets.IsTownPet[index1] && WorldGen.TownManager.HasRoom(index1, out roomPosition1);
      if ((WorldGen.roomHasStinkbug || WorldGen.roomHasEchoStinkbug) && !flag1)
        return TownNPCSpawnResult.Blocked;
      WorldGen.ScoreRoom(npcTypeAskingToScoreRoom: index1);
      if (WorldGen.hiScore <= 0)
        return TownNPCSpawnResult.Blocked;
      bool canSpawnNewTownNPC = true;
      if (!WorldGen.IsThereASpawnablePrioritizedTownNPC(WorldGen.bestX, WorldGen.bestY, ref canSpawnNewTownNPC))
        return TownNPCSpawnResult.Blocked;
      int prioritizedTownNpcType1 = WorldGen.prioritizedTownNPCType;
      if (ahomelessNpc != -1)
      {
        Main.townNPCCanSpawn[WorldGen.prioritizedTownNPCType] = false;
        Main.npc[ahomelessNpc].homeTileX = WorldGen.bestX;
        Main.npc[ahomelessNpc].homeTileY = WorldGen.bestY;
        Main.npc[ahomelessNpc].homeless = false;
        AchievementsHelper.NotifyProgressionEvent(8);
        WorldGen.prioritizedTownNPCType = 0;
        return TownNPCSpawnResult.RelocatedHomeless;
      }
      if (canSpawnNewTownNPC && ahomelessNpc == -1)
      {
        Point roomPosition2;
        if (WorldGen.TownManager.HasRoom(prioritizedTownNpcType1, out roomPosition2) && !WorldGen.currentlyTryingToUseAlternateHousingSpot)
        {
          int bestX = WorldGen.bestX;
          int bestY = WorldGen.bestY;
          WorldGen.currentlyTryingToUseAlternateHousingSpot = true;
          TownNPCSpawnResult townNpcSpawnResult = WorldGen.SpawnTownNPC(roomPosition2.X, roomPosition2.Y - 2);
          WorldGen.currentlyTryingToUseAlternateHousingSpot = false;
          WorldGen.bestX = bestX;
          WorldGen.bestY = bestY;
          if (townNpcSpawnResult == TownNPCSpawnResult.Successful)
            return townNpcSpawnResult;
        }
        int spawnTileX = WorldGen.bestX;
        int spawnTileY = WorldGen.bestY;
        int prioritizedTownNpcType2 = WorldGen.prioritizedTownNPCType;
        if (WorldGen.IsRoomConsideredAlreadyOccupied(spawnTileX, spawnTileY, prioritizedTownNpcType2))
          return TownNPCSpawnResult.BlockedInfiHousing;
        bool flag2 = false;
        if (!flag2)
        {
          flag2 = true;
          Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(spawnTileX * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, spawnTileY * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
          for (int index2 = 0; index2 < (int) byte.MaxValue; ++index2)
          {
            if (Main.player[index2].active && new Microsoft.Xna.Framework.Rectangle((int) Main.player[index2].position.X, (int) Main.player[index2].position.Y, Main.player[index2].width, Main.player[index2].height).Intersects(rectangle))
            {
              flag2 = false;
              break;
            }
          }
        }
        if (!flag2 && (double) spawnTileY <= Main.worldSurface)
        {
          for (int index3 = 1; index3 < 500; ++index3)
          {
            for (int index4 = 0; index4 < 2; ++index4)
            {
              spawnTileX = index4 != 0 ? WorldGen.bestX - index3 : WorldGen.bestX + index3;
              if (spawnTileX > 10 && spawnTileX < Main.maxTilesX - 10)
              {
                int num1 = WorldGen.bestY - index3;
                double num2 = (double) (WorldGen.bestY + index3);
                if (num1 < 10)
                  num1 = 10;
                if (num2 > Main.worldSurface)
                  num2 = Main.worldSurface;
                for (int index5 = num1; (double) index5 < num2; ++index5)
                {
                  spawnTileY = index5;
                  if (Main.tile[spawnTileX, spawnTileY].nactive() && Main.tileSolid[(int) Main.tile[spawnTileX, spawnTileY].type])
                  {
                    if (!Collision.SolidTiles(spawnTileX - 1, spawnTileX + 1, spawnTileY - 3, spawnTileY - 1))
                    {
                      flag2 = true;
                      Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(spawnTileX * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, spawnTileY * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
                      for (int index6 = 0; index6 < (int) byte.MaxValue; ++index6)
                      {
                        if (Main.player[index6].active && new Microsoft.Xna.Framework.Rectangle((int) Main.player[index6].position.X, (int) Main.player[index6].position.Y, Main.player[index6].width, Main.player[index6].height).Intersects(rectangle))
                        {
                          flag2 = false;
                          break;
                        }
                      }
                      break;
                    }
                    break;
                  }
                }
              }
              if (flag2)
                break;
            }
            if (flag2)
              break;
          }
        }
        int index7 = NPC.NewNPC(NPC.GetSpawnSourceForTownSpawn(), spawnTileX * 16, spawnTileY * 16, prioritizedTownNpcType1, 1);
        Main.townNPCCanSpawn[prioritizedTownNpcType1] = false;
        Main.npc[index7].homeTileX = WorldGen.bestX;
        Main.npc[index7].homeTileY = WorldGen.bestY;
        if (spawnTileX < WorldGen.bestX)
          Main.npc[index7].direction = 1;
        else if (spawnTileX > WorldGen.bestX)
          Main.npc[index7].direction = -1;
        Main.npc[index7].netUpdate = true;
        string fullName = Main.npc[index7].FullName;
        switch (Main.netMode)
        {
          case 0:
            Main.NewText(Language.GetTextValue("Announcement.HasArrived", (object) fullName), (byte) 50, (byte) 125);
            break;
          case 2:
            ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasArrived", (object) Main.npc[index7].GetFullNetName()), new Color(50, 125, (int) byte.MaxValue));
            break;
        }
        AchievementsHelper.NotifyProgressionEvent(8);
        switch (Main.npc[index7].type)
        {
          case 17:
            NPC.unlockedMerchantSpawn = true;
            break;
          case 18:
            NPC.unlockedNurseSpawn = true;
            break;
          case 19:
            NPC.unlockedArmsDealerSpawn = true;
            break;
          case 38:
            NPC.unlockedDemolitionistSpawn = true;
            break;
          case 160:
            AchievementsHelper.NotifyProgressionEvent(18);
            NPC.unlockedTruffleSpawn = true;
            NetMessage.SendData(7);
            break;
          case 207:
            NPC.unlockedDyeTraderSpawn = true;
            break;
          case 208:
            NPC.unlockedPartyGirlSpawn = true;
            break;
          case 663:
            NPC.unlockedPrincessSpawn = true;
            break;
          case 678:
            NPC.unlockedSlimeGreenSpawn = true;
            break;
        }
        WorldGen.CheckAchievement_RealEstateAndTownSlimes();
        WorldGen.prioritizedTownNPCType = 0;
      }
      return TownNPCSpawnResult.Successful;
    }

    private static int FindAHomelessNPC()
    {
      int ahomelessNpc = -1;
      for (int index = 0; index < 200; ++index)
      {
        if (Main.npc[index].active && Main.npc[index].homeless && Main.npc[index].type == WorldGen.prioritizedTownNPCType && WorldGen.CheckSpecialTownNPCSpawningConditions(Main.npc[index].type))
        {
          ahomelessNpc = index;
          break;
        }
      }
      return ahomelessNpc;
    }

    private static bool IsRoomConsideredAlreadyOccupied(
      int spawnTileX,
      int spawnTileY,
      int npcTypeToSpawn)
    {
      bool flag = false;
      for (int index = 0; index < 200; ++index)
      {
        NPC npc2 = Main.npc[index];
        if (npc2.active && npc2.townNPC && !npc2.homeless && npc2.homeTileX == spawnTileX && npc2.homeTileY == spawnTileY && !WorldGen.TownManager.CanNPCsLiveWithEachOther(npcTypeToSpawn, npc2))
        {
          flag = true;
          break;
        }
      }
      return flag;
    }

    public static void CheckAchievement_RealEstateAndTownSlimes()
    {
      bool[] flagArray = new bool[(int) NPCID.Count];
      for (int index = 0; index < 200; ++index)
      {
        if (Main.npc[index].active && Main.npc[index].type >= 0 && Main.npc[index].type < (int) NPCID.Count)
          flagArray[Main.npc[index].type] = true;
      }
      if (flagArray[38] && flagArray[17] && flagArray[107] && flagArray[19] && flagArray[22] && flagArray[124] && flagArray[228] && flagArray[178] && flagArray[18] && flagArray[229] && flagArray[209] && flagArray[54] && flagArray[108] && flagArray[160] && flagArray[20] && flagArray[369] && flagArray[207] && flagArray[227] && flagArray[208] && flagArray[441] && flagArray[353] && flagArray[550] && flagArray[588] && flagArray[633] && flagArray[663])
        AchievementsHelper.NotifyProgressionEvent(17);
      if (!flagArray[670] || !flagArray[678] || !flagArray[679] || !flagArray[680] || !flagArray[681] || !flagArray[682] || !flagArray[683] || !flagArray[684])
        return;
      AchievementsHelper.NotifyProgressionEvent(26);
    }

    public static bool RoomNeeds(int npcType)
    {
      WorldGen.roomChair = false;
      WorldGen.roomDoor = false;
      WorldGen.roomTable = false;
      WorldGen.roomTorch = false;
      for (int index = 0; index < TileID.Sets.RoomNeeds.CountsAsChair.Length; ++index)
      {
        if (WorldGen.houseTile[TileID.Sets.RoomNeeds.CountsAsChair[index]])
        {
          WorldGen.roomChair = true;
          break;
        }
      }
      for (int index = 0; index < TileID.Sets.RoomNeeds.CountsAsTable.Length; ++index)
      {
        if (WorldGen.houseTile[TileID.Sets.RoomNeeds.CountsAsTable[index]])
        {
          WorldGen.roomTable = true;
          break;
        }
      }
      for (int index = 0; index < TileID.Sets.RoomNeeds.CountsAsTorch.Length; ++index)
      {
        if (WorldGen.houseTile[TileID.Sets.RoomNeeds.CountsAsTorch[index]])
        {
          WorldGen.roomTorch = true;
          break;
        }
      }
      for (int index = 0; index < TileID.Sets.RoomNeeds.CountsAsDoor.Length; ++index)
      {
        if (WorldGen.houseTile[TileID.Sets.RoomNeeds.CountsAsDoor[index]])
        {
          WorldGen.roomDoor = true;
          break;
        }
      }
      WorldGen.canSpawn = WorldGen.roomChair && WorldGen.roomTable && WorldGen.roomDoor && WorldGen.roomTorch;
      return WorldGen.canSpawn;
    }

    public static void QuickFindHome(int npc)
    {
      bool flag = Main.tileSolid[379];
      Main.tileSolid[379] = true;
      if (Main.npc[npc].homeTileX > 10 && Main.npc[npc].homeTileY > 10 && Main.npc[npc].homeTileX < Main.maxTilesX - 10 && Main.npc[npc].homeTileY < Main.maxTilesY)
      {
        WorldGen.canSpawn = false;
        WorldGen.StartRoomCheck(Main.npc[npc].homeTileX, Main.npc[npc].homeTileY - 1);
        if (!WorldGen.canSpawn)
        {
          for (int x = Main.npc[npc].homeTileX - 1; x < Main.npc[npc].homeTileX + 2; ++x)
          {
            int y = Main.npc[npc].homeTileY - 1;
            while (y < Main.npc[npc].homeTileY + 2 && !WorldGen.StartRoomCheck(x, y))
              ++y;
          }
        }
        if (!WorldGen.canSpawn)
        {
          int num = 10;
          for (int x = Main.npc[npc].homeTileX - num; x <= Main.npc[npc].homeTileX + num; x += 2)
          {
            int y = Main.npc[npc].homeTileY - num;
            while (y <= Main.npc[npc].homeTileY + num && !WorldGen.StartRoomCheck(x, y))
              y += 2;
          }
        }
        if (WorldGen.canSpawn)
        {
          WorldGen.RoomNeeds(Main.npc[npc].type);
          if (WorldGen.canSpawn)
            WorldGen.ScoreRoom(npc, Main.npc[npc].type);
          if (WorldGen.canSpawn && WorldGen.hiScore > 0)
            WorldGen.canSpawn = WorldGen.IsRoomConsideredOccupiedForNPCIndex(npc);
          if (WorldGen.canSpawn && WorldGen.hiScore > 0)
          {
            Main.npc[npc].homeTileX = WorldGen.bestX;
            Main.npc[npc].homeTileY = WorldGen.bestY;
            Main.npc[npc].homeless = false;
            AchievementsHelper.NotifyProgressionEvent(8);
            WorldGen.canSpawn = false;
          }
          else
            Main.npc[npc].homeless = true;
        }
        else
          Main.npc[npc].homeless = true;
      }
      Main.tileSolid[379] = flag;
    }

    private static bool IsRoomConsideredOccupiedForNPCIndex(int npc)
    {
      bool flag = true;
      for (int index = 0; index < 200; ++index)
      {
        if (index != npc)
        {
          NPC npc2 = Main.npc[index];
          if (npc2.active && npc2.townNPC && !npc2.homeless && npc2.homeTileX == WorldGen.bestX && npc2.homeTileY == WorldGen.bestY && !WorldGen.TownManager.CanNPCsLiveWithEachOther(Main.npc[npc], npc2))
          {
            flag = false;
            break;
          }
        }
      }
      return flag;
    }

    private static bool ScoreRoom_IsThisRoomOccupiedBySomeone(int ignoreNPC = -1, int npcTypeAsking = -1)
    {
      for (int index1 = 0; index1 < 200; ++index1)
      {
        if (Main.npc[index1].active && Main.npc[index1].townNPC && ignoreNPC != index1 && !Main.npc[index1].homeless)
        {
          for (int index2 = 0; index2 < WorldGen.numRoomTiles; ++index2)
          {
            if (Main.npc[index1].homeTileX == WorldGen.roomX[index2] && Main.npc[index1].homeTileY == WorldGen.roomY[index2])
            {
              bool flag = false;
              for (int index3 = 0; index3 < WorldGen.numRoomTiles; ++index3)
              {
                if (Main.npc[index1].homeTileX == WorldGen.roomX[index3] && Main.npc[index1].homeTileY - 1 == WorldGen.roomY[index3])
                {
                  if (WorldGen.TownManager.CanNPCsLiveWithEachOther(npcTypeAsking, Main.npc[index1]))
                  {
                    WorldGen.sharedRoomX = Main.npc[index1].homeTileX;
                  }
                  else
                  {
                    flag = true;
                    break;
                  }
                }
              }
              if (flag)
                return true;
            }
          }
        }
      }
      return false;
    }

    public static void CountTileTypesInArea(
      int[] tileTypeCounts,
      int startX,
      int endX,
      int startY,
      int endY)
    {
      for (int index1 = startX; index1 <= endX; ++index1)
      {
        for (int index2 = startY; index2 <= endY; ++index2)
        {
          if (Main.tile[index1, index2].active())
            ++tileTypeCounts[(int) Main.tile[index1, index2].type];
        }
      }
    }

    public static int GetTileTypeCountByCategory(int[] tileTypeCounts, TileScanGroup group)
    {
      switch (group)
      {
        case TileScanGroup.None:
          return 0;
        case TileScanGroup.Corruption:
          return tileTypeCounts[23] + tileTypeCounts[24] + tileTypeCounts[25] + tileTypeCounts[32] + tileTypeCounts[112] + tileTypeCounts[163] + tileTypeCounts[400] + tileTypeCounts[398] + -5 * tileTypeCounts[27];
        case TileScanGroup.Crimson:
          return tileTypeCounts[199] + tileTypeCounts[203] + tileTypeCounts[200] + tileTypeCounts[401] + tileTypeCounts[399] + tileTypeCounts[234] + tileTypeCounts[352] - 5 * tileTypeCounts[27];
        case TileScanGroup.Hallow:
          return tileTypeCounts[109] + tileTypeCounts[110] + tileTypeCounts[113] + tileTypeCounts[117] + tileTypeCounts[116] + tileTypeCounts[164] + tileTypeCounts[403] + tileTypeCounts[402];
        case TileScanGroup.TotalGoodEvil:
          int typeCountByCategory1 = WorldGen.GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Hallow);
          int typeCountByCategory2 = WorldGen.GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Corruption);
          int typeCountByCategory3 = WorldGen.GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Crimson);
          int num1 = 5 * tileTypeCounts[27];
          int num2 = typeCountByCategory3;
          int num3 = typeCountByCategory2 + num2 + num1;
          return typeCountByCategory1 - num3;
        default:
          return 0;
      }
    }

    public static void ScoreRoom(int ignoreNPC = -1, int npcTypeAskingToScoreRoom = -1)
    {
      WorldGen.roomOccupied = false;
      WorldGen.roomEvil = false;
      WorldGen.sharedRoomX = -1;
      if (WorldGen.ScoreRoom_IsThisRoomOccupiedBySomeone(ignoreNPC, npcTypeAskingToScoreRoom))
      {
        WorldGen.roomOccupied = true;
        WorldGen.hiScore = -1;
      }
      else
      {
        WorldGen.hiScore = 0;
        int num1 = 50;
        int startX;
        int endX;
        int startY;
        int endY;
        WorldGen.Housing_GetTestedRoomBounds(out startX, out endX, out startY, out endY);
        int[] tileTypeCounts = new int[(int) TileID.Count];
        WorldGen.CountTileTypesInArea(tileTypeCounts, startX + 1, endX - 1, startY + 2, endY + 1);
        int num2 = -WorldGen.GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.TotalGoodEvil);
        if (num2 < 50)
          num2 = 0;
        int num3 = num1 - num2;
        if (num2 > 0)
          WorldGen.roomEvil = true;
        if (num3 <= -250)
        {
          WorldGen.hiScore = num3;
        }
        else
        {
          int roomX1 = WorldGen.roomX1;
          int roomX2 = WorldGen.roomX2;
          int roomY1 = WorldGen.roomY1;
          endY = WorldGen.roomY2;
          for (int index1 = roomX1 + 1; index1 < roomX2; ++index1)
          {
            for (int index2 = roomY1 + 2; index2 < endY + 2; ++index2)
            {
              if (Main.tile[index1, index2].nactive() && WorldGen.ScoreRoom_CanBeHomeSpot(index1, index2))
              {
                int num4 = num3;
                if (Main.tileSolid[(int) Main.tile[index1, index2].type] && !Main.tileSolidTop[(int) Main.tile[index1, index2].type] && !Collision.SolidTiles(index1 - 1, index1 + 1, index2 - 3, index2 - 1) && Main.tile[index1 - 1, index2].nactive() && Main.tileSolid[(int) Main.tile[index1 - 1, index2].type] && Main.tile[index1 + 1, index2].nactive() && Main.tileSolid[(int) Main.tile[index1 + 1, index2].type])
                {
                  int num5 = 0;
                  int num6 = 0;
                  for (int x = index1 - 2; x < index1 + 3; ++x)
                  {
                    for (int y = index2 - 4; y < index2; ++y)
                    {
                      Tile tile = Main.tile[x, y];
                      if (tile.nactive() && !TileID.Sets.IgnoredInHouseScore[(int) tile.type] && (tile.type != (ushort) 11 || WorldGen.IsOpenDoorAnchorFrame(x, y)))
                      {
                        if (x == index1)
                          ++num5;
                        else if (TileID.Sets.BasicChest[(int) tile.type])
                          ++num6;
                        else if (tile.type == (ushort) 10 || tile.type == (ushort) 388)
                          num4 -= 20;
                        else if (WorldGen.IsOpenDoorAnchorFrame(x, y) || tile.type == (ushort) 389)
                          num4 -= 20;
                        else if (Main.tileSolid[(int) tile.type])
                          num4 -= 5;
                        else
                          num4 += 5;
                      }
                    }
                  }
                  if (WorldGen.sharedRoomX >= 0 && num4 >= 1 && Math.Abs(WorldGen.sharedRoomX - index1) < 3)
                    num4 = 1;
                  if (num4 > 0 && num6 > 0)
                  {
                    num4 -= 30 * num6;
                    if (num4 < 1)
                      num4 = 1;
                  }
                  if (num4 > 0 && num5 > 0)
                  {
                    num4 -= 15 * num5;
                    if (num4 <= 0)
                      num4 = 0;
                  }
                  if (num4 > WorldGen.hiScore)
                  {
                    bool flag1 = WorldGen.Housing_CheckIfInRoom(index1, index2);
                    bool[] flagArray = new bool[3];
                    for (int index3 = 1; index3 <= 3; ++index3)
                    {
                      if (!Main.tile[index1, index2 - index3].active() || !Main.tileSolid[(int) Main.tile[index1, index2 - index3].type])
                        flagArray[index3 - 1] = true;
                      if (!WorldGen.Housing_CheckIfInRoom(index1, index2 - index3))
                        flagArray[index3 - 1] = false;
                    }
                    foreach (bool flag2 in flagArray)
                    {
                      if (!flag2)
                      {
                        flag1 = false;
                        break;
                      }
                    }
                    if (flag1 && !WorldGen.Housing_CheckIfIsCeiling(index1, index2))
                    {
                      WorldGen.hiScore = num4;
                      WorldGen.bestX = index1;
                      WorldGen.bestY = index2;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    public static void Housing_GetTestedRoomBounds(
      out int startX,
      out int endX,
      out int startY,
      out int endY)
    {
      int num1 = 40;
      int num2 = 5;
      int num3 = 3;
      startX = WorldGen.roomX1 - num2 - 1 - num1;
      endX = WorldGen.roomX2 + num2 + 1 + num1;
      startY = WorldGen.roomY1 - num3 - 1 - num1;
      endY = WorldGen.roomY2 + num3 + 1 + num1;
      if (startX < 5)
        startX = 5;
      if (endX >= Main.maxTilesX - 5)
        endX = Main.maxTilesX - 6;
      if (startY < 5)
        startY = 5;
      if (endY < Main.maxTilesY - 5)
        return;
      endY = Main.maxTilesY - 6;
    }

    private static bool ScoreRoom_CanBeHomeSpot(int x, int y)
    {
      Tile tile = Main.tile[x, y];
      return !tile.active() || tile.type != (ushort) 379;
    }

    private static bool Housing_CheckIfIsCeiling(int i, int j)
    {
      bool flag = false;
      for (int index = 0; index < WorldGen.roomCeilingsCount; ++index)
      {
        if (WorldGen.roomCeilingX[index] == i)
        {
          if (WorldGen.roomCeilingY[index] == j)
          {
            flag = true;
            break;
          }
          break;
        }
      }
      return flag;
    }

    private static bool Housing_CheckIfInRoom(int i, int j)
    {
      bool flag = false;
      for (int index = 0; index < WorldGen.numRoomTiles; ++index)
      {
        if (WorldGen.roomX[index] == i && WorldGen.roomY[index] == j)
        {
          flag = true;
          break;
        }
      }
      return flag;
    }

    public static bool StartRoomCheck(int x, int y)
    {
      WorldGen.roomHasStinkbug = false;
      WorldGen.roomHasEchoStinkbug = false;
      WorldGen.roomX1 = x;
      WorldGen.roomX2 = x;
      WorldGen.roomY1 = y;
      WorldGen.roomY2 = y;
      WorldGen.numRoomTiles = 0;
      WorldGen.roomCeilingsCount = 0;
      for (int index = 0; index < (int) TileID.Count; ++index)
        WorldGen.houseTile[index] = false;
      WorldGen.canSpawn = true;
      if (Main.tile[x, y].nactive() && Main.tileSolid[(int) Main.tile[x, y].type])
      {
        WorldGen.roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomCheckStartedInASolidTile;
        WorldGen.canSpawn = false;
        return false;
      }
      WorldGen.roomCheckFailureReason = TownNPCRoomCheckFailureReason.None;
      WorldGen.CheckRoom(x, y);
      if (!WorldGen.canSpawn)
        return false;
      if (WorldGen.numRoomTiles < 60)
      {
        WorldGen.roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomIsTooSmall;
        WorldGen.canSpawn = false;
        return false;
      }
      return WorldGen.canSpawn;
    }

    public static void CheckRoom(int x, int y)
    {
      if (!WorldGen.canSpawn)
        return;
      if (x < 10 || y < 10 || x >= Main.maxTilesX - 10 || y >= WorldGen.lastMaxTilesY - 10)
      {
        WorldGen.roomCheckFailureReason = TownNPCRoomCheckFailureReason.TooCloseToWorldEdge;
        WorldGen.canSpawn = false;
      }
      else
      {
        for (int index = 0; index < WorldGen.numRoomTiles; ++index)
        {
          if (WorldGen.roomX[index] == x && WorldGen.roomY[index] == y)
            return;
        }
        WorldGen.roomX[WorldGen.numRoomTiles] = x;
        WorldGen.roomY[WorldGen.numRoomTiles] = y;
        bool flag1 = false;
        for (int index = 0; index < WorldGen.roomCeilingsCount; ++index)
        {
          if (WorldGen.roomCeilingX[index] == x)
          {
            flag1 = true;
            if (WorldGen.roomCeilingY[index] > y)
            {
              WorldGen.roomCeilingY[index] = y;
              break;
            }
            break;
          }
        }
        if (!flag1)
        {
          WorldGen.roomCeilingX[WorldGen.roomCeilingsCount] = x;
          WorldGen.roomCeilingY[WorldGen.roomCeilingsCount] = y;
          ++WorldGen.roomCeilingsCount;
        }
        ++WorldGen.numRoomTiles;
        if (WorldGen.numRoomTiles >= WorldGen.maxRoomTiles)
        {
          WorldGen.roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomIsTooBig;
          WorldGen.canSpawn = false;
        }
        else
        {
          if (Main.tile[x, y].nactive())
          {
            WorldGen.houseTile[(int) Main.tile[x, y].type] = true;
            if (Main.tileSolid[(int) Main.tile[x, y].type] || Main.tile[x, y].type == (ushort) 11 && (Main.tile[x, y].frameX == (short) 0 || Main.tile[x, y].frameX == (short) 54 || Main.tile[x, y].frameX == (short) 72 || Main.tile[x, y].frameX == (short) 126) || Main.tile[x, y].type == (ushort) 389 || Main.tile[x, y].type == (ushort) 386 && (Main.tile[x, y].frameX < (short) 36 && Main.tile[x, y].frameY == (short) 18 || Main.tile[x, y].frameX >= (short) 36 && Main.tile[x, y].frameY == (short) 0))
              return;
          }
          if (x < WorldGen.roomX1)
            WorldGen.roomX1 = x;
          if (x > WorldGen.roomX2)
            WorldGen.roomX2 = x;
          if (y < WorldGen.roomY1)
            WorldGen.roomY1 = y;
          if (y > WorldGen.roomY2)
            WorldGen.roomY2 = y;
          if (Main.tile[x, y].type == (ushort) 630)
            WorldGen.roomHasStinkbug = true;
          if (Main.tile[x, y].type == (ushort) 631)
            WorldGen.roomHasEchoStinkbug = true;
          bool flag2 = false;
          bool flag3 = false;
          for (int index = -2; index < 3; ++index)
          {
            if (Main.wallHouse[(int) Main.tile[x + index, y].wall])
              flag2 = true;
            if (Main.tile[x + index, y].nactive() && (Main.tileSolid[(int) Main.tile[x + index, y].type] || TileID.Sets.HousingWalls[(int) Main.tile[x + index, y].type]))
              flag2 = true;
            if (Main.wallHouse[(int) Main.tile[x, y + index].wall])
              flag3 = true;
            if (Main.tile[x, y + index].nactive() && (Main.tileSolid[(int) Main.tile[x, y + index].type] || TileID.Sets.HousingWalls[(int) Main.tile[x, y + index].type]))
              flag3 = true;
          }
          if (!flag2 || !flag3)
          {
            WorldGen.roomCheckFailureReason = TownNPCRoomCheckFailureReason.HoleInWallIsTooBig;
            WorldGen.canSpawn = false;
          }
          else
          {
            for (int x1 = x - 1; x1 < x + 2; ++x1)
            {
              for (int y1 = y - 1; y1 < y + 2; ++y1)
              {
                if ((x1 != x || y1 != y) && WorldGen.canSpawn)
                  WorldGen.CheckRoom(x1, y1);
              }
            }
          }
        }
      }
    }

    public static void dropMeteor()
    {
      bool flag = true;
      if (Main.netMode == 1)
        return;
      for (int index = 0; index < (int) byte.MaxValue; ++index)
      {
        if (Main.player[index].active)
        {
          flag = false;
          break;
        }
      }
      int num1 = 0;
      int num2 = (int) (400.0 * ((double) Main.maxTilesX / 4200.0));
      for (int index1 = 5; index1 < Main.maxTilesX - 5; ++index1)
      {
        for (int index2 = 5; (double) index2 < Main.worldSurface; ++index2)
        {
          if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 37)
          {
            ++num1;
            if (num1 > num2)
              return;
          }
        }
      }
      double num3 = 600.0;
      int num4 = 0;
      while (!flag)
      {
        double num5 = (double) Main.maxTilesX * 0.08;
        int i1 = Main.rand.Next(150, Main.maxTilesX - 150);
        while ((double) i1 > (double) Main.spawnTileX - num5 && (double) i1 < (double) Main.spawnTileX + num5)
          i1 = Main.rand.Next(150, Main.maxTilesX - 150);
        for (int j1 = (int) (Main.worldSurface * 0.3); j1 < Main.maxTilesY; ++j1)
        {
          Tile tile = Main.tile[i1, j1];
          if (tile.active() && Main.tileSolid[(int) tile.type] && !TileID.Sets.Platforms[(int) tile.type])
          {
            int num6 = 0;
            int num7 = 15;
            for (int i2 = i1 - num7; i2 < i1 + num7; ++i2)
            {
              for (int j2 = j1 - num7; j2 < j1 + num7; ++j2)
              {
                if (WorldGen.SolidTile(i2, j2))
                {
                  ++num6;
                  if (Main.tile[i2, j2].type == (ushort) 189 || Main.tile[i2, j2].type == (ushort) 202)
                    num6 -= 100;
                }
                else if (Main.tile[i2, j2].liquid > (byte) 0)
                  --num6;
              }
            }
            if ((double) num6 >= num3)
            {
              flag = WorldGen.meteor(i1, j1);
              if (!flag)
                break;
              break;
            }
            num3 -= 0.5;
            break;
          }
        }
        ++num4;
        if (num3 < 100.0 || num4 >= Main.maxTilesX * 5)
          break;
      }
    }

    public static bool meteor(int i, int j, bool ignorePlayers = false)
    {
      if (i < 50 || i > Main.maxTilesX - 50 || j < 50 || j > Main.maxTilesY - 50)
        return false;
      int num1 = 35;
      Microsoft.Xna.Framework.Rectangle rectangle1 = new Microsoft.Xna.Framework.Rectangle((i - num1) * 16, (j - num1) * 16, num1 * 2 * 16, num1 * 2 * 16);
      for (int index = 0; index < (int) byte.MaxValue; ++index)
      {
        if (Main.player[index].active && !ignorePlayers)
        {
          Microsoft.Xna.Framework.Rectangle rectangle2 = new Microsoft.Xna.Framework.Rectangle((int) ((double) Main.player[index].position.X + (double) (Main.player[index].width / 2) - (double) (NPC.sWidth / 2) - (double) NPC.safeRangeX), (int) ((double) Main.player[index].position.Y + (double) (Main.player[index].height / 2) - (double) (NPC.sHeight / 2) - (double) NPC.safeRangeY), NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
          if (rectangle1.Intersects(rectangle2))
            return false;
        }
      }
      for (int index = 0; index < 200; ++index)
      {
        if (Main.npc[index].active)
        {
          Microsoft.Xna.Framework.Rectangle rectangle3 = new Microsoft.Xna.Framework.Rectangle((int) Main.npc[index].position.X, (int) Main.npc[index].position.Y, Main.npc[index].width, Main.npc[index].height);
          if (rectangle1.Intersects(rectangle3))
            return false;
        }
      }
      for (int index1 = i - num1; index1 < i + num1; ++index1)
      {
        for (int index2 = j - num1; index2 < j + num1; ++index2)
        {
          if (Main.tile[index1, index2].active())
          {
            if (TileID.Sets.BasicChest[(int) Main.tile[index1, index2].type] || Main.tileDungeon[(int) Main.tile[index1, index2].type])
              return false;
            switch (Main.tile[index1, index2].type)
            {
              case 226:
              case 470:
              case 475:
              case 488:
              case 597:
                return false;
              default:
                continue;
            }
          }
        }
      }
      WorldGen.stopDrops = true;
      int num2 = WorldGen.genRand.Next(17, 23);
      for (int index3 = i - num2; index3 < i + num2; ++index3)
      {
        for (int index4 = j - num2; index4 < j + num2; ++index4)
        {
          if (index4 > j + Main.rand.Next(-2, 3) - 5)
          {
            double num3 = (double) Math.Abs(i - index3);
            double num4 = (double) Math.Abs(j - index4);
            if (Math.Sqrt(num3 * num3 + num4 * num4) < (double) num2 * 0.9 + (double) Main.rand.Next(-4, 5))
            {
              if (!Main.tileSolid[(int) Main.tile[index3, index4].type])
                Main.tile[index3, index4].active(false);
              Main.tile[index3, index4].type = (ushort) 37;
            }
          }
        }
      }
      int num5 = WorldGen.genRand.Next(8, 14);
      for (int index5 = i - num5; index5 < i + num5; ++index5)
      {
        for (int index6 = j - num5; index6 < j + num5; ++index6)
        {
          if (index6 > j + Main.rand.Next(-2, 3) - 4)
          {
            double num6 = (double) Math.Abs(i - index5);
            double num7 = (double) Math.Abs(j - index6);
            if (Math.Sqrt(num6 * num6 + num7 * num7) < (double) num5 * 0.8 + (double) Main.rand.Next(-3, 4))
              Main.tile[index5, index6].active(false);
          }
        }
      }
      int num8 = WorldGen.genRand.Next(25, 35);
      for (int i1 = i - num8; i1 < i + num8; ++i1)
      {
        for (int j1 = j - num8; j1 < j + num8; ++j1)
        {
          double num9 = (double) Math.Abs(i - i1);
          double num10 = (double) Math.Abs(j - j1);
          if (Math.Sqrt(num9 * num9 + num10 * num10) < (double) num8 * 0.7)
          {
            if (TileID.Sets.GetsDestroyedForMeteors[(int) Main.tile[i1, j1].type])
              WorldGen.KillTile(i1, j1);
            Main.tile[i1, j1].liquid = (byte) 0;
          }
          if (Main.tile[i1, j1].type == (ushort) 37)
          {
            if (!WorldGen.SolidTile(i1 - 1, j1) && !WorldGen.SolidTile(i1 + 1, j1) && !WorldGen.SolidTile(i1, j1 - 1) && !WorldGen.SolidTile(i1, j1 + 1))
              Main.tile[i1, j1].active(false);
            else if ((Main.tile[i1, j1].halfBrick() || Main.tile[i1 - 1, j1].topSlope()) && !WorldGen.SolidTile(i1, j1 + 1))
              Main.tile[i1, j1].active(false);
          }
          WorldGen.SquareTileFrame(i1, j1);
          WorldGen.SquareWallFrame(i1, j1);
        }
      }
      int num11 = WorldGen.genRand.Next(23, 32);
      for (int i2 = i - num11; i2 < i + num11; ++i2)
      {
        for (int j2 = j - num11; j2 < j + num11; ++j2)
        {
          if (j2 > j + WorldGen.genRand.Next(-3, 4) - 3 && Main.tile[i2, j2].active() && Main.rand.Next(10) == 0)
          {
            double num12 = (double) Math.Abs(i - i2);
            double num13 = (double) Math.Abs(j - j2);
            if (Math.Sqrt(num12 * num12 + num13 * num13) < (double) num11 * 0.8)
            {
              if (TileID.Sets.GetsDestroyedForMeteors[(int) Main.tile[i2, j2].type])
                WorldGen.KillTile(i2, j2);
              Main.tile[i2, j2].type = (ushort) 37;
              WorldGen.SquareTileFrame(i2, j2);
            }
          }
        }
      }
      int num14 = WorldGen.genRand.Next(30, 38);
      for (int i3 = i - num14; i3 < i + num14; ++i3)
      {
        for (int j3 = j - num14; j3 < j + num14; ++j3)
        {
          if (j3 > j + WorldGen.genRand.Next(-2, 3) && Main.tile[i3, j3].active() && Main.rand.Next(20) == 0)
          {
            double num15 = (double) Math.Abs(i - i3);
            double num16 = (double) Math.Abs(j - j3);
            if (Math.Sqrt(num15 * num15 + num16 * num16) < (double) num14 * 0.85)
            {
              if (TileID.Sets.GetsDestroyedForMeteors[(int) Main.tile[i3, j3].type])
                WorldGen.KillTile(i3, j3);
              Main.tile[i3, j3].type = (ushort) 37;
              WorldGen.SquareTileFrame(i3, j3);
            }
          }
        }
      }
      WorldGen.stopDrops = false;
      if (Main.netMode == 0)
        Main.NewText(Lang.gen[59].Value, (byte) 50, B: (byte) 130);
      else if (Main.netMode == 2)
        ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.gen[59].Key), new Color(50, (int) byte.MaxValue, 130));
      if (Main.netMode != 1)
        NetMessage.SendTileSquare(-1, i, j, 40);
      return true;
    }

    public static void setWorldSize()
    {
      Main.bottomWorld = (float) (Main.maxTilesY * 16);
      Main.rightWorld = (float) (Main.maxTilesX * 16);
      Main.maxSectionsX = Main.maxTilesX / 200;
      Main.maxSectionsY = Main.maxTilesY / 150;
    }

    public static int GetWorldSize()
    {
      if (Main.maxTilesX <= 4200)
        return 0;
      return Main.maxTilesX <= 6400 ? 1 : 2;
    }

    public static void worldGenCallback(object threadContext)
    {
      SoundEngine.PlaySound(10);
      WorldGen.clearWorld();
      WorldGen.GenerateWorld(Main.ActiveWorldFileData.Seed, threadContext as GenerationProgress);
      WorldFile.SaveWorld(Main.ActiveWorldFileData.IsCloudSave, true);
      if (Main.menuMode == 10 || Main.menuMode == 888)
        Main.menuMode = 6;
      SoundEngine.PlaySound(10);
      WorldGen.generatingWorld = false;
    }

    public static Task CreateNewWorld(GenerationProgress progress = null)
    {
      WorldGen.generatingWorld = true;
      Main.rand = new UnifiedRandom(Main.ActiveWorldFileData.Seed);
      WorldGen.gen = true;
      Main.menuMode = 888;
      try
      {
        Main.MenuUI.SetState((UIState) new UIWorldLoad());
      }
      catch
      {
      }
      return Task.Factory.StartNew(new Action<object>(WorldGen.worldGenCallback), (object) progress);
    }

    public static void JustQuit()
    {
      try
      {
        SoundEngine.PlaySound(34, Style: 0);
        SoundEngine.PlaySound(35, Style: 0);
      }
      catch
      {
      }
      Main.invasionProgress = -1;
      Main.invasionProgressDisplayLeft = 0;
      Main.invasionProgressAlpha = 0.0f;
      Main.invasionProgressIcon = 0;
      Main.menuMode = 10;
      Main.gameMenu = true;
      SoundEngine.StopTrackedSounds();
      CaptureInterface.ResetFocus();
      Main.ActivePlayerFileData.StopPlayTimer();
      Main.fastForwardTimeToDawn = false;
      Main.fastForwardTimeToDusk = false;
      Main.UpdateTimeRate();
      if (Main.netMode == 0)
      {
        Main.GoToWorldSelect();
        Main.player[Main.myPlayer].position = new Vector2(0.0f, 0.0f);
      }
      else
      {
        if (Main.netMode != 1)
          return;
        Main.menuMode = 0;
        Netplay.Disconnect = true;
        Main.netMode = 0;
      }
    }

    public static void SaveAndQuitCallBack(object threadContext)
    {
      int netMode = Main.netMode;
      try
      {
        SoundEngine.PlaySound(34, Style: 0);
        SoundEngine.PlaySound(35, Style: 0);
      }
      catch
      {
      }
      if (netMode == 0)
        WorldFile.CacheSaveTime();
      Main.invasionProgress = -1;
      Main.invasionProgressDisplayLeft = 0;
      Main.invasionProgressAlpha = 0.0f;
      Main.invasionProgressIcon = 0;
      Main.menuMode = 10;
      Main.gameMenu = true;
      SoundEngine.StopTrackedSounds();
      CaptureInterface.ResetFocus();
      Main.ActivePlayerFileData.StopPlayTimer();
      Player.SavePlayer(Main.ActivePlayerFileData);
      Player.ClearPlayerTempInfo();
      Rain.ClearRain();
      if (netMode == 0)
      {
        WorldFile.SaveWorld();
        SoundEngine.PlaySound(10);
      }
      else
      {
        Netplay.Disconnect = true;
        Main.netMode = 0;
      }
      Main.fastForwardTimeToDawn = false;
      Main.fastForwardTimeToDusk = false;
      Main.UpdateTimeRate();
      Main.menuMode = 0;
      if (threadContext == null)
        return;
      ((Action) threadContext)();
    }

    public static void SaveAndQuit(Action callback = null)
    {
      SoundEngine.PlaySound(11);
      ThreadPool.QueueUserWorkItem(new WaitCallback(WorldGen.SaveAndQuitCallBack), (object) callback);
    }

    public static void RenameWorld(WorldFileData data, string newName, Action<string> callback = null)
    {
      data.SetAsActive();
      ThreadPool.QueueUserWorkItem(new WaitCallback(WorldGen.RenameWorldCallBack), (object) Tuple.Create<string, Action<string>>(newName, callback));
    }

    public static void RenameWorldCallBack(object threadContext)
    {
      if (threadContext == null || !(threadContext is Tuple<string, Action<string>> tuple))
        return;
      string str = tuple.Item1;
      Action<string> action = tuple.Item2;
      WorldGen.noMapUpdate = true;
      Main.ToggleGameplayUpdates(false);
      WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
      WorldGen.noMapUpdate = false;
      if (WorldGen.loadFailed || !WorldGen.loadSuccess)
      {
        Main.LoadWorlds();
        Main.GoToWorldSelect();
      }
      else
      {
        Main.sectionManager.SetAllSectionsLoaded();
        double time = Main.time;
        bool dayTime = Main.dayTime;
        WorldFile.SetOngoingToTemps();
        WorldFile.CacheSaveTime();
        Main.time = time;
        Main.dayTime = dayTime;
        Main.worldName = str;
        WorldFile.SaveWorld();
        Rain.ClearRain();
        Main.fastForwardTimeToDawn = false;
        Main.fastForwardTimeToDusk = false;
        Main.UpdateTimeRate();
        if (action == null)
          return;
        action(str);
      }
    }

    public static void playWorldCallBack(object threadContext)
    {
      if (Main.rand == null)
        Main.rand = new UnifiedRandom((int) DateTime.Now.Ticks);
      for (int index = 0; index < (int) byte.MaxValue; ++index)
      {
        if (index != Main.myPlayer)
          Main.player[index].active = false;
      }
      WorldGen.noMapUpdate = true;
      Main.ToggleGameplayUpdates(false);
      WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
      if (WorldGen.loadFailed || !WorldGen.loadSuccess)
      {
        WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
        if (WorldGen.loadFailed || !WorldGen.loadSuccess)
        {
          bool isCloudSave = Main.ActiveWorldFileData.IsCloudSave;
          WorldGen.worldBackup = FileUtilities.Exists(Main.worldPathName + ".bak", isCloudSave);
          if (!Main.dedServ)
          {
            if (WorldGen.worldBackup)
            {
              Main.menuMode = 200;
              return;
            }
            Main.menuMode = 201;
            return;
          }
          if (WorldGen.worldBackup)
          {
            FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bad", isCloudSave);
            FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave);
            FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
            WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
            if (WorldGen.loadFailed || !WorldGen.loadSuccess)
            {
              WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
              if (WorldGen.loadFailed || !WorldGen.loadSuccess)
              {
                FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bak", isCloudSave);
                FileUtilities.Copy(Main.worldPathName + ".bad", Main.worldPathName, isCloudSave);
                FileUtilities.Delete(Main.worldPathName + ".bad", isCloudSave);
                Console.WriteLine(Language.GetTextValue("Error.LoadFailed"));
                return;
              }
            }
          }
          else
          {
            Console.WriteLine(Language.GetTextValue("Error.LoadFailedNoBackup"));
            return;
          }
        }
      }
      if (Main.mapEnabled)
        Main.Map.Load();
      if (Main.netMode != 2)
        Main.sectionManager.SetAllSectionsLoaded();
      while (Main.loadMapLock)
      {
        float num = (float) Main.loadMapLastX / (float) Main.maxTilesX;
        Main.statusText = Lang.gen[68].Value + " " + (object) (int) ((double) num * 100.0 + 1.0) + "%";
        Thread.Sleep(0);
        if (!Main.mapEnabled)
          break;
      }
      if (Main.gameMenu)
        Main.gameMenu = false;
      if (Main.netMode == 0 && Main.anglerWhoFinishedToday.Contains(Main.player[Main.myPlayer].name))
        Main.anglerQuestFinished = true;
      Main.player[Main.myPlayer].Spawn(PlayerSpawnContext.SpawningIntoWorld);
      WorldGen._lastSeed = Main.ActiveWorldFileData.Seed;
      WorldFile.SetOngoingToTemps();
      SoundEngine.PlaySound(11);
      Main.resetClouds = true;
      WorldGen.noMapUpdate = false;
    }

    public static void playWorld() => ThreadPool.QueueUserWorkItem(new WaitCallback(WorldGen.playWorldCallBack), (object) 1);

    public static void saveAndPlayCallBack(object threadContext) => WorldFile.SaveWorld();

    public static void saveAndPlay() => ThreadPool.QueueUserWorkItem(new WaitCallback(WorldGen.saveAndPlayCallBack), (object) 1);

    public static void saveToonWhilePlayingCallBack(object threadContext) => Player.SavePlayer(Main.ActivePlayerFileData);

    public static void saveToonWhilePlaying() => ThreadPool.QueueUserWorkItem(new WaitCallback(WorldGen.saveToonWhilePlayingCallBack), (object) 1);

    public static void serverLoadWorldCallBack()
    {
      Main.rand = new UnifiedRandom((int) DateTime.Now.Ticks);
      WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
      if (WorldGen.loadFailed || !WorldGen.loadSuccess)
      {
        WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
        if (WorldGen.loadFailed || !WorldGen.loadSuccess)
        {
          bool isCloudSave = Main.ActiveWorldFileData.IsCloudSave;
          WorldGen.worldBackup = FileUtilities.Exists(Main.worldPathName + ".bak", isCloudSave);
          if (!Main.dedServ)
          {
            if (WorldGen.worldBackup)
            {
              Main.menuMode = 200;
              return;
            }
            Main.menuMode = 201;
            return;
          }
          if (WorldGen.worldBackup)
          {
            FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave);
            FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
            WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
            if (WorldGen.loadFailed || !WorldGen.loadSuccess)
            {
              WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
              if (WorldGen.loadFailed || !WorldGen.loadSuccess)
              {
                Console.WriteLine(Language.GetTextValue("Error.LoadFailed"));
                return;
              }
            }
          }
          else
          {
            Console.WriteLine(Language.GetTextValue("Error.LoadFailedNoBackup"));
            return;
          }
        }
      }
      WorldGen._lastSeed = Main.ActiveWorldFileData.Seed;
      SoundEngine.PlaySound(10);
      WorldFile.SetOngoingToTemps();
      WorldGen.Hooks.WorldLoaded();
    }

    public static Task serverLoadWorld() => Task.Factory.StartNew(new Action(WorldGen.serverLoadWorldCallBack));

    public static void clearWorld()
    {
      WorldGen.ResetTreeShakes();
      Main.ladyBugRainBoost = 0;
      Main.getGoodWorld = false;
      Main.drunkWorld = false;
      Main.tenthAnniversaryWorld = false;
      Main.dontStarveWorld = false;
      Main.notTheBeesWorld = false;
      Main.remixWorld = false;
      Main.noTrapsWorld = false;
      Main.zenithWorld = false;
      Main.afterPartyOfDoom = false;
      Main.shimmerAlpha = 0.0f;
      Main.shimmerDarken = 0.0f;
      Main.shimmerBrightenDelay = 0.0f;
      NPC.ResetBadgerHatTime();
      NPC.freeCake = false;
      NPC.mechQueen = -1;
      Main.mapDelay = 2;
      Main.waterStyle = 0;
      Main.ResetWindCounter(true);
      WorldGen.TownManager = new TownRoomManager();
      PressurePlateHelper.Reset();
      WorldGen.TownManager.Clear();
      NPC.ResetKillCount();
      Main.instance.ClearCachedTileDraws();
      MapHelper.ResetMapData();
      TileEntity.Clear();
      Main.checkXMas();
      Main.checkHalloween();
      DontStarveDarknessDamageDealer.Reset();
      Wiring.ClearAll();
      Main.ParticleSystem_World_BehindPlayers.Particles.Clear();
      Main.ParticleSystem_World_OverPlayers.Particles.Clear();
      if (Main.mapReady)
      {
        for (int index = 0; index < WorldGen.lastMaxTilesX; ++index)
        {
          double num = (double) index / (double) WorldGen.lastMaxTilesX;
          Main.statusText = Lang.gen[65].Value;
        }
        if (Main.Map != null)
          Main.Map.Clear();
      }
      NPC.MoonLordCountdown = 0;
      Main.forceHalloweenForToday = false;
      Main.forceXMasForToday = false;
      NPC.RevengeManager.Reset();
      Main.pumpkinMoon = false;
      Main.clearMap = true;
      Main.mapTime = 0;
      Main.updateMap = false;
      Main.mapReady = false;
      Main.refreshMap = false;
      Main.eclipse = false;
      Main.slimeRain = false;
      Main.slimeRainTime = 0.0;
      Main.slimeWarningTime = 0;
      Main.sundialCooldown = 0;
      Main.moondialCooldown = 0;
      Main.fastForwardTimeToDawn = false;
      Main.fastForwardTimeToDusk = false;
      BirthdayParty.WorldClear();
      LanternNight.WorldClear();
      WorldGen.mysticLogsEvent.WorldClear();
      CreditsRollEvent.Reset();
      Sandstorm.WorldClear();
      Main.DroneCameraTracker.WorldClear();
      Main.LocalGolfState.WorldClear();
      Main.CurrentPan = Vector2.Zero;
      Main.UpdateTimeRate();
      Main.wofNPCIndex = -1;
      NPC.waveKills = 0.0f;
      WorldGen.spawnHardBoss = 0;
      WorldGen.totalSolid2 = 0;
      WorldGen.totalGood2 = 0;
      WorldGen.totalEvil2 = 0;
      WorldGen.totalBlood2 = 0;
      WorldGen.totalSolid = 0;
      WorldGen.totalGood = 0;
      WorldGen.totalEvil = 0;
      WorldGen.totalBlood = 0;
      WorldFile.ResetTemps();
      Main.maxRaining = 0.0f;
      WorldGen.totalX = 0;
      WorldGen.totalD = 0;
      WorldGen.tEvil = (byte) 0;
      WorldGen.tBlood = (byte) 0;
      WorldGen.tGood = (byte) 0;
      WorldGen.spawnEye = false;
      WorldGen.prioritizedTownNPCType = 0;
      WorldGen.shadowOrbCount = 0;
      WorldGen.altarCount = 0;
      WorldGen.SavedOreTiers.Copper = -1;
      WorldGen.SavedOreTiers.Iron = -1;
      WorldGen.SavedOreTiers.Silver = -1;
      WorldGen.SavedOreTiers.Gold = -1;
      WorldGen.SavedOreTiers.Cobalt = -1;
      WorldGen.SavedOreTiers.Mythril = -1;
      WorldGen.SavedOreTiers.Adamantite = -1;
      GenVars.shimmerPosition = Vector2D.Zero;
      Main.cloudBGActive = 0.0f;
      Main.raining = false;
      Main.hardMode = false;
      Main.helpText = 0;
      Main.BartenderHelpTextIndex = 0;
      Main.dungeonX = 0;
      Main.dungeonY = 0;
      NPC.downedBoss1 = false;
      NPC.downedBoss2 = false;
      NPC.downedBoss3 = false;
      NPC.downedQueenBee = false;
      NPC.downedSlimeKing = false;
      NPC.downedMechBossAny = false;
      NPC.downedMechBoss1 = false;
      NPC.downedMechBoss2 = false;
      NPC.downedMechBoss3 = false;
      NPC.downedFishron = false;
      NPC.downedAncientCultist = false;
      NPC.downedMoonlord = false;
      NPC.downedHalloweenKing = false;
      NPC.downedHalloweenTree = false;
      NPC.downedChristmasIceQueen = false;
      NPC.downedChristmasSantank = false;
      NPC.downedChristmasTree = false;
      NPC.downedPlantBoss = false;
      NPC.downedGolemBoss = false;
      NPC.downedEmpressOfLight = false;
      NPC.downedQueenSlime = false;
      NPC.downedDeerclops = false;
      NPC.combatBookWasUsed = false;
      NPC.combatBookVolumeTwoWasUsed = false;
      NPC.peddlersSatchelWasUsed = false;
      NPC.savedStylist = false;
      NPC.savedGoblin = false;
      NPC.savedWizard = false;
      NPC.savedMech = false;
      NPC.savedTaxCollector = false;
      NPC.savedAngler = false;
      NPC.savedBartender = false;
      NPC.savedGolfer = false;
      NPC.boughtCat = false;
      NPC.boughtDog = false;
      NPC.boughtBunny = false;
      NPC.unlockedSlimeBlueSpawn = false;
      NPC.unlockedSlimeGreenSpawn = false;
      NPC.unlockedSlimeOldSpawn = false;
      NPC.unlockedSlimePurpleSpawn = false;
      NPC.unlockedSlimeRainbowSpawn = false;
      NPC.unlockedSlimeRedSpawn = false;
      NPC.unlockedSlimeYellowSpawn = false;
      NPC.unlockedSlimeCopperSpawn = false;
      NPC.unlockedMerchantSpawn = false;
      NPC.unlockedDemolitionistSpawn = false;
      NPC.unlockedPartyGirlSpawn = false;
      NPC.unlockedDyeTraderSpawn = false;
      NPC.unlockedTruffleSpawn = false;
      NPC.unlockedArmsDealerSpawn = false;
      NPC.unlockedNurseSpawn = false;
      NPC.unlockedPrincessSpawn = false;
      Array.Clear((Array) NPC.ShimmeredTownNPCs, 0, NPC.ShimmeredTownNPCs.Length);
      NPC.downedGoblins = false;
      NPC.downedClown = false;
      NPC.downedFrost = false;
      NPC.downedPirates = false;
      NPC.downedMartians = false;
      int num1;
      NPC.LunarApocalypseIsUp = (num1 = 0) != 0;
      NPC.downedTowerStardust = num1 != 0;
      NPC.downedTowerNebula = num1 != 0;
      NPC.downedTowerVortex = num1 != 0;
      NPC.downedTowerSolar = num1 != 0;
      int num2;
      NPC.TowerActiveStardust = (num2 = 0) != 0;
      NPC.TowerActiveNebula = num2 != 0;
      NPC.TowerActiveVortex = num2 != 0;
      NPC.TowerActiveSolar = num2 != 0;
      DD2Event.ResetProgressEntirely();
      NPC.ClearFoundActiveNPCs();
      Main.BestiaryTracker.Reset();
      Main.PylonSystem.Reset();
      CreativePowerManager.Instance.Reset();
      Main.CreativeMenu.Reset();
      WorldGen.shadowOrbSmashed = false;
      WorldGen.spawnMeteor = false;
      WorldGen.stopDrops = false;
      Main.invasionDelay = 0;
      Main.invasionType = 0;
      Main.invasionSize = 0;
      Main.invasionWarn = 0;
      Main.invasionX = 0.0;
      Main.invasionSizeStart = 0;
      Main.treeX[0] = Main.maxTilesX;
      Main.treeX[1] = Main.maxTilesX;
      Main.treeX[2] = Main.maxTilesX;
      Main.treeStyle[0] = 0;
      Main.treeStyle[1] = 0;
      Main.treeStyle[2] = 0;
      Main.treeStyle[3] = 0;
      WorldGen.noLiquidCheck = false;
      Liquid.numLiquid = 0;
      LiquidBuffer.numLiquidBuffer = 0;
      if (Main.netMode == 1 || WorldGen.lastMaxTilesX > Main.maxTilesX || WorldGen.lastMaxTilesY > Main.maxTilesY)
      {
        for (int index1 = 0; index1 < WorldGen.lastMaxTilesX; ++index1)
        {
          float num3 = (float) index1 / (float) WorldGen.lastMaxTilesX;
          Main.statusText = Lang.gen[46].Value + " " + (object) (int) ((double) num3 * 100.0 + 1.0) + "%";
          for (int index2 = 0; index2 < WorldGen.lastMaxTilesY; ++index2)
            Main.tile[index1, index2] = (Tile) null;
        }
      }
      WorldGen.lastMaxTilesX = Main.maxTilesX;
      WorldGen.lastMaxTilesY = Main.maxTilesY;
      if (Main.netMode != 2)
        Main.sectionManager = new WorldSections(Main.maxTilesX / 200, Main.maxTilesY / 150);
      if (Main.netMode != 1)
      {
        for (int index3 = 0; index3 < Main.maxTilesX; ++index3)
        {
          float num4 = (float) index3 / (float) Main.maxTilesX;
          Main.statusText = Lang.gen[47].Value + " " + (object) (int) ((double) num4 * 100.0 + 1.0) + "%";
          for (int index4 = 0; index4 < Main.maxTilesY; ++index4)
          {
            if (Main.tile[index3, index4] == null)
              Main.tile[index3, index4] = new Tile();
            else
              Main.tile[index3, index4].ClearEverything();
          }
        }
      }
      for (int index = 0; index < Main.countsAsHostForGameplay.Length; ++index)
        Main.countsAsHostForGameplay[index] = false;
      CombatText.clearAll();
      PopupText.ClearAll();
      for (int index = 0; index < 6000; ++index)
      {
        Main.dust[index] = new Dust();
        Main.dust[index].dustIndex = index;
      }
      for (int index = 0; index < 600; ++index)
        Main.gore[index] = new Gore();
      for (int index = 0; index < 400; ++index)
      {
        Main.item[index] = new Item();
        Main.item[index].whoAmI = index;
        Main.timeItemSlotCannotBeReusedFor[index] = 0;
      }
      for (int index = 0; index < 200; ++index)
      {
        Main.npc[index] = new NPC();
        Main.npc[index].whoAmI = index;
      }
      for (int index = 0; index < 1000; ++index)
      {
        Main.projectile[index] = new Projectile();
        Main.projectile[index].whoAmI = index;
      }
      for (int index = 0; index < 8000; ++index)
        Main.chest[index] = (Chest) null;
      for (int index = 0; index < 1000; ++index)
        Main.sign[index] = (Sign) null;
      for (int index = 0; index < Liquid.maxLiquid; ++index)
        Main.liquid[index] = new Liquid();
      for (int index = 0; index < 50000; ++index)
        Main.liquidBuffer[index] = new LiquidBuffer();
      WorldGen.setWorldSize();
      Star.SpawnStars();
      WorldGen.worldCleared = true;
    }

    public static void setBG(int bg, int style)
    {
      switch (bg)
      {
        case 0:
          WorldGen.treeBG1 = style;
          WorldGen.SetForestBGSet(style, Main.treeMntBGSet1, Main.treeBGSet1);
          break;
        case 1:
          WorldGen.corruptBG = style;
          switch (style)
          {
            case 1:
              Main.corruptBG[0] = 56;
              Main.corruptBG[1] = 57;
              Main.corruptBG[2] = 58;
              return;
            case 2:
              Main.corruptBG[0] = 211;
              Main.corruptBG[1] = 212;
              Main.corruptBG[2] = 213;
              return;
            case 3:
              Main.corruptBG[0] = 225;
              Main.corruptBG[1] = 226;
              Main.corruptBG[2] = 227;
              return;
            case 4:
              Main.corruptBG[0] = 240;
              Main.corruptBG[1] = 241;
              Main.corruptBG[2] = 242;
              return;
            default:
              Main.corruptBG[0] = 12;
              Main.corruptBG[1] = 13;
              Main.corruptBG[2] = 14;
              return;
          }
        case 2:
          WorldGen.jungleBG = style;
          switch (style)
          {
            case 1:
              Main.jungleBG[0] = 59;
              Main.jungleBG[1] = 60;
              Main.jungleBG[2] = 61;
              return;
            case 2:
              Main.jungleBG[0] = 222;
              Main.jungleBG[1] = 223;
              Main.jungleBG[2] = 224;
              return;
            case 3:
              Main.jungleBG[0] = 237;
              Main.jungleBG[1] = 238;
              Main.jungleBG[2] = 239;
              return;
            case 4:
              Main.jungleBG[0] = 284;
              Main.jungleBG[1] = 285;
              Main.jungleBG[2] = 286;
              return;
            case 5:
              Main.jungleBG[0] = 271;
              Main.jungleBG[1] = 272;
              Main.jungleBG[2] = 273;
              return;
            default:
              Main.jungleBG[0] = 15;
              Main.jungleBG[1] = 16;
              Main.jungleBG[2] = 17;
              return;
          }
        case 3:
          WorldGen.snowBG = style;
          Main.snowMntBG[0] = 35;
          Main.snowMntBG[1] = 36;
          switch (style)
          {
            case 1:
              Main.snowBG[0] = 97;
              Main.snowBG[1] = 96;
              Main.snowBG[2] = 95;
              return;
            case 2:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 99;
              Main.snowBG[0] = -1;
              Main.snowBG[1] = -1;
              Main.snowBG[2] = -1;
              return;
            case 3:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 100;
              Main.snowBG[0] = -1;
              Main.snowBG[1] = -1;
              Main.snowBG[2] = -1;
              return;
            case 4:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 101;
              Main.snowBG[0] = -1;
              Main.snowBG[1] = -1;
              Main.snowBG[2] = -1;
              return;
            case 5:
              Main.snowMntBG[0] = -1;
              Main.snowMntBG[1] = -1;
              Main.snowBG[0] = 258;
              Main.snowBG[1] = 259;
              Main.snowBG[2] = 260;
              return;
            case 6:
              Main.snowMntBG[0] = -1;
              Main.snowMntBG[1] = -1;
              Main.snowBG[0] = 263;
              Main.snowBG[1] = 264;
              Main.snowBG[2] = 265;
              return;
            case 7:
              Main.snowMntBG[0] = 269;
              Main.snowMntBG[1] = 270;
              Main.snowBG[0] = 267;
              Main.snowBG[1] = 266;
              Main.snowBG[2] = 268;
              return;
            case 21:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 99;
              Main.snowBG[0] = 95;
              Main.snowBG[1] = 96;
              Main.snowBG[2] = 97;
              return;
            case 22:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 99;
              Main.snowBG[0] = 37;
              Main.snowBG[1] = 38;
              Main.snowBG[2] = 39;
              return;
            case 31:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 100;
              Main.snowBG[0] = 95;
              Main.snowBG[1] = 96;
              Main.snowBG[2] = 97;
              return;
            case 32:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 100;
              Main.snowBG[0] = 37;
              Main.snowBG[1] = 38;
              Main.snowBG[2] = 39;
              return;
            case 41:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 101;
              Main.snowBG[0] = 95;
              Main.snowBG[1] = 96;
              Main.snowBG[2] = 97;
              return;
            case 42:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 101;
              Main.snowBG[0] = 37;
              Main.snowBG[1] = 38;
              Main.snowBG[2] = 39;
              return;
            default:
              Main.snowBG[0] = 37;
              Main.snowBG[1] = 38;
              Main.snowBG[2] = 39;
              return;
          }
        case 4:
          WorldGen.hallowBG = style;
          switch (style)
          {
            case 1:
              Main.hallowBG[0] = 102;
              Main.hallowBG[1] = 103;
              Main.hallowBG[2] = 104;
              return;
            case 2:
              Main.hallowBG[0] = 219;
              Main.hallowBG[1] = 220;
              Main.hallowBG[2] = 221;
              return;
            case 3:
              Main.hallowBG[0] = 243;
              Main.hallowBG[1] = 244;
              Main.hallowBG[2] = 245;
              return;
            case 4:
              Main.hallowBG[0] = -1;
              Main.hallowBG[1] = 261;
              Main.hallowBG[2] = 262;
              return;
            default:
              Main.hallowBG[0] = 29;
              Main.hallowBG[1] = 30;
              Main.hallowBG[2] = 31;
              return;
          }
        case 5:
          WorldGen.crimsonBG = style;
          switch (style)
          {
            case 1:
              Main.crimsonBG[0] = 105;
              Main.crimsonBG[1] = 106;
              Main.crimsonBG[2] = 107;
              return;
            case 2:
              Main.crimsonBG[0] = 174;
              Main.crimsonBG[1] = -1;
              Main.crimsonBG[2] = 175;
              return;
            case 3:
              Main.crimsonBG[0] = 214;
              Main.crimsonBG[1] = 215;
              Main.crimsonBG[2] = 216;
              return;
            case 4:
              Main.crimsonBG[0] = -1;
              Main.crimsonBG[1] = 229;
              Main.crimsonBG[2] = 230;
              return;
            case 5:
              Main.crimsonBG[0] = (int) byte.MaxValue;
              Main.crimsonBG[1] = 256;
              Main.crimsonBG[2] = 257;
              return;
            default:
              Main.crimsonBG[0] = 43;
              Main.crimsonBG[1] = 44;
              Main.crimsonBG[2] = 45;
              return;
          }
        case 6:
          WorldGen.desertBG = style;
          switch (style)
          {
            case 1:
              Main.desertBG[0] = 108;
              Main.desertBG[1] = 109;
              Main.desertBG[2] = -1;
              return;
            case 2:
              Main.desertBG[0] = 207;
              Main.desertBG[1] = 208;
              Main.desertBG[2] = -1;
              return;
            case 3:
              Main.desertBG[0] = 217;
              Main.desertBG[1] = 218;
              Main.desertBG[2] = -1;
              return;
            case 4:
              Main.desertBG[0] = 248;
              Main.desertBG[1] = 249;
              Main.desertBG[2] = 250;
              return;
            default:
              Main.desertBG[0] = 21;
              Main.desertBG[1] = 20;
              Main.desertBG[2] = -1;
              return;
          }
        case 7:
          WorldGen.oceanBG = style;
          switch (style)
          {
            case 1:
              Main.oceanBG = 110;
              return;
            case 2:
              Main.oceanBG = 111;
              return;
            case 3:
              Main.oceanBG = 209;
              return;
            case 4:
              Main.oceanBG = 210;
              return;
            case 5:
              Main.oceanBG = 283;
              return;
            default:
              Main.oceanBG = 28;
              return;
          }
        case 8:
          WorldGen.mushroomBG = style;
          switch (style)
          {
            case 1:
              Main.mushroomBG[0] = 231;
              Main.mushroomBG[1] = 232;
              Main.mushroomBG[2] = 233;
              return;
            case 2:
              Main.mushroomBG[0] = 234;
              Main.mushroomBG[1] = 235;
              Main.mushroomBG[2] = 236;
              return;
            case 3:
              Main.mushroomBG[0] = 287;
              Main.mushroomBG[1] = 288;
              Main.mushroomBG[2] = 289;
              return;
            default:
              Main.mushroomBG[0] = 46;
              Main.mushroomBG[1] = 47;
              Main.mushroomBG[2] = 48;
              return;
          }
        case 9:
          WorldGen.underworldBG = style;
          if (style != 1)
          {
            if (style != 2)
            {
              Main.underworldBG[0] = 0;
              Main.underworldBG[1] = 1;
              Main.underworldBG[2] = 2;
              Main.underworldBG[3] = 3;
              Main.underworldBG[4] = 4;
              break;
            }
            Main.underworldBG[0] = 10;
            Main.underworldBG[1] = 11;
            Main.underworldBG[2] = 12;
            Main.underworldBG[3] = 13;
            Main.underworldBG[4] = 9;
            break;
          }
          Main.underworldBG[0] = 5;
          Main.underworldBG[1] = 6;
          Main.underworldBG[2] = 7;
          Main.underworldBG[3] = 8;
          Main.underworldBG[4] = 9;
          break;
        case 10:
          WorldGen.treeBG2 = style;
          WorldGen.SetForestBGSet(style, Main.treeMntBGSet2, Main.treeBGSet2);
          break;
        case 11:
          WorldGen.treeBG3 = style;
          WorldGen.SetForestBGSet(style, Main.treeMntBGSet3, Main.treeBGSet3);
          break;
        case 12:
          WorldGen.treeBG4 = style;
          WorldGen.SetForestBGSet(style, Main.treeMntBGSet4, Main.treeBGSet4);
          break;
      }
    }

    private static void SetForestBGSet(int style, int[] mountainSet, int[] treeSet)
    {
      mountainSet[0] = 7;
      mountainSet[1] = 8;
      switch (style)
      {
        case 1:
          treeSet[0] = 50;
          treeSet[1] = 51;
          treeSet[2] = 52;
          break;
        case 2:
          treeSet[0] = 53;
          treeSet[1] = 54;
          treeSet[2] = 55;
          break;
        case 3:
          mountainSet[1] = 90;
          treeSet[0] = 91;
          treeSet[1] = -1;
          treeSet[2] = 92;
          break;
        case 4:
          mountainSet[0] = 93;
          mountainSet[1] = 94;
          treeSet[0] = -1;
          treeSet[1] = -1;
          treeSet[2] = -1;
          break;
        case 5:
          mountainSet[0] = 93;
          mountainSet[1] = 94;
          treeSet[0] = -1;
          treeSet[1] = -1;
          treeSet[2] = 55;
          break;
        case 6:
          mountainSet[0] = 171;
          mountainSet[1] = 172;
          treeSet[0] = 173;
          treeSet[1] = -1;
          treeSet[2] = -1;
          break;
        case 7:
          mountainSet[0] = 176;
          mountainSet[1] = 177;
          treeSet[0] = 178;
          treeSet[1] = -1;
          treeSet[2] = -1;
          break;
        case 8:
          mountainSet[0] = 179;
          mountainSet[1] = 180;
          treeSet[0] = 184;
          treeSet[1] = -1;
          treeSet[2] = -1;
          break;
        case 9:
          mountainSet[0] = 277;
          mountainSet[1] = 278;
          treeSet[0] = 279;
          treeSet[1] = -1;
          treeSet[2] = -1;
          break;
        case 10:
          mountainSet[0] = 280;
          mountainSet[1] = 281;
          treeSet[0] = 282;
          treeSet[1] = -1;
          treeSet[2] = -1;
          break;
        case 31:
          mountainSet[1] = 90;
          treeSet[0] = 91;
          treeSet[1] = -1;
          treeSet[2] = 11;
          break;
        case 51:
          mountainSet[0] = 93;
          mountainSet[1] = 94;
          treeSet[0] = -1;
          treeSet[1] = -1;
          treeSet[2] = 11;
          break;
        case 71:
          mountainSet[0] = 176;
          mountainSet[1] = 177;
          treeSet[0] = 178;
          treeSet[1] = -1;
          treeSet[2] = 11;
          break;
        case 72:
          mountainSet[0] = 176;
          mountainSet[1] = 177;
          treeSet[0] = 178;
          treeSet[1] = -1;
          treeSet[2] = 52;
          break;
        case 73:
          mountainSet[0] = 176;
          mountainSet[1] = 177;
          treeSet[0] = 178;
          treeSet[1] = -1;
          treeSet[2] = 55;
          break;
        default:
          treeSet[0] = 9;
          treeSet[1] = 10;
          treeSet[2] = 11;
          break;
      }
    }

    public static void RandomizeWeather()
    {
      Main.numClouds = WorldGen.genRand.Next(10, 200);
      Main.windSpeedCurrent = 0.0f;
      while ((double) Main.windSpeedCurrent == 0.0)
      {
        Main.windSpeedCurrent = (float) WorldGen.genRand.Next(-400, 401) * (1f / 1000f);
        Main.windSpeedTarget = Main.windSpeedCurrent;
      }
      Cloud.resetClouds();
    }

    public static void RandomizeMoonState(UnifiedRandom random, bool garenteeNewStyle = false)
    {
      int moonType = Main.moonType;
      do
      {
        Main.moonType = random.Next(9);
      }
      while (garenteeNewStyle && moonType == Main.moonType);
    }

    public static void RandomizeBackgroundBasedOnPlayer(UnifiedRandom random, Player player)
    {
      if (player.ZoneGlowshroom)
      {
        int mushroomBg = WorldGen.mushroomBG;
        while (mushroomBg == WorldGen.mushroomBG)
          WorldGen.setBG(8, random.Next(4));
      }
      else if (player.ZoneUnderworldHeight)
      {
        int underworldBg = WorldGen.underworldBG;
        while (underworldBg == WorldGen.underworldBG)
          WorldGen.setBG(9, random.Next(3));
      }
      else if (player.ZoneDesert)
      {
        int desertBg = WorldGen.desertBG;
        while (desertBg == WorldGen.desertBG)
          WorldGen.setBG(6, random.Next(5));
      }
      else if (player.ZoneHallow)
      {
        int hallowBg = WorldGen.hallowBG;
        while (hallowBg == WorldGen.hallowBG)
          WorldGen.setBG(4, random.Next(5));
      }
      else if (player.ZoneCorrupt)
      {
        int corruptBg = WorldGen.corruptBG;
        while (corruptBg == WorldGen.corruptBG)
          WorldGen.setBG(1, random.Next(5));
      }
      else if (player.ZoneCrimson)
      {
        int crimsonBg = WorldGen.crimsonBG;
        while (crimsonBg == WorldGen.crimsonBG)
          WorldGen.setBG(5, random.Next(6));
      }
      else if (player.ZoneJungle)
      {
        int jungleBg = WorldGen.jungleBG;
        while (jungleBg == WorldGen.jungleBG)
          WorldGen.setBG(2, random.Next(6));
      }
      else if (player.ZoneSnow)
      {
        int snowBg = WorldGen.snowBG;
        while (snowBg == WorldGen.snowBG)
        {
          WorldGen.snowBG = random.Next(8);
          if (WorldGen.snowBG == 2 && random.Next(2) == 0)
            WorldGen.snowBG = random.Next(2) != 0 ? 22 : 21;
          if (WorldGen.snowBG == 3 && random.Next(2) == 0)
            WorldGen.snowBG = random.Next(2) != 0 ? 32 : 31;
          if (WorldGen.snowBG == 4 && random.Next(2) == 0)
            WorldGen.snowBG = random.Next(2) != 0 ? 42 : 41;
          WorldGen.setBG(3, WorldGen.snowBG);
        }
      }
      else if (player.ZoneBeach)
      {
        int oceanBg = WorldGen.oceanBG;
        while (oceanBg == WorldGen.oceanBG)
          WorldGen.setBG(7, random.Next(6));
      }
      else
      {
        int num = (int) ((double) player.Center.X / 16.0);
        if (num < Main.treeX[0])
        {
          int treeBg1 = WorldGen.treeBG1;
          while (WorldGen.IsBackgroundConsideredTheSame(treeBg1, WorldGen.treeBG1))
            WorldGen.treeBG1 = WorldGen.RollRandomForestBGStyle(random);
          WorldGen.setBG(0, WorldGen.treeBG1);
        }
        else if (num < Main.treeX[1])
        {
          int treeBg2 = WorldGen.treeBG2;
          while (WorldGen.IsBackgroundConsideredTheSame(treeBg2, WorldGen.treeBG2))
            WorldGen.treeBG2 = WorldGen.RollRandomForestBGStyle(random);
          WorldGen.setBG(10, WorldGen.treeBG2);
        }
        else if (num < Main.treeX[2])
        {
          int treeBg3 = WorldGen.treeBG3;
          while (WorldGen.IsBackgroundConsideredTheSame(treeBg3, WorldGen.treeBG3))
            WorldGen.treeBG3 = WorldGen.RollRandomForestBGStyle(random);
          WorldGen.setBG(11, WorldGen.treeBG3);
        }
        else
        {
          int treeBg4 = WorldGen.treeBG4;
          while (WorldGen.IsBackgroundConsideredTheSame(treeBg4, WorldGen.treeBG4))
            WorldGen.treeBG4 = WorldGen.RollRandomForestBGStyle(random);
          WorldGen.setBG(12, WorldGen.treeBG4);
        }
      }
      WorldGen.BackgroundsCache.UpdateCache();
    }

    public static void RandomizeBackgrounds(UnifiedRandom random)
    {
      WorldGen.treeBG1 = WorldGen.RollRandomForestBGStyle(random);
      WorldGen.treeBG2 = WorldGen.RollRandomForestBGStyle(random);
      while (WorldGen.treeBG2 == WorldGen.treeBG1)
        WorldGen.treeBG2 = WorldGen.RollRandomForestBGStyle(random);
      WorldGen.treeBG3 = WorldGen.RollRandomForestBGStyle(random);
      while (WorldGen.treeBG3 == WorldGen.treeBG1 || WorldGen.treeBG3 == WorldGen.treeBG2)
        WorldGen.treeBG3 = WorldGen.RollRandomForestBGStyle(random);
      WorldGen.treeBG4 = WorldGen.RollRandomForestBGStyle(random);
      while (WorldGen.treeBG4 == WorldGen.treeBG1 || WorldGen.treeBG4 == WorldGen.treeBG2 || WorldGen.treeBG4 == WorldGen.treeBG3)
        WorldGen.treeBG4 = WorldGen.RollRandomForestBGStyle(random);
      WorldGen.setBG(0, WorldGen.treeBG1);
      WorldGen.setBG(10, WorldGen.treeBG2);
      WorldGen.setBG(11, WorldGen.treeBG3);
      WorldGen.setBG(12, WorldGen.treeBG4);
      WorldGen.setBG(1, random.Next(5));
      WorldGen.setBG(2, random.Next(6));
      WorldGen.snowBG = random.Next(8);
      if (WorldGen.snowBG == 2 && random.Next(2) == 0)
        WorldGen.snowBG = random.Next(2) != 0 ? 22 : 21;
      if (WorldGen.snowBG == 3 && random.Next(2) == 0)
        WorldGen.snowBG = random.Next(2) != 0 ? 32 : 31;
      if (WorldGen.snowBG == 4 && random.Next(2) == 0)
        WorldGen.snowBG = random.Next(2) != 0 ? 42 : 41;
      WorldGen.setBG(3, WorldGen.snowBG);
      WorldGen.setBG(4, random.Next(5));
      WorldGen.setBG(5, random.Next(6));
      WorldGen.setBG(6, random.Next(5));
      WorldGen.setBG(7, random.Next(6));
      WorldGen.setBG(8, random.Next(4));
      WorldGen.setBG(9, random.Next(3));
    }

    private static int RollRandomForestBGStyle(UnifiedRandom random)
    {
      int num = random.Next(11);
      if ((num == 1 || num == 2) && random.Next(2) == 0)
        num = random.Next(11);
      if (num == 0)
        num = random.Next(11);
      if (num == 3 && random.Next(3) == 0)
        num = 31;
      if (num == 5 && random.Next(2) == 0)
        num = 51;
      if (num == 7 && random.Next(4) == 0)
        num = random.Next(71, 74);
      return num;
    }

    public static bool IsBackgroundConsideredTheSame(int oldBG, int newBG)
    {
      switch (oldBG)
      {
        case 3:
        case 31:
          return newBG == 3 || newBG == 31;
        case 5:
        case 51:
          return newBG == 5 || newBG == 51;
        case 7:
        case 71:
        case 72:
        case 73:
          if (newBG == 7)
            return true;
          return newBG >= 71 && newBG <= 73;
        default:
          return oldBG == newBG;
      }
    }

    public static void RandomizeTreeStyle()
    {
      switch (Main.maxTilesX)
      {
        case 4200:
          Main.treeX[0] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.5 - (double) Main.maxTilesX * 0.25), (int) ((double) Main.maxTilesX * 0.5 + (double) Main.maxTilesX * 0.25));
          Main.treeStyle[0] = WorldGen.genRand.Next(6);
          Main.treeStyle[1] = WorldGen.genRand.Next(6);
          while (Main.treeStyle[1] == Main.treeStyle[0])
            Main.treeStyle[1] = WorldGen.genRand.Next(6);
          Main.treeX[1] = Main.maxTilesX;
          Main.treeX[2] = Main.maxTilesX;
          for (int index = 0; index < 2; ++index)
          {
            if (Main.treeStyle[index] == 0 && WorldGen.genRand.Next(3) != 0)
              Main.treeStyle[index] = 4;
          }
          break;
        case 6400:
          Main.treeX[0] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.334 - (double) Main.maxTilesX * 0.2), (int) ((double) Main.maxTilesX * 0.334 + (double) Main.maxTilesX * 0.2));
          Main.treeX[1] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.667 - (double) Main.maxTilesX * 0.2), (int) ((double) Main.maxTilesX * 0.667 + (double) Main.maxTilesX * 0.2));
          Main.treeStyle[0] = WorldGen.genRand.Next(6);
          Main.treeStyle[1] = WorldGen.genRand.Next(6);
          Main.treeStyle[2] = WorldGen.genRand.Next(6);
          while (Main.treeStyle[1] == Main.treeStyle[0])
            Main.treeStyle[1] = WorldGen.genRand.Next(6);
          while (Main.treeStyle[2] == Main.treeStyle[0] || Main.treeStyle[2] == Main.treeStyle[1])
            Main.treeStyle[2] = WorldGen.genRand.Next(6);
          Main.treeX[2] = Main.maxTilesX;
          for (int index = 0; index < 3; ++index)
          {
            if (Main.treeStyle[index] == 0 && WorldGen.genRand.Next(3) != 0)
              Main.treeStyle[index] = 4;
          }
          break;
        default:
          Main.treeX[0] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.25 - (double) Main.maxTilesX * 0.15), (int) ((double) Main.maxTilesX * 0.25 + (double) Main.maxTilesX * 0.15));
          Main.treeX[1] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.5 - (double) Main.maxTilesX * 0.15), (int) ((double) Main.maxTilesX * 0.5 + (double) Main.maxTilesX * 0.15));
          Main.treeX[2] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.75 - (double) Main.maxTilesX * 0.15), (int) ((double) Main.maxTilesX * 0.75 + (double) Main.maxTilesX * 0.15));
          Main.treeStyle[0] = WorldGen.genRand.Next(6);
          Main.treeStyle[1] = WorldGen.genRand.Next(6);
          Main.treeStyle[2] = WorldGen.genRand.Next(6);
          Main.treeStyle[3] = WorldGen.genRand.Next(6);
          while (Main.treeStyle[1] == Main.treeStyle[0])
            Main.treeStyle[1] = WorldGen.genRand.Next(6);
          while (Main.treeStyle[2] == Main.treeStyle[0] || Main.treeStyle[2] == Main.treeStyle[1])
            Main.treeStyle[2] = WorldGen.genRand.Next(6);
          while (Main.treeStyle[3] == Main.treeStyle[0] || Main.treeStyle[3] == Main.treeStyle[1] || Main.treeStyle[3] == Main.treeStyle[2])
            Main.treeStyle[3] = WorldGen.genRand.Next(6);
          for (int index = 0; index < 4; ++index)
          {
            if (Main.treeStyle[index] == 0 && WorldGen.genRand.Next(3) != 0)
              Main.treeStyle[index] = 4;
          }
          break;
      }
    }

    public static void RandomizeCaveBackgrounds()
    {
      int maxValue = 8;
      switch (Main.maxTilesX)
      {
        case 4200:
          Main.caveBackX[0] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.5 - (double) Main.maxTilesX * 0.25), (int) ((double) Main.maxTilesX * 0.5 + (double) Main.maxTilesX * 0.25));
          Main.caveBackX[1] = Main.maxTilesX;
          Main.caveBackX[2] = Main.maxTilesX;
          Main.caveBackStyle[0] = WorldGen.genRand.Next(maxValue);
          Main.caveBackStyle[1] = WorldGen.genRand.Next(maxValue);
          while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
            Main.caveBackStyle[1] = WorldGen.genRand.Next(maxValue);
          break;
        case 6400:
          Main.caveBackX[0] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.334 - (double) Main.maxTilesX * 0.2), (int) ((double) Main.maxTilesX * 0.334 + (double) Main.maxTilesX * 0.2));
          Main.caveBackX[1] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.667 - (double) Main.maxTilesX * 0.2), (int) ((double) Main.maxTilesX * 0.667 + (double) Main.maxTilesX * 0.2));
          Main.caveBackX[2] = Main.maxTilesX;
          Main.caveBackStyle[0] = WorldGen.genRand.Next(maxValue);
          Main.caveBackStyle[1] = WorldGen.genRand.Next(maxValue);
          Main.caveBackStyle[2] = WorldGen.genRand.Next(maxValue);
          while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
            Main.caveBackStyle[1] = WorldGen.genRand.Next(maxValue);
          while (Main.caveBackStyle[2] == Main.caveBackStyle[0] || Main.caveBackStyle[2] == Main.caveBackStyle[1])
            Main.caveBackStyle[2] = WorldGen.genRand.Next(maxValue);
          break;
        default:
          Main.caveBackX[0] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.25 - (double) Main.maxTilesX * 0.15), (int) ((double) Main.maxTilesX * 0.25 + (double) Main.maxTilesX * 0.15));
          Main.caveBackX[1] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.5 - (double) Main.maxTilesX * 0.15), (int) ((double) Main.maxTilesX * 0.5 + (double) Main.maxTilesX * 0.15));
          Main.caveBackX[2] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.75 - (double) Main.maxTilesX * 0.15), (int) ((double) Main.maxTilesX * 0.75 + (double) Main.maxTilesX * 0.15));
          Main.caveBackStyle[0] = WorldGen.genRand.Next(maxValue);
          Main.caveBackStyle[1] = WorldGen.genRand.Next(maxValue);
          Main.caveBackStyle[2] = WorldGen.genRand.Next(maxValue);
          Main.caveBackStyle[3] = WorldGen.genRand.Next(maxValue);
          while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
            Main.caveBackStyle[1] = WorldGen.genRand.Next(maxValue);
          while (Main.caveBackStyle[2] == Main.caveBackStyle[0] || Main.caveBackStyle[2] == Main.caveBackStyle[1])
            Main.caveBackStyle[2] = WorldGen.genRand.Next(maxValue);
          while (Main.caveBackStyle[3] == Main.caveBackStyle[0] || Main.caveBackStyle[3] == Main.caveBackStyle[1] || Main.caveBackStyle[3] == Main.caveBackStyle[2])
            Main.caveBackStyle[3] = WorldGen.genRand.Next(maxValue);
          break;
      }
      Main.iceBackStyle = WorldGen.genRand.Next(4);
      Main.hellBackStyle = WorldGen.genRand.Next(3);
      Main.jungleBackStyle = WorldGen.genRand.Next(2);
    }

    private static void ResetGenerator()
    {
      GenVars.numOrePatch = 0;
      GenVars.numTunnels = 0;
      GenVars.numLakes = 0;
      GenVars.numMushroomBiomes = 0;
      GenVars.numOceanCaveTreasure = 0;
      GenVars.numOasis = 0;
      GenVars.mudWall = false;
      GenVars.hellChest = 0;
      GenVars.JungleX = 0;
      GenVars.numMCaves = 0;
      GenVars.numIslandHouses = 0;
      GenVars.skyIslandHouseCount = 0;
      GenVars.dEnteranceX = 0;
      GenVars.numDRooms = 0;
      GenVars.numDDoors = 0;
      GenVars.generatedShadowKey = false;
      GenVars.numDungeonPlatforms = 0;
      GenVars.numJChests = 0;
      GenVars.JungleItemCount = 0;
      GenVars.lastDungeonHall = Vector2D.Zero;
    }

    public static bool mayanTrap(int x2, int y2)
    {
      int num1 = 1;
      if (WorldGen.genRand.Next(3) == 0)
        num1 = 0;
      int index1 = x2;
      int y = y2;
      while (!WorldGen.SolidOrSlopedTile(index1, y))
      {
        ++y;
        if (y >= Main.maxTilesY - 300)
          return false;
      }
      if (Main.tile[index1, y].type == (ushort) 232 || Main.tile[index1, y].type == (ushort) 10)
        return false;
      int j = y - 1;
      if (Main.tile[index1, j].liquid > (byte) 0 && Main.tile[index1, j].lava())
        return false;
      if (num1 == -1 && WorldGen.genRand.Next(20) == 0)
        num1 = 2;
      else if (num1 == -1)
        num1 = WorldGen.genRand.Next(2);
      if (Main.tile[index1, j].nactive() || Main.tile[index1 - 1, j].nactive() || Main.tile[index1 + 1, j].nactive() || Main.tile[index1, j - 1].nactive() || Main.tile[index1 - 1, j - 1].nactive() || Main.tile[index1 + 1, j - 1].nactive() || Main.tile[index1, j - 2].nactive() || Main.tile[index1 - 1, j - 2].nactive() || Main.tile[index1 + 1, j - 2].nactive() || Main.tile[index1, j + 1].type == (ushort) 10 || Main.tile[index1, j + 1].type == (ushort) 48 || Main.tile[index1, j + 1].type == (ushort) 232)
        return false;
      switch (num1)
      {
        case 0:
          int x1 = index1;
          int index2 = j - WorldGen.genRand.Next(3);
          while (WorldGen.InWorld(x1, index2, 5) && !WorldGen.SolidOrSlopedTile(x1, index2))
            --x1;
          int x3 = x1;
          int x4 = index1;
          while (WorldGen.InWorld(x4, index2, 5) && !WorldGen.SolidOrSlopedTile(x4, index2))
            ++x4;
          int x5 = x4;
          int num2 = index1 - x3;
          int num3 = x5 - index1;
          bool flag1 = false;
          bool flag2 = false;
          if (num2 > 5 && num2 < 50)
            flag1 = true;
          if (num3 > 5 && num3 < 50)
            flag2 = true;
          if (flag1 && !WorldGen.SolidOrSlopedTile(x3, index2 + 1))
            flag1 = false;
          if (flag2 && !WorldGen.SolidOrSlopedTile(x5, index2 + 1))
            flag2 = false;
          if (flag1 && (Main.tile[x3, index2].type == (ushort) 10 || Main.tile[x3, index2].type == (ushort) 48 || Main.tile[x3, index2 + 1].type == (ushort) 10 || Main.tile[x3, index2 + 1].type == (ushort) 48))
            flag1 = false;
          if (flag2 && (Main.tile[x5, index2].type == (ushort) 10 || Main.tile[x5, index2].type == (ushort) 48 || Main.tile[x5, index2 + 1].type == (ushort) 10 || Main.tile[x5, index2 + 1].type == (ushort) 48))
            flag2 = false;
          int num4;
          int i;
          if (flag1 & flag2)
          {
            num4 = 1;
            i = x3;
            if (WorldGen.genRand.Next(2) == 0)
            {
              i = x5;
              num4 = -1;
            }
          }
          else if (flag2)
          {
            i = x5;
            num4 = -1;
          }
          else
          {
            if (!flag1)
              return false;
            i = x3;
            num4 = 1;
          }
          if (Main.tile[i, index2].wall != (ushort) 87 || Main.tile[i, index2].type == (ushort) 190 || Main.tile[i, index2].type == (ushort) 135 || Main.tile[i, index2].type == (ushort) 137 || Main.tile[i, index2].type == (ushort) 232 || Main.tile[i, index2].type == (ushort) 237 || Main.tile[i, index2].type == (ushort) 10)
            return false;
          WorldGen.PlaceTile(index1, j, 135, true, true, style: 6);
          WorldGen.KillTile(i, index2);
          int num5 = WorldGen.genRand.Next(3);
          if (Main.tile[index1, j].wire())
            num5 = 0;
          if (Main.tile[index1, j].wire2())
            num5 = 1;
          if (Main.tile[index1, j].wire3())
            num5 = 2;
          int num6 = Math.Abs(i - index1);
          int style1 = 1;
          if (num6 < 10 && WorldGen.genRand.Next(3) != 0)
            style1 = 2;
          WorldGen.PlaceTile(i, index2, 137, true, true, style: style1);
          if (num4 == 1)
            Main.tile[i, index2].frameX += (short) 18;
          int num7 = WorldGen.genRand.Next(5);
          int index3 = index2;
          while (num7 > 0)
          {
            --num7;
            --index3;
            if (WorldGen.SolidTile(i, index3) && WorldGen.SolidTile(i - num4, index3) && !WorldGen.SolidOrSlopedTile(i + num4, index3))
            {
              WorldGen.PlaceTile(i, index3, 137, true, true, style: style1);
              if (num4 == 1)
                Main.tile[i, index3].frameX += (short) 18;
              switch (num5)
              {
                case 0:
                  Main.tile[i, index3].wire(true);
                  continue;
                case 1:
                  Main.tile[i, index3].wire2(true);
                  continue;
                case 2:
                  Main.tile[i, index3].wire3(true);
                  continue;
                default:
                  continue;
              }
            }
            else
              break;
          }
          int index4 = index1;
          int index5 = j;
          while (index4 != i || index5 != index2)
          {
            switch (num5)
            {
              case 0:
                Main.tile[index4, index5].wire(true);
                break;
              case 1:
                Main.tile[index4, index5].wire2(true);
                break;
              case 2:
                Main.tile[index4, index5].wire3(true);
                break;
            }
            if (index4 > i)
              --index4;
            if (index4 < i)
              ++index4;
            switch (num5)
            {
              case 0:
                Main.tile[index4, index5].wire(true);
                break;
              case 1:
                Main.tile[index4, index5].wire2(true);
                break;
              case 2:
                Main.tile[index4, index5].wire3(true);
                break;
            }
            if (index5 > index2)
              --index5;
            if (index5 < index2)
              ++index5;
            switch (num5)
            {
              case 0:
                Main.tile[index4, index5].wire(true);
                continue;
              case 1:
                Main.tile[index4, index5].wire2(true);
                continue;
              case 2:
                Main.tile[index4, index5].wire3(true);
                continue;
              default:
                continue;
            }
          }
          return true;
        case 1:
          int index6 = index1;
          int index7 = j;
          while (!WorldGen.SolidOrSlopedTile(index6, index7))
          {
            --index7;
            if ((double) index7 < Main.worldSurface)
              return false;
          }
          int num8 = Math.Abs(index7 - j);
          if (num8 < 3)
            return false;
          int num9 = WorldGen.genRand.Next(3);
          if (Main.tile[index1, j].wire())
            num9 = 0;
          if (Main.tile[index1, j].wire2())
            num9 = 1;
          if (Main.tile[index1, j].wire3())
            num9 = 2;
          int style2 = 3;
          if (num8 < 16 && WorldGen.genRand.Next(3) != 0)
            style2 = 4;
          if (Main.tile[index6, index7].type == (ushort) 135 || Main.tile[index6, index7].type == (ushort) 137 || Main.tile[index6, index7].type == (ushort) 232 || Main.tile[index6, index7].type == (ushort) 237 || Main.tile[index6, index7].type == (ushort) 10 || Main.tile[index6, index7].wall != (ushort) 87)
            return false;
          WorldGen.PlaceTile(index1, j, 135, true, true, style: 6);
          WorldGen.PlaceTile(index6, index7, 137, true, true, style: style2);
          for (int index8 = 0; index8 < 2; ++index8)
          {
            int num10 = WorldGen.genRand.Next(1, 5);
            int index9 = index6;
            int num11 = -1;
            if (index8 == 1)
              num11 = 1;
            while (num10 > 0)
            {
              --num10;
              index9 += num11;
              if (WorldGen.SolidTile(index9, index7 - 1) && !WorldGen.SolidOrSlopedTile(index9, index7 + 1))
              {
                WorldGen.PlaceTile(index9, index7, 137, true, true, style: style2);
                switch (num9)
                {
                  case 0:
                    Main.tile[index9, index7].wire(true);
                    continue;
                  case 1:
                    Main.tile[index9, index7].wire2(true);
                    continue;
                  case 2:
                    Main.tile[index9, index7].wire3(true);
                    continue;
                  default:
                    continue;
                }
              }
              else
                break;
            }
          }
          int index10 = index1;
          int index11 = j;
          while (index10 != index6 || index11 != index7)
          {
            switch (num9)
            {
              case 0:
                Main.tile[index10, index11].wire(true);
                break;
              case 1:
                Main.tile[index10, index11].wire2(true);
                break;
              case 2:
                Main.tile[index10, index11].wire3(true);
                break;
            }
            if (index10 > index6)
              --index10;
            if (index10 < index6)
              ++index10;
            switch (num9)
            {
              case 0:
                Main.tile[index10, index11].wire(true);
                break;
              case 1:
                Main.tile[index10, index11].wire2(true);
                break;
              case 2:
                Main.tile[index10, index11].wire3(true);
                break;
            }
            if (index11 > index7)
              --index11;
            if (index11 < index7)
              ++index11;
            switch (num9)
            {
              case 0:
                Main.tile[index10, index11].wire(true);
                continue;
              case 1:
                Main.tile[index10, index11].wire2(true);
                continue;
              case 2:
                Main.tile[index10, index11].wire3(true);
                continue;
              default:
                continue;
            }
          }
          return true;
        default:
          return false;
      }
    }

    public static bool placeLavaTrap(int x, int y)
    {
      int num1 = 5;
      int num2 = 50;
      int num3 = 40;
      int num4 = 20;
      int num5 = 4;
      if (Main.tile[x, y].active() || Main.tile[x, y].liquid < byte.MaxValue || !Main.tile[x, y].lava())
        return false;
      int num6 = 0;
      for (int index1 = x - num1; index1 <= x + num1; ++index1)
      {
        for (int index2 = y - num1; index2 <= y + num1; ++index2)
        {
          if (Main.tile[index1, index2].lava() && !Main.tile[index1, index2].active() && Main.tile[index1, index2].liquid == byte.MaxValue)
            ++num6;
        }
      }
      if (num6 < num2)
        return false;
      int index3 = y;
      while (!Main.tile[x, index3].active())
      {
        ++index3;
        if (index3 > Main.maxTilesY - 200)
          return false;
      }
      if (!Main.tileSolid[(int) Main.tile[x, index3].type] || Main.tileSolidTop[(int) Main.tile[x, index3].type])
        return false;
      int num7 = index3;
      for (int index4 = x - num4; index4 <= x + num4; ++index4)
      {
        for (int index5 = index3 - num4; index5 <= index3 + num4; ++index5)
        {
          if (Main.tile[index4, index5].wire())
            return false;
        }
      }
      while (Main.tile[x, index3].active() && Main.tileSolid[(int) Main.tile[x, index3].type] && !Main.tileSolidTop[(int) Main.tile[x, index3].type])
      {
        ++index3;
        if (index3 > Main.maxTilesY - 200)
          return false;
      }
      Tile tile = Main.tile[x, index3 - 1];
      if (Main.tileDungeon[(int) tile.type] || tile.type == (ushort) 225 || tile.type == (ushort) 226)
        return false;
      int num8 = index3;
      while (!Main.tile[x, index3].active())
      {
        ++index3;
        if (index3 > Main.maxTilesY - 200 || Main.tile[x, index3].liquid > (byte) 0)
          return false;
      }
      if (!Main.tileSolid[(int) Main.tile[x, index3].type] || Main.tileSolidTop[(int) Main.tile[x, index3].type] || Main.tile[x, index3].type == (ushort) 162)
        return false;
      int j = index3 - 1;
      if (j - num7 > num3 || j - num8 < num5)
        return false;
      Main.tile[x, index3].slope((byte) 0);
      Main.tile[x, index3].halfBrick(false);
      WorldGen.PlaceTile(x, j, 135, forced: true, style: 7);
      for (int index6 = num7; index6 <= j; ++index6)
      {
        Main.tile[x, index6].wire(true);
        if (index6 < num8)
        {
          Main.tile[x, index6].slope((byte) 0);
          Main.tile[x, index6].halfBrick(false);
          Main.tile[x, index6].actuator(true);
        }
      }
      return true;
    }

    public static bool IsTileNearby(int x, int y, int type, int distance)
    {
      for (int x1 = x - distance; x1 <= x + distance; ++x1)
      {
        for (int y1 = y - distance; y1 <= y + distance; ++y1)
        {
          if (WorldGen.InWorld(x1, y1) && Main.tile[x1, y1].active() && (int) Main.tile[x1, y1].type == type)
            return true;
        }
      }
      return false;
    }

    private static bool placeTNTBarrel(int x, int y)
    {
      int i = x;
      int index = y;
      while (!Main.tile[i, index].active())
      {
        ++index;
        if (index > Main.maxTilesY - 350)
          return false;
      }
      int j = index - 1;
      return !Main.tile[i, j].shimmer() && WorldGen.PlaceTile(i, j, 654);
    }

    public static bool placeTrap(int x2, int y2, int type = -1)
    {
      int index1 = x2;
      int j1 = y2;
      if (Vector2D.Distance(new Vector2D((double) x2, (double) y2), GenVars.shimmerPosition) < 100.0)
        return false;
      bool flag1 = false;
      bool flag2 = false;
      if (WorldGen.noTrapsWorldGen)
        Main.tileSolid[138] = false;
      while (!WorldGen.SolidTile(index1, j1))
      {
        ++j1;
        if (j1 > Main.maxTilesY - 10)
          return false;
        if (j1 >= Main.maxTilesY - 300)
          flag2 = true;
      }
      if (WorldGen.noTrapsWorldGen)
        Main.tileSolid[138] = true;
      int index2 = j1 - 1;
      if (!WorldGen.noTrapsWorldGen && WorldGen.IsTileNearby(index1, index2, 70, 20) || Main.tile[index1, index2].wall == (ushort) 87)
        return false;
      if (Main.tile[index1, index2].liquid > (byte) 0 && Main.tile[index1, index2].lava())
        flag1 = true;
      if (Main.remixWorld)
      {
        if (type == -1 && WorldGen.genRand.Next(20) == 0)
          type = 2;
        else if (type == -1 && (double) index2 < Main.rockLayer - 30.0 && WorldGen.genRand.Next(3) != 0)
          type = 3;
        else if (type == -1)
          type = WorldGen.genRand.Next(2);
      }
      else if (type == -1 && WorldGen.genRand.Next(20) == 0)
        type = 2;
      else if (type == -1 && index2 > GenVars.lavaLine + 30 && WorldGen.genRand.Next(6) != 0)
        type = 3;
      else if (type == -1)
        type = WorldGen.genRand.Next(2);
      if (!WorldGen.InWorld(index1, index2, 3) || flag1 && type != 3 || flag2 && type != 3 || Main.tile[index1, index2].nactive() || Main.tile[index1 - 1, index2].nactive() || Main.tile[index1 + 1, index2].nactive() || Main.tile[index1, index2 - 1].nactive() || Main.tile[index1 - 1, index2 - 1].nactive() || Main.tile[index1 + 1, index2 - 1].nactive() || Main.tile[index1, index2 - 2].nactive() || Main.tile[index1 - 1, index2 - 2].nactive() || Main.tile[index1 + 1, index2 - 2].nactive() || Main.tile[index1, index2 + 1].type == (ushort) 48 || Main.tile[index1, index2 + 1].type == (ushort) 232)
        return false;
      if (type == 1)
      {
        for (int index3 = index1 - 3; index3 <= index1 + 3; ++index3)
        {
          for (int index4 = index2 - 3; index4 <= index2 + 3; ++index4)
          {
            if (Main.tile[index3, index4].type == (ushort) 147 || Main.tile[index3, index4].type == (ushort) 161)
              type = 0;
          }
        }
      }
      if (WorldGen.noTrapsWorldGen)
        Main.tileSolid[138] = false;
      switch (type)
      {
        case 0:
          int i1 = index1;
          int j2 = index2 - WorldGen.genRand.Next(3);
          while (!WorldGen.SolidTile(i1, j2) && !Main.tileCracked[(int) Main.tile[i1, j2].type])
          {
            --i1;
            if (i1 < 0)
              return false;
          }
          int i2 = i1;
          int i3 = index1;
          while (!WorldGen.SolidTile(i3, j2) && !Main.tileCracked[(int) Main.tile[i3, j2].type])
          {
            ++i3;
            if (i3 > Main.maxTilesX)
              return false;
          }
          int i4 = i3;
          int num1 = index1 - i2;
          int num2 = i4 - index1;
          bool flag3 = false;
          bool flag4 = false;
          if (num1 > 5 && num1 < 50)
            flag3 = true;
          if (num2 > 5 && num2 < 50)
            flag4 = true;
          if (flag3 && !WorldGen.SolidTile(i2, j2 + 1))
            flag3 = false;
          if (flag4 && !WorldGen.SolidTile(i4, j2 + 1))
            flag4 = false;
          if (flag3 && (Main.tile[i2, j2].type == (ushort) 10 || Main.tile[i2, j2].type == (ushort) 48 || Main.tile[i2, j2 + 1].type == (ushort) 10 || Main.tile[i2, j2 + 1].type == (ushort) 48))
            flag3 = false;
          if (flag4 && (Main.tile[i4, j2].type == (ushort) 10 || Main.tile[i4, j2].type == (ushort) 48 || Main.tile[i4, j2 + 1].type == (ushort) 10 || Main.tile[i4, j2 + 1].type == (ushort) 48))
            flag4 = false;
          int num3;
          int i5;
          if (flag3 & flag4)
          {
            num3 = 1;
            i5 = i2;
            if (WorldGen.genRand.Next(2) == 0)
            {
              i5 = i4;
              num3 = -1;
            }
          }
          else if (flag4)
          {
            i5 = i4;
            num3 = -1;
          }
          else if (flag3)
          {
            i5 = i2;
            num3 = 1;
          }
          else
          {
            ++WorldGen.trapDiag[type, 0];
            return false;
          }
          if (Main.tile[i5, j2].type == (ushort) 190)
          {
            ++WorldGen.trapDiag[type, 0];
            return false;
          }
          if (Main.tile[index1, index2].wall > (ushort) 0)
            WorldGen.PlaceTile(index1, index2, 135, true, true, style: 2);
          else
            WorldGen.PlaceTile(index1, index2, 135, true, true, style: WorldGen.genRand.Next(2, 4));
          WorldGen.KillTile(i5, j2);
          WorldGen.PlaceTile(i5, j2, 137, true, true);
          if (num3 == 1)
            Main.tile[i5, j2].frameX += (short) 18;
          int index5 = index1;
          int index6 = index2;
          while (index5 != i5 || index6 != j2)
          {
            Main.tile[index5, index6].wire(true);
            if (index5 > i5)
              --index5;
            if (index5 < i5)
              ++index5;
            Main.tile[index5, index6].wire(true);
            if (index6 > j2)
              --index6;
            if (index6 < j2)
              ++index6;
            Main.tile[index5, index6].wire(true);
          }
          ++WorldGen.trapDiag[type, 1];
          return true;
        case 1:
          if (WorldGen.noTrapsWorldGen)
            Main.tileSolid[138] = true;
          int num4 = index1;
          int y = index2 - 8;
          int index7 = num4 + WorldGen.genRand.Next(-1, 2);
          if (WorldGen.noTrapsWorldGen)
          {
            if (WorldGen.IsTileNearby(index7, y, 138, 6) || WorldGen.IsTileNearby(index7, y, 664, 6))
              return false;
          }
          else if (WorldGen.IsTileNearby(index7, y, 138, 10) || WorldGen.IsTileNearby(index7, y, 664, 10) || WorldGen.IsTileNearby(index7, y, 665, 10))
            return false;
          bool flag5 = true;
          while (flag5)
          {
            bool flag6 = true;
            int num5 = 0;
            for (int i6 = index7 - 2; i6 <= index7 + 3; ++i6)
            {
              for (int j3 = y; j3 <= y + 3; ++j3)
              {
                if (!WorldGen.SolidTile(i6, j3))
                  flag6 = false;
                if (Main.tile[i6, j3].active())
                {
                  if (Main.tile[i6, j3].type == (ushort) 226)
                  {
                    ++WorldGen.trapDiag[type, 0];
                    return false;
                  }
                  if (Main.tile[i6, j3].type == (ushort) 0 || Main.tile[i6, j3].type == (ushort) 1 || Main.tile[i6, j3].type == (ushort) 59)
                    ++num5;
                }
              }
            }
            --y;
            if ((double) y < Main.worldSurface)
            {
              ++WorldGen.trapDiag[type, 0];
              return false;
            }
            if (flag6 && num5 > 2)
              flag5 = false;
          }
          if (index2 - y <= 5 || index2 - y >= 40)
          {
            ++WorldGen.trapDiag[type, 0];
            return false;
          }
          for (int i7 = index7; i7 <= index7 + 1; ++i7)
          {
            for (int j4 = y; j4 <= index2; ++j4)
              WorldGen.KillTile(i7, j4);
          }
          for (int i8 = index7 - 2; i8 <= index7 + 3; ++i8)
          {
            for (int j5 = y - 2; j5 <= y + 3; ++j5)
            {
              if (WorldGen.SolidTile(i8, j5))
                Main.tile[i8, j5].type = (ushort) 1;
            }
          }
          if (WorldGen.IsTileNearby(index7, y, 21, 4) || WorldGen.IsTileNearby(index7, y, 467, 4))
          {
            ++WorldGen.trapDiag[type, 0];
            return false;
          }
          WorldGen.PlaceTile(index1, index2, 135, true, true, style: 7);
          WorldGen.PlaceTile(index7, y + 2, 130, true);
          WorldGen.PlaceTile(index7 + 1, y + 2, 130, true);
          if ((WorldGen.tenthAnniversaryWorldGen || WorldGen.noTrapsWorldGen) && WorldGen.genRand.Next(3) == 0)
            WorldGen.PlaceTile(index7 + 1, y + 1, 664, true);
          else
            WorldGen.PlaceTile(index7 + 1, y + 1, 138, true);
          int index8 = y + 2;
          Main.tile[index7, index8].wire(true);
          Main.tile[index7 + 1, index8].wire(true);
          int j6 = index8 + 1;
          WorldGen.PlaceTile(index7, j6, 130, true);
          WorldGen.PlaceTile(index7 + 1, j6, 130, true);
          Main.tile[index7, j6].wire(true);
          Main.tile[index7 + 1, j6].wire(true);
          WorldGen.PlaceTile(index7, j6 + 1, 130, true);
          WorldGen.PlaceTile(index7 + 1, j6 + 1, 130, true);
          Main.tile[index7, j6 + 1].wire(true);
          Main.tile[index7 + 1, j6 + 1].wire(true);
          int index9 = index1;
          int index10 = index2;
          while (index9 != index7 || index10 != j6)
          {
            Main.tile[index9, index10].wire(true);
            if (index9 > index7)
              --index9;
            if (index9 < index7)
              ++index9;
            Main.tile[index9, index10].wire(true);
            if (index10 > j6)
              --index10;
            if (index10 < j6)
              ++index10;
            Main.tile[index9, index10].wire(true);
          }
          ++WorldGen.trapDiag[type, 1];
          return true;
        case 2:
          int num6 = WorldGen.genRand.Next(4, 7);
          int i9 = index1 + WorldGen.genRand.Next(-1, 2);
          int j7 = index2;
          for (int index11 = 0; index11 < num6; ++index11)
          {
            ++j7;
            if (!WorldGen.SolidTile(i9, j7))
            {
              ++WorldGen.trapDiag[type, 0];
              return false;
            }
          }
          for (int i10 = i9 - 2; i10 <= i9 + 2; ++i10)
          {
            for (int j8 = j7 - 2; j8 <= j7 + 2; ++j8)
            {
              if (!WorldGen.SolidTile(i10, j8))
                return false;
            }
          }
          WorldGen.KillTile(i9, j7);
          Main.tile[i9, j7].active(true);
          Main.tile[i9, j7].type = (ushort) 141;
          Main.tile[i9, j7].frameX = (short) 0;
          Main.tile[i9, j7].frameY = (short) (18 * WorldGen.genRand.Next(2));
          WorldGen.PlaceTile(index1, index2, 135, true, true, style: WorldGen.genRand.Next(2, 4));
          int index12 = index1;
          int index13 = index2;
          while (index12 != i9 || index13 != j7)
          {
            Main.tile[index12, index13].wire(true);
            if (index12 > i9)
              --index12;
            if (index12 < i9)
              ++index12;
            Main.tile[index12, index13].wire(true);
            if (index13 > j7)
              --index13;
            if (index13 < j7)
              ++index13;
            Main.tile[index12, index13].wire(true);
          }
          ++WorldGen.trapDiag[type, 1];
          break;
        case 3:
          if (Main.tile[index1 + 1, index2].active() || Main.tile[index1, index2].liquid > (byte) 0 && !Main.tile[index1, index2].lava() || WorldGen.noTrapsWorldGen && (WorldGen.tenthAnniversaryWorldGen || WorldGen.notTheBees) && (WorldGen.genRand.Next(3) != 0 || WorldGen.IsTileNearby(index1, index2, 443, 30)))
            return false;
          for (int i11 = index1; i11 <= index1 + 1; ++i11)
          {
            int j9 = index2 + 1;
            if (!WorldGen.SolidTile(i11, j9))
              return false;
          }
          int num7 = WorldGen.genRand.Next(2);
          for (int index14 = 0; index14 < 2; ++index14)
          {
            Main.tile[index1 + index14, index2].active(true);
            Main.tile[index1 + index14, index2].type = (ushort) 443;
            Main.tile[index1 + index14, index2].frameX = (short) (18 * index14 + 36 * num7);
            Main.tile[index1 + index14, index2].frameY = (short) 0;
          }
          return true;
      }
      if (WorldGen.noTrapsWorldGen)
        Main.tileSolid[138] = true;
      return false;
    }

    public static int countWires(int x, int y, int size)
    {
      int num = 0;
      for (int x1 = x - size; x1 <= x + size; ++x1)
      {
        for (int y1 = y - size; y1 <= y + size; ++y1)
        {
          if (WorldGen.InWorld(x1, y1))
          {
            if (Main.tile[x1, y1].wire())
              ++num;
            if (Main.tile[x1, y1].wire2())
              ++num;
            if (Main.tile[x1, y1].wire3())
              ++num;
            if (Main.tile[x1, y1].wire4())
              ++num;
          }
        }
      }
      return num;
    }

    public static int countTiles(int x, int y, bool jungle = false, bool lavaOk = false)
    {
      WorldGen.numTileCount = 0;
      WorldGen.shroomCount = 0;
      WorldGen.lavaCount = 0;
      WorldGen.iceCount = 0;
      WorldGen.sandCount = 0;
      WorldGen.rockCount = 0;
      WorldGen.CountedTiles.Clear();
      WorldGen.nextCount(x, y, jungle, lavaOk);
      return WorldGen.numTileCount;
    }

    public static void nextCount(int x, int y, bool jungle = false, bool lavaOk = false)
    {
      if (WorldGen.numTileCount >= WorldGen.maxTileCount)
        return;
      if (x <= 1 || x >= Main.maxTilesX - 1 || y <= 1 || y >= Main.maxTilesY - 1)
      {
        WorldGen.numTileCount = WorldGen.maxTileCount;
      }
      else
      {
        if (WorldGen.CountedTiles.ContainsKey(new Point(x, y)))
          return;
        if (Main.tile[x, y].wall == (ushort) 244)
          WorldGen.numTileCount = WorldGen.maxTileCount;
        else if (Main.tile[x, y].shimmer() && Main.tile[x, y].liquid > (byte) 0)
        {
          WorldGen.numTileCount = WorldGen.maxTileCount;
        }
        else
        {
          if (!jungle)
          {
            if (Main.tile[x, y].wall != (ushort) 0)
            {
              WorldGen.numTileCount = WorldGen.maxTileCount;
              return;
            }
            if (!lavaOk)
            {
              if (Main.tile[x, y].lava() && Main.tile[x, y].liquid > (byte) 0)
              {
                ++WorldGen.lavaCount;
                WorldGen.numTileCount = WorldGen.maxTileCount;
                return;
              }
            }
            else if (Main.tile[x, y].lava() && Main.tile[x, y].liquid > (byte) 0)
              ++WorldGen.lavaCount;
          }
          if (Main.tile[x, y].active())
          {
            if (Main.tile[x, y].type == (ushort) 70)
              ++WorldGen.shroomCount;
            if (Main.tile[x, y].type == (ushort) 1)
              ++WorldGen.rockCount;
            if (Main.tile[x, y].type == (ushort) 147 || Main.tile[x, y].type == (ushort) 161)
              ++WorldGen.iceCount;
            if (Main.tile[x, y].type == (ushort) 53 || Main.tile[x, y].type == (ushort) 396 || Main.tile[x, y].type == (ushort) 397)
              ++WorldGen.sandCount;
          }
          if (WorldGen.SolidTile(x, y))
            return;
          WorldGen.CountedTiles.Add(new Point(x, y), true);
          ++WorldGen.numTileCount;
          WorldGen.nextCount(x - 1, y, jungle, lavaOk);
          WorldGen.nextCount(x + 1, y, jungle, lavaOk);
          WorldGen.nextCount(x, y - 1, jungle, lavaOk);
          WorldGen.nextCount(x, y + 1, jungle, lavaOk);
        }
      }
    }

    public static int countDirtTiles(int x, int y)
    {
      WorldGen.numTileCount = 0;
      WorldGen.CountedTiles.Clear();
      WorldGen.nextDirtCount(x, y);
      return WorldGen.numTileCount;
    }

    public static void nextDirtCount(int x, int y)
    {
      if (WorldGen.numTileCount >= WorldGen.maxTileCount)
        return;
      if (x <= 1 || x >= Main.maxTilesX - 1 || y <= 1 || y >= Main.maxTilesY - 1)
      {
        WorldGen.numTileCount = WorldGen.maxTileCount;
      }
      else
      {
        if (WorldGen.CountedTiles.ContainsKey(new Point(x, y)))
          return;
        if (Main.tile[x, y].active() && (Main.tile[x, y].type == (ushort) 147 || Main.tile[x, y].type == (ushort) 161))
          WorldGen.numTileCount = WorldGen.maxTileCount;
        else if (Main.tile[x, y].wall == (ushort) 244 || Main.tile[x, y].wall == (ushort) 83 || Main.tile[x, y].wall == (ushort) 3 || Main.tile[x, y].wall == (ushort) 187 || Main.tile[x, y].wall == (ushort) 216)
        {
          WorldGen.numTileCount = WorldGen.maxTileCount;
        }
        else
        {
          if (WorldGen.SolidTile(x, y) || Main.tile[x, y].wall != (ushort) 2 && Main.tile[x, y].wall != (ushort) 59)
            return;
          WorldGen.CountedTiles.Add(new Point(x, y), true);
          ++WorldGen.numTileCount;
          WorldGen.nextDirtCount(x - 1, y);
          WorldGen.nextDirtCount(x + 1, y);
          WorldGen.nextDirtCount(x, y - 1);
          WorldGen.nextDirtCount(x, y + 1);
          WorldGen.nextDirtCount(x - 1, y - 1);
          WorldGen.nextDirtCount(x - 1, y + 1);
          WorldGen.nextDirtCount(x + 1, y - 1);
          WorldGen.nextDirtCount(x + 1, y + 1);
          WorldGen.nextDirtCount(x - 2, y);
          WorldGen.nextDirtCount(x + 2, y);
        }
      }
    }

    public static bool InWorld(int x, int y, int fluff = 0) => x >= fluff && x < Main.maxTilesX - fluff && y >= fluff && y < Main.maxTilesY - fluff;

    public static void gemCave(int x, int y)
    {
      WorldGen.countTiles(x, y);
      for (int index = 0; index < 6; ++index)
        WorldGen.gem[index] = false;
      WorldGen.gem[WorldGen.genRand.Next(6)] = true;
      for (int index = 0; index < 6; ++index)
      {
        if (WorldGen.genRand.Next(6) == 0)
          WorldGen.gem[index] = true;
      }
      WorldGen.Spread.Gem(x, y);
    }

    public static int randGem()
    {
      int index = WorldGen.genRand.Next(6);
      while (!WorldGen.gem[index])
        index = WorldGen.genRand.Next(6);
      return index;
    }

    public static ushort randGemTile()
    {
      if (WorldGen.genRand.Next(20) != 0)
        return 1;
      switch ((ushort) WorldGen.randGem())
      {
        case 0:
          return 67;
        case 1:
          return 66;
        case 2:
          return 63;
        case 3:
          return 65;
        case 4:
          return 64;
        default:
          return 68;
      }
    }

    public static void randMoss(bool justNeon = false)
    {
      WorldGen.neonMossType = WorldGen.genRand.NextFromList<ushort>((ushort) 539, (ushort) 536, (ushort) 534, (ushort) 625);
      if (justNeon)
        return;
      WorldGen.mossType[0] = WorldGen.genRand.Next(5);
      WorldGen.mossType[1] = WorldGen.genRand.Next(5);
      while (WorldGen.mossType[1] == WorldGen.mossType[0])
        WorldGen.mossType[1] = WorldGen.genRand.Next(5);
      WorldGen.mossType[2] = WorldGen.genRand.Next(5);
      while (WorldGen.mossType[2] == WorldGen.mossType[0] || WorldGen.mossType[2] == WorldGen.mossType[1])
        WorldGen.mossType[2] = WorldGen.genRand.Next(5);
    }

    public static void neonMossBiome(int i, int j, int maxY = 99999)
    {
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      Vector2D vector2D2;
      vector2D2.X = WorldGen.genRand.NextDouble() * 4.0 - 2.0;
      vector2D2.Y = WorldGen.genRand.NextDouble() * 4.0 - 2.0;
      if (vector2D2.X == 0.0)
        vector2D2.X = 1.0;
      while (((Vector2D) ref vector2D2).Length() < 4.0)
        vector2D2 = Vector2D.op_Multiply(vector2D2, 1.5);
      double num1 = (double) WorldGen.genRand.Next(60, 80);
      double num2 = (double) WorldGen.genRand.Next(30, 40);
      double num3 = (double) Main.maxTilesX / 4200.0;
      if (WorldGen.getGoodWorldGen)
        num3 *= 1.5;
      double num4 = num1 * num3;
      double num5 = num2 * num3;
      while (num5 > 0.0)
      {
        num4 *= 0.98;
        --num5;
        int num6 = (int) (vector2D1.X - num4);
        int num7 = (int) (vector2D1.X + num4);
        int num8 = (int) (vector2D1.Y - num4);
        int num9 = (int) (vector2D1.Y + num4);
        if (num6 < 1)
          num6 = 1;
        if (num7 > Main.maxTilesX - 1)
          num7 = Main.maxTilesX - 1;
        if (num8 < 1)
          num8 = 1;
        if (num9 > Main.maxTilesY - 1)
          num9 = Main.maxTilesY - 1;
        if (Main.remixWorld)
        {
          if ((double) num8 < Main.worldSurface)
          {
            num8 = (int) Main.worldSurface;
            if (vector2D2.Y < 5.0)
              vector2D2.Y = 5.0;
          }
        }
        else if ((double) num8 < Main.rockLayer)
        {
          num8 = (int) Main.rockLayer;
          if (vector2D2.Y < 5.0)
            vector2D2.Y = 5.0;
        }
        if (num9 > maxY)
        {
          num9 = maxY;
          if (vector2D2.Y > -5.0)
            vector2D2.Y = -5.0;
        }
        double num10 = num4 * (1.0 + WorldGen.genRand.NextDouble() * 0.4 - 0.2);
        for (int x = num6; x < num7; ++x)
        {
          for (int index = num8; index < num9; ++index)
          {
            Vector2D vector2D3 = new Vector2D(Math.Abs((double) x - vector2D1.X), Math.Abs((double) index - vector2D1.Y));
            if (((Vector2D) ref vector2D3).Length() < num10 * 0.8 && WorldGen.TileType(x, index) == 1 && (!Main.tile[x - 1, index].active() || !Main.tile[x + 1, index].active() || !Main.tile[x, index - 1].active() || !Main.tile[x, index + 1].active()))
              WorldGen.SpreadGrass(x - 1, index, 1, (int) WorldGen.neonMossType);
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += WorldGen.genRand.NextDouble() * 4.0 - 2.0;
        vector2D2.Y += WorldGen.genRand.NextDouble() * 4.0 - 2.0;
        vector2D2.Y = Utils.Clamp<double>(vector2D2.Y, -10.0, 10.0);
        vector2D2.X = Utils.Clamp<double>(vector2D2.X, -10.0, 10.0);
      }
    }

    public static void setMoss(int x, int y)
    {
      int index = (double) x >= (double) Main.maxTilesX * 0.334 ? ((double) x >= (double) Main.maxTilesX * 0.667 ? 2 : 1) : 0;
      GenVars.mossWall = (ushort) (54 + WorldGen.mossType[index]);
      GenVars.mossTile = (ushort) (179 + WorldGen.mossType[index]);
    }

    public static void FillWallHolesInArea(Microsoft.Xna.Framework.Rectangle worldCoordsArea)
    {
      int num1 = Math.Max(worldCoordsArea.Left, 0);
      int num2 = Math.Min(worldCoordsArea.Right, Main.maxTilesX);
      int num3 = 0;
      for (int x = num1; x <= num2; ++x)
      {
        if (x >= 0 && x < Main.maxTilesX)
          num3 += WorldGen.FillWallHolesInColumn(x, worldCoordsArea.Top, worldCoordsArea.Bottom);
      }
    }

    private static int FillWallHolesInColumn(int x, int startY, int endY)
    {
      int num = 0;
      x = Utils.Clamp<int>(x, 2, Main.maxTilesX - 1 - 2);
      startY = Math.Max(startY, 2);
      endY = Math.Min(endY, Main.maxTilesY - 2);
      bool flag = false;
      for (int originY = startY; originY < endY; ++originY)
      {
        if (Main.tile[x, originY].wall == (ushort) 0)
        {
          if (flag)
          {
            flag = false;
            if (WorldGen.FillWallHolesInSpot(x, originY, 150))
              ++num;
          }
        }
        else
          flag = true;
      }
      return num;
    }

    private static bool FillWallHolesInSpot(int originX, int originY, int maxWallsThreshold)
    {
      if (!WorldGen.InWorld(originX, originY, 2))
        return false;
      List<Point> pointList = new List<Point>();
      List<Point> collection = new List<Point>();
      HashSet<Point> pointSet = new HashSet<Point>();
      Dictionary<ushort, int> dictionary = new Dictionary<ushort, int>();
      collection.Add(new Point(originX, originY));
      while (collection.Count > 0)
      {
        pointList.Clear();
        pointList.AddRange((IEnumerable<Point>) collection);
        collection.Clear();
        while (pointList.Count > 0)
        {
          if (pointSet.Count >= maxWallsThreshold)
            return false;
          Point point1 = pointList[0];
          if (pointSet.Contains(point1))
            pointList.Remove(point1);
          else if (!WorldGen.InWorld(point1.X, point1.Y, 1))
          {
            pointList.Remove(point1);
          }
          else
          {
            pointSet.Add(point1);
            pointList.Remove(point1);
            Tile tile = Main.tile[point1.X, point1.Y];
            if (tile.wall != (ushort) 0)
            {
              dictionary[tile.wall] = !dictionary.ContainsKey(tile.wall) ? 1 : dictionary[tile.wall] + 1;
            }
            else
            {
              bool flag = false;
              if (!flag)
              {
                int y = point1.Y;
                for (int index = point1.X - 1; index <= point1.X + 1; ++index)
                {
                  if (!Main.tile[index, y].active())
                  {
                    flag = true;
                    break;
                  }
                }
              }
              if (!flag)
              {
                int x = point1.X;
                for (int index = point1.Y - 1; index <= point1.Y + 1; ++index)
                {
                  if (!Main.tile[x, index].active())
                  {
                    flag = true;
                    break;
                  }
                }
              }
              if (flag)
              {
                Point point2 = new Point(point1.X - 1, point1.Y);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X + 1, point1.Y);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X, point1.Y - 1);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X, point1.Y + 1);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
              }
            }
          }
        }
      }
      if (pointSet.Count == 1)
        return false;
      ushort num1 = 0;
      int num2 = -1;
      foreach (KeyValuePair<ushort, int> keyValuePair in dictionary)
      {
        if (keyValuePair.Value > num2)
        {
          num1 = keyValuePair.Key;
          num2 = keyValuePair.Value;
        }
      }
      if (num2 == -1)
        num1 = (ushort) 2;
      foreach (Point point in pointSet)
      {
        Tile tile = Main.tile[point.X, point.Y];
        if (tile.wall == (ushort) 0)
          tile.wall = num1;
      }
      return true;
    }

    public static void tileCountAndDestroy()
    {
      for (int x = 10; x < Main.maxTilesX - 10; ++x)
      {
        for (int y = 10; y < Main.maxTilesY - 10; ++y)
        {
          if (Main.tile[x, y].active() && WorldGen.tileCounter(x, y) < WorldGen.tileCounterMax)
            WorldGen.tileCounterKill();
        }
      }
    }

    public static int tileCounter(int x, int y)
    {
      WorldGen.tileCounterNum = 0;
      WorldGen.tileCounterNext(x, y);
      return WorldGen.tileCounterNum;
    }

    public static void tileCounterNext(int x, int y)
    {
      if (WorldGen.tileCounterNum >= WorldGen.tileCounterMax || x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5 || !Main.tile[x, y].active() || !Main.tileSolid[(int) Main.tile[x, y].type] || !TileID.Sets.CanBeClearedDuringGeneration[(int) Main.tile[x, y].type])
        return;
      for (int index = 0; index < WorldGen.tileCounterNum; ++index)
      {
        if (WorldGen.tileCounterX[index] == x && WorldGen.tileCounterY[index] == y)
          return;
      }
      WorldGen.tileCounterX[WorldGen.tileCounterNum] = x;
      WorldGen.tileCounterY[WorldGen.tileCounterNum] = y;
      ++WorldGen.tileCounterNum;
      WorldGen.tileCounterNext(x - 1, y);
      WorldGen.tileCounterNext(x + 1, y);
      WorldGen.tileCounterNext(x, y - 1);
      WorldGen.tileCounterNext(x, y + 1);
    }

    public static void tileCounterKill()
    {
      for (int index1 = 0; index1 < WorldGen.tileCounterNum; ++index1)
      {
        int index2 = WorldGen.tileCounterX[index1];
        int index3 = WorldGen.tileCounterY[index1];
        Main.tile[index2, index3].active(false);
      }
    }

    private static void AddGenerationPass(string name, WorldGenLegacyMethod method) => WorldGen._generator.Append((GenPass) new PassLegacy(name, method));

    private static void AddGenerationPass(GenPass pass) => WorldGen._generator.Append(pass);

    private static void AddGenerationPass(string name, double weight, WorldGenLegacyMethod method) => WorldGen._generator.Append((GenPass) new PassLegacy(name, method, weight));

    public static bool checkUnderground(int x, int y)
    {
      try
      {
        int num1 = 120;
        int num2 = 80;
        int num3 = 3;
        if ((double) y > Main.worldSurface + (double) num2)
          return true;
        if ((double) y < Main.worldSurface / 2.0)
          return false;
        int num4 = y - num2;
        int num5 = x - num1 / 2;
        int num6 = 0;
        if (num5 < 0)
          num5 = 0;
        if (num5 >= Main.maxTilesX - num1)
          num5 = Main.maxTilesX - num1 - 1;
        for (int i = num5; i < num5 + num1; ++i)
        {
          for (int j = num4; j < num4 + num3; ++j)
          {
            if (WorldGen.SolidTile(i, j) || Main.tile[x, y].wall > (ushort) 0)
              ++num6;
          }
        }
        if ((double) num6 >= (double) (num1 * num3) * 0.8)
          return true;
      }
      catch
      {
      }
      return false;
    }

    public static int GetNextJungleChestItem()
    {
      int nextJungleChestItem = 211;
      switch (GenVars.JungleItemCount % 4)
      {
        case 0:
          nextJungleChestItem = 211;
          break;
        case 1:
          nextJungleChestItem = 212;
          break;
        case 2:
          nextJungleChestItem = 213;
          break;
        case 3:
          nextJungleChestItem = 964;
          break;
      }
      if (WorldGen.genRand.Next(50) == 0)
        nextJungleChestItem = 753;
      else if (WorldGen.genRand.Next(15) == 0)
        nextJungleChestItem = 2292;
      else if (WorldGen.genRand.Next(20) == 0)
        nextJungleChestItem = 3017;
      ++GenVars.JungleItemCount;
      return nextJungleChestItem;
    }

    private static void ScanTileColumnAndRemoveClumps(int x)
    {
      int num = 0;
      int y = 0;
      for (int index = 10; index < Main.maxTilesY - 10; ++index)
      {
        if (Main.tile[x, index].active() && Main.tileSolid[(int) Main.tile[x, index].type] && TileID.Sets.CanBeClearedDuringGeneration[(int) Main.tile[x, index].type])
        {
          if (num == 0)
            y = index;
          ++num;
        }
        else
        {
          if (num > 0 && num < WorldGen.tileCounterMax)
          {
            ++WorldGen.SmallConsecutivesFound;
            if (WorldGen.tileCounter(x, y) < WorldGen.tileCounterMax)
            {
              ++WorldGen.SmallConsecutivesEliminated;
              WorldGen.tileCounterKill();
            }
          }
          num = 0;
        }
      }
    }

    public static void OreHelper(int X, int Y)
    {
      for (int index1 = X - 1; index1 <= X + 1; ++index1)
      {
        for (int index2 = Y - 1; index2 <= Y + 1; ++index2)
        {
          if (Main.tile[index1, index2].type == (ushort) 1 || Main.tile[index1, index2].type == (ushort) 40)
            Main.tile[index1, index2].type = (ushort) 0;
        }
      }
    }

    public static bool StonePatch(int X, int Y)
    {
      int i1 = X;
      int j1 = Y;
      while (!WorldGen.SolidTile(i1, j1))
      {
        ++j1;
        if ((double) j1 > Main.worldSurface)
          return false;
      }
      if (!TileID.Sets.Conversion.Grass[(int) Main.tile[i1, j1].type] || !TileID.Sets.Conversion.Grass[(int) Main.tile[i1 - 1, j1].type] || !TileID.Sets.Conversion.Grass[(int) Main.tile[i1 + 1, j1].type] || Main.tile[i1, j1].wall > (ushort) 0)
        return false;
      for (int index1 = i1 - 10; index1 <= i1 + 10; ++index1)
      {
        for (int index2 = j1 + 7; index2 <= j1 + 30; ++index2)
        {
          if (!Main.tile[index1, index2].active() || Main.tileDungeon[(int) Main.tile[index1, index2].type] || TileID.Sets.Clouds[(int) Main.tile[index1, index2].type] || TileID.Sets.Conversion.Sand[(int) Main.tile[index1, index2].type] || Main.tile[index1, index2].wall == (ushort) 0 || Main.tile[index1, index2].type == (ushort) 199 || Main.tile[index1, index2].type == (ushort) 23)
            return false;
        }
      }
      Vector2D vector2D1;
      // ISSUE: explicit constructor call
      ((Vector2D) ref vector2D1).\u002Ector((double) i1, (double) j1);
      Vector2D vector2D2;
      vector2D2.X = WorldGen.genRand.NextDouble() * 0.6 - 0.3;
      vector2D2.Y = WorldGen.genRand.NextDouble() * 0.5 + 0.5;
      double num1 = (double) WorldGen.genRand.Next(13, 18);
      int num2 = WorldGen.genRand.Next(13, 19);
      if (WorldGen.genRand.Next(3) == 0)
        num1 += (double) WorldGen.genRand.Next(3);
      if (WorldGen.genRand.Next(3) == 0)
        num2 += WorldGen.genRand.Next(3);
      while (num2 > 0)
      {
        --num2;
        for (int i2 = i1 - (int) num1 * 4; (double) i2 <= (double) i1 + num1 * 4.0; ++i2)
        {
          for (int j2 = j1 - (int) num1 * 4; (double) j2 <= (double) j1 + num1 * 4.0; ++j2)
          {
            double num3 = num1 * (0.7 + WorldGen.genRand.NextDouble() * 0.6) * 0.3;
            if (WorldGen.genRand.Next(8) == 0)
              num3 *= 2.0;
            Vector2D vector2D3 = Vector2D.op_Subtraction(vector2D1, new Vector2D((double) i2, (double) j2));
            if (((Vector2D) ref vector2D3).Length() < num3 * 2.0 && !Main.tile[i2, j2].active() && Main.tile[i2, j2 + 1].active() && Main.tile[i2, j2 + 1].type == (ushort) 1 && WorldGen.genRand.Next(7) == 0 && WorldGen.SolidTile(i2 - 1, j2 + 1) && WorldGen.SolidTile(i2 + 1, j2 + 1))
            {
              if (WorldGen.genRand.Next(3) != 0)
                WorldGen.PlaceTile(i2, j2, 186, true, style: WorldGen.genRand.Next(7, 13));
              if (WorldGen.genRand.Next(3) != 0)
                WorldGen.PlaceSmallPile(i2, j2, WorldGen.genRand.Next(6), 1);
              WorldGen.PlaceSmallPile(i2, j2, WorldGen.genRand.Next(6), 0);
            }
            if (((Vector2D) ref vector2D3).Length() < num3)
            {
              if (Main.tileSolid[(int) Main.tile[i2, j2].type])
                Main.tile[i2, j2].type = (ushort) 1;
              if (!WorldGen.gen)
                WorldGen.SquareTileFrame(i2, j2);
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += WorldGen.genRand.NextDouble() * 0.2 - 0.1;
        vector2D2.Y += WorldGen.genRand.NextDouble() * 0.2 - 0.1;
        Utils.Clamp<double>(vector2D2.X, -0.3, 0.3);
        Utils.Clamp<double>(vector2D2.Y, 0.5, 1.0);
      }
      return true;
    }

    public static bool ShellPile(int X, int Y)
    {
      int i1 = X;
      int j1 = Y;
      while (!WorldGen.SolidTile(i1, j1))
      {
        ++j1;
        if ((double) j1 > Main.worldSurface)
          return false;
      }
      if (Main.tile[i1, j1].type != (ushort) 53 || Main.tile[i1, j1].wall > (ushort) 0)
        return false;
      int num1 = j1 - 1;
      Vector2D vector2D1;
      // ISSUE: explicit constructor call
      ((Vector2D) ref vector2D1).\u002Ector((double) i1, (double) num1);
      Vector2D vector2D2;
      vector2D2.X = WorldGen.genRand.NextDouble() * 0.6 - 0.3;
      vector2D2.Y = WorldGen.genRand.NextDouble() * 0.5 + 0.5;
      double num2 = (double) WorldGen.genRand.Next(2, 4);
      if (WorldGen.genRand.Next(10) == 0)
        ++num2;
      int num3 = WorldGen.genRand.Next(3, 6);
      while (num3 > 0)
      {
        --num3;
        for (int i2 = i1 - (int) num2 * 4; (double) i2 <= (double) i1 + num2 * 4.0; ++i2)
        {
          for (int j2 = num1 + (int) num2 * 4; (double) j2 > (double) num1 - num2 * 4.0; --j2)
          {
            double num4 = num2 * (double) WorldGen.genRand.Next(70, 91) * 0.01;
            Vector2D vector2D3 = Vector2D.op_Subtraction(vector2D1, new Vector2D((double) i2, (double) j2));
            vector2D3.X *= 0.6;
            if (((Vector2D) ref vector2D3).Length() < num4)
            {
              if (j2 <= num1 + 1 || WorldGen.genRand.Next(6) == 0)
              {
                Main.tile[i2, j2].type = (ushort) 495;
                Main.tile[i2, j2].active(true);
                Main.tile[i2, j2].halfBrick(false);
                Main.tile[i2, j2].slope((byte) 0);
                if (!Main.tile[i2, j2 + 1].active())
                {
                  Main.tile[i2, j2 + 1].type = (ushort) 495;
                  Main.tile[i2, j2 + 1].active(true);
                  Main.tile[i2, j2 + 1].halfBrick(false);
                  Main.tile[i2, j2 + 1].slope((byte) 0);
                  if (!Main.tile[i2, j2 + 2].active())
                  {
                    Main.tile[i2, j2 + 2].type = (ushort) 53;
                    Main.tile[i2, j2 + 2].active(true);
                    Main.tile[i2, j2 + 2].halfBrick(false);
                    Main.tile[i2, j2 + 2].slope((byte) 0);
                    if (!Main.tile[i2, j2 + 3].active())
                    {
                      Main.tile[i2, j2 + 3].type = (ushort) 397;
                      Main.tile[i2, j2 + 3].active(true);
                      Main.tile[i2, j2 + 3].halfBrick(false);
                      Main.tile[i2, j2 + 3].slope((byte) 0);
                    }
                  }
                }
                if (!WorldGen.gen)
                  WorldGen.SquareTileFrame(i2, j2);
              }
              else if (Main.tile[i2, j2].type != (ushort) 495)
              {
                Main.tile[i2, j2].active(true);
                Main.tile[i2, j2].halfBrick(false);
                Main.tile[i2, j2].slope((byte) 0);
                Main.tile[i2, j2].type = (ushort) 53;
                if (!WorldGen.gen)
                  WorldGen.SquareTileFrame(i2, j2);
              }
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += WorldGen.genRand.NextDouble() * 0.2 - 0.1;
        vector2D2.Y += WorldGen.genRand.NextDouble() * 0.2 - 0.1;
        Utils.Clamp<double>(vector2D2.X, -0.3, 0.3);
        Utils.Clamp<double>(vector2D2.Y, 0.5, 1.0);
      }
      return true;
    }

    public static bool MarblePileWithStatues(int X, int Y)
    {
      int i1 = X;
      int j1 = Y;
      while (!WorldGen.SolidTile(i1, j1))
      {
        ++j1;
        if ((double) j1 > Main.worldSurface)
          return false;
      }
      if (Main.tile[i1, j1].type != (ushort) 0 && Main.tile[i1, j1].type != (ushort) 2 || Main.tile[i1, j1].wall > (ushort) 0)
        return false;
      int num1 = 130;
      int num2 = 60;
      int num3 = (int) MathHelper.Clamp((float) (i1 - num1), 30f, (float) (Main.maxTilesX - 30));
      int num4 = (int) MathHelper.Clamp((float) (i1 + num1), 30f, (float) (Main.maxTilesX - 30));
      int num5 = (int) MathHelper.Clamp((float) (j1 - num2), 30f, (float) (Main.maxTilesY - 30));
      int num6 = (int) MathHelper.Clamp((float) (j1 + num2), 30f, (float) (Main.maxTilesY - 30));
      for (int index1 = num3; index1 <= num4; ++index1)
      {
        for (int index2 = num5; index2 <= num6; ++index2)
        {
          if (Main.tile[index1, index2].active() && (Main.tile[index1, index2].type == (ushort) 367 || Main.tile[index1, index2].type == (ushort) 191))
            return false;
        }
      }
      int num7 = j1 - 1;
      Vector2D vector2D1;
      // ISSUE: explicit constructor call
      ((Vector2D) ref vector2D1).\u002Ector((double) i1, (double) num7);
      Vector2D vector2D2;
      vector2D2.X = WorldGen.genRand.NextDouble() * 0.6 - 0.3;
      vector2D2.Y = WorldGen.genRand.NextDouble() * 0.5 + 0.5;
      double num8 = (double) WorldGen.genRand.Next(2, 4);
      if (WorldGen.genRand.Next(10) == 0)
        ++num8;
      int num9 = WorldGen.genRand.Next(3, 6);
      while (num9 > 0)
      {
        --num9;
        for (int i2 = i1 - (int) num8 * 5; (double) i2 <= (double) i1 + num8 * 5.0; ++i2)
        {
          for (int j2 = num7 + (int) num8 * 3; (double) j2 > (double) num7 - num8 * 3.0; --j2)
          {
            double num10 = num8 * (double) WorldGen.genRand.Next(70, 91) * 0.01 * 1.2;
            Vector2D vector2D3 = Vector2D.op_Subtraction(vector2D1, new Vector2D((double) i2, (double) j2));
            if (((Vector2D) ref vector2D3).Length() > 30.0)
            {
              // ISSUE: explicit constructor call
              ((Vector2D) ref vector2D1).\u002Ector((double) i1, (double) num7);
              vector2D2.X = WorldGen.genRand.NextDouble() * 0.6 - 0.3;
              vector2D2.Y = WorldGen.genRand.NextDouble() * 0.5 + 0.5;
            }
            else
            {
              vector2D3.X *= 0.25;
              vector2D3.Y *= 0.8;
              if (((Vector2D) ref vector2D3).Length() < num10 && Main.tile[i2, j2].active())
              {
                Main.tile[i2, j2].active(true);
                Main.tile[i2, j2].halfBrick(false);
                Main.tile[i2, j2].slope((byte) 0);
                Main.tile[i2, j2].type = (ushort) 367;
                if (!WorldGen.gen)
                  WorldGen.SquareTileFrame(i2, j2);
              }
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += WorldGen.genRand.NextDouble() * 0.2 - 0.1;
        vector2D2.Y += (0.1 + WorldGen.genRand.NextDouble() * 0.1) * 0.8;
        Utils.Clamp<double>(vector2D2.X, -0.3, 0.3);
        Utils.Clamp<double>(vector2D2.Y, 0.5, 1.0);
      }
      int num11 = 0;
      for (int x = i1 - (int) num8 * 5; (double) x <= (double) i1 + num8 * 5.0 && num11 < 3; ++x)
      {
        if (x % 2 != 1 && (num11 <= 0 || WorldGen.genRand.Next(5) == 0))
        {
          int index = (int) vector2D1.Y - 20;
          Tile tile;
          for (tile = Main.tile[x, index]; tile != null && !tile.active(); tile = Main.tile[x, index])
            ++index;
          if (tile != null && tile.type == (ushort) 367 && !Main.tile[x, index - 1].active() && WorldGen.Statue(x, index - 1, (byte) 26))
            ++num11;
        }
      }
      return true;
    }

    public static bool Statue(int x, int y, byte paint)
    {
      int index1 = WorldGen.genRand.Next(2, GenVars.statueList.Length);
      int x1 = (int) GenVars.statueList[index1].X;
      int y1 = (int) GenVars.statueList[index1].Y;
      while (!Main.tile[x, y].active())
      {
        ++y;
        if (y >= Main.maxTilesY)
          break;
      }
      if (y >= Main.maxTilesY)
        return false;
      --y;
      if (!WorldGen.PlaceTile(x, y, x1, true, true, style: y1))
        return false;
      for (int index2 = 0; index2 < 2; ++index2)
      {
        for (int index3 = 0; index3 < 3; ++index3)
          Main.tile[x + index2, y + index3 - 2].color(paint);
      }
      return true;
    }

    public static bool OrePatch(int X, int Y)
    {
      ushort num1 = (ushort) WorldGen.SavedOreTiers.Copper;
      if (WorldGen.genRand.Next(3) == 0)
        num1 = (ushort) WorldGen.SavedOreTiers.Iron;
      int index1 = X;
      int j = Y;
      while (!WorldGen.SolidTile(index1, j))
      {
        ++j;
        if ((double) j > Main.worldSurface)
          return false;
      }
      if (!TileID.Sets.Conversion.Grass[(int) Main.tile[index1, j].type] || !TileID.Sets.Conversion.Grass[(int) Main.tile[index1 - 1, j].type] || !TileID.Sets.Conversion.Grass[(int) Main.tile[index1 + 1, j].type] || Main.tile[index1, j].wall > (ushort) 0)
        return false;
      for (int index2 = index1 - 10; index2 <= index1 + 10; ++index2)
      {
        for (int index3 = j + 7; index3 <= j + 30; ++index3)
        {
          if (!Main.tile[index2, index3].active() || Main.tileDungeon[(int) Main.tile[index2, index3].type] || TileID.Sets.Clouds[(int) Main.tile[index2, index3].type] || TileID.Sets.Conversion.Sand[(int) Main.tile[index2, index3].type] || Main.tile[index2, index3].wall == (ushort) 0)
            return false;
        }
      }
      int index4 = j + WorldGen.genRand.Next(2);
      Main.tile[index1, index4].type = num1;
      Main.tile[index1, index4].active(true);
      WorldGen.OreHelper(index1, index4);
      if (!WorldGen.gen)
        WorldGen.SquareTileFrame(index1, index4);
      int num2 = index4;
      while (index4 < num2 + WorldGen.genRand.Next(8, 13))
      {
        index1 += WorldGen.genRand.Next(-1, 2);
        index4 += WorldGen.genRand.Next(1, 3);
        if (WorldGen.genRand.Next(3) == 0)
          ++index4;
        Main.tile[index1, index4].type = num1;
        Main.tile[index1, index4].active(true);
        WorldGen.OreHelper(index1, index4);
        if (!WorldGen.gen)
          WorldGen.SquareTileFrame(index1, index4);
        if (WorldGen.genRand.Next(4) == 0)
        {
          int index5 = index1 + WorldGen.genRand.Next(-2, 3);
          int index6 = index4 + WorldGen.genRand.Next(2);
          Main.tile[index5, index6].type = num1;
          Main.tile[index5, index6].active(true);
          WorldGen.OreHelper(index5, index6);
          if (!WorldGen.gen)
            WorldGen.SquareTileFrame(index5, index6);
        }
      }
      Vector2D vector2D1;
      // ISSUE: explicit constructor call
      ((Vector2D) ref vector2D1).\u002Ector((double) index1, (double) index4);
      Vector2D vector2D2;
      vector2D2.X = WorldGen.genRand.NextDouble() * 0.6 - 0.3;
      vector2D2.Y = WorldGen.genRand.NextDouble() * 0.5 + 0.5;
      double num3 = (double) WorldGen.genRand.Next(5, 9);
      int num4 = WorldGen.genRand.Next(9, 14);
      if (WorldGen.genRand.Next(3) == 0)
        num3 += (double) WorldGen.genRand.Next(2);
      if (WorldGen.genRand.Next(3) == 0)
        num4 += WorldGen.genRand.Next(2);
      while (num4 > 0)
      {
        --num4;
        for (int index7 = index1 - (int) num3 * 4; (double) index7 <= (double) index1 + num3 * 4.0; ++index7)
        {
          for (int index8 = index4 - (int) num3 * 4; (double) index8 <= (double) index4 + num3 * 4.0; ++index8)
          {
            double num5 = num3 * (0.5 + WorldGen.genRand.NextDouble() * 0.5) * 0.1;
            double num6 = num3 * (0.7 + WorldGen.genRand.NextDouble() * 0.6) * 0.3;
            if (WorldGen.genRand.Next(8) == 0)
              num6 *= 2.0;
            Vector2D vector2D3 = Vector2D.op_Subtraction(vector2D1, new Vector2D((double) index7, (double) index8));
            if (((Vector2D) ref vector2D3).Length() < num5)
              Main.tile[index7, index8].active(false);
            else if (((Vector2D) ref vector2D3).Length() < num6)
            {
              Main.tile[index7, index8].type = num1;
              if (WorldGen.genRand.Next(4) == 0)
                Main.tile[index7, index8].active(true);
              WorldGen.OreHelper(index7, index8);
              if (!WorldGen.gen)
                WorldGen.SquareTileFrame(index7, index8);
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += WorldGen.genRand.NextDouble() * 0.2 - 0.1;
        vector2D2.Y += WorldGen.genRand.NextDouble() * 0.2 - 0.1;
        Utils.Clamp<double>(vector2D2.X, -0.3, 0.3);
        Utils.Clamp<double>(vector2D2.Y, 0.5, 1.0);
      }
      return true;
    }

    public static bool PlaceOasis(int X, int Y)
    {
      int x = X;
      int y = Y;
      if (Main.tile[x, y].active() || Main.tile[x, y].wall != (ushort) 0)
        return false;
      while (!Main.tile[x, y].active() && Main.tile[x, y].wall == (ushort) 0 && (double) y <= Main.worldSurface)
        ++y;
      if ((double) y > Main.worldSurface - 10.0 || Main.tile[x, y].type != (ushort) 53)
        return false;
      int num1 = 350;
      for (int index = 0; index < GenVars.numOasis; ++index)
      {
        if (Vector2D.Distance(GenVars.oasisPosition[index].ToVector2D(), new Vector2D((double) x, (double) y)) < (double) num1)
          return false;
      }
      int num2 = WorldGen.genRand.Next(45, 61);
      int oasisHeight = GenVars.oasisHeight;
      int num3 = num2 + 50;
      int num4 = 4;
      for (int index1 = x - num3; index1 <= x + num3; ++index1)
      {
        for (int index2 = y - oasisHeight; index2 <= y + oasisHeight + num4; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile.active())
          {
            if (Main.tileSolid[(int) tile.type] && ((tile.type == (ushort) 151 || tile.type == (ushort) 397) && Math.Abs(index1 - x) < num2 && Math.Abs(index2 - y) < oasisHeight / 2 || tile.type != (ushort) 53))
              return false;
          }
          else if ((tile.liquid > (byte) 0 || tile.wall > (ushort) 0) && Math.Abs(index1 - x) < num2 && Math.Abs(index2 - y) < oasisHeight / 2)
            return false;
        }
        if (index1 > x - num2 / 2 && index1 < x - num2 / 2 && (Main.tile[index1, y - 6].active() || !Main.tile[index1, y + 1].active()))
          return false;
      }
      int num5 = 5;
      int num6 = y;
      while (!Main.tile[x - num2, y + num5].active() || Main.tile[x - num2, y + num5].wall != (ushort) 0 || !Main.tile[x + num2, y + num5].active() || Main.tile[x + num2, y + num5].wall != (ushort) 0)
      {
        ++y;
        if (y - num6 > 20)
          break;
      }
      int num7 = num2 / 2;
      int num8 = x - num2 * 3;
      int num9 = x + num2 * 3;
      int num10 = y - oasisHeight * 4;
      int num11 = y + oasisHeight * 3;
      if (num8 < 0)
        num8 = 0;
      if (num9 > Main.maxTilesX)
        num9 = Main.maxTilesX;
      if (num10 < 0)
        num10 = 0;
      if (num11 > Main.maxTilesY)
        num11 = Main.maxTilesY;
      for (int index3 = num8; index3 < num9; ++index3)
      {
        for (int index4 = num10; index4 < num11; ++index4)
        {
          double num12 = (double) Math.Abs(index3 - x) * 0.7;
          double num13 = (double) Math.Abs(index4 - y) * 1.35;
          double num14 = Math.Sqrt(num12 * num12 + num13 * num13);
          double num15 = (double) num7 * (0.53 + WorldGen.genRand.NextDouble() * 0.04);
          double num16 = (1.0 - (double) Math.Abs(index3 - x) / (double) (num9 - x)) * 2.3;
          double num17 = num16 * num16;
          double num18 = num17 * num17;
          double num19 = num15;
          if (num14 < num19)
          {
            if (index4 == y + 1)
              Main.tile[index3, index4].liquid = (byte) 127;
            else if (index4 > y + 1)
              Main.tile[index3, index4].liquid = byte.MaxValue;
            Main.tile[index3, index4].lava(false);
            Main.tile[index3, index4].active(false);
          }
          else if (index4 < y && num12 < num15 + (double) (Math.Abs(index4 - y) * 3) * num18)
          {
            if (Main.tile[index3, index4].type == (ushort) 53)
              Main.tile[index3, index4].active(false);
          }
          else if (index4 >= y && num12 < num15 + (double) Math.Abs(index4 - y) * num18 && Main.tile[index3, index4].wall == (ushort) 0)
          {
            if (Main.tile[index3, index4].active() && Main.tileSolid[(int) Main.tile[index3, index4].type] && !Main.tileSolidTop[(int) Main.tile[index3, index4].type])
            {
              Main.tile[index3, index4].slope((byte) 0);
              Main.tile[index3, index4].halfBrick(false);
            }
            else
            {
              Main.tile[index3, index4].active(true);
              Main.tile[index3, index4].type = (ushort) 53;
              Main.tile[index3, index4].slope((byte) 0);
              Main.tile[index3, index4].halfBrick(false);
            }
          }
        }
      }
      int num20 = 50;
      int num21 = x - num2 * 2;
      int num22 = x + num2 * 2;
      int num23 = y + oasisHeight * 2;
      for (int index5 = num21; index5 < num22; ++index5)
      {
        for (int index6 = num23; index6 >= y; --index6)
        {
          double num24 = (double) Math.Abs(index5 - x) * 0.7;
          double num25 = (double) Math.Abs(index6 - y) * 1.35;
          if (Math.Sqrt(num24 * num24 + num25 * num25) > (double) num7 * 0.57000000000000006)
          {
            bool flag1 = false;
            if (!Main.tile[index5, index6].active() && Main.tile[index5, index6].wall == (ushort) 0)
            {
              int num26 = -1;
              int num27 = -1;
              for (int index7 = index5; index7 <= index5 + num20 && Main.tile[index7, index6 + 1].active() && Main.tileSolid[(int) Main.tile[index7, index6 + 1].type] && Main.tile[index7, index6].wall <= (ushort) 0; ++index7)
              {
                if (Main.tile[index7, index6].active() && Main.tileSolid[(int) Main.tile[index7, index6].type])
                {
                  if (Main.tile[index7, index6].type == (ushort) 53)
                    flag1 = true;
                  num27 = index7;
                  break;
                }
                if (Main.tile[index7, index6].active())
                  break;
              }
              for (int index8 = index5; index8 >= index5 - num20 && Main.tile[index8, index6 + 1].active() && Main.tileSolid[(int) Main.tile[index8, index6 + 1].type] && Main.tile[index8, index6].wall <= (ushort) 0; --index8)
              {
                if (Main.tile[index8, index6].active() && Main.tileSolid[(int) Main.tile[index8, index6].type])
                {
                  if (Main.tile[index8, index6].type == (ushort) 53)
                    flag1 = true;
                  num26 = index8;
                  break;
                }
                if (Main.tile[index8, index6].active())
                  break;
              }
              bool flag2 = true;
              if (((num26 <= -1 ? 0 : (num27 > -1 ? 1 : 0)) & (flag2 ? 1 : 0)) != 0)
              {
                int num28 = 0;
                for (int index9 = num26 + 1; index9 < num27; ++index9)
                {
                  if (num27 - num26 > 5 && WorldGen.genRand.Next(5) == 0)
                    num28 = WorldGen.genRand.Next(5, 10);
                  Main.tile[index9, index6].active(true);
                  Main.tile[index9, index6].type = (ushort) 53;
                  if (num28 > 0)
                  {
                    --num28;
                    Main.tile[index9, index6 - 1].active(true);
                    Main.tile[index9, index6 - 1].type = (ushort) 53;
                  }
                }
              }
            }
          }
        }
      }
      if (GenVars.numOasis < GenVars.maxOasis)
      {
        GenVars.oasisPosition[GenVars.numOasis] = new Point(x, y);
        GenVars.oasisWidth[GenVars.numOasis] = num2;
        ++GenVars.numOasis;
      }
      return true;
    }

    public static bool BiomeTileCheck(int x, int y)
    {
      int num = 50;
      for (int x1 = x - num; x1 <= x + num; ++x1)
      {
        for (int y1 = y - num; y1 <= y + num; ++y1)
        {
          if (WorldGen.InWorld(x1, y1))
          {
            if (Main.tile[x1, y1].active())
            {
              switch (Main.tile[x1, y1].type)
              {
                case 70:
                case 72:
                case 147:
                case 161:
                case 162:
                case 367:
                case 368:
                case 396:
                case 397:
                  return true;
              }
            }
            switch (Main.tile[x1, y1].wall)
            {
              case 187:
              case 216:
                return true;
              default:
                continue;
            }
          }
        }
      }
      return false;
    }

    public static double oceanLevel => (Main.worldSurface + Main.rockLayer) / 2.0 + 40.0;

    public static bool oceanDepths(int x, int y) => (double) y <= WorldGen.oceanLevel && (x < WorldGen.beachDistance || x > Main.maxTilesX - WorldGen.beachDistance);

    public static void UpdateDesertHiveBounds(int x, int y)
    {
      if (GenVars.desertHiveHigh > y)
        GenVars.desertHiveHigh = y;
      if (GenVars.desertHiveLow < y)
        GenVars.desertHiveLow = y;
      if (GenVars.desertHiveLeft > x)
        GenVars.desertHiveLeft = x;
      if (GenVars.desertHiveRight >= x)
        return;
      GenVars.desertHiveRight = x;
    }

    public static void GenerateWorld(int seed, GenerationProgress customProgressObject = null)
    {
      WorldGen.remixWorldGen = WorldGen.tempRemixWorldGen;
      WorldGen.tenthAnniversaryWorldGen = WorldGen.tempTenthAnniversaryWorldGen;
      WorldGen.drunkWorldGen = false;
      WorldGen.drunkWorldGenText = false;
      Main.afterPartyOfDoom = false;
      if (seed == 5162020 || WorldGen.everythingWorldGen)
      {
        WorldGen.drunkWorldGen = true;
        WorldGen.drunkWorldGenText = true;
        Main.drunkWorld = true;
        Main.rand = new UnifiedRandom();
        seed = Main.rand.Next(999999999);
        if (!Main.dayTime)
          Main.time = 0.0;
      }
      else if (seed == 5162021 || seed == 5162011)
        WorldGen.tenthAnniversaryWorldGen = true;
      Main.notTheBeesWorld = WorldGen.notTheBees;
      if (WorldGen.notTheBees)
      {
        Main.rand = new UnifiedRandom();
        seed = Main.rand.Next(999999999);
      }
      Main.noTrapsWorld = WorldGen.noTrapsWorldGen;
      if (WorldGen.noTrapsWorldGen)
      {
        Main.rand = new UnifiedRandom();
        seed = Main.rand.Next(999999999);
      }
      if (WorldGen.getGoodWorldGen)
      {
        Main.getGoodWorld = true;
        Main.rand = new UnifiedRandom();
        seed = Main.rand.Next(999999999);
      }
      else
        Main.getGoodWorld = false;
      Main.tenthAnniversaryWorld = WorldGen.tenthAnniversaryWorldGen;
      if (WorldGen.tenthAnniversaryWorldGen)
      {
        Main.rand = new UnifiedRandom();
        seed = Main.rand.Next(999999999);
      }
      Main.dontStarveWorld = WorldGen.dontStarveWorldGen;
      if (WorldGen.dontStarveWorldGen)
      {
        Main.rand = new UnifiedRandom();
        seed = Main.rand.Next(999999999);
      }
      Main.remixWorld = WorldGen.remixWorldGen;
      if (WorldGen.remixWorldGen)
      {
        Main.rand = new UnifiedRandom();
        seed = Main.rand.Next(999999999);
      }
      Main.zenithWorld = WorldGen.everythingWorldGen;
      Console.WriteLine("Creating world - Seed: {0} Width: {1}, Height: {2}, Evil: {3}, IsExpert: {4}", (object) seed, (object) Main.maxTilesX, (object) Main.maxTilesY, (object) WorldGen.WorldGenParam_Evil, (object) Main.expertMode);
      Main.lockMenuBGChange = true;
      GenVars.configuration = WorldGenConfiguration.FromEmbeddedPath("Terraria.GameContent.WorldBuilding.Configuration.json");
      WorldGen.Hooks.ProcessWorldGenConfig(ref GenVars.configuration);
      WorldGen._lastSeed = seed;
      WorldGen._generator = new WorldGenerator(seed, GenVars.configuration);
      WorldGen._genRand = new UnifiedRandom(seed);
      Main.rand = new UnifiedRandom(seed);
      GenVars.structures = new StructureMap();
      GenVars.desertHiveHigh = Main.maxTilesY;
      GenVars.desertHiveLow = 0;
      GenVars.desertHiveLeft = Main.maxTilesX;
      GenVars.desertHiveRight = 0;
      GenVars.worldSurfaceLow = 0.0;
      GenVars.worldSurface = 0.0;
      GenVars.worldSurfaceHigh = 0.0;
      GenVars.rockLayerLow = 0.0;
      GenVars.rockLayer = 0.0;
      GenVars.rockLayerHigh = 0.0;
      GenVars.copper = 7;
      GenVars.iron = 6;
      GenVars.silver = 9;
      GenVars.gold = 8;
      GenVars.dungeonSide = 0;
      GenVars.jungleHut = (ushort) WorldGen.genRand.Next(5);
      GenVars.shellStartXLeft = 0;
      GenVars.shellStartYLeft = 0;
      GenVars.shellStartXRight = 0;
      GenVars.shellStartYRight = 0;
      GenVars.PyrX = (int[]) null;
      GenVars.PyrY = (int[]) null;
      GenVars.numPyr = 0;
      GenVars.jungleMinX = -1;
      GenVars.jungleMaxX = -1;
      GenVars.snowMinX = new int[Main.maxTilesY];
      GenVars.snowMaxX = new int[Main.maxTilesY];
      GenVars.snowTop = 0;
      GenVars.snowBottom = 0;
      GenVars.skyLakes = 1;
      if (Main.maxTilesX > 8000)
        ++GenVars.skyLakes;
      if (Main.maxTilesX > 6000)
        ++GenVars.skyLakes;
      GenVars.beachBordersWidth = 275;
      GenVars.beachSandRandomCenter = GenVars.beachBordersWidth + 5 + 40;
      GenVars.beachSandRandomWidthRange = 20;
      GenVars.beachSandDungeonExtraWidth = 40;
      GenVars.beachSandJungleExtraWidth = 20;
      GenVars.oceanWaterStartRandomMin = 220;
      GenVars.oceanWaterStartRandomMax = GenVars.oceanWaterStartRandomMin + 40;
      GenVars.oceanWaterForcedJungleLength = 275;
      GenVars.leftBeachEnd = 0;
      GenVars.rightBeachStart = 0;
      GenVars.evilBiomeBeachAvoidance = GenVars.beachSandRandomCenter + 60;
      GenVars.evilBiomeAvoidanceMidFixer = 50;
      GenVars.lakesBeachAvoidance = GenVars.beachSandRandomCenter + 20;
      GenVars.smallHolesBeachAvoidance = GenVars.beachSandRandomCenter + 20;
      GenVars.surfaceCavesBeachAvoidance = GenVars.beachSandRandomCenter + 20;
      GenVars.surfaceCavesBeachAvoidance2 = GenVars.beachSandRandomCenter + 20;
      GenVars.jungleOriginX = 0;
      GenVars.snowOriginLeft = 0;
      GenVars.snowOriginRight = 0;
      GenVars.logX = -1;
      GenVars.logY = -1;
      GenVars.dungeonLocation = 0;
      if (WorldGen.everythingWorldGen)
        Main.starGame = true;
      WorldGen.AddGenerationPass("Reset", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        GenVars.crimsonLeft = WorldGen.genRand.Next(2) != 0;
        GenVars.numOceanCaveTreasure = 0;
        GenVars.skipDesertTileCheck = false;
        WorldGen.growGrassUnderground = false;
        WorldGen.gen = true;
        Liquid.ReInit();
        WorldGen.noTileActions = true;
        progress.Message = "";
        WorldGen.SetupStatueList();
        WorldGen.RandomizeWeather();
        Main.cloudAlpha = 0.0f;
        Main.maxRaining = 0.0f;
        Main.raining = false;
        WorldGen.heartCount = 0;
        GenVars.extraBastStatueCount = 0;
        GenVars.extraBastStatueCountMax = 2;
        Main.checkXMas();
        Main.checkHalloween();
        WorldGen.ResetGenerator();
        GenVars.UndergroundDesertLocation = Microsoft.Xna.Framework.Rectangle.Empty;
        GenVars.UndergroundDesertHiveLocation = Microsoft.Xna.Framework.Rectangle.Empty;
        GenVars.numLarva = 0;
        List<int> intList1 = new List<int>()
        {
          274,
          220,
          112,
          218,
          3019
        };
        if (WorldGen.remixWorldGen)
          intList1 = new List<int>()
          {
            274,
            220,
            683,
            218,
            3019
          };
        List<int> intList2 = new List<int>();
        while (intList1.Count > 0)
        {
          int index = WorldGen.genRand.Next(intList1.Count);
          int num = intList1[index];
          intList2.Add(num);
          intList1.RemoveAt(index);
        }
        GenVars.hellChestItem = intList2.ToArray();
        int num1 = 86400;
        Main.slimeRainTime = (double) -WorldGen.genRand.Next(num1 * 2, num1 * 3);
        Main.cloudBGActive = (float) -WorldGen.genRand.Next(8640, 86400);
        WorldGen.skipFramingDuringGen = false;
        WorldGen.SavedOreTiers.Copper = 7;
        WorldGen.SavedOreTiers.Iron = 6;
        WorldGen.SavedOreTiers.Silver = 9;
        WorldGen.SavedOreTiers.Gold = 8;
        GenVars.copperBar = 20;
        GenVars.ironBar = 22;
        GenVars.silverBar = 21;
        GenVars.goldBar = 19;
        if (WorldGen.genRand.Next(2) == 0)
        {
          GenVars.copper = 166;
          GenVars.copperBar = 703;
          WorldGen.SavedOreTiers.Copper = 166;
        }
        if ((!WorldGen.dontStarveWorldGen || WorldGen.drunkWorldGen) && WorldGen.genRand.Next(2) == 0)
        {
          GenVars.iron = 167;
          GenVars.ironBar = 704;
          WorldGen.SavedOreTiers.Iron = 167;
        }
        if (WorldGen.genRand.Next(2) == 0)
        {
          GenVars.silver = 168;
          GenVars.silverBar = 705;
          WorldGen.SavedOreTiers.Silver = 168;
        }
        if ((!WorldGen.dontStarveWorldGen || WorldGen.drunkWorldGen) && WorldGen.genRand.Next(2) == 0)
        {
          GenVars.gold = 169;
          GenVars.goldBar = 706;
          WorldGen.SavedOreTiers.Gold = 169;
        }
        WorldGen.crimson = WorldGen.genRand.Next(2) == 0;
        if (WorldGen.WorldGenParam_Evil == 0)
          WorldGen.crimson = false;
        if (WorldGen.WorldGenParam_Evil == 1)
          WorldGen.crimson = true;
        switch (GenVars.jungleHut)
        {
          case 0:
            GenVars.jungleHut = (ushort) 119;
            break;
          case 1:
            GenVars.jungleHut = (ushort) 120;
            break;
          case 2:
            GenVars.jungleHut = (ushort) 158;
            break;
          case 3:
            GenVars.jungleHut = (ushort) 175;
            break;
          case 4:
            GenVars.jungleHut = (ushort) 45;
            break;
        }
        Main.worldID = WorldGen.genRand.Next(int.MaxValue);
        WorldGen.RandomizeTreeStyle();
        WorldGen.RandomizeCaveBackgrounds();
        WorldGen.RandomizeBackgrounds(WorldGen.genRand);
        WorldGen.RandomizeMoonState(WorldGen.genRand);
        WorldGen.TreeTops.CopyExistingWorldInfoForWorldGeneration();
        GenVars.dungeonSide = WorldGen.genRand.Next(2) == 0 ? -1 : 1;
        if (WorldGen.remixWorldGen)
        {
          if (GenVars.dungeonSide == -1)
          {
            double num2 = 1.0 - (double) WorldGen.genRand.Next(20, 35) * 0.01;
            GenVars.jungleOriginX = (int) ((double) Main.maxTilesX * num2);
          }
          else
          {
            double num3 = (double) WorldGen.genRand.Next(20, 35) * 0.01;
            GenVars.jungleOriginX = (int) ((double) Main.maxTilesX * num3);
          }
        }
        else
        {
          int minValue = 15;
          int maxValue = 30;
          if (WorldGen.tenthAnniversaryWorldGen && !WorldGen.remixWorldGen)
          {
            minValue = 25;
            maxValue = 35;
          }
          if (GenVars.dungeonSide == -1)
          {
            double num4 = 1.0 - (double) WorldGen.genRand.Next(minValue, maxValue) * 0.01;
            GenVars.jungleOriginX = (int) ((double) Main.maxTilesX * num4);
          }
          else
          {
            double num5 = (double) WorldGen.genRand.Next(minValue, maxValue) * 0.01;
            GenVars.jungleOriginX = (int) ((double) Main.maxTilesX * num5);
          }
        }
        int num6 = WorldGen.genRand.Next(Main.maxTilesX);
        if (WorldGen.drunkWorldGen)
          GenVars.dungeonSide *= -1;
        if (GenVars.dungeonSide == 1)
        {
          while ((double) num6 < (double) Main.maxTilesX * 0.6 || (double) num6 > (double) Main.maxTilesX * 0.75)
            num6 = WorldGen.genRand.Next(Main.maxTilesX);
        }
        else
        {
          while ((double) num6 < (double) Main.maxTilesX * 0.25 || (double) num6 > (double) Main.maxTilesX * 0.4)
            num6 = WorldGen.genRand.Next(Main.maxTilesX);
        }
        if (WorldGen.drunkWorldGen)
          GenVars.dungeonSide *= -1;
        int num7 = WorldGen.genRand.Next(50, 90);
        double num8 = (double) Main.maxTilesX / 4200.0;
        int num9 = num7 + (int) ((double) WorldGen.genRand.Next(20, 40) * num8) + (int) ((double) WorldGen.genRand.Next(20, 40) * num8);
        int num10 = num6 - num9;
        int num11 = WorldGen.genRand.Next(50, 90) + (int) ((double) WorldGen.genRand.Next(20, 40) * num8) + (int) ((double) WorldGen.genRand.Next(20, 40) * num8);
        int num12 = num6 + num11;
        if (num10 < 0)
          num10 = 0;
        if (num12 > Main.maxTilesX)
          num12 = Main.maxTilesX;
        GenVars.snowOriginLeft = num10;
        GenVars.snowOriginRight = num12;
        GenVars.leftBeachEnd = WorldGen.genRand.Next(GenVars.beachSandRandomCenter - GenVars.beachSandRandomWidthRange, GenVars.beachSandRandomCenter + GenVars.beachSandRandomWidthRange);
        if (WorldGen.tenthAnniversaryWorldGen && !WorldGen.remixWorldGen)
          GenVars.leftBeachEnd = GenVars.beachSandRandomCenter + GenVars.beachSandRandomWidthRange;
        if (GenVars.dungeonSide == 1)
          GenVars.leftBeachEnd += GenVars.beachSandDungeonExtraWidth;
        else
          GenVars.leftBeachEnd += GenVars.beachSandJungleExtraWidth;
        GenVars.rightBeachStart = Main.maxTilesX - WorldGen.genRand.Next(GenVars.beachSandRandomCenter - GenVars.beachSandRandomWidthRange, GenVars.beachSandRandomCenter + GenVars.beachSandRandomWidthRange);
        if (WorldGen.tenthAnniversaryWorldGen && !WorldGen.remixWorldGen)
          GenVars.rightBeachStart = Main.maxTilesX - (GenVars.beachSandRandomCenter + GenVars.beachSandRandomWidthRange);
        if (GenVars.dungeonSide == -1)
          GenVars.rightBeachStart -= GenVars.beachSandDungeonExtraWidth;
        else
          GenVars.rightBeachStart -= GenVars.beachSandJungleExtraWidth;
        int num13 = 50;
        GenVars.dungeonLocation = GenVars.dungeonSide != -1 ? WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.8), GenVars.rightBeachStart - num13) : WorldGen.genRand.Next(GenVars.leftBeachEnd + num13, (int) ((double) Main.maxTilesX * 0.2));
        int num14 = 0;
        if (Main.maxTilesX >= 8400)
          num14 = 2;
        else if (Main.maxTilesX >= 6400)
          num14 = 1;
        GenVars.extraBastStatueCountMax = 2 + num14;
        Main.tileSolid[659] = false;
      }));
      WorldGen.AddGenerationPass((GenPass) new TerrainPass());
      WorldGen.AddGenerationPass("Dunes", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[1].Value;
        int random = passConfig.Get<WorldGenRange>("Count").GetRandom(WorldGen.genRand);
        double num15 = passConfig.Get<double>("ChanceOfPyramid");
        if (WorldGen.drunkWorldGen)
          num15 = 1.0;
        double num16 = (double) Main.maxTilesX / 4200.0;
        GenVars.PyrX = new int[random + 3];
        GenVars.PyrY = new int[random + 3];
        DunesBiome biome = GenVars.configuration.CreateBiome<DunesBiome>();
        for (int index1 = 0; index1 < random; ++index1)
        {
          progress.Set((double) index1 / (double) random);
          Point origin = Point.Zero;
          bool flag1 = false;
          int num17 = 0;
          bool flag2;
          bool flag3;
          bool flag4;
          for (; !flag1; flag1 = !(flag2 | flag3 | flag4))
          {
            origin = WorldGen.RandomWorldPoint(right: 500, left: 500);
            flag2 = Math.Abs(origin.X - GenVars.jungleOriginX) < (int) (600.0 * num16);
            flag3 = Math.Abs(origin.X - Main.maxTilesX / 2) < 300;
            flag4 = origin.X > GenVars.snowOriginLeft - 300 && origin.X < GenVars.snowOriginRight + 300;
            ++num17;
            if (num17 >= Main.maxTilesX)
              flag2 = false;
            if (num17 >= Main.maxTilesX * 2)
              flag4 = false;
          }
          biome.Place(origin, GenVars.structures);
          if (WorldGen.genRand.NextDouble() <= num15)
          {
            int index2 = WorldGen.genRand.Next(origin.X - 200, origin.X + 200);
            for (int index3 = 0; index3 < Main.maxTilesY; ++index3)
            {
              if (Main.tile[index2, index3].active())
              {
                GenVars.PyrX[GenVars.numPyr] = index2;
                GenVars.PyrY[GenVars.numPyr] = index3 + 20;
                ++GenVars.numPyr;
                break;
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Ocean Sand", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Language.GetTextValue("WorldGeneration.OceanSand");
        for (int index4 = 0; index4 < 3; ++index4)
        {
          progress.Set((double) index4 / 3.0);
          int num18 = WorldGen.genRand.Next(Main.maxTilesX);
          while ((double) num18 > (double) Main.maxTilesX * 0.4 && (double) num18 < (double) Main.maxTilesX * 0.6)
            num18 = WorldGen.genRand.Next(Main.maxTilesX);
          int num19 = WorldGen.genRand.Next(35, 90);
          if (index4 == 1)
          {
            double num20 = (double) Main.maxTilesX / 4200.0;
            num19 += (int) ((double) WorldGen.genRand.Next(20, 40) * num20);
          }
          if (WorldGen.genRand.Next(3) == 0)
            num19 *= 2;
          if (index4 == 1)
            num19 *= 2;
          int num21 = num18 - num19;
          int num22 = WorldGen.genRand.Next(35, 90);
          if (WorldGen.genRand.Next(3) == 0)
            num22 *= 2;
          if (index4 == 1)
            num22 *= 2;
          int num23 = num18 + num22;
          if (num21 < 0)
            num21 = 0;
          if (num23 > Main.maxTilesX)
            num23 = Main.maxTilesX;
          switch (index4)
          {
            case 0:
              num21 = 0;
              num23 = GenVars.leftBeachEnd;
              break;
            case 1:
              continue;
            case 2:
              num21 = GenVars.rightBeachStart;
              num23 = Main.maxTilesX;
              break;
          }
          int num24 = WorldGen.genRand.Next(50, 100);
          for (int index5 = num21; index5 < num23; ++index5)
          {
            if (WorldGen.genRand.Next(2) == 0)
            {
              num24 += WorldGen.genRand.Next(-1, 2);
              if (num24 < 50)
                num24 = 50;
              if (num24 > 200)
                num24 = 200;
            }
            for (int index6 = 0; (double) index6 < (Main.worldSurface + Main.rockLayer) / 2.0; ++index6)
            {
              if (Main.tile[index5, index6].active())
              {
                if (index5 == (num21 + num23) / 2 && WorldGen.genRand.Next(6) == 0)
                {
                  GenVars.PyrX[GenVars.numPyr] = index5;
                  GenVars.PyrY[GenVars.numPyr] = index6;
                  ++GenVars.numPyr;
                }
                int num25 = num24;
                if (index5 - num21 < num25)
                  num25 = index5 - num21;
                if (num23 - index5 < num25)
                  num25 = num23 - index5;
                int num26 = num25 + WorldGen.genRand.Next(5);
                for (int index7 = index6; index7 < index6 + num26; ++index7)
                {
                  if (index5 > num21 + WorldGen.genRand.Next(5) && index5 < num23 - WorldGen.genRand.Next(5))
                    Main.tile[index5, index7].type = (ushort) 53;
                }
                break;
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Sand Patches", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        int num = (int) ((double) Main.maxTilesX * 0.013);
        if (WorldGen.remixWorldGen)
          num /= 4;
        for (int index = 0; index < num; ++index)
        {
          int i = WorldGen.genRand.Next(0, Main.maxTilesX);
          int j = WorldGen.genRand.Next((int) Main.worldSurface, (int) Main.rockLayer);
          if (WorldGen.remixWorldGen)
            j = WorldGen.genRand.Next((int) Main.rockLayer - 100, Main.maxTilesY - 350);
          for (; (double) i > (double) Main.maxTilesX * 0.46 && (double) i < (double) Main.maxTilesX * 0.54 && (double) j < Main.worldSurface + 150.0; j = WorldGen.genRand.Next((int) Main.worldSurface, (int) Main.rockLayer))
            i = WorldGen.genRand.Next(0, Main.maxTilesX);
          int strength = WorldGen.genRand.Next(15, 70);
          int steps = WorldGen.genRand.Next(20, 130);
          WorldGen.TileRunner(i, j, (double) strength, steps, 53);
        }
      }));
      WorldGen.AddGenerationPass("Tunnels", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        int num27 = (int) ((double) Main.maxTilesX * 0.0015);
        if (WorldGen.remixWorldGen)
          num27 = (int) ((double) num27 * 1.5);
        for (int index8 = 0; index8 < num27 && GenVars.numTunnels < GenVars.maxTunnels - 1; ++index8)
        {
          int[] numArray1 = new int[10];
          int[] numArray2 = new int[10];
          int num28 = WorldGen.genRand.Next(450, Main.maxTilesX - 450);
          if (!WorldGen.remixWorldGen)
          {
            if (WorldGen.tenthAnniversaryWorldGen)
            {
              num28 = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.2), (int) ((double) Main.maxTilesX * 0.8));
            }
            else
            {
              while ((double) num28 > (double) Main.maxTilesX * 0.4 && (double) num28 < (double) Main.maxTilesX * 0.6)
                num28 = WorldGen.genRand.Next(450, Main.maxTilesX - 450);
            }
          }
          int index9 = 0;
          bool flag;
          do
          {
            flag = false;
            for (int index10 = 0; index10 < 10; ++index10)
            {
              int index11 = num28 % Main.maxTilesX;
              while (!Main.tile[index11, index9].active())
                ++index9;
              if (Main.tile[index11, index9].type == (ushort) 53)
                flag = true;
              numArray1[index10] = index11;
              numArray2[index10] = index9 - WorldGen.genRand.Next(11, 16);
              num28 = index11 + WorldGen.genRand.Next(5, 11);
            }
          }
          while (flag);
          GenVars.tunnelX[GenVars.numTunnels] = numArray1[5];
          ++GenVars.numTunnels;
          for (int index12 = 0; index12 < 10; ++index12)
          {
            WorldGen.TileRunner(numArray1[index12], numArray2[index12], (double) WorldGen.genRand.Next(5, 8), WorldGen.genRand.Next(6, 9), 0, true, -2.0, -0.3);
            WorldGen.TileRunner(numArray1[index12], numArray2[index12], (double) WorldGen.genRand.Next(5, 8), WorldGen.genRand.Next(6, 9), 0, true, 2.0, -0.3);
          }
        }
      }));
      WorldGen.AddGenerationPass("Mount Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        GenVars.numMCaves = 0;
        progress.Message = Lang.gen[2].Value;
        int num29 = (int) ((double) Main.maxTilesX * 0.001);
        if (WorldGen.remixWorldGen)
          num29 = (int) ((double) num29 * 1.5);
        for (int index13 = 0; index13 < num29; ++index13)
        {
          progress.Set((double) index13 / (double) num29);
          int num30 = 0;
          bool flag5 = false;
          bool flag6 = false;
          int i = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.25), (int) ((double) Main.maxTilesX * 0.75));
          while (!flag6)
          {
            flag6 = true;
            if (!WorldGen.remixWorldGen)
            {
              while (i > Main.maxTilesX / 2 - 90 && i < Main.maxTilesX / 2 + 90)
                i = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.25), (int) ((double) Main.maxTilesX * 0.75));
            }
            for (int index14 = 0; index14 < GenVars.numMCaves; ++index14)
            {
              if (Math.Abs(i - GenVars.mCaveX[index14]) < 100)
              {
                ++num30;
                flag6 = false;
                break;
              }
            }
            if (num30 >= Main.maxTilesX / 5)
            {
              flag5 = true;
              break;
            }
          }
          if (!flag5)
          {
            for (int j = 0; (double) j < Main.worldSurface; ++j)
            {
              if (Main.tile[i, j].active())
              {
                for (int index15 = i - 50; index15 < i + 50; ++index15)
                {
                  for (int index16 = j - 25; index16 < j + 25; ++index16)
                  {
                    if (Main.tile[index15, index16].active() && (Main.tile[index15, index16].type == (ushort) 53 || Main.tile[index15, index16].type == (ushort) 151 || Main.tile[index15, index16].type == (ushort) 274))
                      flag5 = true;
                  }
                }
                if (!flag5)
                {
                  WorldGen.Mountinater(i, j);
                  GenVars.mCaveX[GenVars.numMCaves] = i;
                  GenVars.mCaveY[GenVars.numMCaves] = j;
                  ++GenVars.numMCaves;
                  break;
                }
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Dirt Wall Backgrounds", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[3].Value;
        int num31 = 0;
        for (int index17 = 1; index17 < Main.maxTilesX - 1; ++index17)
        {
          ushort num32 = 2;
          double num33 = (double) index17 / (double) Main.maxTilesX;
          progress.Set(num33);
          bool flag = false;
          num31 += WorldGen.genRand.Next(-1, 2);
          if (num31 < 0)
            num31 = 0;
          if (num31 > 10)
            num31 = 10;
          for (int index18 = 0; (double) index18 < Main.worldSurface + 10.0 && (double) index18 <= Main.worldSurface + (double) num31; ++index18)
          {
            if (Main.tile[index17, index18].active())
              num32 = Main.tile[index17, index18].type != (ushort) 147 ? (ushort) 2 : (ushort) 40;
            if (flag && Main.tile[index17, index18].wall != (ushort) 64)
              Main.tile[index17, index18].wall = num32;
            if (Main.tile[index17, index18].active() && Main.tile[index17 - 1, index18].active() && Main.tile[index17 + 1, index18].active() && Main.tile[index17, index18 + 1].active() && Main.tile[index17 - 1, index18 + 1].active() && Main.tile[index17 + 1, index18 + 1].active())
              flag = true;
          }
        }
      }));
      WorldGen.AddGenerationPass("Rocks In Dirt", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[4].Value;
        double num34 = (double) (Main.maxTilesX * Main.maxTilesY) * 0.00015;
        for (int index = 0; (double) index < num34; ++index)
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next(0, (int) GenVars.worldSurfaceLow + 1), (double) WorldGen.genRand.Next(4, 15), WorldGen.genRand.Next(5, 40), 1);
        progress.Set(0.34);
        double num35 = (double) (Main.maxTilesX * Main.maxTilesY) * 0.0002;
        for (int index = 0; (double) index < num35; ++index)
        {
          int i = WorldGen.genRand.Next(0, Main.maxTilesX);
          int j = WorldGen.genRand.Next((int) GenVars.worldSurfaceLow, (int) GenVars.worldSurfaceHigh + 1);
          if (!Main.tile[i, j - 10].active())
            j = WorldGen.genRand.Next((int) GenVars.worldSurfaceLow, (int) GenVars.worldSurfaceHigh + 1);
          WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(4, 10), WorldGen.genRand.Next(5, 30), 1);
        }
        progress.Set(0.67);
        double num36 = (double) (Main.maxTilesX * Main.maxTilesY) * 0.0045;
        for (int index = 0; (double) index < num36; ++index)
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.worldSurfaceHigh, (int) GenVars.rockLayerHigh + 1), (double) WorldGen.genRand.Next(2, 7), WorldGen.genRand.Next(2, 23), 1);
      }));
      WorldGen.AddGenerationPass("Dirt In Rocks", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[5].Value;
        double num = (double) (Main.maxTilesX * Main.maxTilesY) * 0.005;
        for (int index = 0; (double) index < num; ++index)
        {
          progress.Set((double) index / num);
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.rockLayerLow, Main.maxTilesY), (double) WorldGen.genRand.Next(2, 6), WorldGen.genRand.Next(2, 40), 0);
        }
        if (!WorldGen.remixWorldGen)
          return;
        for (int index19 = 0; index19 < Main.maxTilesX; ++index19)
        {
          for (int index20 = (int) Main.worldSurface + WorldGen.genRand.Next(-1, 3); index20 < Main.maxTilesY; ++index20)
          {
            if (Main.tile[index19, index20].active())
            {
              if (Main.tile[index19, index20].type == (ushort) 0)
                Main.tile[index19, index20].type = (ushort) 1;
              else if (Main.tile[index19, index20].type == (ushort) 1)
                Main.tile[index19, index20].type = (ushort) 0;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Clay", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[6].Value;
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2E-05); ++index)
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next(0, (int) GenVars.worldSurfaceLow), (double) WorldGen.genRand.Next(4, 14), WorldGen.genRand.Next(10, 50), 40);
        progress.Set(0.25);
        if (WorldGen.remixWorldGen)
        {
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 7E-05); ++index)
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.rockLayer - 25, Main.maxTilesY - 350), (double) WorldGen.genRand.Next(8, 15), WorldGen.genRand.Next(5, 50), 40);
        }
        else
        {
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 5E-05); ++index)
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.worldSurfaceLow, (int) GenVars.worldSurfaceHigh + 1), (double) WorldGen.genRand.Next(8, 14), WorldGen.genRand.Next(15, 45), 40);
          progress.Set(0.5);
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2E-05); ++index)
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.worldSurfaceHigh, (int) GenVars.rockLayerHigh + 1), (double) WorldGen.genRand.Next(8, 15), WorldGen.genRand.Next(5, 50), 40);
        }
        progress.Set(0.75);
        for (int index21 = 5; index21 < Main.maxTilesX - 5; ++index21)
        {
          for (int index22 = 1; (double) index22 < Main.worldSurface - 1.0; ++index22)
          {
            if (Main.tile[index21, index22].active())
            {
              for (int index23 = index22; index23 < index22 + 5; ++index23)
              {
                if (Main.tile[index21, index23].type == (ushort) 40)
                  Main.tile[index21, index23].type = (ushort) 0;
              }
              break;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Small Holes", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[7].Value;
        double worldSurfaceHigh = GenVars.worldSurfaceHigh;
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0015); ++index)
        {
          double num = (double) index / ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0015);
          progress.Set(num);
          int type = -1;
          if (WorldGen.genRand.Next(5) == 0)
            type = -2;
          int i1 = WorldGen.genRand.Next(0, Main.maxTilesX);
          int j1 = WorldGen.genRand.Next((int) GenVars.worldSurfaceHigh, Main.maxTilesY);
          if (!WorldGen.remixWorldGen && WorldGen.tenthAnniversaryWorldGen)
          {
            for (; (double) i1 < (double) Main.maxTilesX * 0.2 && (double) i1 > (double) Main.maxTilesX * 0.8 && (double) j1 < GenVars.worldSurface; j1 = WorldGen.genRand.Next((int) GenVars.worldSurfaceHigh, Main.maxTilesY))
              i1 = WorldGen.genRand.Next(0, Main.maxTilesX);
          }
          else
          {
            for (; (i1 < GenVars.smallHolesBeachAvoidance || i1 > Main.maxTilesX - GenVars.smallHolesBeachAvoidance) && (double) j1 < worldSurfaceHigh || (double) i1 > (double) Main.maxTilesX * 0.45 && (double) i1 < (double) Main.maxTilesX * 0.55 && (double) j1 < GenVars.worldSurface; j1 = WorldGen.genRand.Next((int) GenVars.worldSurfaceHigh, Main.maxTilesY))
              i1 = WorldGen.genRand.Next(0, Main.maxTilesX);
          }
          int strength1 = WorldGen.genRand.Next(2, 5);
          int steps1 = WorldGen.genRand.Next(2, 20);
          if (WorldGen.remixWorldGen && (double) j1 > Main.rockLayer)
          {
            strength1 = (int) ((double) strength1 * 0.8);
            steps1 = (int) ((double) steps1 * 0.9);
          }
          WorldGen.TileRunner(i1, j1, (double) strength1, steps1, type);
          int i2 = WorldGen.genRand.Next(0, Main.maxTilesX);
          int j2;
          for (j2 = WorldGen.genRand.Next((int) GenVars.worldSurfaceHigh, Main.maxTilesY); (i2 < GenVars.smallHolesBeachAvoidance || i2 > Main.maxTilesX - GenVars.smallHolesBeachAvoidance) && (double) j2 < worldSurfaceHigh || (double) i2 > (double) Main.maxTilesX * 0.45 && (double) i2 < (double) Main.maxTilesX * 0.55 && (double) j2 < GenVars.worldSurface; j2 = WorldGen.genRand.Next((int) GenVars.worldSurfaceHigh, Main.maxTilesY))
            i2 = WorldGen.genRand.Next(0, Main.maxTilesX);
          int strength2 = WorldGen.genRand.Next(8, 15);
          int steps2 = WorldGen.genRand.Next(7, 30);
          if (WorldGen.remixWorldGen && (double) j2 > Main.rockLayer)
          {
            strength2 = (int) ((double) strength2 * 0.7);
            steps2 = (int) ((double) steps2 * 0.9);
          }
          WorldGen.TileRunner(i2, j2, (double) strength2, steps2, type);
        }
      }));
      WorldGen.AddGenerationPass("Dirt Layer Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[8].Value;
        double worldSurfaceHigh = GenVars.worldSurfaceHigh;
        int num37 = (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 3E-05);
        if (WorldGen.remixWorldGen)
          num37 *= 2;
        for (int index = 0; index < num37; ++index)
        {
          double num38 = (double) index / (double) num37;
          progress.Set(num38);
          if (GenVars.rockLayerHigh <= (double) Main.maxTilesY)
          {
            int type = -1;
            if (WorldGen.genRand.Next(6) == 0)
              type = -2;
            int i = WorldGen.genRand.Next(0, Main.maxTilesX);
            int j;
            for (j = WorldGen.genRand.Next((int) GenVars.worldSurfaceLow, (int) GenVars.rockLayerHigh + 1); (i < GenVars.smallHolesBeachAvoidance || i > Main.maxTilesX - GenVars.smallHolesBeachAvoidance) && (double) j < worldSurfaceHigh || (double) i >= (double) Main.maxTilesX * 0.45 && (double) i <= (double) Main.maxTilesX * 0.55 && (double) j < Main.worldSurface; j = WorldGen.genRand.Next((int) GenVars.worldSurfaceLow, (int) GenVars.rockLayerHigh + 1))
              i = WorldGen.genRand.Next(0, Main.maxTilesX);
            int strength = WorldGen.genRand.Next(5, 15);
            int steps = WorldGen.genRand.Next(30, 200);
            if (WorldGen.remixWorldGen)
            {
              strength = (int) ((double) strength * 1.1);
              steps = (int) ((double) steps * 1.9);
            }
            WorldGen.TileRunner(i, j, (double) strength, steps, type);
          }
        }
      }));
      WorldGen.AddGenerationPass("Rock Layer Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[9].Value;
        int num39 = (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.00013);
        if (WorldGen.remixWorldGen)
          num39 = (int) ((double) num39 * 1.1);
        for (int index = 0; index < num39; ++index)
        {
          double num40 = (double) index / (double) num39;
          progress.Set(num40);
          if (GenVars.rockLayerHigh <= (double) Main.maxTilesY)
          {
            int type = -1;
            if (WorldGen.genRand.Next(10) == 0)
              type = -2;
            int strength = WorldGen.genRand.Next(6, 20);
            int steps = WorldGen.genRand.Next(50, 300);
            if (WorldGen.remixWorldGen)
            {
              strength = (int) ((double) strength * 0.7);
              steps = (int) ((double) steps * 0.7);
            }
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.rockLayerHigh, Main.maxTilesY), (double) strength, steps, type);
          }
        }
        if (!WorldGen.remixWorldGen)
          return;
        int num41 = (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.00013 * 0.4);
        for (int index = 0; index < num41; ++index)
        {
          if (GenVars.rockLayerHigh <= (double) Main.maxTilesY)
          {
            int type = -1;
            if (WorldGen.genRand.Next(10) == 0)
              type = -2;
            int strength = WorldGen.genRand.Next(7, 26);
            int steps = WorldGen.genRand.Next(50, 200);
            double speedX = (double) WorldGen.genRand.Next(100, 221) * 0.1;
            double speedY = (double) WorldGen.genRand.Next(-10, 11) * 0.02;
            int i = WorldGen.genRand.Next(0, Main.maxTilesX);
            int j = WorldGen.genRand.Next((int) GenVars.rockLayerHigh, Main.maxTilesY);
            WorldGen.TileRunner(i, j, (double) strength, steps, type, speedX: speedX, speedY: speedY, noYChange: true);
            WorldGen.TileRunner(i, j, (double) strength, steps, type, speedX: (-speedX), speedY: (-speedY), noYChange: true);
          }
        }
      }));
      WorldGen.AddGenerationPass("Surface Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[10].Value;
        int num42 = (int) ((double) Main.maxTilesX * 0.002);
        int num43 = (int) ((double) Main.maxTilesX * 0.0007);
        int num44 = (int) ((double) Main.maxTilesX * 0.0003);
        if (WorldGen.remixWorldGen)
        {
          num42 *= 3;
          num43 *= 3;
          num44 *= 3;
        }
        for (int index = 0; index < num42; ++index)
        {
          int i = WorldGen.genRand.Next(0, Main.maxTilesX);
          while ((double) i > (double) Main.maxTilesX * 0.45 && (double) i < (double) Main.maxTilesX * 0.55 || i < GenVars.leftBeachEnd + 20 || i > GenVars.rightBeachStart - 20)
            i = WorldGen.genRand.Next(0, Main.maxTilesX);
          for (int j = 0; (double) j < GenVars.worldSurfaceHigh; ++j)
          {
            if (Main.tile[i, j].active())
            {
              WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(5, 50), -1, speedX: ((double) WorldGen.genRand.Next(-10, 11) * 0.1), speedY: 1.0);
              break;
            }
          }
        }
        progress.Set(0.2);
        for (int index = 0; index < num43; ++index)
        {
          int i = WorldGen.genRand.Next(0, Main.maxTilesX);
          while ((double) i > (double) Main.maxTilesX * 0.43 && (double) i < (double) Main.maxTilesX * 0.57000000000000006 || i < GenVars.leftBeachEnd + 20 || i > GenVars.rightBeachStart - 20)
            i = WorldGen.genRand.Next(0, Main.maxTilesX);
          for (int j = 0; (double) j < GenVars.worldSurfaceHigh; ++j)
          {
            if (Main.tile[i, j].active())
            {
              WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(10, 15), WorldGen.genRand.Next(50, 130), -1, speedX: ((double) WorldGen.genRand.Next(-10, 11) * 0.1), speedY: 2.0);
              break;
            }
          }
        }
        progress.Set(0.4);
        for (int index = 0; index < num44; ++index)
        {
          int i = WorldGen.genRand.Next(0, Main.maxTilesX);
          while ((double) i > (double) Main.maxTilesX * 0.4 && (double) i < (double) Main.maxTilesX * 0.6 || i < GenVars.leftBeachEnd + 20 || i > GenVars.rightBeachStart - 20)
            i = WorldGen.genRand.Next(0, Main.maxTilesX);
          for (int j = 0; (double) j < GenVars.worldSurfaceHigh; ++j)
          {
            if (Main.tile[i, j].active())
            {
              WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(12, 25), WorldGen.genRand.Next(150, 500), -1, speedX: ((double) WorldGen.genRand.Next(-10, 11) * 0.1), speedY: 4.0);
              WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(8, 17), WorldGen.genRand.Next(60, 200), -1, speedX: ((double) WorldGen.genRand.Next(-10, 11) * 0.1), speedY: 2.0);
              WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(5, 13), WorldGen.genRand.Next(40, 170), -1, speedX: ((double) WorldGen.genRand.Next(-10, 11) * 0.1), speedY: 2.0);
              break;
            }
          }
        }
        progress.Set(0.6);
        for (int index = 0; index < (int) ((double) Main.maxTilesX * 0.0004); ++index)
        {
          int i = WorldGen.genRand.Next(0, Main.maxTilesX);
          while ((double) i > (double) Main.maxTilesX * 0.4 && (double) i < (double) Main.maxTilesX * 0.6 || i < GenVars.leftBeachEnd + 20 || i > GenVars.rightBeachStart - 20)
            i = WorldGen.genRand.Next(0, Main.maxTilesX);
          for (int j = 0; (double) j < GenVars.worldSurfaceHigh; ++j)
          {
            if (Main.tile[i, j].active())
            {
              WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(7, 12), WorldGen.genRand.Next(150, 250), -1, speedY: 1.0, noYChange: true);
              break;
            }
          }
        }
        progress.Set(0.8);
        double num45 = (double) Main.maxTilesX / 4200.0;
        for (int index = 0; (double) index < 5.0 * num45; ++index)
        {
          try
          {
            int minValue = (int) Main.rockLayer;
            int maxValue = Main.maxTilesY - 400;
            if (minValue >= maxValue)
              minValue = maxValue - 1;
            WorldGen.Caverer(WorldGen.genRand.Next(GenVars.surfaceCavesBeachAvoidance2, Main.maxTilesX - GenVars.surfaceCavesBeachAvoidance2), WorldGen.genRand.Next(minValue, maxValue));
          }
          catch
          {
          }
        }
      }));
      WorldGen.AddGenerationPass("Wavy Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (!WorldGen.dontStarveWorldGen)
          return;
        progress.Message = Language.GetTextValue("WorldGeneration.WavyCaves");
        double num46 = (double) Main.maxTilesX / 4200.0;
        int num47 = (int) (35.0 * (num46 * num46));
        if (Main.remixWorld)
          num47 /= 3;
        int num48 = 0;
        int num49 = 80;
        for (int index = 0; index < num47; ++index)
        {
          double num50 = (double) index / (double) (num47 - 1);
          progress.Set(num50);
          int startY = WorldGen.genRand.Next((int) Main.worldSurface + 100, Main.UnderworldLayer - 100);
          int num51 = 0;
          for (; Math.Abs(startY - num48) < num49; startY = WorldGen.genRand.Next((int) Main.worldSurface + 100, Main.UnderworldLayer - 100))
          {
            ++num51;
            if (num51 > 100)
              break;
          }
          num48 = startY;
          int num52 = 80;
          int startX = num52 + (int) ((double) (Main.maxTilesX - num52 * 2) * num50);
          try
          {
            WorldGen.WavyCaverer(startX, startY, (double) (12 + WorldGen.genRand.Next(3, 6)), 0.25 + WorldGen.genRand.NextDouble(), WorldGen.genRand.Next(300, 500), -1);
          }
          catch
          {
          }
        }
      }));
      WorldGen.AddGenerationPass("Generate Ice Biome", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[56].Value;
        GenVars.snowTop = (int) Main.worldSurface;
        int num53 = GenVars.lavaLine - WorldGen.genRand.Next(160, 200);
        int num54 = GenVars.lavaLine;
        if (WorldGen.remixWorldGen)
        {
          num54 = Main.maxTilesY - 250;
          num53 = num54 - WorldGen.genRand.Next(160, 200);
        }
        int num55 = GenVars.snowOriginLeft;
        int num56 = GenVars.snowOriginRight;
        int num57 = 10;
        for (int index24 = 0; index24 <= num54 - 140; ++index24)
        {
          progress.Set((double) index24 / (double) (num54 - 140));
          num55 += WorldGen.genRand.Next(-4, 4);
          num56 += WorldGen.genRand.Next(-3, 5);
          if (index24 > 0)
          {
            num55 = (num55 + GenVars.snowMinX[index24 - 1]) / 2;
            num56 = (num56 + GenVars.snowMaxX[index24 - 1]) / 2;
          }
          if (GenVars.dungeonSide > 0)
          {
            if (WorldGen.genRand.Next(4) == 0)
            {
              ++num55;
              ++num56;
            }
          }
          else if (WorldGen.genRand.Next(4) == 0)
          {
            --num55;
            --num56;
          }
          GenVars.snowMinX[index24] = num55;
          GenVars.snowMaxX[index24] = num56;
          for (int index25 = num55; index25 < num56; ++index25)
          {
            if (index24 < num53)
            {
              if (Main.tile[index25, index24].wall == (ushort) 2)
                Main.tile[index25, index24].wall = (ushort) 40;
              switch (Main.tile[index25, index24].type)
              {
                case 0:
                case 2:
                case 23:
                case 40:
                case 53:
                  Main.tile[index25, index24].type = (ushort) 147;
                  continue;
                case 1:
                  Main.tile[index25, index24].type = (ushort) 161;
                  continue;
                default:
                  continue;
              }
            }
            else
            {
              num57 += WorldGen.genRand.Next(-3, 4);
              if (WorldGen.genRand.Next(3) == 0)
              {
                num57 += WorldGen.genRand.Next(-4, 5);
                if (WorldGen.genRand.Next(3) == 0)
                  num57 += WorldGen.genRand.Next(-6, 7);
              }
              if (num57 < 0)
                num57 = WorldGen.genRand.Next(3);
              else if (num57 > 50)
                num57 = 50 - WorldGen.genRand.Next(3);
              for (int index26 = index24; index26 < index24 + num57; ++index26)
              {
                if (Main.tile[index25, index26].wall == (ushort) 2)
                  Main.tile[index25, index26].wall = (ushort) 40;
                switch (Main.tile[index25, index26].type)
                {
                  case 0:
                  case 2:
                  case 23:
                  case 40:
                  case 53:
                    Main.tile[index25, index26].type = (ushort) 147;
                    break;
                  case 1:
                    Main.tile[index25, index26].type = (ushort) 161;
                    break;
                }
              }
            }
          }
          if (GenVars.snowBottom < index24)
            GenVars.snowBottom = index24;
        }
      }));
      WorldGen.AddGenerationPass("Grass", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        double num = (double) (Main.maxTilesX * Main.maxTilesY) * 0.002;
        for (int index27 = 0; (double) index27 < num; ++index27)
        {
          progress.Set((double) index27 / num);
          int index28 = WorldGen.genRand.Next(1, Main.maxTilesX - 1);
          int index29 = WorldGen.genRand.Next((int) GenVars.worldSurfaceLow, (int) GenVars.worldSurfaceHigh);
          if (index29 >= Main.maxTilesY)
            index29 = Main.maxTilesY - 2;
          if (Main.tile[index28 - 1, index29].active() && Main.tile[index28 - 1, index29].type == (ushort) 0 && Main.tile[index28 + 1, index29].active() && Main.tile[index28 + 1, index29].type == (ushort) 0 && Main.tile[index28, index29 - 1].active() && Main.tile[index28, index29 - 1].type == (ushort) 0 && Main.tile[index28, index29 + 1].active() && Main.tile[index28, index29 + 1].type == (ushort) 0)
          {
            Main.tile[index28, index29].active(true);
            Main.tile[index28, index29].type = (ushort) 2;
          }
          int index30 = WorldGen.genRand.Next(1, Main.maxTilesX - 1);
          int index31 = WorldGen.genRand.Next(0, (int) GenVars.worldSurfaceLow);
          if (index31 >= Main.maxTilesY)
            index31 = Main.maxTilesY - 2;
          if (Main.tile[index30 - 1, index31].active() && Main.tile[index30 - 1, index31].type == (ushort) 0 && Main.tile[index30 + 1, index31].active() && Main.tile[index30 + 1, index31].type == (ushort) 0 && Main.tile[index30, index31 - 1].active() && Main.tile[index30, index31 - 1].type == (ushort) 0 && Main.tile[index30, index31 + 1].active() && Main.tile[index30, index31 + 1].type == (ushort) 0)
          {
            Main.tile[index30, index31].active(true);
            Main.tile[index30, index31].type = (ushort) 2;
          }
        }
      }));
      WorldGen.AddGenerationPass((GenPass) new JunglePass());
      WorldGen.AddGenerationPass("Mud Caves To Grass", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[77].Value;
        WorldGen.NotTheBees();
        for (int i = 0; i < Main.maxTilesX; ++i)
        {
          for (int j = 0; j < Main.maxTilesY; ++j)
          {
            if (Main.tile[i, j].active())
            {
              WorldGen.grassSpread = 0;
              WorldGen.SpreadGrass(i, j, 59, 60);
            }
            progress.Set(0.2 * ((double) (i * Main.maxTilesY + j) / (double) (Main.maxTilesX * Main.maxTilesY)));
          }
        }
        WorldGen.SmallConsecutivesFound = 0;
        WorldGen.SmallConsecutivesEliminated = 0;
        double num58 = (double) (Main.maxTilesX - 20);
        for (int x = 10; x < Main.maxTilesX - 10; ++x)
        {
          WorldGen.ScanTileColumnAndRemoveClumps(x);
          double num59 = (double) (x - 10) / num58;
          progress.Set(0.2 + num59 * 0.8);
        }
      }));
      WorldGen.AddGenerationPass("Full Desert", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[78].Value;
        Main.tileSolid[484] = false;
        int num60 = 0;
        int dungeonSide = GenVars.dungeonSide;
        int maxValue = Main.maxTilesX / 2;
        int num61 = WorldGen.genRand.Next(maxValue) / 8 + maxValue / 8;
        int x = maxValue + num61 * -dungeonSide;
        int num62 = 0;
        DesertBiome biome = GenVars.configuration.CreateBiome<DesertBiome>();
        while (!biome.Place(new Point(x, (int) GenVars.worldSurfaceHigh + 25), GenVars.structures))
        {
          int num63 = WorldGen.genRand.Next(maxValue) / 2 + maxValue / 8 + WorldGen.genRand.Next(num62 / 12);
          x = maxValue + num63 * -dungeonSide;
          if (++num62 > Main.maxTilesX / 4)
          {
            dungeonSide *= -1;
            num62 = 0;
            ++num60;
            if (num60 >= 2)
              GenVars.skipDesertTileCheck = true;
          }
        }
        if (!WorldGen.remixWorldGen)
          return;
        for (int i = 50; i < Main.maxTilesX - 50; ++i)
        {
          for (int index32 = (int) Main.rockLayer + WorldGen.genRand.Next(-1, 2); index32 < Main.maxTilesY - 50; ++index32)
          {
            if ((Main.tile[i, index32].type == (ushort) 396 || Main.tile[i, index32].type == (ushort) 397 || Main.tile[i, index32].type == (ushort) 53) && !WorldGen.SolidTile(i, index32 - 1))
            {
              for (int index33 = index32; index33 < index32 + WorldGen.genRand.Next(4, 7) && Main.tile[i, index33 + 1].active() && (Main.tile[i, index33].type == (ushort) 396 || Main.tile[i, index33].type == (ushort) 397); ++index33)
                Main.tile[i, index33].type = (ushort) 53;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Floating Islands", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        GenVars.numIslandHouses = 0;
        GenVars.skyIslandHouseCount = 0;
        progress.Message = Lang.gen[12].Value;
        int num64 = (int) ((double) Main.maxTilesX * 0.0008);
        int num65 = 0;
        double num66 = (double) (num64 + GenVars.skyLakes);
        for (int index34 = 0; (double) index34 < num66; ++index34)
        {
          progress.Set((double) index34 / num66);
          int num67 = Main.maxTilesX;
          while (--num67 > 0)
          {
            bool flag7 = true;
            int i = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.1), (int) ((double) Main.maxTilesX * 0.9));
            while (i > Main.maxTilesX / 2 - 150 && i < Main.maxTilesX / 2 + 150)
              i = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.1), (int) ((double) Main.maxTilesX * 0.9));
            for (int index35 = 0; index35 < GenVars.numIslandHouses; ++index35)
            {
              if (i > GenVars.floatingIslandHouseX[index35] - 180 && i < GenVars.floatingIslandHouseX[index35] + 180)
              {
                flag7 = false;
                break;
              }
            }
            if (flag7)
            {
              bool flag8 = false;
              int num68 = 0;
              for (int index36 = 200; (double) index36 < Main.worldSurface; ++index36)
              {
                if (Main.tile[i, index36].active())
                {
                  num68 = index36;
                  flag8 = true;
                  break;
                }
              }
              if (flag8)
              {
                int num69 = 0;
                num67 = -1;
                int j = Math.Min(WorldGen.genRand.Next(90, num68 - 100), (int) GenVars.worldSurfaceLow - 50);
                if (num65 >= num64)
                {
                  GenVars.skyLake[GenVars.numIslandHouses] = true;
                  WorldGen.CloudLake(i, j);
                }
                else
                {
                  GenVars.skyLake[GenVars.numIslandHouses] = false;
                  if (WorldGen.drunkWorldGen && !WorldGen.remixWorldGen)
                  {
                    if (WorldGen.genRand.Next(2) == 0)
                    {
                      num69 = 3;
                      WorldGen.SnowCloudIsland(i, j);
                    }
                    else
                    {
                      num69 = 1;
                      WorldGen.DesertCloudIsland(i, j);
                    }
                  }
                  else
                  {
                    if (WorldGen.remixWorldGen && WorldGen.drunkWorldGen)
                      num69 = !GenVars.crimsonLeft || i >= Main.maxTilesX / 2 ? (GenVars.crimsonLeft || i <= Main.maxTilesX / 2 ? 4 : 5) : 5;
                    else if (WorldGen.getGoodWorldGen || WorldGen.remixWorldGen)
                      num69 = !WorldGen.crimson ? 4 : 5;
                    else if (Main.tenthAnniversaryWorld)
                      num69 = 6;
                    WorldGen.CloudIsland(i, j);
                  }
                }
                GenVars.floatingIslandHouseX[GenVars.numIslandHouses] = i;
                GenVars.floatingIslandHouseY[GenVars.numIslandHouses] = j;
                GenVars.floatingIslandStyle[GenVars.numIslandHouses] = num69;
                ++GenVars.numIslandHouses;
                ++num65;
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Mushroom Patches", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[13].Value;
        if (WorldGen.remixWorldGen)
        {
          for (int index37 = 10; index37 < Main.maxTilesX - 10; ++index37)
          {
            for (int index38 = Main.maxTilesY + WorldGen.genRand.Next(3) - 350; index38 < Main.maxTilesY - 10; ++index38)
            {
              if (Main.tile[index37, index38].type == (ushort) 0)
                Main.tile[index37, index38].type = (ushort) 59;
            }
          }
        }
        double num70 = (double) Main.maxTilesX / 700.0;
        if (num70 > (double) GenVars.maxMushroomBiomes)
          num70 = (double) GenVars.maxMushroomBiomes;
        for (int index39 = 0; (double) index39 < num70; ++index39)
        {
          int num71 = 0;
          bool flag = true;
          while (flag)
          {
            int i = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.2), (int) ((double) Main.maxTilesX * 0.8));
            if (num71 > Main.maxTilesX / 4)
              i = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.25), (int) ((double) Main.maxTilesX * 0.975));
            int j = !WorldGen.remixWorldGen ? WorldGen.genRand.Next((int) Main.rockLayer + 50, Main.maxTilesY - 300) : WorldGen.genRand.Next((int) Main.worldSurface + 50, (int) Main.rockLayer - 50);
            flag = false;
            int num72 = 100;
            int num73 = 500;
            for (int x = i - num72; x < i + num72; x += 3)
            {
              for (int y = j - num72; y < j + num72; y += 3)
              {
                if (WorldGen.InWorld(x, y))
                {
                  if (Main.tile[x, y].type == (ushort) 147 || Main.tile[x, y].type == (ushort) 161 || Main.tile[x, y].type == (ushort) 162 || Main.tile[x, y].type == (ushort) 60 || Main.tile[x, y].type == (ushort) 368 || Main.tile[x, y].type == (ushort) 367)
                  {
                    flag = true;
                    break;
                  }
                  if (GenVars.UndergroundDesertLocation.Contains(new Point(x, y)))
                  {
                    flag = true;
                    break;
                  }
                }
                else
                  flag = true;
              }
            }
            if (!flag)
            {
              for (int index40 = 0; index40 < GenVars.numMushroomBiomes; ++index40)
              {
                if (Vector2D.Distance(GenVars.mushroomBiomesPosition[index40].ToVector2D(), new Vector2D((double) i, (double) j)) < (double) num73)
                  flag = true;
              }
            }
            if (!flag && GenVars.numMushroomBiomes < GenVars.maxMushroomBiomes)
            {
              WorldGen.ShroomPatch(i, j);
              for (int index41 = 0; index41 < 5; ++index41)
                WorldGen.ShroomPatch(i + WorldGen.genRand.Next(-40, 41), j + WorldGen.genRand.Next(-40, 41));
              GenVars.mushroomBiomesPosition[GenVars.numMushroomBiomes].X = i;
              GenVars.mushroomBiomesPosition[GenVars.numMushroomBiomes].Y = j;
              ++GenVars.numMushroomBiomes;
            }
            ++num71;
            if (num71 > Main.maxTilesX / 2)
              break;
          }
        }
        for (int index = 0; index < Main.maxTilesX; ++index)
        {
          progress.Set((double) index / (double) Main.maxTilesX);
          for (int worldSurface = (int) Main.worldSurface; worldSurface < Main.maxTilesY; ++worldSurface)
          {
            if (WorldGen.InWorld(index, worldSurface, 50) && Main.tile[index, worldSurface].active())
            {
              WorldGen.grassSpread = 0;
              WorldGen.SpreadGrass(index, worldSurface, 59, 70, false);
            }
          }
        }
        for (int index = 0; index < Main.maxTilesX; ++index)
        {
          for (int worldSurface = (int) Main.worldSurface; worldSurface < Main.maxTilesY; ++worldSurface)
          {
            if (Main.tile[index, worldSurface].active() && Main.tile[index, worldSurface].type == (ushort) 70)
            {
              int Type = 59;
              for (int i = index - 1; i <= index + 1; ++i)
              {
                for (int j = worldSurface - 1; j <= worldSurface + 1; ++j)
                {
                  if (Main.tile[i, j].active())
                  {
                    if (!Main.tile[i - 1, j].active() && !Main.tile[i + 1, j].active())
                      WorldGen.KillTile(i, j);
                    else if (!Main.tile[i, j - 1].active() && !Main.tile[i, j + 1].active())
                      WorldGen.KillTile(i, j);
                  }
                  else if (Main.tile[i - 1, j].active() && Main.tile[i + 1, j].active())
                  {
                    WorldGen.PlaceTile(i, j, Type);
                    if (Main.tile[i - 1, worldSurface].type == (ushort) 70)
                      Main.tile[i - 1, worldSurface].type = (ushort) 59;
                    if (Main.tile[i + 1, worldSurface].type == (ushort) 70)
                      Main.tile[i + 1, worldSurface].type = (ushort) 59;
                  }
                  else if (Main.tile[i, j - 1].active() && Main.tile[i, j + 1].active())
                  {
                    WorldGen.PlaceTile(i, j, Type);
                    if (Main.tile[i, worldSurface - 1].type == (ushort) 70)
                      Main.tile[i, worldSurface - 1].type = (ushort) 59;
                    if (Main.tile[i, worldSurface + 1].type == (ushort) 70)
                      Main.tile[i, worldSurface + 1].type = (ushort) 59;
                  }
                }
              }
              if (WorldGen.genRand.Next(4) == 0)
              {
                int x = index + WorldGen.genRand.Next(-20, 21);
                int y = worldSurface + WorldGen.genRand.Next(-20, 21);
                if (WorldGen.InWorld(x, y) && Main.tile[x, y].type == (ushort) 59)
                  Main.tile[x, y].type = (ushort) 70;
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Marble", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[80].Value;
        int num74 = passConfig.Get<WorldGenRange>("Count").GetRandom(WorldGen.genRand);
        double width = (double) (Main.maxTilesX - 160) / (double) num74;
        MarbleBiome biome = GenVars.configuration.CreateBiome<MarbleBiome>();
        int num75 = 0;
        int num76 = 0;
        while (num76 < num74)
        {
          double num77 = (double) num76 / (double) num74;
          progress.Set(num77);
          Point origin = WorldGen.RandomRectanglePoint((int) (num77 * (double) (Main.maxTilesX - 160)) + 80, (int) GenVars.rockLayer + 20, (int) width, Main.maxTilesY - ((int) GenVars.rockLayer + 40) - 200);
          if (WorldGen.remixWorldGen)
            origin = WorldGen.RandomRectanglePoint((int) (num77 * (double) (Main.maxTilesX - 160)) + 80, (int) GenVars.worldSurface + 100, (int) width, (int) GenVars.rockLayer - (int) GenVars.worldSurface - 100);
          while ((double) origin.X > (double) Main.maxTilesX * 0.45 && (double) origin.X < (double) Main.maxTilesX * 0.55)
            origin.X = WorldGen.genRand.Next(WorldGen.beachDistance, Main.maxTilesX - WorldGen.beachDistance);
          ++num75;
          if (biome.Place(origin, GenVars.structures))
          {
            ++num76;
            num75 = 0;
          }
          else if (num75 > Main.maxTilesX * 10)
          {
            num74 = num76;
            ++num76;
            num75 = 0;
          }
        }
      }));
      WorldGen.AddGenerationPass("Granite", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[81].Value;
        int capacity = passConfig.Get<WorldGenRange>("Count").GetRandom(WorldGen.genRand);
        double width = (double) (Main.maxTilesX - 200) / (double) capacity;
        List<Point> pointList = new List<Point>(capacity);
        int num78 = 0;
        int num79 = 0;
        while (num79 < capacity)
        {
          double num80 = (double) num79 / (double) capacity;
          progress.Set(num80);
          Point origin = WorldGen.RandomRectanglePoint((int) (num80 * (double) (Main.maxTilesX - 200)) + 100, (int) GenVars.rockLayer + 20, (int) width, Main.maxTilesY - ((int) GenVars.rockLayer + 40) - 200);
          if (WorldGen.remixWorldGen)
            origin = WorldGen.RandomRectanglePoint((int) (num80 * (double) (Main.maxTilesX - 200)) + 100, (int) GenVars.worldSurface + 100, (int) width, (int) GenVars.rockLayer - (int) GenVars.worldSurface - 100);
          while ((double) origin.X > (double) Main.maxTilesX * 0.45 && (double) origin.X < (double) Main.maxTilesX * 0.55)
            origin.X = WorldGen.genRand.Next(WorldGen.beachDistance, Main.maxTilesX - WorldGen.beachDistance);
          ++num78;
          if (GraniteBiome.CanPlace(origin, GenVars.structures))
          {
            pointList.Add(origin);
            ++num79;
          }
          else if (num78 > Main.maxTilesX * 10)
          {
            capacity = num79;
            ++num79;
            num78 = 0;
          }
        }
        GraniteBiome biome = GenVars.configuration.CreateBiome<GraniteBiome>();
        for (int index = 0; index < capacity; ++index)
          biome.Place(pointList[index], GenVars.structures);
      }));
      WorldGen.AddGenerationPass("Dirt To Mud", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[14].Value;
        double num = (double) (Main.maxTilesX * Main.maxTilesY) * 0.001;
        for (int index = 0; (double) index < num; ++index)
        {
          progress.Set((double) index / num);
          if (WorldGen.remixWorldGen)
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) Main.worldSurface, (int) GenVars.rockLayerLow), (double) WorldGen.genRand.Next(2, 6), WorldGen.genRand.Next(2, 40), 59, ignoreTileType: 53);
          else
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.rockLayerLow, Main.maxTilesY), (double) WorldGen.genRand.Next(2, 6), WorldGen.genRand.Next(2, 40), 59, ignoreTileType: 53);
        }
      }));
      WorldGen.AddGenerationPass("Silt", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[15].Value;
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0001); ++index)
        {
          int i = WorldGen.genRand.Next(0, Main.maxTilesX);
          int j = WorldGen.genRand.Next((int) GenVars.rockLayerHigh, Main.maxTilesY);
          if (WorldGen.remixWorldGen)
            j = WorldGen.genRand.Next((int) Main.worldSurface, (int) Main.rockLayer);
          if (Main.tile[i, j].wall != (ushort) 187 && Main.tile[i, j].wall != (ushort) 216)
            WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(5, 12), WorldGen.genRand.Next(15, 50), 123);
        }
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0005); ++index)
        {
          int i = WorldGen.genRand.Next(0, Main.maxTilesX);
          int j = WorldGen.genRand.Next((int) GenVars.rockLayerHigh, Main.maxTilesY);
          if (WorldGen.remixWorldGen)
            j = WorldGen.genRand.Next((int) Main.worldSurface, (int) Main.rockLayer);
          if (Main.tile[i, j].wall != (ushort) 187 && Main.tile[i, j].wall != (ushort) 216)
            WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(2, 5), WorldGen.genRand.Next(2, 5), 123);
        }
      }));
      WorldGen.AddGenerationPass("Shinies", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[16].Value;
        if (WorldGen.remixWorldGen)
        {
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 6E-05); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.copper = WorldGen.genRand.Next(2) != 0 ? 166 : 7;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.worldSurfaceLow, (int) GenVars.worldSurfaceHigh), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(2, 6), GenVars.copper);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 8E-05); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.copper = WorldGen.genRand.Next(2) != 0 ? 166 : 7;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.worldSurfaceHigh, (int) GenVars.rockLayerHigh), (double) WorldGen.genRand.Next(3, 7), WorldGen.genRand.Next(3, 7), GenVars.copper);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0002); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.copper = WorldGen.genRand.Next(2) != 0 ? 166 : 7;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.rockLayerLow, Main.maxTilesY), (double) WorldGen.genRand.Next(4, 9), WorldGen.genRand.Next(4, 8), GenVars.copper);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 3E-05); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.iron = WorldGen.genRand.Next(2) != 0 ? 167 : 6;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.worldSurfaceLow, (int) GenVars.worldSurfaceHigh), (double) WorldGen.genRand.Next(3, 7), WorldGen.genRand.Next(2, 5), GenVars.iron);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 8E-05); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.iron = WorldGen.genRand.Next(2) != 0 ? 167 : 6;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.worldSurfaceHigh, (int) GenVars.rockLayerHigh), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(3, 6), GenVars.iron);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0002); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.iron = WorldGen.genRand.Next(2) != 0 ? 167 : 6;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.rockLayerLow, Main.maxTilesY), (double) WorldGen.genRand.Next(4, 9), WorldGen.genRand.Next(4, 8), GenVars.iron);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2.6E-05); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.silver = WorldGen.genRand.Next(2) != 0 ? 168 : 9;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) Main.rockLayer - 100, Main.maxTilesY - 250), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(3, 6), GenVars.silver);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.00015); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.silver = WorldGen.genRand.Next(2) != 0 ? 168 : 9;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) Main.worldSurface, (int) Main.rockLayer), (double) WorldGen.genRand.Next(4, 9), WorldGen.genRand.Next(4, 8), GenVars.silver);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.00017); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.silver = WorldGen.genRand.Next(2) != 0 ? 168 : 9;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next(0, (int) GenVars.worldSurfaceLow), (double) WorldGen.genRand.Next(4, 9), WorldGen.genRand.Next(4, 8), GenVars.silver);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.00012); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.gold = WorldGen.genRand.Next(2) != 0 ? 169 : 8;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) Main.worldSurface, (int) Main.rockLayer), (double) WorldGen.genRand.Next(4, 8), WorldGen.genRand.Next(4, 8), GenVars.gold);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.00012); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.gold = WorldGen.genRand.Next(2) != 0 ? 169 : 8;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next(0, (int) GenVars.worldSurfaceLow - 20), (double) WorldGen.genRand.Next(4, 8), WorldGen.genRand.Next(4, 8), GenVars.gold);
          }
          if (WorldGen.drunkWorldGen)
          {
            for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); ++index)
              WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(4, 8), 204);
            for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); ++index)
              WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(4, 8), 22);
          }
          if (WorldGen.crimson)
          {
            for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 4.25E-05); ++index)
              WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) Main.worldSurface, (int) Main.rockLayer), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(4, 8), 204);
          }
          else
          {
            for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 4.25E-05); ++index)
              WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) Main.worldSurface, (int) Main.rockLayer), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(4, 8), 22);
          }
        }
        else
        {
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 6E-05); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.copper = WorldGen.genRand.Next(2) != 0 ? 166 : 7;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.worldSurfaceLow, (int) GenVars.worldSurfaceHigh), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(2, 6), GenVars.copper);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 8E-05); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.copper = WorldGen.genRand.Next(2) != 0 ? 166 : 7;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.worldSurfaceHigh, (int) GenVars.rockLayerHigh), (double) WorldGen.genRand.Next(3, 7), WorldGen.genRand.Next(3, 7), GenVars.copper);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0002); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.copper = WorldGen.genRand.Next(2) != 0 ? 166 : 7;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.rockLayerLow, Main.maxTilesY), (double) WorldGen.genRand.Next(4, 9), WorldGen.genRand.Next(4, 8), GenVars.copper);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 3E-05); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.iron = WorldGen.genRand.Next(2) != 0 ? 167 : 6;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.worldSurfaceLow, (int) GenVars.worldSurfaceHigh), (double) WorldGen.genRand.Next(3, 7), WorldGen.genRand.Next(2, 5), GenVars.iron);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 8E-05); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.iron = WorldGen.genRand.Next(2) != 0 ? 167 : 6;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.worldSurfaceHigh, (int) GenVars.rockLayerHigh), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(3, 6), GenVars.iron);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0002); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.iron = WorldGen.genRand.Next(2) != 0 ? 167 : 6;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.rockLayerLow, Main.maxTilesY), (double) WorldGen.genRand.Next(4, 9), WorldGen.genRand.Next(4, 8), GenVars.iron);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2.6E-05); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.silver = WorldGen.genRand.Next(2) != 0 ? 168 : 9;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.worldSurfaceHigh, (int) GenVars.rockLayerHigh), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(3, 6), GenVars.silver);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.00015); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.silver = WorldGen.genRand.Next(2) != 0 ? 168 : 9;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.rockLayerLow, Main.maxTilesY), (double) WorldGen.genRand.Next(4, 9), WorldGen.genRand.Next(4, 8), GenVars.silver);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.00017); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.silver = WorldGen.genRand.Next(2) != 0 ? 168 : 9;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next(0, (int) GenVars.worldSurfaceLow), (double) WorldGen.genRand.Next(4, 9), WorldGen.genRand.Next(4, 8), GenVars.silver);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.00012); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.gold = WorldGen.genRand.Next(2) != 0 ? 169 : 8;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) GenVars.rockLayerLow, Main.maxTilesY), (double) WorldGen.genRand.Next(4, 8), WorldGen.genRand.Next(4, 8), GenVars.gold);
          }
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.00012); ++index)
          {
            if (WorldGen.drunkWorldGen)
              GenVars.gold = WorldGen.genRand.Next(2) != 0 ? 169 : 8;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next(0, (int) GenVars.worldSurfaceLow - 20), (double) WorldGen.genRand.Next(4, 8), WorldGen.genRand.Next(4, 8), GenVars.gold);
          }
          if (WorldGen.drunkWorldGen)
          {
            for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); ++index)
              WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(4, 8), 204);
            for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); ++index)
              WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(4, 8), 22);
          }
          if (WorldGen.crimson)
          {
            for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2.25E-05); ++index)
              WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(4, 8), 204);
          }
          else
          {
            for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2.25E-05); ++index)
              WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(4, 8), 22);
          }
        }
      }));
      WorldGen.AddGenerationPass("Webs", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[17].Value;
        for (int index42 = 0; index42 < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0006); ++index42)
        {
          int index43 = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
          int index44 = WorldGen.genRand.Next((int) GenVars.worldSurfaceHigh, Main.maxTilesY - 20);
          if (index42 < GenVars.numMCaves)
          {
            index43 = GenVars.mCaveX[index42];
            index44 = GenVars.mCaveY[index42];
          }
          if (!Main.tile[index43, index44].active() && ((double) index44 > Main.worldSurface || Main.tile[index43, index44].wall > (ushort) 0))
          {
            while (!Main.tile[index43, index44].active() && index44 > (int) GenVars.worldSurfaceLow)
              --index44;
            int j = index44 + 1;
            int speedX = 1;
            if (WorldGen.genRand.Next(2) == 0)
              speedX = -1;
            while (!Main.tile[index43, j].active() && index43 > 10 && index43 < Main.maxTilesX - 10)
              index43 += speedX;
            int i = index43 - speedX;
            if ((double) j > Main.worldSurface || Main.tile[i, j].wall > (ushort) 0)
              WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(4, 11), WorldGen.genRand.Next(2, 4), 51, true, (double) speedX, -1.0, overRide: false);
          }
        }
      }));
      WorldGen.AddGenerationPass("Underworld", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[18].Value;
        progress.Set(0.0);
        int num81 = Main.maxTilesY - WorldGen.genRand.Next(150, 190);
        for (int index45 = 0; index45 < Main.maxTilesX; ++index45)
        {
          num81 += WorldGen.genRand.Next(-3, 4);
          if (num81 < Main.maxTilesY - 190)
            num81 = Main.maxTilesY - 190;
          if (num81 > Main.maxTilesY - 160)
            num81 = Main.maxTilesY - 160;
          for (int index46 = num81 - 20 - WorldGen.genRand.Next(3); index46 < Main.maxTilesY; ++index46)
          {
            if (index46 >= num81)
            {
              Main.tile[index45, index46].active(false);
              Main.tile[index45, index46].lava(false);
              Main.tile[index45, index46].liquid = (byte) 0;
            }
            else
              Main.tile[index45, index46].type = (ushort) 57;
          }
        }
        int num82 = Main.maxTilesY - WorldGen.genRand.Next(40, 70);
        for (int index47 = 10; index47 < Main.maxTilesX - 10; ++index47)
        {
          num82 += WorldGen.genRand.Next(-10, 11);
          if (num82 > Main.maxTilesY - 60)
            num82 = Main.maxTilesY - 60;
          if (num82 < Main.maxTilesY - 100)
            num82 = Main.maxTilesY - 120;
          for (int index48 = num82; index48 < Main.maxTilesY - 10; ++index48)
          {
            if (!Main.tile[index47, index48].active())
            {
              Main.tile[index47, index48].lava(true);
              Main.tile[index47, index48].liquid = byte.MaxValue;
            }
          }
        }
        for (int index49 = 0; index49 < Main.maxTilesX; ++index49)
        {
          if (WorldGen.genRand.Next(50) == 0)
          {
            int index50 = Main.maxTilesY - 65;
            while (!Main.tile[index49, index50].active() && index50 > Main.maxTilesY - 135)
              --index50;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), index50 + WorldGen.genRand.Next(20, 50), (double) WorldGen.genRand.Next(15, 20), 1000, 57, true, speedY: ((double) WorldGen.genRand.Next(1, 3)), noYChange: true);
          }
        }
        Liquid.QuickWater(-2);
        for (int i = 0; i < Main.maxTilesX; ++i)
        {
          double num83 = (double) i / (double) (Main.maxTilesX - 1);
          progress.Set(num83 / 2.0 + 0.5);
          if (WorldGen.genRand.Next(13) == 0)
          {
            int index = Main.maxTilesY - 65;
            while ((Main.tile[i, index].liquid > (byte) 0 || Main.tile[i, index].active()) && index > Main.maxTilesY - 140)
              --index;
            if (!WorldGen.drunkWorldGen && !WorldGen.remixWorldGen || WorldGen.genRand.Next(3) == 0 || (double) i <= (double) Main.maxTilesX * 0.4 || (double) i >= (double) Main.maxTilesX * 0.6)
              WorldGen.TileRunner(i, index - WorldGen.genRand.Next(2, 5), (double) WorldGen.genRand.Next(5, 30), 1000, 57, true, speedY: ((double) WorldGen.genRand.Next(1, 3)), noYChange: true);
            double num84 = (double) WorldGen.genRand.Next(1, 3);
            if (WorldGen.genRand.Next(3) == 0)
              num84 *= 0.5;
            if (!WorldGen.drunkWorldGen && !WorldGen.remixWorldGen || WorldGen.genRand.Next(3) == 0 || (double) i <= (double) Main.maxTilesX * 0.4 || (double) i >= (double) Main.maxTilesX * 0.6)
            {
              if (WorldGen.genRand.Next(2) == 0)
                WorldGen.TileRunner(i, index - WorldGen.genRand.Next(2, 5), (double) (int) ((double) WorldGen.genRand.Next(5, 15) * num84), (int) ((double) WorldGen.genRand.Next(10, 15) * num84), 57, true, 1.0, 0.3);
              if (WorldGen.genRand.Next(2) == 0)
              {
                double num85 = (double) WorldGen.genRand.Next(1, 3);
                WorldGen.TileRunner(i, index - WorldGen.genRand.Next(2, 5), (double) (int) ((double) WorldGen.genRand.Next(5, 15) * num85), (int) ((double) WorldGen.genRand.Next(10, 15) * num85), 57, true, -1.0, 0.3);
              }
            }
            WorldGen.TileRunner(i + WorldGen.genRand.Next(-10, 10), index + WorldGen.genRand.Next(-10, 10), (double) WorldGen.genRand.Next(5, 15), WorldGen.genRand.Next(5, 10), -2, speedX: ((double) WorldGen.genRand.Next(-1, 3)), speedY: ((double) WorldGen.genRand.Next(-1, 3)));
            if (WorldGen.genRand.Next(3) == 0)
              WorldGen.TileRunner(i + WorldGen.genRand.Next(-10, 10), index + WorldGen.genRand.Next(-10, 10), (double) WorldGen.genRand.Next(10, 30), WorldGen.genRand.Next(10, 20), -2, speedX: ((double) WorldGen.genRand.Next(-1, 3)), speedY: ((double) WorldGen.genRand.Next(-1, 3)));
            if (WorldGen.genRand.Next(5) == 0)
              WorldGen.TileRunner(i + WorldGen.genRand.Next(-15, 15), index + WorldGen.genRand.Next(-15, 10), (double) WorldGen.genRand.Next(15, 30), WorldGen.genRand.Next(5, 20), -2, speedX: ((double) WorldGen.genRand.Next(-1, 3)), speedY: ((double) WorldGen.genRand.Next(-1, 3)));
          }
        }
        for (int index = 0; index < Main.maxTilesX; ++index)
          WorldGen.TileRunner(WorldGen.genRand.Next(20, Main.maxTilesX - 20), WorldGen.genRand.Next(Main.maxTilesY - 180, Main.maxTilesY - 10), (double) WorldGen.genRand.Next(2, 7), WorldGen.genRand.Next(2, 7), -2);
        if (WorldGen.drunkWorldGen || WorldGen.remixWorldGen)
        {
          for (int index = 0; index < Main.maxTilesX * 2; ++index)
            WorldGen.TileRunner(WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.35), (int) ((double) Main.maxTilesX * 0.65)), WorldGen.genRand.Next(Main.maxTilesY - 180, Main.maxTilesY - 10), (double) WorldGen.genRand.Next(5, 20), WorldGen.genRand.Next(5, 10), -2);
        }
        for (int index = 0; index < Main.maxTilesX; ++index)
        {
          if (!Main.tile[index, Main.maxTilesY - 145].active())
          {
            Main.tile[index, Main.maxTilesY - 145].liquid = byte.MaxValue;
            Main.tile[index, Main.maxTilesY - 145].lava(true);
          }
          if (!Main.tile[index, Main.maxTilesY - 144].active())
          {
            Main.tile[index, Main.maxTilesY - 144].liquid = byte.MaxValue;
            Main.tile[index, Main.maxTilesY - 144].lava(true);
          }
        }
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0008); ++index)
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next(Main.maxTilesY - 140, Main.maxTilesY), (double) WorldGen.genRand.Next(2, 7), WorldGen.genRand.Next(3, 7), 58);
        if (WorldGen.remixWorldGen)
        {
          int num86 = (int) ((double) Main.maxTilesX * 0.38);
          int num87 = (int) ((double) Main.maxTilesX * 0.62);
          int index51 = num86;
          int num88 = Main.maxTilesY - 1;
          int num89 = Main.maxTilesY - 135;
          int num90 = Main.maxTilesY - 160;
          bool flag = false;
          Liquid.QuickWater(-2);
          for (; num88 < Main.maxTilesY - 1 || index51 < num87; ++index51)
          {
            if (!flag)
            {
              num88 -= WorldGen.genRand.Next(1, 4);
              if (num88 < num89)
                flag = true;
            }
            else if (index51 >= num87)
            {
              num88 += WorldGen.genRand.Next(1, 4);
              if (num88 > Main.maxTilesY - 1)
                num88 = Main.maxTilesY - 1;
            }
            else
            {
              if ((index51 <= Main.maxTilesX / 2 - 5 || index51 >= Main.maxTilesX / 2 + 5) && WorldGen.genRand.Next(4) == 0)
              {
                if (WorldGen.genRand.Next(3) == 0)
                  num88 += WorldGen.genRand.Next(-1, 2);
                else if (WorldGen.genRand.Next(6) == 0)
                  num88 += WorldGen.genRand.Next(-2, 3);
                else if (WorldGen.genRand.Next(8) == 0)
                  num88 += WorldGen.genRand.Next(-4, 5);
              }
              if (num88 < num90)
                num88 = num90;
              if (num88 > num89)
                num88 = num89;
            }
            for (int index52 = num88; index52 > num88 - 20; --index52)
              Main.tile[index51, index52].liquid = (byte) 0;
            for (int index53 = num88; index53 < Main.maxTilesY; ++index53)
            {
              Main.tile[index51, index53] = new Tile();
              Main.tile[index51, index53].active(true);
              Main.tile[index51, index53].type = (ushort) 57;
            }
          }
          Liquid.QuickWater(-2);
          for (int index54 = num86; index54 < num87 + 15; ++index54)
          {
            for (int index55 = Main.maxTilesY - 300; index55 < num89 + 20; ++index55)
            {
              Main.tile[index54, index55].liquid = (byte) 0;
              if (Main.tile[index54, index55].type == (ushort) 57 && Main.tile[index54, index55].active() && (!Main.tile[index54 - 1, index55 - 1].active() || !Main.tile[index54, index55 - 1].active() || !Main.tile[index54 + 1, index55 - 1].active() || !Main.tile[index54 - 1, index55].active() || !Main.tile[index54 + 1, index55].active() || !Main.tile[index54 - 1, index55 + 1].active() || !Main.tile[index54, index55 + 1].active() || !Main.tile[index54 + 1, index55 + 1].active()))
                Main.tile[index54, index55].type = (ushort) 633;
            }
          }
          for (int checkedX = num86; checkedX < num87 + 15; ++checkedX)
          {
            for (int checkedY = Main.maxTilesY - 200; checkedY < num89 + 20; ++checkedY)
            {
              if (Main.tile[checkedX, checkedY].type == (ushort) 633 && Main.tile[checkedX, checkedY].active() && !Main.tile[checkedX, checkedY - 1].active() && WorldGen.genRand.Next(3) == 0)
                WorldGen.TryGrowingTreeByType(634, checkedX, checkedY);
            }
          }
        }
        else if (!WorldGen.drunkWorldGen)
        {
          for (int index56 = 25; index56 < Main.maxTilesX - 25; ++index56)
          {
            if ((double) index56 < (double) Main.maxTilesX * 0.17 || (double) index56 > (double) Main.maxTilesX * 0.83)
            {
              for (int index57 = Main.maxTilesY - 300; index57 < Main.maxTilesY - 100 + WorldGen.genRand.Next(-1, 2); ++index57)
              {
                if (Main.tile[index56, index57].type == (ushort) 57 && Main.tile[index56, index57].active() && (!Main.tile[index56 - 1, index57 - 1].active() || !Main.tile[index56, index57 - 1].active() || !Main.tile[index56 + 1, index57 - 1].active() || !Main.tile[index56 - 1, index57].active() || !Main.tile[index56 + 1, index57].active() || !Main.tile[index56 - 1, index57 + 1].active() || !Main.tile[index56, index57 + 1].active() || !Main.tile[index56 + 1, index57 + 1].active()))
                  Main.tile[index56, index57].type = (ushort) 633;
              }
            }
          }
          for (int checkedX = 25; checkedX < Main.maxTilesX - 25; ++checkedX)
          {
            if ((double) checkedX < (double) Main.maxTilesX * 0.17 || (double) checkedX > (double) Main.maxTilesX * 0.83)
            {
              for (int checkedY = Main.maxTilesY - 200; checkedY < Main.maxTilesY - 50; ++checkedY)
              {
                if (Main.tile[checkedX, checkedY].type == (ushort) 633 && Main.tile[checkedX, checkedY].active() && !Main.tile[checkedX, checkedY - 1].active() && WorldGen.genRand.Next(3) == 0)
                  WorldGen.TryGrowingTreeByType(634, checkedX, checkedY);
              }
            }
          }
        }
        WorldGen.AddHellHouses();
        if (!WorldGen.drunkWorldGen)
          return;
        for (int index58 = 25; index58 < Main.maxTilesX - 25; ++index58)
        {
          for (int index59 = Main.maxTilesY - 300; index59 < Main.maxTilesY - 100 + WorldGen.genRand.Next(-1, 2); ++index59)
          {
            if (Main.tile[index58, index59].type == (ushort) 57 && Main.tile[index58, index59].active() && (!Main.tile[index58 - 1, index59 - 1].active() || !Main.tile[index58, index59 - 1].active() || !Main.tile[index58 + 1, index59 - 1].active() || !Main.tile[index58 - 1, index59].active() || !Main.tile[index58 + 1, index59].active() || !Main.tile[index58 - 1, index59 + 1].active() || !Main.tile[index58, index59 + 1].active() || !Main.tile[index58 + 1, index59 + 1].active()))
              Main.tile[index58, index59].type = (ushort) 633;
          }
        }
        for (int checkedX = 25; checkedX < Main.maxTilesX - 25; ++checkedX)
        {
          for (int checkedY = Main.maxTilesY - 200; checkedY < Main.maxTilesY - 50; ++checkedY)
          {
            if (Main.tile[checkedX, checkedY].type == (ushort) 633 && Main.tile[checkedX, checkedY].active() && !Main.tile[checkedX, checkedY - 1].active() && WorldGen.genRand.Next(3) == 0)
              WorldGen.TryGrowingTreeByType(634, checkedX, checkedY);
          }
        }
      }));
      WorldGen.AddGenerationPass("Corruption", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        int num91 = Main.maxTilesX;
        int num92 = 0;
        int num93 = Main.maxTilesX;
        int num94 = 0;
        for (int index60 = 0; index60 < Main.maxTilesX; ++index60)
        {
          for (int index61 = 0; (double) index61 < Main.worldSurface; ++index61)
          {
            if (Main.tile[index60, index61].active())
            {
              if (Main.tile[index60, index61].type == (ushort) 60)
              {
                if (index60 < num91)
                  num91 = index60;
                if (index60 > num92)
                  num92 = index60;
              }
              else if (Main.tile[index60, index61].type == (ushort) 147 || Main.tile[index60, index61].type == (ushort) 161)
              {
                if (index60 < num93)
                  num93 = index60;
                if (index60 > num94)
                  num94 = index60;
              }
            }
          }
        }
        int num95 = 10;
        int num96 = num91 - num95;
        int num97 = num92 + num95;
        int num98 = num93 - num95;
        int num99 = num94 + num95;
        int minValue = 500;
        int num100 = 100;
        bool flag9 = WorldGen.crimson;
        double num101 = (double) Main.maxTilesX * 0.00045;
        if (WorldGen.remixWorldGen)
          num101 *= 2.0;
        else if (WorldGen.tenthAnniversaryWorldGen)
        {
          minValue *= 2;
          num100 *= 2;
        }
        if (WorldGen.drunkWorldGen)
        {
          flag9 = true;
          num101 /= 2.0;
        }
        if (flag9)
        {
          progress.Message = Lang.gen[72].Value;
          for (int index62 = 0; (double) index62 < num101; ++index62)
          {
            int num102 = num98;
            int num103 = num99;
            int num104 = num96;
            int num105 = num97;
            double num106 = (double) index62 / num101;
            progress.Set(num106);
            bool flag10 = false;
            int i3 = 0;
            int num107 = 0;
            int num108 = 0;
            while (!flag10)
            {
              flag10 = true;
              int num109 = Main.maxTilesX / 2;
              int num110 = 200;
              if (WorldGen.drunkWorldGen)
              {
                num110 = 100;
                i3 = !GenVars.crimsonLeft ? WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.5), Main.maxTilesX - minValue) : WorldGen.genRand.Next(minValue, (int) ((double) Main.maxTilesX * 0.5));
              }
              else
                i3 = WorldGen.genRand.Next(minValue, Main.maxTilesX - minValue);
              num107 = i3 - WorldGen.genRand.Next(200) - 100;
              num108 = i3 + WorldGen.genRand.Next(200) + 100;
              if (num107 < GenVars.evilBiomeBeachAvoidance)
                num107 = GenVars.evilBiomeBeachAvoidance;
              if (num108 > Main.maxTilesX - GenVars.evilBiomeBeachAvoidance)
                num108 = Main.maxTilesX - GenVars.evilBiomeBeachAvoidance;
              if (i3 < num107 + GenVars.evilBiomeAvoidanceMidFixer)
                i3 = num107 + GenVars.evilBiomeAvoidanceMidFixer;
              if (i3 > num108 - GenVars.evilBiomeAvoidanceMidFixer)
                i3 = num108 - GenVars.evilBiomeAvoidanceMidFixer;
              if (GenVars.dungeonSide < 0 && num107 < 400)
                num107 = 400;
              else if (GenVars.dungeonSide > 0 && num107 > Main.maxTilesX - 400)
                num107 = Main.maxTilesX - 400;
              if (num107 < GenVars.dungeonLocation + num100 && num108 > GenVars.dungeonLocation - num100)
                flag10 = false;
              if (!WorldGen.remixWorldGen)
              {
                if (!WorldGen.tenthAnniversaryWorldGen)
                {
                  if (i3 > num109 - num110 && i3 < num109 + num110)
                    flag10 = false;
                  if (num107 > num109 - num110 && num107 < num109 + num110)
                    flag10 = false;
                  if (num108 > num109 - num110 && num108 < num109 + num110)
                    flag10 = false;
                }
                if (i3 > GenVars.UndergroundDesertLocation.X && i3 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
                  flag10 = false;
                if (num107 > GenVars.UndergroundDesertLocation.X && num107 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
                  flag10 = false;
                if (num108 > GenVars.UndergroundDesertLocation.X && num108 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
                  flag10 = false;
                if (num107 < num103 && num108 > num102)
                {
                  ++num102;
                  --num103;
                  flag10 = false;
                }
                if (num107 < num105 && num108 > num104)
                {
                  ++num104;
                  --num105;
                  flag10 = false;
                }
              }
            }
            WorldGen.CrimStart(i3, (int) GenVars.worldSurfaceLow - 10);
            for (int index63 = num107; index63 < num108; ++index63)
            {
              for (int worldSurfaceLow = (int) GenVars.worldSurfaceLow; (double) worldSurfaceLow < Main.worldSurface - 1.0; ++worldSurfaceLow)
              {
                if (Main.tile[index63, worldSurfaceLow].active())
                {
                  int num111 = worldSurfaceLow + WorldGen.genRand.Next(10, 14);
                  for (int index64 = worldSurfaceLow; index64 < num111; ++index64)
                  {
                    if (Main.tile[index63, index64].type == (ushort) 60 && index63 >= num107 + WorldGen.genRand.Next(5) && index63 < num108 - WorldGen.genRand.Next(5))
                      Main.tile[index63, index64].type = (ushort) 662;
                  }
                  break;
                }
              }
            }
            double num112 = Main.worldSurface + 40.0;
            for (int i4 = num107; i4 < num108; ++i4)
            {
              num112 += (double) WorldGen.genRand.Next(-2, 3);
              if (num112 < Main.worldSurface + 30.0)
                num112 = Main.worldSurface + 30.0;
              if (num112 > Main.worldSurface + 50.0)
                num112 = Main.worldSurface + 50.0;
              bool flag11 = false;
              for (int worldSurfaceLow = (int) GenVars.worldSurfaceLow; (double) worldSurfaceLow < num112; ++worldSurfaceLow)
              {
                if (Main.tile[i4, worldSurfaceLow].active())
                {
                  if (Main.tile[i4, worldSurfaceLow].type == (ushort) 53 && i4 >= num107 + WorldGen.genRand.Next(5) && i4 <= num108 - WorldGen.genRand.Next(5))
                    Main.tile[i4, worldSurfaceLow].type = (ushort) 234;
                  if ((double) worldSurfaceLow < Main.worldSurface - 1.0 && !flag11)
                  {
                    if (Main.tile[i4, worldSurfaceLow].type == (ushort) 0)
                    {
                      WorldGen.grassSpread = 0;
                      WorldGen.SpreadGrass(i4, worldSurfaceLow, grass: 199);
                    }
                    else if (Main.tile[i4, worldSurfaceLow].type == (ushort) 59)
                    {
                      WorldGen.grassSpread = 0;
                      WorldGen.SpreadGrass(i4, worldSurfaceLow, 59, 662);
                    }
                  }
                  flag11 = true;
                  if (Main.tile[i4, worldSurfaceLow].wall == (ushort) 216)
                    Main.tile[i4, worldSurfaceLow].wall = (ushort) 218;
                  else if (Main.tile[i4, worldSurfaceLow].wall == (ushort) 187)
                    Main.tile[i4, worldSurfaceLow].wall = (ushort) 221;
                  if (Main.tile[i4, worldSurfaceLow].type == (ushort) 1)
                  {
                    if (i4 >= num107 + WorldGen.genRand.Next(5) && i4 <= num108 - WorldGen.genRand.Next(5))
                      Main.tile[i4, worldSurfaceLow].type = (ushort) 203;
                  }
                  else if (Main.tile[i4, worldSurfaceLow].type == (ushort) 2)
                    Main.tile[i4, worldSurfaceLow].type = (ushort) 199;
                  else if (Main.tile[i4, worldSurfaceLow].type == (ushort) 60)
                    Main.tile[i4, worldSurfaceLow].type = (ushort) 662;
                  else if (Main.tile[i4, worldSurfaceLow].type == (ushort) 161)
                    Main.tile[i4, worldSurfaceLow].type = (ushort) 200;
                  else if (Main.tile[i4, worldSurfaceLow].type == (ushort) 396)
                    Main.tile[i4, worldSurfaceLow].type = (ushort) 401;
                  else if (Main.tile[i4, worldSurfaceLow].type == (ushort) 397)
                    Main.tile[i4, worldSurfaceLow].type = (ushort) 399;
                }
              }
            }
            int num113 = WorldGen.genRand.Next(10, 15);
            for (int index65 = 0; index65 < num113; ++index65)
            {
              int num114 = 0;
              bool flag12 = false;
              int num115 = 0;
              while (!flag12)
              {
                ++num114;
                int x = WorldGen.genRand.Next(num107 - num115, num108 + num115);
                int y;
                for (y = WorldGen.genRand.Next((int) (Main.worldSurface - (double) (num115 / 2)), (int) (Main.worldSurface + 100.0 + (double) num115)); WorldGen.oceanDepths(x, y); y = WorldGen.genRand.Next((int) (Main.worldSurface - (double) (num115 / 2)), (int) (Main.worldSurface + 100.0 + (double) num115)))
                  x = WorldGen.genRand.Next(num107 - num115, num108 + num115);
                if (num114 > 100)
                {
                  ++num115;
                  num114 = 0;
                }
                if (!Main.tile[x, y].active())
                {
                  while (!Main.tile[x, y].active())
                    ++y;
                  --y;
                }
                else
                {
                  while (Main.tile[x, y].active() && (double) y > Main.worldSurface)
                    --y;
                }
                if ((num115 > 10 || Main.tile[x, y + 1].active() && Main.tile[x, y + 1].type == (ushort) 203) && !WorldGen.IsTileNearby(x, y, 26, 3))
                {
                  WorldGen.Place3x2(x, y, (ushort) 26, 1);
                  if (Main.tile[x, y].type == (ushort) 26)
                    flag12 = true;
                }
                if (num115 > 100)
                  flag12 = true;
              }
            }
          }
          WorldGen.CrimPlaceHearts();
        }
        if (WorldGen.drunkWorldGen)
          flag9 = false;
        if (flag9)
          return;
        progress.Message = Lang.gen[20].Value;
        for (int index66 = 0; (double) index66 < num101; ++index66)
        {
          int num116 = num98;
          int num117 = num99;
          int num118 = num96;
          int num119 = num97;
          double num120 = (double) index66 / num101;
          progress.Set(num120);
          bool flag13 = false;
          int num121 = 0;
          int num122 = 0;
          int num123 = 0;
          while (!flag13)
          {
            flag13 = true;
            int num124 = Main.maxTilesX / 2;
            int num125 = 200;
            num121 = !WorldGen.drunkWorldGen ? WorldGen.genRand.Next(minValue, Main.maxTilesX - minValue) : (GenVars.crimsonLeft ? WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.5), Main.maxTilesX - minValue) : WorldGen.genRand.Next(minValue, (int) ((double) Main.maxTilesX * 0.5)));
            num122 = num121 - WorldGen.genRand.Next(200) - 100;
            num123 = num121 + WorldGen.genRand.Next(200) + 100;
            if (num122 < GenVars.evilBiomeBeachAvoidance)
              num122 = GenVars.evilBiomeBeachAvoidance;
            if (num123 > Main.maxTilesX - GenVars.evilBiomeBeachAvoidance)
              num123 = Main.maxTilesX - GenVars.evilBiomeBeachAvoidance;
            if (num121 < num122 + GenVars.evilBiomeAvoidanceMidFixer)
              num121 = num122 + GenVars.evilBiomeAvoidanceMidFixer;
            if (num121 > num123 - GenVars.evilBiomeAvoidanceMidFixer)
              num121 = num123 - GenVars.evilBiomeAvoidanceMidFixer;
            if (num122 < GenVars.dungeonLocation + num100 && num123 > GenVars.dungeonLocation - num100)
              flag13 = false;
            if (!WorldGen.remixWorldGen)
            {
              if (!WorldGen.tenthAnniversaryWorldGen)
              {
                if (num121 > num124 - num125 && num121 < num124 + num125)
                  flag13 = false;
                if (num122 > num124 - num125 && num122 < num124 + num125)
                  flag13 = false;
                if (num123 > num124 - num125 && num123 < num124 + num125)
                  flag13 = false;
              }
              if (num121 > GenVars.UndergroundDesertLocation.X && num121 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
                flag13 = false;
              if (num122 > GenVars.UndergroundDesertLocation.X && num122 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
                flag13 = false;
              if (num123 > GenVars.UndergroundDesertLocation.X && num123 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
                flag13 = false;
              if (num122 < num117 && num123 > num116)
              {
                ++num116;
                --num117;
                flag13 = false;
              }
              if (num122 < num119 && num123 > num118)
              {
                ++num118;
                --num119;
                flag13 = false;
              }
            }
          }
          int num126 = 0;
          for (int i = num122; i < num123; ++i)
          {
            if (num126 > 0)
              --num126;
            if (i == num121 || num126 == 0)
            {
              for (int worldSurfaceLow = (int) GenVars.worldSurfaceLow; (double) worldSurfaceLow < Main.worldSurface - 1.0; ++worldSurfaceLow)
              {
                if (Main.tile[i, worldSurfaceLow].active() || Main.tile[i, worldSurfaceLow].wall > (ushort) 0)
                {
                  if (i == num121)
                  {
                    num126 = 20;
                    WorldGen.ChasmRunner(i, worldSurfaceLow, WorldGen.genRand.Next(150) + 150, true);
                    break;
                  }
                  if (WorldGen.genRand.Next(35) == 0 && num126 == 0)
                  {
                    num126 = 30;
                    bool makeOrb = true;
                    WorldGen.ChasmRunner(i, worldSurfaceLow, WorldGen.genRand.Next(50) + 50, makeOrb);
                    break;
                  }
                  break;
                }
              }
            }
            for (int worldSurfaceLow = (int) GenVars.worldSurfaceLow; (double) worldSurfaceLow < Main.worldSurface - 1.0; ++worldSurfaceLow)
            {
              if (Main.tile[i, worldSurfaceLow].active())
              {
                int num127 = worldSurfaceLow + WorldGen.genRand.Next(10, 14);
                for (int index67 = worldSurfaceLow; index67 < num127; ++index67)
                {
                  if (Main.tile[i, index67].type == (ushort) 60 && i >= num122 + WorldGen.genRand.Next(5) && i < num123 - WorldGen.genRand.Next(5))
                    Main.tile[i, index67].type = (ushort) 661;
                }
                break;
              }
            }
          }
          double num128 = Main.worldSurface + 40.0;
          for (int i = num122; i < num123; ++i)
          {
            num128 += (double) WorldGen.genRand.Next(-2, 3);
            if (num128 < Main.worldSurface + 30.0)
              num128 = Main.worldSurface + 30.0;
            if (num128 > Main.worldSurface + 50.0)
              num128 = Main.worldSurface + 50.0;
            bool flag14 = false;
            for (int worldSurfaceLow = (int) GenVars.worldSurfaceLow; (double) worldSurfaceLow < num128; ++worldSurfaceLow)
            {
              if (Main.tile[i, worldSurfaceLow].active())
              {
                if (Main.tile[i, worldSurfaceLow].type == (ushort) 53 && i >= num122 + WorldGen.genRand.Next(5) && i <= num123 - WorldGen.genRand.Next(5))
                  Main.tile[i, worldSurfaceLow].type = (ushort) 112;
                if ((double) worldSurfaceLow < Main.worldSurface - 1.0 && !flag14)
                {
                  if (Main.tile[i, worldSurfaceLow].type == (ushort) 0)
                  {
                    WorldGen.grassSpread = 0;
                    WorldGen.SpreadGrass(i, worldSurfaceLow, grass: 23);
                  }
                  else if (Main.tile[i, worldSurfaceLow].type == (ushort) 59)
                  {
                    WorldGen.grassSpread = 0;
                    WorldGen.SpreadGrass(i, worldSurfaceLow, 59, 661);
                  }
                }
                flag14 = true;
                if (Main.tile[i, worldSurfaceLow].wall == (ushort) 216)
                  Main.tile[i, worldSurfaceLow].wall = (ushort) 217;
                else if (Main.tile[i, worldSurfaceLow].wall == (ushort) 187)
                  Main.tile[i, worldSurfaceLow].wall = (ushort) 220;
                if (Main.tile[i, worldSurfaceLow].type == (ushort) 1)
                {
                  if (i >= num122 + WorldGen.genRand.Next(5) && i <= num123 - WorldGen.genRand.Next(5))
                    Main.tile[i, worldSurfaceLow].type = (ushort) 25;
                }
                else if (Main.tile[i, worldSurfaceLow].type == (ushort) 2)
                  Main.tile[i, worldSurfaceLow].type = (ushort) 23;
                else if (Main.tile[i, worldSurfaceLow].type == (ushort) 60)
                  Main.tile[i, worldSurfaceLow].type = (ushort) 661;
                else if (Main.tile[i, worldSurfaceLow].type == (ushort) 161)
                  Main.tile[i, worldSurfaceLow].type = (ushort) 163;
                else if (Main.tile[i, worldSurfaceLow].type == (ushort) 396)
                  Main.tile[i, worldSurfaceLow].type = (ushort) 400;
                else if (Main.tile[i, worldSurfaceLow].type == (ushort) 397)
                  Main.tile[i, worldSurfaceLow].type = (ushort) 398;
              }
            }
          }
          for (int index68 = num122; index68 < num123; ++index68)
          {
            for (int index69 = 0; index69 < Main.maxTilesY - 50; ++index69)
            {
              if (Main.tile[index68, index69].active() && Main.tile[index68, index69].type == (ushort) 31)
              {
                int num129 = index68 - 13;
                int num130 = index68 + 13;
                int num131 = index69 - 13;
                int num132 = index69 + 13;
                for (int index70 = num129; index70 < num130; ++index70)
                {
                  if (index70 > 10 && index70 < Main.maxTilesX - 10)
                  {
                    for (int index71 = num131; index71 < num132; ++index71)
                    {
                      if (Math.Abs(index70 - index68) + Math.Abs(index71 - index69) < 9 + WorldGen.genRand.Next(11) && WorldGen.genRand.Next(3) != 0 && Main.tile[index70, index71].type != (ushort) 31)
                      {
                        Main.tile[index70, index71].active(true);
                        Main.tile[index70, index71].type = (ushort) 25;
                        if (Math.Abs(index70 - index68) <= 1 && Math.Abs(index71 - index69) <= 1)
                          Main.tile[index70, index71].active(false);
                      }
                      if (Main.tile[index70, index71].type != (ushort) 31 && Math.Abs(index70 - index68) <= 2 + WorldGen.genRand.Next(3) && Math.Abs(index71 - index69) <= 2 + WorldGen.genRand.Next(3))
                        Main.tile[index70, index71].active(false);
                    }
                  }
                }
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Lakes", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[19].Value;
        double num133 = (double) Main.maxTilesX / 4200.0;
        int num134 = WorldGen.genRand.Next((int) (num133 * 3.0), (int) (num133 * 6.0));
        for (int index72 = 0; index72 < num134; ++index72)
        {
          int num135 = Main.maxTilesX / 4;
          if (GenVars.numLakes >= GenVars.maxLakes - 1)
            break;
          double num136 = (double) index72 / (double) num134;
          progress.Set(num136);
          while (num135 > 0)
          {
            bool flag = false;
            --num135;
            int i5 = WorldGen.genRand.Next(GenVars.lakesBeachAvoidance, Main.maxTilesX - GenVars.lakesBeachAvoidance);
            if (WorldGen.tenthAnniversaryWorldGen && !WorldGen.remixWorldGen)
            {
              i5 = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.15), (int) ((double) Main.maxTilesX * 0.85));
            }
            else
            {
              while ((double) i5 > (double) Main.maxTilesX * 0.45 && (double) i5 < (double) Main.maxTilesX * 0.55)
                i5 = WorldGen.genRand.Next(GenVars.lakesBeachAvoidance, Main.maxTilesX - GenVars.lakesBeachAvoidance);
            }
            for (int index73 = 0; index73 < GenVars.numLakes; ++index73)
            {
              if (Math.Abs(i5 - GenVars.LakeX[index73]) < 150)
              {
                flag = true;
                break;
              }
            }
            for (int index74 = 0; index74 < GenVars.numMCaves; ++index74)
            {
              if (Math.Abs(i5 - GenVars.mCaveX[index74]) < 100)
              {
                flag = true;
                break;
              }
            }
            for (int index75 = 0; index75 < GenVars.numTunnels; ++index75)
            {
              if (Math.Abs(i5 - GenVars.tunnelX[index75]) < 100)
              {
                flag = true;
                break;
              }
            }
            if (!flag)
            {
              int j3 = (int) GenVars.worldSurfaceLow - 20;
              while (!Main.tile[i5, j3].active())
              {
                ++j3;
                if ((double) j3 >= Main.worldSurface || Main.tile[i5, j3].wall > (ushort) 0)
                {
                  flag = true;
                  break;
                }
              }
              if (Main.tile[i5, j3].type == (ushort) 53)
                flag = true;
              if (!flag)
              {
                int num137 = 50;
                for (int index76 = i5 - num137; index76 <= i5 + num137; ++index76)
                {
                  for (int index77 = j3 - num137; index77 <= j3 + num137; ++index77)
                  {
                    if (Main.tile[index76, index77].type == (ushort) 203 || Main.tile[index76, index77].type == (ushort) 25)
                    {
                      flag = true;
                      break;
                    }
                  }
                }
                if (!flag)
                {
                  int num138 = j3;
                  int num139 = 20;
                  while (!WorldGen.SolidTile(i5 - num139, j3) || !WorldGen.SolidTile(i5 + num139, j3))
                  {
                    ++j3;
                    if ((double) j3 > Main.worldSurface - 50.0)
                      flag = true;
                  }
                  if (j3 - num138 <= 10)
                  {
                    int num140 = 60;
                    for (int index78 = i5 - num140; index78 <= i5 + num140; ++index78)
                    {
                      int index79 = j3 - 20;
                      if (Main.tile[index78, index79].active() || Main.tile[index78, index79].wall > (ushort) 0)
                        flag = true;
                    }
                    if (!flag)
                    {
                      int num141 = 0;
                      for (int i6 = i5 - num140; i6 <= i5 + num140; ++i6)
                      {
                        for (int j4 = j3; j4 <= j3 + num140 * 2; ++j4)
                        {
                          if (WorldGen.SolidTile(i6, j4))
                            ++num141;
                        }
                      }
                      int num142 = (num140 * 2 + 1) * (num140 * 2 + 1);
                      if ((double) num141 >= (double) num142 * 0.8 && !GenVars.UndergroundDesertLocation.Intersects(new Microsoft.Xna.Framework.Rectangle(i5 - 8, j3 - 8, 16, 16)))
                      {
                        WorldGen.SonOfLakinater(i5, j3);
                        GenVars.LakeX[GenVars.numLakes] = i5;
                        ++GenVars.numLakes;
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Dungeon", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        int dungeonLocation = GenVars.dungeonLocation;
        int num143 = (int) ((Main.worldSurface + Main.rockLayer) / 2.0) + WorldGen.genRand.Next(-200, 200);
        int num144 = (int) ((Main.worldSurface + Main.rockLayer) / 2.0) + 200;
        int y = num143;
        bool flag = false;
        for (int index = 0; index < 10; ++index)
        {
          if (WorldGen.SolidTile(dungeonLocation, y + index))
          {
            flag = true;
            break;
          }
        }
        if (!flag)
        {
          while (y < num144 && !WorldGen.SolidTile(dungeonLocation, y + 10))
            ++y;
        }
        if (WorldGen.drunkWorldGen)
          y = (int) Main.worldSurface + 70;
        WorldGen.MakeDungeon(dungeonLocation, y);
      }));
      WorldGen.AddGenerationPass("Slush", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        for (int snowTop = GenVars.snowTop; snowTop < GenVars.snowBottom; ++snowTop)
        {
          for (int index80 = GenVars.snowMinX[snowTop]; index80 < GenVars.snowMaxX[snowTop]; ++index80)
          {
            switch (Main.tile[index80, snowTop].type)
            {
              case 1:
                Main.tile[index80, snowTop].type = (ushort) 161;
                break;
              case 59:
                bool flag = true;
                int num = 3;
                for (int index81 = index80 - num; index81 <= index80 + num; ++index81)
                {
                  for (int index82 = snowTop - num; index82 <= snowTop + num; ++index82)
                  {
                    if (Main.tile[index81, index82].type == (ushort) 60 || Main.tile[index81, index82].type == (ushort) 70 || Main.tile[index81, index82].type == (ushort) 71 || Main.tile[index81, index82].type == (ushort) 72)
                    {
                      flag = false;
                      break;
                    }
                  }
                }
                if (flag)
                {
                  Main.tile[index80, snowTop].type = (ushort) 224;
                  break;
                }
                break;
              case 123:
                Main.tile[index80, snowTop].type = (ushort) 224;
                break;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Mountain Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[21].Value;
        for (int index = 0; index < GenVars.numMCaves; ++index)
        {
          int i = GenVars.mCaveX[index];
          int j = GenVars.mCaveY[index];
          WorldGen.CaveOpenater(i, j);
          WorldGen.Cavinator(i, j, WorldGen.genRand.Next(40, 50));
        }
      }));
      WorldGen.AddGenerationPass("Beaches", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        int num145 = 50;
        progress.Message = Lang.gen[22].Value;
        bool floridaStyle1 = false;
        bool floridaStyle2 = false;
        if (WorldGen.genRand.Next(4) == 0)
        {
          if (WorldGen.genRand.Next(2) == 0)
            floridaStyle1 = true;
          else
            floridaStyle2 = true;
        }
        for (int index83 = 0; index83 < 2; ++index83)
        {
          if (index83 == 0)
          {
            int num146 = 0;
            int num147 = WorldGen.genRand.Next(GenVars.oceanWaterStartRandomMin, GenVars.oceanWaterStartRandomMax);
            if (GenVars.dungeonSide == 1)
              num147 = GenVars.oceanWaterForcedJungleLength;
            int num148 = GenVars.leftBeachEnd - num145;
            if (num147 > num148)
              num147 = num148;
            int count = 0;
            double depth = 1.0;
            int index84 = 0;
            while (!Main.tile[num147 - 1, index84].active())
              ++index84;
            GenVars.shellStartYLeft = index84;
            int num149 = index84 + WorldGen.genRand.Next(1, 5);
            for (int index85 = num147 - 1; index85 >= num146; --index85)
            {
              if (index85 > 30)
              {
                ++count;
                depth = WorldGen.TuneOceanDepth(count, depth, floridaStyle1);
              }
              else
                ++depth;
              int num150 = WorldGen.genRand.Next(15, 20);
              for (int index86 = 0; (double) index86 < (double) num149 + depth + (double) num150; ++index86)
              {
                if ((double) index86 < (double) num149 + depth * 0.75 - 3.0)
                {
                  Main.tile[index85, index86].active(false);
                  if (index86 > num149)
                  {
                    Main.tile[index85, index86].liquid = byte.MaxValue;
                    Main.tile[index85, index86].lava(false);
                  }
                  else if (index86 == num149)
                  {
                    Main.tile[index85, index86].liquid = (byte) 127;
                    if (GenVars.shellStartXLeft == 0)
                      GenVars.shellStartXLeft = index85;
                  }
                }
                else if (index86 > num149)
                {
                  Main.tile[index85, index86].type = (ushort) 53;
                  Main.tile[index85, index86].active(true);
                }
                Main.tile[index85, index86].wall = (ushort) 0;
              }
            }
          }
          else
          {
            int index87 = Main.maxTilesX - WorldGen.genRand.Next(GenVars.oceanWaterStartRandomMin, GenVars.oceanWaterStartRandomMax);
            int maxTilesX = Main.maxTilesX;
            if (GenVars.dungeonSide == -1)
              index87 = Main.maxTilesX - GenVars.oceanWaterForcedJungleLength;
            int num151 = GenVars.rightBeachStart + num145;
            if (index87 < num151)
              index87 = num151;
            double depth = 1.0;
            int count = 0;
            int index88 = 0;
            while (!Main.tile[index87, index88].active())
              ++index88;
            GenVars.shellStartXRight = 0;
            GenVars.shellStartYRight = index88;
            int num152 = index88 + WorldGen.genRand.Next(1, 5);
            for (int index89 = index87; index89 < maxTilesX; ++index89)
            {
              if (index89 < maxTilesX - 30)
              {
                ++count;
                depth = WorldGen.TuneOceanDepth(count, depth, floridaStyle2);
              }
              else
                ++depth;
              int num153 = WorldGen.genRand.Next(15, 20);
              for (int index90 = 0; (double) index90 < (double) num152 + depth + (double) num153; ++index90)
              {
                if ((double) index90 < (double) num152 + depth * 0.75 - 3.0)
                {
                  Main.tile[index89, index90].active(false);
                  if (index90 > num152)
                  {
                    Main.tile[index89, index90].liquid = byte.MaxValue;
                    Main.tile[index89, index90].lava(false);
                  }
                  else if (index90 == num152)
                  {
                    Main.tile[index89, index90].liquid = (byte) 127;
                    if (GenVars.shellStartXRight == 0)
                      GenVars.shellStartXRight = index89;
                  }
                }
                else if (index90 > num152)
                {
                  Main.tile[index89, index90].type = (ushort) 53;
                  Main.tile[index89, index90].active(true);
                }
                Main.tile[index89, index90].wall = (ushort) 0;
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Gems", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[23].Value;
        Main.tileSolid[484] = false;
        for (int type = 63; type <= 68; ++type)
        {
          double num154 = (double) (type - 63) / 6.0;
          progress.Set(num154);
          double num155 = 0.0;
          switch (type)
          {
            case 63:
              num155 = (double) Main.maxTilesX * 0.3;
              break;
            case 64:
              num155 = (double) Main.maxTilesX * 0.1;
              break;
            case 65:
              num155 = (double) Main.maxTilesX * 0.25;
              break;
            case 66:
              num155 = (double) Main.maxTilesX * 0.45;
              break;
            case 67:
              num155 = (double) Main.maxTilesX * 0.5;
              break;
            case 68:
              num155 = (double) Main.maxTilesX * 0.05;
              break;
          }
          double num156 = num155 * 0.2;
          for (int index = 0; (double) index < num156; ++index)
          {
            int i = WorldGen.genRand.Next(0, Main.maxTilesX);
            int j;
            for (j = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY); Main.tile[i, j].type != (ushort) 1; j = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY))
              i = WorldGen.genRand.Next(0, Main.maxTilesX);
            WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(2, 6), WorldGen.genRand.Next(3, 7), type);
          }
        }
        for (int index91 = 0; index91 < 2; ++index91)
        {
          int num157 = 1;
          int num158 = 5;
          int num159 = Main.maxTilesX - 5;
          if (index91 == 1)
          {
            num157 = -1;
            num158 = Main.maxTilesX - 5;
            num159 = 5;
          }
          for (int index92 = num158; index92 != num159; index92 += num157)
          {
            if (index92 <= GenVars.UndergroundDesertLocation.Left || index92 >= GenVars.UndergroundDesertLocation.Right)
            {
              for (int index93 = 10; index93 < Main.maxTilesY - 10; ++index93)
              {
                if (Main.tile[index92, index93].active() && Main.tile[index92, index93 + 1].active() && Main.tileSand[(int) Main.tile[index92, index93].type] && Main.tileSand[(int) Main.tile[index92, index93 + 1].type])
                {
                  ushort type = Main.tile[index92, index93].type;
                  int index94 = index92 + num157;
                  int index95 = index93 + 1;
                  if (!Main.tile[index94, index93].active() && !Main.tile[index94, index95].active())
                  {
                    while (!Main.tile[index94, index95].active())
                      ++index95;
                    int index96 = index95 - 1;
                    Main.tile[index92, index93].active(false);
                    Main.tile[index94, index96].active(true);
                    Main.tile[index94, index96].type = type;
                  }
                }
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Gravitating Sand", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[24].Value;
        for (int x = 0; x < Main.maxTilesX; ++x)
        {
          double num160 = (double) x / (double) (Main.maxTilesX - 1);
          progress.Set(num160);
          bool flag = false;
          int num161 = 0;
          for (int y = Main.maxTilesY - 1; y > 0; --y)
          {
            if (WorldGen.SolidOrSlopedTile(x, y))
            {
              ushort type = Main.tile[x, y].type;
              if (flag && y < (int) Main.worldSurface && y != num161 - 1 && TileID.Sets.Falling[(int) type])
              {
                for (int index = y; index < num161; ++index)
                  Main.tile[x, index].ResetToType(type);
              }
              flag = true;
              num161 = y;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Create Ocean Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        int maxValue = 3;
        if (WorldGen.remixWorldGen)
          maxValue = 2;
        for (int index = 0; index < 2; ++index)
        {
          if ((index != 0 || GenVars.dungeonSide <= 0) && (index != 1 || GenVars.dungeonSide >= 0) && (WorldGen.genRand.Next(maxValue) == 0 || WorldGen.drunkWorldGen || WorldGen.tenthAnniversaryWorldGen))
          {
            progress.Message = Lang.gen[90].Value;
            int i = WorldGen.genRand.Next(55, 95);
            if (index == 1)
              i = WorldGen.genRand.Next(Main.maxTilesX - 95, Main.maxTilesX - 55);
            int j = 0;
            while (!Main.tile[i, j].active())
              ++j;
            WorldGen.oceanCave(i, j);
          }
        }
      }));
      WorldGen.AddGenerationPass("Shimmer", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        int num162 = 50;
        int minValue1 = (int) (Main.worldSurface + Main.rockLayer) / 2 + num162;
        int maxValue1 = (int) ((double) ((Main.maxTilesY - 250) * 2) + Main.rockLayer) / 3;
        if (maxValue1 > Main.maxTilesY - 330 - 100 - 30)
          maxValue1 = Main.maxTilesY - 330 - 100 - 30;
        if (maxValue1 <= minValue1)
          maxValue1 = minValue1 + 50;
        int Y = WorldGen.genRand.Next(minValue1, maxValue1);
        int X = GenVars.dungeonSide < 0 ? WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.89), Main.maxTilesX - 200) : WorldGen.genRand.Next(200, (int) ((double) Main.maxTilesX * 0.11));
        int minValue2 = (int) Main.worldSurface + 150;
        int maxValue2 = (int) (Main.rockLayer + Main.worldSurface + 200.0) / 2;
        if (maxValue2 <= minValue2)
          maxValue2 = minValue2 + 50;
        if (WorldGen.tenthAnniversaryWorldGen)
          Y = WorldGen.genRand.Next(minValue2, maxValue2);
        int num163 = 0;
        while (!WorldGen.ShimmerMakeBiome(X, Y))
        {
          ++num163;
          if (WorldGen.tenthAnniversaryWorldGen && num163 < 10000)
          {
            Y = WorldGen.genRand.Next(minValue2, maxValue2);
            X = GenVars.dungeonSide < 0 ? WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.89), Main.maxTilesX - 200) : WorldGen.genRand.Next(200, (int) ((double) Main.maxTilesX * 0.11));
          }
          else if (num163 > 20000)
          {
            Y = WorldGen.genRand.Next((int) Main.worldSurface + 100 + 20, maxValue1);
            X = GenVars.dungeonSide < 0 ? WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.8), Main.maxTilesX - 200) : WorldGen.genRand.Next(200, (int) ((double) Main.maxTilesX * 0.2));
          }
          else
          {
            Y = WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2 + 20, maxValue1);
            X = GenVars.dungeonSide < 0 ? WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.89), Main.maxTilesX - 200) : WorldGen.genRand.Next(200, (int) ((double) Main.maxTilesX * 0.11));
          }
        }
        GenVars.shimmerPosition = new Vector2D((double) X, (double) Y);
        int num164 = 200;
        GenVars.structures.AddProtectedStructure(new Microsoft.Xna.Framework.Rectangle(X - num164 / 2, Y - num164 / 2, num164, num164));
      }));
      WorldGen.AddGenerationPass("Clean Up Dirt", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[25].Value;
        for (int index97 = 3; index97 < Main.maxTilesX - 3; ++index97)
        {
          double num = (double) index97 / (double) Main.maxTilesX;
          progress.Set(0.5 * num);
          bool flag = true;
          for (int index98 = 0; (double) index98 < Main.worldSurface; ++index98)
          {
            if (flag)
            {
              if (Main.tile[index97, index98].wall == (ushort) 2 || Main.tile[index97, index98].wall == (ushort) 40 || Main.tile[index97, index98].wall == (ushort) 64 || Main.tile[index97, index98].wall == (ushort) 86)
                Main.tile[index97, index98].wall = (ushort) 0;
              if (Main.tile[index97, index98].type != (ushort) 53 && Main.tile[index97, index98].type != (ushort) 112 && Main.tile[index97, index98].type != (ushort) 234)
              {
                if (Main.tile[index97 - 1, index98].wall == (ushort) 2 || Main.tile[index97 - 1, index98].wall == (ushort) 40 || Main.tile[index97 - 1, index98].wall == (ushort) 40)
                  Main.tile[index97 - 1, index98].wall = (ushort) 0;
                if ((Main.tile[index97 - 2, index98].wall == (ushort) 2 || Main.tile[index97 - 2, index98].wall == (ushort) 40 || Main.tile[index97 - 2, index98].wall == (ushort) 40) && WorldGen.genRand.Next(2) == 0)
                  Main.tile[index97 - 2, index98].wall = (ushort) 0;
                if ((Main.tile[index97 - 3, index98].wall == (ushort) 2 || Main.tile[index97 - 3, index98].wall == (ushort) 40 || Main.tile[index97 - 3, index98].wall == (ushort) 40) && WorldGen.genRand.Next(2) == 0)
                  Main.tile[index97 - 3, index98].wall = (ushort) 0;
                if (Main.tile[index97 + 1, index98].wall == (ushort) 2 || Main.tile[index97 + 1, index98].wall == (ushort) 40 || Main.tile[index97 + 1, index98].wall == (ushort) 40)
                  Main.tile[index97 + 1, index98].wall = (ushort) 0;
                if ((Main.tile[index97 + 2, index98].wall == (ushort) 2 || Main.tile[index97 + 2, index98].wall == (ushort) 40 || Main.tile[index97 + 2, index98].wall == (ushort) 40) && WorldGen.genRand.Next(2) == 0)
                  Main.tile[index97 + 2, index98].wall = (ushort) 0;
                if ((Main.tile[index97 + 3, index98].wall == (ushort) 2 || Main.tile[index97 + 3, index98].wall == (ushort) 40 || Main.tile[index97 + 3, index98].wall == (ushort) 40) && WorldGen.genRand.Next(2) == 0)
                  Main.tile[index97 + 3, index98].wall = (ushort) 0;
                if (Main.tile[index97, index98].active())
                  flag = false;
              }
            }
            else if (Main.tile[index97, index98].wall == (ushort) 0 && Main.tile[index97, index98 + 1].wall == (ushort) 0 && Main.tile[index97, index98 + 2].wall == (ushort) 0 && Main.tile[index97, index98 + 3].wall == (ushort) 0 && Main.tile[index97, index98 + 4].wall == (ushort) 0 && Main.tile[index97 - 1, index98].wall == (ushort) 0 && Main.tile[index97 + 1, index98].wall == (ushort) 0 && Main.tile[index97 - 2, index98].wall == (ushort) 0 && Main.tile[index97 + 2, index98].wall == (ushort) 0 && !Main.tile[index97, index98].active() && !Main.tile[index97, index98 + 1].active() && !Main.tile[index97, index98 + 2].active() && !Main.tile[index97, index98 + 3].active())
              flag = true;
          }
        }
        for (int index99 = Main.maxTilesX - 5; index99 >= 5; --index99)
        {
          double num = (double) index99 / (double) Main.maxTilesX;
          progress.Set(1.0 - 0.5 * num);
          bool flag = true;
          for (int index100 = 0; (double) index100 < Main.worldSurface; ++index100)
          {
            if (flag)
            {
              if (Main.tile[index99, index100].wall == (ushort) 2 || Main.tile[index99, index100].wall == (ushort) 40 || Main.tile[index99, index100].wall == (ushort) 64)
                Main.tile[index99, index100].wall = (ushort) 0;
              if (Main.tile[index99, index100].type != (ushort) 53)
              {
                if (Main.tile[index99 - 1, index100].wall == (ushort) 2 || Main.tile[index99 - 1, index100].wall == (ushort) 40 || Main.tile[index99 - 1, index100].wall == (ushort) 40)
                  Main.tile[index99 - 1, index100].wall = (ushort) 0;
                if ((Main.tile[index99 - 2, index100].wall == (ushort) 2 || Main.tile[index99 - 2, index100].wall == (ushort) 40 || Main.tile[index99 - 2, index100].wall == (ushort) 40) && WorldGen.genRand.Next(2) == 0)
                  Main.tile[index99 - 2, index100].wall = (ushort) 0;
                if ((Main.tile[index99 - 3, index100].wall == (ushort) 2 || Main.tile[index99 - 3, index100].wall == (ushort) 40 || Main.tile[index99 - 3, index100].wall == (ushort) 40) && WorldGen.genRand.Next(2) == 0)
                  Main.tile[index99 - 3, index100].wall = (ushort) 0;
                if (Main.tile[index99 + 1, index100].wall == (ushort) 2 || Main.tile[index99 + 1, index100].wall == (ushort) 40 || Main.tile[index99 + 1, index100].wall == (ushort) 40)
                  Main.tile[index99 + 1, index100].wall = (ushort) 0;
                if ((Main.tile[index99 + 2, index100].wall == (ushort) 2 || Main.tile[index99 + 2, index100].wall == (ushort) 40 || Main.tile[index99 + 2, index100].wall == (ushort) 40) && WorldGen.genRand.Next(2) == 0)
                  Main.tile[index99 + 2, index100].wall = (ushort) 0;
                if ((Main.tile[index99 + 3, index100].wall == (ushort) 2 || Main.tile[index99 + 3, index100].wall == (ushort) 40 || Main.tile[index99 + 3, index100].wall == (ushort) 40) && WorldGen.genRand.Next(2) == 0)
                  Main.tile[index99 + 3, index100].wall = (ushort) 0;
                if (Main.tile[index99, index100].active())
                  flag = false;
              }
            }
            else if (Main.tile[index99, index100].wall == (ushort) 0 && Main.tile[index99, index100 + 1].wall == (ushort) 0 && Main.tile[index99, index100 + 2].wall == (ushort) 0 && Main.tile[index99, index100 + 3].wall == (ushort) 0 && Main.tile[index99, index100 + 4].wall == (ushort) 0 && Main.tile[index99 - 1, index100].wall == (ushort) 0 && Main.tile[index99 + 1, index100].wall == (ushort) 0 && Main.tile[index99 - 2, index100].wall == (ushort) 0 && Main.tile[index99 + 2, index100].wall == (ushort) 0 && !Main.tile[index99, index100].active() && !Main.tile[index99, index100 + 1].active() && !Main.tile[index99, index100 + 2].active() && !Main.tile[index99, index100 + 3].active())
              flag = true;
          }
        }
      }));
      WorldGen.AddGenerationPass("Pyramids", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        Microsoft.Xna.Framework.Rectangle undergroundDesertLocation = GenVars.UndergroundDesertLocation;
        if (Main.tenthAnniversaryWorld)
          WorldGen.Pyramid(undergroundDesertLocation.Center.X, undergroundDesertLocation.Top - 10);
        for (int index101 = 0; index101 < GenVars.numPyr; ++index101)
        {
          int index102 = GenVars.PyrX[index101];
          int y = GenVars.PyrY[index101];
          if (index102 > 300 && index102 < Main.maxTilesX - 300 && (GenVars.dungeonSide >= 0 || (double) index102 >= (double) GenVars.dungeonX + (double) Main.maxTilesX * 0.15) && (GenVars.dungeonSide <= 0 || (double) index102 <= (double) GenVars.dungeonX - (double) Main.maxTilesX * 0.15) && (!Main.tenthAnniversaryWorld || !undergroundDesertLocation.Contains(index102, y)))
          {
            while (!Main.tile[index102, y].active() && (double) y < Main.worldSurface)
              ++y;
            if ((double) y < Main.worldSurface && Main.tile[index102, y].type == (ushort) 53)
            {
              int num165 = Main.maxTilesX;
              for (int index103 = 0; index103 < index101; ++index103)
              {
                int num166 = Math.Abs(index102 - GenVars.PyrX[index103]);
                if (num166 < num165)
                  num165 = num166;
              }
              int num167 = 220;
              if (WorldGen.drunkWorldGen)
                num167 /= 2;
              if (num165 >= num167)
              {
                int j = y - 1;
                WorldGen.Pyramid(index102, j);
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Dirt Rock Wall Runner", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        for (int index = 0; index < Main.maxTilesX; ++index)
        {
          int i = WorldGen.genRand.Next(10, Main.maxTilesX - 10);
          int j = WorldGen.genRand.Next(10, (int) Main.worldSurface);
          if (Main.tile[i, j].wall == (ushort) 2)
            WorldGen.DirtyRockRunner(i, j);
        }
      }));
      WorldGen.AddGenerationPass("Living Trees", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        int num168 = 200;
        double num169 = (double) Main.maxTilesX / 4200.0;
        int num170 = WorldGen.genRand.Next(0, (int) (2.0 * num169) + 1);
        if (num170 == 0 && WorldGen.genRand.Next(2) == 0)
          ++num170;
        if (WorldGen.drunkWorldGen)
          num170 += (int) (2.0 * num169);
        else if (Main.tenthAnniversaryWorld)
          num170 += (int) (3.0 * num169);
        else if (WorldGen.remixWorldGen)
          num170 += (int) (2.0 * num169);
        for (int index104 = 0; index104 < num170; ++index104)
        {
          bool flag15 = false;
          int num171 = 0;
          while (!flag15)
          {
            ++num171;
            if (num171 > Main.maxTilesX / 2)
              flag15 = true;
            int i7 = WorldGen.genRand.Next(WorldGen.beachDistance, Main.maxTilesX - WorldGen.beachDistance);
            if (WorldGen.tenthAnniversaryWorldGen && !WorldGen.remixWorldGen)
              i7 = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.15), (int) ((double) Main.maxTilesX * 0.85000002384185791));
            if (i7 <= Main.maxTilesX / 2 - num168 || i7 >= Main.maxTilesX / 2 + num168)
            {
              int index105 = 0;
              while (!Main.tile[i7, index105].active() && (double) index105 < Main.worldSurface)
                ++index105;
              if (Main.tile[i7, index105].type == (ushort) 0)
              {
                int j5 = index105 - 1;
                if (j5 > 150)
                {
                  bool flag16 = true;
                  for (int index106 = i7 - 50; index106 < i7 + 50; ++index106)
                  {
                    for (int index107 = j5 - 50; index107 < j5 + 50; ++index107)
                    {
                      if (Main.tile[index106, index107].active())
                      {
                        switch (Main.tile[index106, index107].type)
                        {
                          case 41:
                          case 43:
                          case 44:
                          case 189:
                          case 196:
                          case 460:
                          case 481:
                          case 482:
                          case 483:
                            flag16 = false;
                            continue;
                          default:
                            continue;
                        }
                      }
                    }
                  }
                  for (int index108 = 0; index108 < GenVars.numMCaves; ++index108)
                  {
                    if (i7 > GenVars.mCaveX[index108] - 50 && i7 < GenVars.mCaveX[index108] + 50)
                    {
                      flag16 = false;
                      break;
                    }
                  }
                  if (flag16)
                  {
                    flag15 = WorldGen.GrowLivingTree(i7, j5);
                    if (flag15)
                    {
                      for (int index109 = -1; index109 <= 1; ++index109)
                      {
                        if (index109 != 0)
                        {
                          int i8 = i7;
                          int num172 = WorldGen.genRand.Next(4);
                          if (WorldGen.drunkWorldGen || Main.tenthAnniversaryWorld)
                            num172 += WorldGen.genRand.Next(2, 5);
                          else if (WorldGen.remixWorldGen)
                            num172 += WorldGen.genRand.Next(1, 6);
                          for (int index110 = 0; index110 < num172; ++index110)
                          {
                            i8 += WorldGen.genRand.Next(13, 31) * index109;
                            if (i8 <= Main.maxTilesX / 2 - num168 || i8 >= Main.maxTilesX / 2 + num168)
                            {
                              int j6 = j5;
                              if (Main.tile[i8, j6].active())
                              {
                                while (Main.tile[i8, j6].active())
                                  --j6;
                              }
                              else
                              {
                                while (!Main.tile[i8, j6].active())
                                  ++j6;
                                --j6;
                              }
                              bool flag17 = true;
                              for (int index111 = i7 - 50; index111 < i7 + 50; ++index111)
                              {
                                for (int index112 = j5 - 50; index112 < j5 + 50; ++index112)
                                {
                                  if (Main.tile[index111, index112].active())
                                  {
                                    switch (Main.tile[index111, index112].type)
                                    {
                                      case 41:
                                      case 43:
                                      case 44:
                                      case 189:
                                      case 196:
                                      case 460:
                                      case 481:
                                      case 482:
                                      case 483:
                                        flag17 = false;
                                        continue;
                                      default:
                                        continue;
                                    }
                                  }
                                }
                              }
                              if (flag17)
                                WorldGen.GrowLivingTree(i8, j6, true);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        Main.tileSolid[192] = false;
      }));
      WorldGen.AddGenerationPass("Wood Tree Walls", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        for (int index113 = 25; index113 < Main.maxTilesX - 25; ++index113)
        {
          for (int index114 = 25; (double) index114 < Main.worldSurface; ++index114)
          {
            if (Main.tile[index113, index114].type == (ushort) 191 || Main.tile[index113, index114 - 1].type == (ushort) 191 || Main.tile[index113 - 1, index114].type == (ushort) 191 || Main.tile[index113 + 1, index114].type == (ushort) 191 || Main.tile[index113, index114 + 1].type == (ushort) 191)
            {
              bool flag = true;
              for (int index115 = index113 - 1; index115 <= index113 + 1; ++index115)
              {
                for (int index116 = index114 - 1; index116 <= index114 + 1; ++index116)
                {
                  if (index115 != index113 && index116 != index114 && Main.tile[index115, index116].type != (ushort) 191 && Main.tile[index115, index116].wall != (ushort) 244)
                    flag = false;
                }
              }
              if (flag)
                Main.tile[index113, index114].wall = (ushort) 244;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Altars", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        Main.tileSolid[484] = false;
        progress.Message = Lang.gen[26].Value;
        int num = (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 3.3E-06);
        if (WorldGen.remixWorldGen)
          num *= 3;
        for (int index117 = 0; index117 < num; ++index117)
        {
          progress.Set((double) index117 / (double) num);
          for (int index118 = 0; index118 < 10000; ++index118)
          {
            int x = WorldGen.genRand.Next(281, Main.maxTilesX - 3 - 280);
            while ((double) x > (double) Main.maxTilesX * 0.45 && (double) x < (double) Main.maxTilesX * 0.55)
              x = WorldGen.genRand.Next(281, Main.maxTilesX - 3 - 280);
            int y = WorldGen.genRand.Next((int) (Main.worldSurface * 2.0 + Main.rockLayer) / 3, (int) (Main.rockLayer + (double) ((Main.maxTilesY - 350) * 2)) / 3);
            if (WorldGen.remixWorldGen)
              y = WorldGen.genRand.Next(100, (int) ((double) Main.maxTilesY * 0.9));
            while (WorldGen.oceanDepths(x, y) || Vector2D.Distance(new Vector2D((double) x, (double) y), GenVars.shimmerPosition) < (double) WorldGen.shimmerSafetyDistance)
            {
              x = WorldGen.genRand.Next(281, Main.maxTilesX - 3 - 280);
              while ((double) x > (double) Main.maxTilesX * 0.45 && (double) x < (double) Main.maxTilesX * 0.55)
                x = WorldGen.genRand.Next(281, Main.maxTilesX - 3 - 280);
              y = WorldGen.genRand.Next((int) (Main.worldSurface * 2.0 + Main.rockLayer) / 3, (int) (Main.rockLayer + (double) ((Main.maxTilesY - 350) * 2)) / 3);
              if (WorldGen.remixWorldGen)
                y = WorldGen.genRand.Next(100, (int) ((double) Main.maxTilesY * 0.9));
            }
            int style = WorldGen.crimson ? 1 : 0;
            if (WorldGen.drunkWorldGen)
              style = !GenVars.crimsonLeft ? (x >= Main.maxTilesX / 2 ? 1 : 0) : (x >= Main.maxTilesX / 2 ? 0 : 1);
            if (!WorldGen.IsTileNearby(x, y, 26, 3))
              WorldGen.Place3x2(x, y, (ushort) 26, style);
            if (Main.tile[x, y].type == (ushort) 26)
              break;
          }
        }
      }));
      WorldGen.AddGenerationPass("Wet Jungle", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        for (int index = 0; index < Main.maxTilesX; ++index)
        {
          for (int worldSurfaceLow = (int) GenVars.worldSurfaceLow; (double) worldSurfaceLow < Main.worldSurface - 1.0; ++worldSurfaceLow)
          {
            if (Main.tile[index, worldSurfaceLow].active())
            {
              if (Main.tile[index, worldSurfaceLow].type == (ushort) 60)
              {
                Main.tile[index, worldSurfaceLow - 1].liquid = byte.MaxValue;
                Main.tile[index, worldSurfaceLow - 2].liquid = byte.MaxValue;
                break;
              }
              break;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Jungle Temple", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        int num173 = 0;
        progress.Message = Lang.gen[70].Value;
        long num174 = 0;
        double num175 = 0.25;
        bool flag18 = false;
        while (true)
        {
          do
          {
            int minValue = (int) Main.rockLayer;
            int maxValue = Main.maxTilesY - 500;
            if (minValue > maxValue - 1)
              minValue = maxValue - 1;
            int y1 = WorldGen.genRand.Next(minValue, maxValue);
            int x1 = (int) (((WorldGen.genRand.NextDouble() * num175 + 0.1) * (double) -GenVars.dungeonSide + 0.5) * (double) Main.maxTilesX);
            if (WorldGen.remixWorldGen)
            {
              int x2;
              if (WorldGen.notTheBees)
              {
                x2 = GenVars.dungeonSide <= 0 ? WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.6), (int) ((double) Main.maxTilesX * 0.8)) : WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.2), (int) ((double) Main.maxTilesX * 0.4));
              }
              else
              {
                x2 = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.2), (int) ((double) Main.maxTilesX * 0.8));
                while ((double) x2 > (double) Main.maxTilesX * 0.4 && (double) x2 < (double) Main.maxTilesX * 0.6)
                  x2 = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.2), (int) ((double) Main.maxTilesX * 0.8));
              }
              while (Main.tile[x2, y1].active() || Main.tile[x2, y1].wall > (ushort) 0 || (double) y1 > Main.worldSurface - 5.0)
                --y1;
              int index119 = y1 + 1;
              if (Main.tile[x2, index119].active() && (Main.tile[x2, index119].type == (ushort) 60 || Main.tile[x2, index119].type == (ushort) 59))
              {
                int num176 = 10;
                bool flag19 = false;
                for (int index120 = x2 - num176; index120 <= index120 + num176; ++index120)
                {
                  for (int index121 = index119 - num176; index121 < num176; ++index121)
                  {
                    if (Main.tile[index120, index121].type == (ushort) 191 || Main.tileDungeon[(int) Main.tile[index120, index121].type])
                      flag19 = true;
                  }
                }
                if (!flag19)
                {
                  flag18 = true;
                  int y2 = index119 - (10 + WorldGen.genRand.Next(10));
                  WorldGen.makeTemple(x2, y2);
                  goto label_29;
                }
              }
            }
            else if (Main.tile[x1, y1].active() && Main.tile[x1, y1].type == (ushort) 60)
            {
              flag18 = true;
              WorldGen.makeTemple(x1, y1);
              goto label_29;
            }
          }
          while (num174++ <= 2000000L);
          if (num175 == 0.35)
          {
            ++num173;
            if (num173 > 10)
              break;
          }
          num175 = Math.Min(0.35, num175 + 0.05);
          num174 = 0L;
        }
label_29:
        if (flag18)
          return;
        int x = Main.maxTilesX - GenVars.dungeonX;
        int y = (int) Main.rockLayer + 100;
        if (WorldGen.remixWorldGen)
          x = !WorldGen.notTheBees ? (GenVars.dungeonSide > 0 ? (int) ((double) Main.maxTilesX * 0.4) : (int) ((double) Main.maxTilesX * 0.6)) : (GenVars.dungeonSide > 0 ? (int) ((double) Main.maxTilesX * 0.3) : (int) ((double) Main.maxTilesX * 0.7));
        WorldGen.makeTemple(x, y);
      }));
      WorldGen.AddGenerationPass("Hives", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[71].Value;
        double num177 = (double) Main.maxTilesX / 4200.0;
        double num178 = (double) (1 + WorldGen.genRand.Next((int) (5.0 * num177), (int) (8.0 * num177)));
        if (WorldGen.drunkWorldGen)
          num178 *= 0.667;
        int num179 = 10000;
        HiveBiome biome1 = GenVars.configuration.CreateBiome<HiveBiome>();
        HoneyPatchBiome biome2 = GenVars.configuration.CreateBiome<HoneyPatchBiome>();
label_10:
        while (num178 > 0.0 && num179 > 0)
        {
          --num179;
          Point origin = WorldGen.RandomWorldPoint((int) (Main.worldSurface + Main.rockLayer) >> 1, 20, 300, 20);
          if (WorldGen.drunkWorldGen)
            WorldGen.RandomWorldPoint((int) Main.worldSurface, 20, 300, 20);
          if (biome1.Place(origin, GenVars.structures))
          {
            --num178;
            int num180 = WorldGen.genRand.Next(5);
            int num181 = 0;
            int num182 = 10000;
            while (true)
            {
              int x;
              int y;
              do
              {
                if (num181 < num180 && num182 > 0)
                {
                  double num183 = WorldGen.genRand.NextDouble() * 60.0 + 30.0;
                  double num184 = WorldGen.genRand.NextDouble() * 6.2831854820251465;
                  x = (int) (Math.Cos(num184) * num183) + origin.X;
                  y = (int) (Math.Sin(num184) * num183) + origin.Y;
                  --num182;
                }
                else
                  goto label_10;
              }
              while (x <= 50 || x >= Main.maxTilesX - 50 || !biome2.Place(new Point(x, y), GenVars.structures));
              ++num181;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Jungle Chests", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        WorldGen.genRand.Next(40, Main.maxTilesX - 40);
        WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 400);
        double num185 = (double) WorldGen.genRand.Next(7, 12) * ((double) Main.maxTilesX / 4200.0);
        int num186 = 0;
        for (int index122 = 0; (double) index122 < num185; ++index122)
        {
          bool flag20 = true;
          while (flag20)
          {
            ++num186;
            int index123 = WorldGen.genRand.Next(40, Main.maxTilesX / 2 - 40);
            if (GenVars.dungeonSide < 0)
              index123 += Main.maxTilesX / 2;
            int index124 = WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 400);
            int num187 = WorldGen.genRand.Next(2, 4);
            int num188 = WorldGen.genRand.Next(2, 4);
            Microsoft.Xna.Framework.Rectangle area = new Microsoft.Xna.Framework.Rectangle(index123 - num187 - 1, index124 - num188 - 1, num187 + 1, num188 + 1);
            if (Main.tile[index123, index124].type == (ushort) 60)
            {
              int num189 = 30;
              flag20 = false;
              for (int index125 = index123 - num189; index125 < index123 + num189; index125 += 3)
              {
                for (int index126 = index124 - num189; index126 < index124 + num189; index126 += 3)
                {
                  if (Main.tile[index125, index126].active() && (Main.tile[index125, index126].type == (ushort) 225 || Main.tile[index125, index126].type == (ushort) 229 || Main.tile[index125, index126].type == (ushort) 226 || Main.tile[index125, index126].type == (ushort) 119 || Main.tile[index125, index126].type == (ushort) 120))
                    flag20 = true;
                  if (Main.tile[index125, index126].wall == (ushort) 86 || Main.tile[index125, index126].wall == (ushort) 87)
                    flag20 = true;
                }
              }
              if (!GenVars.structures.CanPlace(area, 1))
                flag20 = true;
            }
            if (!flag20)
            {
              ushort num190 = 0;
              switch (GenVars.jungleHut)
              {
                case 45:
                  num190 = (ushort) 10;
                  break;
                case 119:
                  num190 = (ushort) 23;
                  break;
                case 120:
                  num190 = (ushort) 24;
                  break;
                case 158:
                  num190 = (ushort) 42;
                  break;
                case 175:
                  num190 = (ushort) 45;
                  break;
              }
              for (int index127 = index123 - num187 - 1; index127 <= index123 + num187 + 1; ++index127)
              {
                for (int index128 = index124 - num188 - 1; index128 <= index124 + num188 + 1; ++index128)
                {
                  Main.tile[index127, index128].active(true);
                  Main.tile[index127, index128].type = GenVars.jungleHut;
                  Main.tile[index127, index128].liquid = (byte) 0;
                  Main.tile[index127, index128].lava(false);
                }
              }
              for (int index129 = index123 - num187; index129 <= index123 + num187; ++index129)
              {
                for (int index130 = index124 - num188; index130 <= index124 + num188; ++index130)
                {
                  Main.tile[index129, index130].active(false);
                  Main.tile[index129, index130].wall = num190;
                }
              }
              bool flag21 = false;
              int num191 = 0;
              while (!flag21 && num191 < 100)
              {
                ++num191;
                int i = WorldGen.genRand.Next(index123 - num187, index123 + num187 + 1);
                int j = WorldGen.genRand.Next(index124 - num188, index124 + num188 - 2);
                WorldGen.PlaceTile(i, j, 4, true, style: 3);
                if (Main.tile[i, j].type == (ushort) 4)
                  flag21 = true;
              }
              for (int index131 = index123 - num187 - 1; index131 <= index123 + num187 + 1; ++index131)
              {
                for (int index132 = index124 + num188 - 2; index132 <= index124 + num188; ++index132)
                  Main.tile[index131, index132].active(false);
              }
              for (int index133 = index123 - num187 - 1; index133 <= index123 + num187 + 1; ++index133)
              {
                for (int index134 = index124 + num188 - 2; index134 <= index124 + num188 - 1; ++index134)
                  Main.tile[index133, index134].active(false);
              }
              for (int index135 = index123 - num187 - 1; index135 <= index123 + num187 + 1; ++index135)
              {
                int num192 = 4;
                for (int index136 = index124 + num188 + 2; !Main.tile[index135, index136].active() && index136 < Main.maxTilesY && num192 > 0; --num192)
                {
                  Main.tile[index135, index136].active(true);
                  Main.tile[index135, index136].type = (ushort) 59;
                  ++index136;
                }
              }
              int num193 = num187 - WorldGen.genRand.Next(1, 3);
              int index137 = index124 - num188 - 2;
              while (num193 > -1)
              {
                for (int index138 = index123 - num193 - 1; index138 <= index123 + num193 + 1; ++index138)
                {
                  Main.tile[index138, index137].active(true);
                  Main.tile[index138, index137].type = GenVars.jungleHut;
                }
                num193 -= WorldGen.genRand.Next(1, 3);
                --index137;
              }
              GenVars.JChestX[GenVars.numJChests] = index123;
              GenVars.JChestY[GenVars.numJChests] = index124;
              GenVars.structures.AddProtectedStructure(area);
              ++GenVars.numJChests;
              num186 = 0;
            }
            else if (num186 > Main.maxTilesX * 10)
            {
              ++index122;
              num186 = 0;
              break;
            }
          }
        }
        Main.tileSolid[137] = false;
      }));
      WorldGen.AddGenerationPass("Settle Liquids", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[27].Value;
        if (WorldGen.notTheBees)
          WorldGen.NotTheBees();
        Liquid.worldGenTilesIgnoreWater(true);
        Liquid.QuickWater(3);
        WorldGen.WaterCheck();
        int num194 = 0;
        Liquid.quickSettle = true;
        int num195 = 10;
        while (num194 < num195)
        {
          int num196 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
          ++num194;
          double num197 = 0.0;
          int num198 = num196 * 5;
          while (Liquid.numLiquid > 0)
          {
            --num198;
            if (num198 >= 0)
            {
              double num199 = (double) (num196 - (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer)) / (double) num196;
              if (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer > num196)
                num196 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
              if (num199 > num197)
                num197 = num199;
              else
                num199 = num197;
              if (num194 == 1)
                progress.Set(num199 / 3.0 + 0.33);
              int num200 = 10;
              if (num194 > num200)
                ;
              Liquid.UpdateLiquid();
            }
            else
              break;
          }
          WorldGen.WaterCheck();
          progress.Set((double) num194 * 0.1 / 3.0 + 0.66);
        }
        Liquid.quickSettle = false;
        Liquid.worldGenTilesIgnoreWater(false);
        Main.tileSolid[484] = false;
      }));
      WorldGen.AddGenerationPass("Remove Water From Sand", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
label_11:
        for (int index139 = 400; index139 < Main.maxTilesX - 400; ++index139)
        {
          for (int index140 = 100; (double) index140 < Main.worldSurface - 1.0; ++index140)
          {
            if (Main.tile[index139, index140].active())
            {
              switch (Main.tile[index139, index140].type)
              {
                case 53:
                case 151:
                case 396:
                case 397:
                case 404:
                case 407:
                  int index141 = index140;
                  while (index141 > 100)
                  {
                    --index141;
                    if (!Main.tile[index139, index141].active())
                      Main.tile[index139, index141].liquid = (byte) 0;
                    else
                      break;
                  }
                  goto label_11;
                default:
                  goto label_11;
              }
            }
          }
        }
        Main.tileSolid[192] = true;
      }));
      WorldGen.AddGenerationPass("Oasis", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.notTheBees)
          return;
        progress.Set(1.0);
        int num201 = Main.maxTilesX / 2100 + WorldGen.genRand.Next(2);
        for (int index = 0; index < num201; ++index)
        {
          int minValue = WorldGen.beachDistance + 300;
          int num202 = Main.maxTilesX * 2;
          while (num202 > 0)
          {
            --num202;
            if (WorldGen.PlaceOasis(WorldGen.genRand.Next(minValue, Main.maxTilesX - minValue), WorldGen.genRand.Next(100, (int) Main.worldSurface)))
              num202 = -1;
          }
        }
      }));
      WorldGen.AddGenerationPass("Shell Piles", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.dontStarveWorldGen)
        {
          int num203 = (int) (5.0 * ((double) Main.maxTilesX / 4200.0));
          int num204 = 0;
          int num205 = 100;
          int num206 = Main.maxTilesX / 2;
          int num207 = num206 - num205;
          int num208 = num206 + num205;
          for (int index = 0; index < 80; ++index)
          {
            int X = WorldGen.genRand.Next(100, Main.maxTilesX - 100);
            if (X >= num207 && X <= num208)
            {
              X = WorldGen.genRand.Next(100, Main.maxTilesX - 100);
              if (X >= num207 && X <= num208)
                continue;
            }
            int Y = (int) Main.worldSurface / 2;
            if (WorldGen.MarblePileWithStatues(X, Y))
            {
              ++num204;
              if (num204 >= num203)
                break;
            }
          }
        }
        if (WorldGen.notTheBees)
          return;
        progress.Set(1.0);
        if (WorldGen.genRand.Next(2) == 0)
        {
          int shellStartXleft = GenVars.shellStartXLeft;
          int shellStartYleft = GenVars.shellStartYLeft;
          for (int index142 = shellStartXleft - 20; index142 <= shellStartXleft + 20; ++index142)
          {
            for (int index143 = shellStartYleft - 10; index143 <= shellStartYleft + 10; ++index143)
            {
              if (Main.tile[index142, index143].active() && Main.tile[index142, index143].type == (ushort) 53 && !Main.tile[index142, index143 - 1].active() && Main.tile[index142, index143 - 1].liquid == (byte) 0 && !Main.tile[index142 - 1, index143].active() && Main.tile[index142 - 1, index143].liquid > (byte) 0)
              {
                GenVars.shellStartXLeft = index142;
                GenVars.shellStartYLeft = index143;
              }
            }
          }
          GenVars.shellStartYLeft -= 50;
          GenVars.shellStartXLeft -= WorldGen.genRand.Next(5);
          if (WorldGen.genRand.Next(2) == 0)
            GenVars.shellStartXLeft -= WorldGen.genRand.Next(10);
          if (WorldGen.genRand.Next(3) == 0)
            GenVars.shellStartXLeft -= WorldGen.genRand.Next(15);
          if (WorldGen.genRand.Next(4) != 0)
            WorldGen.ShellPile(GenVars.shellStartXLeft, GenVars.shellStartYLeft);
          int maxValue = WorldGen.genRand.Next(2, 4);
          if (WorldGen.genRand.Next(maxValue) == 0)
            WorldGen.ShellPile(GenVars.shellStartXLeft - WorldGen.genRand.Next(10, 35), GenVars.shellStartYLeft);
          if (WorldGen.genRand.Next(maxValue) == 0)
            WorldGen.ShellPile(GenVars.shellStartXLeft - WorldGen.genRand.Next(40, 65), GenVars.shellStartYLeft);
          if (WorldGen.genRand.Next(maxValue) == 0)
            WorldGen.ShellPile(GenVars.shellStartXLeft - WorldGen.genRand.Next(70, 95), GenVars.shellStartYLeft);
          if (WorldGen.genRand.Next(maxValue) == 0)
            WorldGen.ShellPile(GenVars.shellStartXLeft - WorldGen.genRand.Next(100, 125), GenVars.shellStartYLeft);
          if (WorldGen.genRand.Next(maxValue) == 0)
            WorldGen.ShellPile(GenVars.shellStartXLeft + WorldGen.genRand.Next(10, 25), GenVars.shellStartYLeft);
        }
        if (WorldGen.genRand.Next(2) != 0)
          return;
        int shellStartXright = GenVars.shellStartXRight;
        int shellStartYright = GenVars.shellStartYRight;
        for (int index144 = shellStartXright - 20; index144 <= shellStartXright + 20; ++index144)
        {
          for (int index145 = shellStartYright - 10; index145 <= shellStartYright + 10; ++index145)
          {
            if (Main.tile[index144, index145].active() && Main.tile[index144, index145].type == (ushort) 53 && !Main.tile[index144, index145 - 1].active() && Main.tile[index144, index145 - 1].liquid == (byte) 0 && !Main.tile[index144 + 1, index145].active() && Main.tile[index144 + 1, index145].liquid > (byte) 0)
            {
              GenVars.shellStartXRight = index144;
              GenVars.shellStartYRight = index145;
            }
          }
        }
        GenVars.shellStartYRight -= 50;
        GenVars.shellStartXRight += WorldGen.genRand.Next(5);
        if (WorldGen.genRand.Next(2) == 0)
          GenVars.shellStartXLeft += WorldGen.genRand.Next(10);
        if (WorldGen.genRand.Next(3) == 0)
          GenVars.shellStartXLeft += WorldGen.genRand.Next(15);
        if (WorldGen.genRand.Next(4) != 0)
          WorldGen.ShellPile(GenVars.shellStartXRight, GenVars.shellStartYRight);
        int maxValue3 = WorldGen.genRand.Next(2, 4);
        if (WorldGen.genRand.Next(maxValue3) == 0)
          WorldGen.ShellPile(GenVars.shellStartXRight + WorldGen.genRand.Next(10, 35), GenVars.shellStartYRight);
        if (WorldGen.genRand.Next(maxValue3) == 0)
          WorldGen.ShellPile(GenVars.shellStartXRight + WorldGen.genRand.Next(40, 65), GenVars.shellStartYRight);
        if (WorldGen.genRand.Next(maxValue3) == 0)
          WorldGen.ShellPile(GenVars.shellStartXRight + WorldGen.genRand.Next(70, 95), GenVars.shellStartYRight);
        if (WorldGen.genRand.Next(maxValue3) == 0)
          WorldGen.ShellPile(GenVars.shellStartXRight + WorldGen.genRand.Next(100, 125), GenVars.shellStartYRight);
        if (WorldGen.genRand.Next(maxValue3) != 0)
          return;
        WorldGen.ShellPile(GenVars.shellStartXRight - WorldGen.genRand.Next(10, 25), GenVars.shellStartYRight);
      }));
      WorldGen.AddGenerationPass("Smooth World", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[60].Value;
        Main.tileSolid[(int) GenVars.crackedType] = true;
        for (int index146 = 20; index146 < Main.maxTilesX - 20; ++index146)
        {
          double num = (double) index146 / (double) Main.maxTilesX;
          progress.Set(num);
          for (int index147 = 20; index147 < Main.maxTilesY - 20; ++index147)
          {
            if (Main.tile[index146, index147].type != (ushort) 48 && Main.tile[index146, index147].type != (ushort) 137 && Main.tile[index146, index147].type != (ushort) 232 && Main.tile[index146, index147].type != (ushort) 191 && Main.tile[index146, index147].type != (ushort) 151 && Main.tile[index146, index147].type != (ushort) 274)
            {
              if (!Main.tile[index146, index147 - 1].active() && Main.tile[index146 - 1, index147].type != (ushort) 136 && Main.tile[index146 + 1, index147].type != (ushort) 136)
              {
                if (WorldGen.SolidTile(index146, index147) && TileID.Sets.CanBeClearedDuringGeneration[(int) Main.tile[index146, index147].type])
                {
                  if (!Main.tile[index146 - 1, index147].halfBrick() && !Main.tile[index146 + 1, index147].halfBrick() && Main.tile[index146 - 1, index147].slope() == (byte) 0 && Main.tile[index146 + 1, index147].slope() == (byte) 0)
                  {
                    if (WorldGen.SolidTile(index146, index147 + 1))
                    {
                      if (!WorldGen.SolidTile(index146 - 1, index147) && !Main.tile[index146 - 1, index147 + 1].halfBrick() && WorldGen.SolidTile(index146 - 1, index147 + 1) && WorldGen.SolidTile(index146 + 1, index147) && !Main.tile[index146 + 1, index147 - 1].active())
                      {
                        if (WorldGen.genRand.Next(2) == 0)
                          WorldGen.SlopeTile(index146, index147, 2);
                        else
                          WorldGen.PoundTile(index146, index147);
                      }
                      else if (!WorldGen.SolidTile(index146 + 1, index147) && !Main.tile[index146 + 1, index147 + 1].halfBrick() && WorldGen.SolidTile(index146 + 1, index147 + 1) && WorldGen.SolidTile(index146 - 1, index147) && !Main.tile[index146 - 1, index147 - 1].active())
                      {
                        if (WorldGen.genRand.Next(2) == 0)
                          WorldGen.SlopeTile(index146, index147, 1);
                        else
                          WorldGen.PoundTile(index146, index147);
                      }
                      else if (WorldGen.SolidTile(index146 + 1, index147 + 1) && WorldGen.SolidTile(index146 - 1, index147 + 1) && !Main.tile[index146 + 1, index147].active() && !Main.tile[index146 - 1, index147].active())
                        WorldGen.PoundTile(index146, index147);
                      if (WorldGen.SolidTile(index146, index147))
                      {
                        if (WorldGen.SolidTile(index146 - 1, index147) && WorldGen.SolidTile(index146 + 1, index147 + 2) && !Main.tile[index146 + 1, index147].active() && !Main.tile[index146 + 1, index147 + 1].active() && !Main.tile[index146 - 1, index147 - 1].active())
                          WorldGen.KillTile(index146, index147);
                        else if (WorldGen.SolidTile(index146 + 1, index147) && WorldGen.SolidTile(index146 - 1, index147 + 2) && !Main.tile[index146 - 1, index147].active() && !Main.tile[index146 - 1, index147 + 1].active() && !Main.tile[index146 + 1, index147 - 1].active())
                          WorldGen.KillTile(index146, index147);
                        else if (!Main.tile[index146 - 1, index147 + 1].active() && !Main.tile[index146 - 1, index147].active() && WorldGen.SolidTile(index146 + 1, index147) && WorldGen.SolidTile(index146, index147 + 2))
                        {
                          if (WorldGen.genRand.Next(5) == 0)
                            WorldGen.KillTile(index146, index147);
                          else if (WorldGen.genRand.Next(5) == 0)
                            WorldGen.PoundTile(index146, index147);
                          else
                            WorldGen.SlopeTile(index146, index147, 2);
                        }
                        else if (!Main.tile[index146 + 1, index147 + 1].active() && !Main.tile[index146 + 1, index147].active() && WorldGen.SolidTile(index146 - 1, index147) && WorldGen.SolidTile(index146, index147 + 2))
                        {
                          if (WorldGen.genRand.Next(5) == 0)
                            WorldGen.KillTile(index146, index147);
                          else if (WorldGen.genRand.Next(5) == 0)
                            WorldGen.PoundTile(index146, index147);
                          else
                            WorldGen.SlopeTile(index146, index147, 1);
                        }
                      }
                    }
                    if (WorldGen.SolidTile(index146, index147) && !Main.tile[index146 - 1, index147].active() && !Main.tile[index146 + 1, index147].active())
                      WorldGen.KillTile(index146, index147);
                  }
                }
                else if (!Main.tile[index146, index147].active() && Main.tile[index146, index147 + 1].type != (ushort) 151 && Main.tile[index146, index147 + 1].type != (ushort) 274)
                {
                  if (Main.tile[index146 + 1, index147].type != (ushort) 190 && Main.tile[index146 + 1, index147].type != (ushort) 48 && Main.tile[index146 + 1, index147].type != (ushort) 232 && WorldGen.SolidTile(index146 - 1, index147 + 1) && WorldGen.SolidTile(index146 + 1, index147) && !Main.tile[index146 - 1, index147].active() && !Main.tile[index146 + 1, index147 - 1].active())
                  {
                    if (Main.tile[index146 + 1, index147].type == (ushort) 495)
                      WorldGen.PlaceTile(index146, index147, (int) Main.tile[index146 + 1, index147].type);
                    else
                      WorldGen.PlaceTile(index146, index147, (int) Main.tile[index146, index147 + 1].type);
                    if (WorldGen.genRand.Next(2) == 0)
                      WorldGen.SlopeTile(index146, index147, 2);
                    else
                      WorldGen.PoundTile(index146, index147);
                  }
                  if (Main.tile[index146 - 1, index147].type != (ushort) 190 && Main.tile[index146 - 1, index147].type != (ushort) 48 && Main.tile[index146 - 1, index147].type != (ushort) 232 && WorldGen.SolidTile(index146 + 1, index147 + 1) && WorldGen.SolidTile(index146 - 1, index147) && !Main.tile[index146 + 1, index147].active() && !Main.tile[index146 - 1, index147 - 1].active())
                  {
                    if (Main.tile[index146 - 1, index147].type == (ushort) 495)
                      WorldGen.PlaceTile(index146, index147, (int) Main.tile[index146 - 1, index147].type);
                    else
                      WorldGen.PlaceTile(index146, index147, (int) Main.tile[index146, index147 + 1].type);
                    if (WorldGen.genRand.Next(2) == 0)
                      WorldGen.SlopeTile(index146, index147, 1);
                    else
                      WorldGen.PoundTile(index146, index147);
                  }
                }
              }
              else if (!Main.tile[index146, index147 + 1].active() && WorldGen.genRand.Next(2) == 0 && WorldGen.SolidTile(index146, index147) && !Main.tile[index146 - 1, index147].halfBrick() && !Main.tile[index146 + 1, index147].halfBrick() && Main.tile[index146 - 1, index147].slope() == (byte) 0 && Main.tile[index146 + 1, index147].slope() == (byte) 0 && WorldGen.SolidTile(index146, index147 - 1))
              {
                if (WorldGen.SolidTile(index146 - 1, index147) && !WorldGen.SolidTile(index146 + 1, index147) && WorldGen.SolidTile(index146 - 1, index147 - 1))
                  WorldGen.SlopeTile(index146, index147, 3);
                else if (WorldGen.SolidTile(index146 + 1, index147) && !WorldGen.SolidTile(index146 - 1, index147) && WorldGen.SolidTile(index146 + 1, index147 - 1))
                  WorldGen.SlopeTile(index146, index147, 4);
              }
              if (TileID.Sets.Conversion.Sand[(int) Main.tile[index146, index147].type])
                Tile.SmoothSlope(index146, index147, false);
            }
          }
        }
        for (int i = 20; i < Main.maxTilesX - 20; ++i)
        {
          for (int j = 20; j < Main.maxTilesY - 20; ++j)
          {
            if (WorldGen.genRand.Next(2) == 0 && !Main.tile[i, j - 1].active() && Main.tile[i, j].type != (ushort) 137 && Main.tile[i, j].type != (ushort) 48 && Main.tile[i, j].type != (ushort) 232 && Main.tile[i, j].type != (ushort) 191 && Main.tile[i, j].type != (ushort) 151 && Main.tile[i, j].type != (ushort) 274 && Main.tile[i, j].type != (ushort) 75 && Main.tile[i, j].type != (ushort) 76 && WorldGen.SolidTile(i, j) && Main.tile[i - 1, j].type != (ushort) 137 && Main.tile[i + 1, j].type != (ushort) 137)
            {
              if (WorldGen.SolidTile(i, j + 1) && WorldGen.SolidTile(i + 1, j) && !Main.tile[i - 1, j].active())
                WorldGen.SlopeTile(i, j, 2);
              if (WorldGen.SolidTile(i, j + 1) && WorldGen.SolidTile(i - 1, j) && !Main.tile[i + 1, j].active())
                WorldGen.SlopeTile(i, j, 1);
            }
            if (Main.tile[i, j].slope() == (byte) 1 && !WorldGen.SolidTile(i - 1, j))
            {
              WorldGen.SlopeTile(i, j);
              WorldGen.PoundTile(i, j);
            }
            if (Main.tile[i, j].slope() == (byte) 2 && !WorldGen.SolidTile(i + 1, j))
            {
              WorldGen.SlopeTile(i, j);
              WorldGen.PoundTile(i, j);
            }
          }
        }
        Main.tileSolid[137] = true;
        Main.tileSolid[190] = false;
        Main.tileSolid[192] = false;
        Main.tileSolid[(int) GenVars.crackedType] = false;
      }));
      WorldGen.AddGenerationPass("Waterfalls", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[69].Value;
        Main.tileSolid[191] = false;
        for (int i = 20; i < Main.maxTilesX - 20; ++i)
        {
          double num209 = (double) i / (double) Main.maxTilesX;
          progress.Set(num209 * 0.5);
          for (int j = 20; j < Main.maxTilesY - 20; ++j)
          {
            if (WorldGen.SolidTile(i, j) && !Main.tile[i - 1, j].active() && WorldGen.SolidTile(i, j + 1) && !Main.tile[i + 1, j].active() && (Main.tile[i - 1, j].liquid > (byte) 0 || Main.tile[i + 1, j].liquid > (byte) 0))
            {
              bool flag = true;
              int num210 = WorldGen.genRand.Next(8, 20);
              int num211 = WorldGen.genRand.Next(8, 20);
              int num212 = j - num210;
              int num213 = num211 + j;
              for (int index = num212; index <= num213; ++index)
              {
                if (Main.tile[i, index].halfBrick())
                  flag = false;
              }
              if ((Main.tile[i, j].type == (ushort) 75 || Main.tile[i, j].type == (ushort) 76) && WorldGen.genRand.Next(10) != 0)
                flag = false;
              if (flag)
                WorldGen.PoundTile(i, j);
            }
          }
        }
        for (int i = 20; i < Main.maxTilesX - 20; ++i)
        {
          double num = (double) i / (double) Main.maxTilesX;
          progress.Set(num * 0.5 + 0.5);
          for (int j = 20; j < Main.maxTilesY - 20; ++j)
          {
            if (Main.tile[i, j].type != (ushort) 48 && Main.tile[i, j].type != (ushort) 232 && WorldGen.SolidTile(i, j) && WorldGen.SolidTile(i, j + 1))
            {
              if (!WorldGen.SolidTile(i + 1, j) && Main.tile[i - 1, j].halfBrick() && Main.tile[i - 2, j].liquid > (byte) 0)
                WorldGen.PoundTile(i, j);
              if (!WorldGen.SolidTile(i - 1, j) && Main.tile[i + 1, j].halfBrick() && Main.tile[i + 2, j].liquid > (byte) 0)
                WorldGen.PoundTile(i, j);
            }
          }
        }
        Main.tileSolid[191] = true;
      }));
      WorldGen.AddGenerationPass("Ice", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.notTheBees)
          WorldGen.NotTheBees();
        progress.Set(1.0);
        for (int i = 10; i < Main.maxTilesX - 10; ++i)
        {
          for (int worldSurface = (int) Main.worldSurface; worldSurface < Main.maxTilesY - 100; ++worldSurface)
          {
            if (Main.tile[i, worldSurface].liquid > (byte) 0 && (!Main.tile[i, worldSurface].lava() || WorldGen.remixWorldGen))
              WorldGen.MakeWateryIceThing(i, worldSurface);
          }
        }
        Main.tileSolid[226] = false;
        Main.tileSolid[162] = false;
      }));
      WorldGen.AddGenerationPass("Wall Variety", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[79].Value;
        int num214 = (int) (300.0 * ((double) (Main.maxTilesX * Main.maxTilesY) / 5040000.0));
        int num215 = num214;
        ShapeData data = new ShapeData();
        while (num214 > 0)
        {
          progress.Set(1.0 - (double) num214 / (double) num215);
          Point point = WorldGen.RandomWorldPoint((int) GenVars.worldSurface, 2, 190, 2);
          while (Vector2D.Distance(new Vector2D((double) point.X, (double) point.Y), GenVars.shimmerPosition) < (double) WorldGen.shimmerSafetyDistance)
            point = WorldGen.RandomWorldPoint((int) GenVars.worldSurface, 2, 190, 2);
          Tile tile1 = Main.tile[point.X, point.Y];
          Tile tile2 = Main.tile[point.X, point.Y - 1];
          ushort type = 0;
          if (tile1.type == (ushort) 60)
            type = (ushort) (204 + WorldGen.genRand.Next(4));
          else if (tile1.type == (ushort) 1 && tile2.wall == (ushort) 0)
            type = !WorldGen.remixWorldGen ? ((double) point.Y >= GenVars.rockLayer ? (point.Y >= GenVars.lavaLine ? (ushort) (208 + WorldGen.genRand.Next(4)) : (ushort) (212 + WorldGen.genRand.Next(4))) : (ushort) (196 + WorldGen.genRand.Next(4))) : ((double) point.Y <= GenVars.rockLayer ? (point.Y <= GenVars.lavaLine || WorldGen.genRand.Next(2) != 0 ? (ushort) (212 + WorldGen.genRand.Next(4)) : (ushort) (208 + WorldGen.genRand.Next(4))) : (ushort) (196 + WorldGen.genRand.Next(4)));
          if (tile1.active() && type != (ushort) 0 && !tile2.active())
          {
            bool foundInvalidTile = false;
            bool flag;
            if (tile1.type == (ushort) 60)
              flag = WorldUtils.Gen(new Point(point.X, point.Y - 1), (GenShape) new ShapeFloodFill(1000), Actions.Chain((GenAction) new Modifiers.IsNotSolid(), new Actions.Blank().Output(data), (GenAction) new Actions.ContinueWrapper(Actions.Chain((GenAction) new Modifiers.IsTouching(true, new ushort[6]
              {
                (ushort) 147,
                (ushort) 161,
                (ushort) 396,
                (ushort) 397,
                (ushort) 70,
                (ushort) 191
              }), (GenAction) new Actions.Custom((GenBase.CustomPerUnitAction) ((x, y, args) =>
              {
                foundInvalidTile = true;
                return true;
              }))))));
            else
              flag = WorldUtils.Gen(new Point(point.X, point.Y - 1), (GenShape) new ShapeFloodFill(1000), Actions.Chain((GenAction) new Modifiers.IsNotSolid(), new Actions.Blank().Output(data), (GenAction) new Actions.ContinueWrapper(Actions.Chain((GenAction) new Modifiers.IsTouching(true, new ushort[7]
              {
                (ushort) 60,
                (ushort) 147,
                (ushort) 161,
                (ushort) 396,
                (ushort) 397,
                (ushort) 70,
                (ushort) 191
              }), (GenAction) new Modifiers.IsTouching(true, new ushort[6]
              {
                (ushort) 147,
                (ushort) 161,
                (ushort) 396,
                (ushort) 397,
                (ushort) 70,
                (ushort) 191
              }), (GenAction) new Actions.Custom((GenBase.CustomPerUnitAction) ((x, y, args) =>
              {
                foundInvalidTile = true;
                return true;
              }))))));
            if (data.Count > 50 & flag && !foundInvalidTile)
            {
              WorldUtils.Gen(new Point(point.X, point.Y), (GenShape) new ModShapes.OuterOutline(data, useInterior: true), Actions.Chain((GenAction) new Modifiers.SkipWalls(new ushort[1]
              {
                (ushort) 87
              }), (GenAction) new Actions.PlaceWall(type)));
              --num214;
            }
            data.Clear();
          }
        }
      }));
      WorldGen.AddGenerationPass("Life Crystals", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.getGoodWorldGen)
          Main.tileSolid[56] = false;
        if (WorldGen.notTheBees)
          WorldGen.NotTheBees();
        progress.Message = Lang.gen[28].Value;
        double num216 = (double) (Main.maxTilesX * Main.maxTilesY) * 2E-05;
        if (WorldGen.tenthAnniversaryWorldGen)
          num216 *= 1.2;
        if (Main.starGame)
          num216 *= Main.starGameMath(0.2);
        for (int index = 0; index < (int) num216; ++index)
        {
          double num217 = (double) index / ((double) (Main.maxTilesX * Main.maxTilesY) * 2E-05);
          progress.Set(num217);
          bool flag = false;
          int num218 = 0;
          while (!flag)
          {
            int j = WorldGen.genRand.Next((int) (Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300);
            if (WorldGen.remixWorldGen)
              j = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 400);
            if (WorldGen.AddLifeCrystal(WorldGen.genRand.Next(Main.offLimitBorderTiles, Main.maxTilesX - Main.offLimitBorderTiles), j))
            {
              flag = true;
            }
            else
            {
              ++num218;
              if (num218 >= 10000)
                flag = true;
            }
          }
        }
        Main.tileSolid[225] = false;
      }));
      WorldGen.AddGenerationPass("Statues", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[29].Value;
        int index148 = 0;
        double num219 = (double) Main.maxTilesX / 4200.0;
        int num220 = (int) ((double) (GenVars.statueList.Length * 2) * num219);
        if (WorldGen.noTrapsWorldGen)
        {
          num220 *= 15;
          if (WorldGen.tenthAnniversaryWorldGen || WorldGen.notTheBees)
            num220 /= 5;
        }
        if (Main.starGame)
          num220 = (int) ((double) num220 * Main.starGameMath(0.2));
        for (int index149 = 0; index149 < num220; ++index149)
        {
          if (index148 >= GenVars.statueList.Length)
            index148 = 0;
          int x = (int) GenVars.statueList[index148].X;
          int y3 = (int) GenVars.statueList[index148].Y;
          double num221 = (double) (index149 / num220);
          progress.Set(num221);
          bool flag = false;
          int num222 = 0;
          while (!flag)
          {
            int index150 = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
            int y4 = WorldGen.genRand.Next((int) (Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300);
            if (WorldGen.remixWorldGen)
              WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 400);
            while (WorldGen.oceanDepths(index150, y4))
            {
              index150 = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
              y4 = WorldGen.genRand.Next((int) (Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300);
              if (WorldGen.remixWorldGen)
                WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 400);
            }
            while (!Main.tile[index150, y4].active())
            {
              ++y4;
              if (y4 >= Main.maxTilesY)
                break;
            }
            if (y4 < Main.maxTilesY)
            {
              int index151 = y4 - 1;
              if (!Main.tile[index150, index151].shimmer())
                WorldGen.PlaceTile(index150, index151, x, true, true, style: y3);
              if (Main.tile[index150, index151].active() && (int) Main.tile[index150, index151].type == x)
              {
                flag = true;
                if (GenVars.StatuesWithTraps.Contains(index148))
                  WorldGen.PlaceStatueTrap(index150, index151);
                ++index148;
              }
              else
              {
                ++num222;
                if (num222 >= 10000)
                  flag = true;
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Buried Chests", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[30].Value;
        Main.tileSolid[226] = true;
        Main.tileSolid[162] = true;
        Main.tileSolid[225] = true;
        CaveHouseBiome biome = GenVars.configuration.CreateBiome<CaveHouseBiome>();
        int random1 = passConfig.Get<WorldGenRange>("CaveHouseCount").GetRandom(WorldGen.genRand);
        int random2 = passConfig.Get<WorldGenRange>("UnderworldChestCount").GetRandom(WorldGen.genRand);
        int num223 = passConfig.Get<WorldGenRange>("CaveChestCount").GetRandom(WorldGen.genRand);
        int random3 = passConfig.Get<WorldGenRange>("AdditionalDesertHouseCount").GetRandom(WorldGen.genRand);
        if (Main.starGame)
          num223 = (int) ((double) num223 * Main.starGameMath(0.2));
        int num224 = random1 + random2 + num223 + random3;
        int num225 = 10000;
        for (int index152 = 0; index152 < num223 && num225 > 0; ++index152)
        {
          progress.Set((double) index152 / (double) num224);
          int index153 = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
          int index154 = WorldGen.genRand.Next((int) ((GenVars.worldSurfaceHigh + 20.0 + Main.rockLayer) / 2.0), Main.maxTilesY - 230);
          if (WorldGen.remixWorldGen)
            index154 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 400);
          ushort wall = Main.tile[index153, index154].wall;
          if (Main.wallDungeon[(int) wall] || wall == (ushort) 87 || WorldGen.oceanDepths(index153, index154) || !WorldGen.AddBuriedChest(index153, index154))
          {
            --num225;
            --index152;
          }
        }
        int num226 = 10000;
        for (int index = 0; index < random2 && num226 > 0; ++index)
        {
          progress.Set((double) (index + num223) / (double) num224);
          int i = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
          int j = WorldGen.genRand.Next(Main.UnderworldLayer, Main.maxTilesY - 50);
          if (Main.wallDungeon[(int) Main.tile[i, j].wall] || !WorldGen.AddBuriedChest(i, j))
          {
            --num226;
            --index;
          }
        }
        int num227 = 10000;
        for (int index = 0; index < random1 && num227 > 0; ++index)
        {
          progress.Set((double) (index + num223 + random2) / (double) num224);
          int x = WorldGen.genRand.Next(80, Main.maxTilesX - 80);
          int y = WorldGen.genRand.Next((int) (GenVars.worldSurfaceHigh + 20.0), Main.maxTilesY - 230);
          if (WorldGen.remixWorldGen)
            y = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 400);
          if (WorldGen.oceanDepths(x, y) || !biome.Place(new Point(x, y), GenVars.structures))
          {
            --num227;
            --index;
          }
        }
        int num228 = 10000;
        Microsoft.Xna.Framework.Rectangle desertHiveLocation = GenVars.UndergroundDesertHiveLocation;
        if ((double) desertHiveLocation.Y < Main.worldSurface + 26.0)
        {
          int num229 = (int) Main.worldSurface + 26 - desertHiveLocation.Y;
          desertHiveLocation.Y += num229;
          desertHiveLocation.Height -= num229;
        }
        for (int index = 0; index < random3 && num228 > 0; ++index)
        {
          progress.Set((double) (index + num223 + random2 + random1) / (double) num224);
          if (!biome.Place(WorldGen.RandomRectanglePoint(desertHiveLocation), GenVars.structures))
          {
            --num228;
            --index;
          }
        }
        Main.tileSolid[226] = false;
        Main.tileSolid[162] = false;
        Main.tileSolid[225] = false;
      }));
      WorldGen.AddGenerationPass("Surface Chests", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[31].Value;
        for (int index155 = 0; index155 < (int) ((double) Main.maxTilesX * 0.005); ++index155)
        {
          double num230 = (double) index155 / ((double) Main.maxTilesX * 0.005);
          progress.Set(num230);
          bool flag22 = false;
          int num231 = 0;
          while (!flag22)
          {
            int index156 = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
            int index157 = WorldGen.genRand.Next((int) GenVars.worldSurfaceLow, (int) Main.worldSurface);
            if (WorldGen.remixWorldGen)
            {
              index157 = WorldGen.genRand.Next(Main.maxTilesY - 400, Main.maxTilesY - 150);
            }
            else
            {
              for (; WorldGen.oceanDepths(index156, index157); index157 = WorldGen.genRand.Next((int) GenVars.worldSurfaceLow, (int) Main.worldSurface))
                index156 = WorldGen.genRand.Next(300, Main.maxTilesX - 300);
            }
            bool flag23 = false;
            if (!Main.tile[index156, index157].active())
            {
              if (Main.tile[index156, index157].wall == (ushort) 2 || Main.tile[index156, index157].wall == (ushort) 59 || Main.tile[index156, index157].wall == (ushort) 244 || WorldGen.remixWorldGen)
                flag23 = true;
            }
            else
            {
              int num232 = 50;
              int num233 = index156;
              int num234 = index157;
              int maxValue = 1;
              for (int index158 = num233 - num232; index158 <= num233 + num232; index158 += 2)
              {
                for (int index159 = num234 - num232; index159 <= num234 + num232; index159 += 2)
                {
                  if ((double) index159 < Main.worldSurface && !Main.tile[index158, index159].active() && Main.tile[index158, index159].wall == (ushort) 244 && WorldGen.genRand.Next(maxValue) == 0)
                  {
                    ++maxValue;
                    flag23 = true;
                    index156 = index158;
                    index157 = index159;
                  }
                }
              }
            }
            if (flag23 && WorldGen.AddBuriedChest(index156, index157, notNearOtherChests: true))
            {
              flag22 = true;
            }
            else
            {
              ++num231;
              if (num231 >= 2000)
                flag22 = true;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Jungle Chests Placement", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[32].Value;
        for (int index160 = 0; index160 < GenVars.numJChests; ++index160)
        {
          double num = (double) index160 / (double) GenVars.numJChests;
          progress.Set(num);
          int nextJungleChestItem = WorldGen.GetNextJungleChestItem();
          if (!WorldGen.AddBuriedChest(GenVars.JChestX[index160] + WorldGen.genRand.Next(2), GenVars.JChestY[index160], nextJungleChestItem, Style: 10))
          {
            for (int i = GenVars.JChestX[index160] - 1; i <= GenVars.JChestX[index160] + 1; ++i)
            {
              for (int j = GenVars.JChestY[index160]; j <= GenVars.JChestY[index160] + 2; ++j)
                WorldGen.KillTile(i, j);
            }
            for (int index161 = GenVars.JChestX[index160] - 1; index161 <= GenVars.JChestX[index160] + 1; ++index161)
            {
              for (int index162 = GenVars.JChestY[index160]; index162 <= GenVars.JChestY[index160] + 3; ++index162)
              {
                if (index162 < Main.maxTilesY)
                {
                  Main.tile[index161, index162].slope((byte) 0);
                  Main.tile[index161, index162].halfBrick(false);
                }
              }
            }
            WorldGen.AddBuriedChest(GenVars.JChestX[index160], GenVars.JChestY[index160], nextJungleChestItem, Style: 10);
          }
        }
      }));
      WorldGen.AddGenerationPass("Water Chests", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[33].Value;
        for (int index = 0; index < GenVars.numOceanCaveTreasure; ++index)
        {
          int contain = (int) WorldGen.genRand.NextFromList<short>((short) 863, (short) 186, (short) 277, (short) 187, (short) 4404);
          bool flag = false;
          double num235 = 2.0;
          while (!flag && num235 < 50.0)
          {
            num235 += 0.1;
            int num236 = WorldGen.genRand.Next(GenVars.oceanCaveTreasure[index].X - (int) num235, GenVars.oceanCaveTreasure[index].X + (int) num235 + 1);
            int j = WorldGen.genRand.Next(GenVars.oceanCaveTreasure[index].Y - (int) num235 / 2, GenVars.oceanCaveTreasure[index].Y + (int) num235 / 2 + 1);
            int i = num236 >= Main.maxTilesX ? (int) ((double) num236 + num235 / 2.0) : (int) ((double) num236 - num235 / 2.0);
            if (Main.tile[i, j].liquid > (byte) 250 && (Main.tile[i, j].liquidType() == (byte) 0 || WorldGen.notTheBees || WorldGen.remixWorldGen))
              flag = WorldGen.AddBuriedChest(i, j, contain, Style: 17, trySlope: true);
          }
        }
        int num237 = 0;
        double num238 = (double) Main.maxTilesX / 4200.0;
        for (int index = 0; (double) index < 9.0 * num238; ++index)
        {
          double num239 = (double) index / (9.0 * num238);
          progress.Set(num239);
          ++num237;
          int maxValue = 10;
          if (WorldGen.tenthAnniversaryWorldGen)
            maxValue = 7;
          int contain;
          if (WorldGen.genRand.Next(maxValue) == 0)
          {
            contain = 863;
          }
          else
          {
            switch (num237)
            {
              case 1:
                contain = 186;
                break;
              case 2:
                contain = 4404;
                break;
              case 3:
                contain = 277;
                break;
              default:
                contain = 187;
                num237 = 0;
                break;
            }
          }
          bool flag24 = false;
          int num240 = 0;
          while (!flag24)
          {
            int i = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
            int j;
            for (j = WorldGen.genRand.Next(1, Main.UnderworldLayer); Main.tile[i, j].liquid < (byte) 250 || Main.tile[i, j].liquidType() != (byte) 0 && !WorldGen.notTheBees && !WorldGen.remixWorldGen; j = WorldGen.genRand.Next(50, Main.UnderworldLayer))
              i = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
            flag24 = WorldGen.AddBuriedChest(i, j, contain, Style: 17, trySlope: (i < WorldGen.beachDistance || i > Main.maxTilesX - WorldGen.beachDistance));
            ++num240;
            if (num240 > 10000)
              break;
          }
          bool flag25 = false;
          int num241 = 0;
          while (!flag25)
          {
            int i = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
            int j;
            for (j = WorldGen.genRand.Next((int) Main.worldSurface, Main.UnderworldLayer); Main.tile[i, j].liquid < (byte) 250 || Main.tile[i, j].liquidType() != (byte) 0 && !WorldGen.notTheBees; j = WorldGen.genRand.Next((int) Main.worldSurface, Main.UnderworldLayer))
              i = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
            flag25 = WorldGen.AddBuriedChest(i, j, contain, Style: 17, trySlope: (i < WorldGen.beachDistance || i > Main.maxTilesX - WorldGen.beachDistance));
            ++num241;
            if (num241 > 10000)
              break;
          }
        }
      }));
      WorldGen.AddGenerationPass("Spider Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[64].Value;
        WorldGen.maxTileCount = 3500;
        int num242 = Main.maxTilesX / 2;
        int num243 = (int) ((double) Main.maxTilesX * 0.005);
        if (WorldGen.getGoodWorldGen)
          num243 *= 3;
        if (WorldGen.notTheBees)
          Main.tileSolid[225] = true;
        for (int index = 0; index < num243; ++index)
        {
          double num244 = (double) index / ((double) Main.maxTilesX * 0.005);
          progress.Set(num244);
          int num245 = 0;
          int x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
          int y = WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 230);
          if (WorldGen.remixWorldGen)
            y = WorldGen.genRand.Next((int) Main.worldSurface, (int) Main.rockLayer);
          int num246 = WorldGen.countTiles(x, y, lavaOk: true);
          while ((num246 >= 3500 || num246 < 500) && num245 < num242)
          {
            ++num245;
            x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
            y = WorldGen.genRand.Next((int) Main.rockLayer + 30, Main.maxTilesY - 230);
            if (WorldGen.remixWorldGen)
              y = WorldGen.genRand.Next((int) Main.worldSurface, (int) Main.rockLayer);
            num246 = WorldGen.countTiles(x, y, lavaOk: true);
            if (WorldGen.shroomCount > 1)
              num246 = 0;
          }
          if (num245 < num242)
            WorldGen.Spread.Spider(x, y);
        }
        if (WorldGen.notTheBees)
          Main.tileSolid[225] = false;
        Main.tileSolid[162] = true;
      }));
      WorldGen.AddGenerationPass("Gem Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.notTheBees)
          return;
        progress.Message = Lang.gen[64].Value;
        WorldGen.maxTileCount = 300;
        double num247 = (double) Main.maxTilesX * 0.003;
        if (WorldGen.tenthAnniversaryWorldGen)
          num247 *= 1.5;
        if (Main.starGame)
          num247 *= Main.starGameMath(0.2);
        for (int index163 = 0; (double) index163 < num247; ++index163)
        {
          double num248 = (double) index163 / num247;
          progress.Set(num248);
          int num249 = 0;
          int x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
          int y = WorldGen.genRand.Next((int) Main.rockLayer + 30, Main.maxTilesY - 230);
          if (WorldGen.remixWorldGen)
            y = WorldGen.genRand.Next((int) Main.worldSurface + 30, (int) Main.rockLayer - 30);
          for (int index164 = WorldGen.countTiles(x, y); (index164 >= 300 || index164 < 50 || WorldGen.lavaCount > 0 || WorldGen.iceCount > 0 || WorldGen.rockCount == 0) && num249 < 1000; index164 = WorldGen.countTiles(x, y))
          {
            ++num249;
            x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
            y = WorldGen.genRand.Next((int) Main.rockLayer + 30, Main.maxTilesY - 230);
            if (WorldGen.remixWorldGen)
              y = WorldGen.genRand.Next((int) Main.worldSurface + 30, (int) Main.rockLayer - 30);
          }
          if (num249 < 1000)
            WorldGen.gemCave(x, y);
        }
      }));
      WorldGen.AddGenerationPass("Moss", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.notTheBees && !WorldGen.remixWorldGen)
          return;
        progress.Message = Lang.gen[61].Value;
        WorldGen.randMoss();
        int num250 = Main.maxTilesX / 2100;
        if (WorldGen.remixWorldGen)
          num250 = (int) ((double) num250 * 1.5);
        else if (WorldGen.tenthAnniversaryWorldGen)
          num250 *= 2;
        int num251 = 0;
        int num252 = 0;
        while (num252 < num250)
        {
          int i = WorldGen.genRand.Next(100, Main.maxTilesX - 100);
          if (WorldGen.remixWorldGen)
            i = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.3), (int) ((double) Main.maxTilesX * 0.7));
          else if (WorldGen.tenthAnniversaryWorldGen)
          {
            if (WorldGen.genRand.Next(2) == 0)
              WorldGen.randMoss(true);
          }
          else if (WorldGen.getGoodWorldGen)
          {
            while ((double) i > (double) Main.maxTilesX * 0.42 && (double) i < (double) Main.maxTilesX * 0.48)
              i = WorldGen.genRand.Next(100, Main.maxTilesX - 100);
          }
          else if (!WorldGen.drunkWorldGen)
          {
            while ((double) i > (double) Main.maxTilesX * 0.38 && (double) i < (double) Main.maxTilesX * 0.62)
              i = WorldGen.genRand.Next(100, Main.maxTilesX - 100);
          }
          int j = !WorldGen.remixWorldGen ? WorldGen.genRand.Next((int) Main.rockLayer + 40, GenVars.lavaLine - 40) : WorldGen.genRand.Next((int) Main.worldSurface + 50, (int) Main.rockLayer - 50);
          bool flag = false;
          int num253 = 50;
          for (int index165 = i - num253; index165 <= i + num253; ++index165)
          {
            for (int index166 = j - num253; index166 <= j + num253; ++index166)
            {
              if (Main.tile[index165, index166].active())
              {
                int type = (int) Main.tile[index165, index166].type;
                if (WorldGen.remixWorldGen)
                {
                  if (type == 60 || type == 161 || type == 147 || Main.tileDungeon[type] || type == 25 || type == 203)
                  {
                    flag = true;
                    index165 = i + num253 + 1;
                    break;
                  }
                }
                else if (type == 70 || type == 60 || type == 367 || type == 368 || type == 161 || type == 147 || type == 396 || type == 397 || Main.tileDungeon[type])
                {
                  flag = true;
                  index165 = i + num253 + 1;
                  break;
                }
              }
            }
          }
          if (flag)
          {
            ++num251;
            if (num251 > Main.maxTilesX)
              ++num252;
          }
          else
          {
            num251 = 0;
            ++num252;
            int maxY = GenVars.lavaLine;
            if (WorldGen.remixWorldGen)
              maxY = (int) Main.rockLayer + 50;
            WorldGen.neonMossBiome(i, j, maxY);
          }
        }
        WorldGen.maxTileCount = 2500;
        for (int index167 = 0; index167 < (int) ((double) Main.maxTilesX * 0.01); ++index167)
        {
          double num254 = (double) index167 / ((double) Main.maxTilesX * 0.01);
          progress.Set(num254);
          int num255 = 0;
          int x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
          int y = WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, GenVars.waterLine);
          if (WorldGen.remixWorldGen)
            y = WorldGen.genRand.Next((int) Main.worldSurface, (int) Main.rockLayer);
          if (Vector2D.Distance(new Vector2D((double) x, (double) y), GenVars.shimmerPosition) >= (double) WorldGen.shimmerSafetyDistance)
          {
            for (int index168 = WorldGen.countTiles(x, y); (index168 >= 2500 || index168 < 10 || WorldGen.lavaCount > 0 || WorldGen.iceCount > 0 || WorldGen.rockCount == 0 || WorldGen.shroomCount > 0) && num255 < 1000; index168 = WorldGen.countTiles(x, y))
            {
              ++num255;
              x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
              y = WorldGen.genRand.Next((int) Main.rockLayer + 30, Main.maxTilesY - 230);
            }
            if (num255 < 1000)
            {
              WorldGen.setMoss(x, y);
              WorldGen.Spread.Moss(x, y);
            }
          }
        }
        for (int index = 0; index < Main.maxTilesX; ++index)
        {
          int x = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
          int y = !WorldGen.remixWorldGen ? WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, GenVars.lavaLine) : WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 300);
          if (Vector2D.Distance(new Vector2D((double) x, (double) y), GenVars.shimmerPosition) >= (double) WorldGen.shimmerSafetyDistance && Main.tile[x, y].type == (ushort) 1)
          {
            WorldGen.setMoss(x, y);
            Main.tile[x, y].type = GenVars.mossTile;
          }
        }
        double num256 = (double) Main.maxTilesX * 0.05;
        while (num256 > 0.0)
        {
          int x = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
          int y = !WorldGen.remixWorldGen ? WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, GenVars.lavaLine) : WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 300);
          if (Vector2D.Distance(new Vector2D((double) x, (double) y), GenVars.shimmerPosition) >= (double) WorldGen.shimmerSafetyDistance && Main.tile[x, y].type == (ushort) 1 && (!Main.tile[x - 1, y].active() || !Main.tile[x + 1, y].active() || !Main.tile[x, y - 1].active() || !Main.tile[x, y + 1].active()))
          {
            WorldGen.setMoss(x, y);
            Main.tile[x, y].type = GenVars.mossTile;
            --num256;
          }
        }
        double num257 = (double) Main.maxTilesX * 0.065;
        if (WorldGen.remixWorldGen)
          num257 *= 2.0;
        for (; num257 > 0.0; num257 -= 0.001)
        {
          int index169 = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
          int index170 = !WorldGen.remixWorldGen ? WorldGen.genRand.Next(GenVars.waterLine, Main.UnderworldLayer) : WorldGen.genRand.Next(GenVars.lavaLine, (int) Main.rockLayer + 50);
          if (Main.tile[index169, index170].type == (ushort) 1 && (!Main.tile[index169 - 1, index170].active() || !Main.tile[index169 + 1, index170].active() || !Main.tile[index169, index170 - 1].active() || !Main.tile[index169, index170 + 1].active()))
          {
            int num258 = 25;
            int num259 = 0;
            for (int index171 = index169 - num258; index171 < index169 + num258; ++index171)
            {
              for (int index172 = index170 - num258; index172 < index170 + num258; ++index172)
              {
                if (Main.tile[index171, index172].liquid > (byte) 0 && Main.tile[index171, index172].lava())
                  ++num259;
              }
            }
            if (num259 > 20)
            {
              Main.tile[index169, index170].type = (ushort) 381;
              --num257;
            }
            else
              num257 -= 0.002;
          }
        }
        for (int index173 = 0; index173 < Main.maxTilesX; ++index173)
        {
          for (int index174 = 0; index174 < Main.maxTilesY; ++index174)
          {
            if (Main.tile[index173, index174].active() && Main.tileMoss[(int) Main.tile[index173, index174].type])
            {
              for (int index175 = 0; index175 < 4; ++index175)
              {
                int i = index173;
                int j = index174;
                if (index175 == 0)
                  --i;
                if (index175 == 1)
                  ++i;
                if (index175 == 2)
                  --j;
                if (index175 == 3)
                  ++j;
                try
                {
                  WorldGen.grassSpread = 0;
                  WorldGen.SpreadGrass(i, j, 1, (int) Main.tile[index173, index174].type);
                }
                catch
                {
                  WorldGen.grassSpread = 0;
                  WorldGen.SpreadGrass(i, j, 1, (int) Main.tile[index173, index174].type, false);
                }
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Temple", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        Main.tileSolid[162] = false;
        Main.tileSolid[226] = true;
        WorldGen.templePart2();
        Main.tileSolid[232] = false;
      }));
      WorldGen.AddGenerationPass("Cave Walls", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[63].Value;
        WorldGen.maxTileCount = 1500;
        for (int index176 = 0; index176 < (int) ((double) Main.maxTilesX * 0.04); ++index176)
        {
          double num260 = (double) index176 / ((double) Main.maxTilesX * 0.04);
          progress.Set(num260 * 0.66);
          int num261 = 0;
          int x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
          int y = WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 220);
          if (WorldGen.remixWorldGen)
            y = WorldGen.genRand.Next((int) Main.worldSurface + 25, (int) Main.rockLayer);
          for (int index177 = WorldGen.countTiles(x, y, lavaOk: true); (index177 >= WorldGen.maxTileCount || index177 < 10) && num261 < 500; index177 = WorldGen.countTiles(x, y, lavaOk: true))
          {
            ++num261;
            x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
            y = WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 220);
            if (WorldGen.remixWorldGen)
              y = WorldGen.genRand.Next((int) Main.worldSurface + 25, (int) Main.rockLayer);
          }
          if (num261 < 500)
          {
            int wallType = WorldGen.genRand.Next(2);
            if ((double) WorldGen.shroomCount > (double) WorldGen.rockCount * 0.75)
              wallType = 80;
            else if (WorldGen.iceCount > 0)
            {
              switch (wallType)
              {
                case 0:
                  wallType = 40;
                  break;
                case 1:
                  wallType = 71;
                  break;
              }
            }
            else if (WorldGen.lavaCount > 0)
            {
              wallType = 79;
            }
            else
            {
              wallType = WorldGen.genRand.Next(4);
              switch (wallType)
              {
                case 0:
                  wallType = 59;
                  break;
                case 1:
                  wallType = 61;
                  break;
                case 2:
                  wallType = 170;
                  break;
                case 3:
                  wallType = 171;
                  break;
              }
            }
            WorldGen.Spread.Wall(x, y, wallType);
          }
        }
        if (WorldGen.remixWorldGen)
        {
          WorldGen.maxTileCount = 1500;
          for (int index178 = 0; index178 < (int) ((double) Main.maxTilesX * 0.04); ++index178)
          {
            double num262 = (double) index178 / ((double) Main.maxTilesX * 0.04);
            progress.Set(num262 * 0.66);
            int num263 = 0;
            int x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
            int y = WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY - 350);
            for (int index179 = WorldGen.countTiles(x, y, lavaOk: true); (index179 >= WorldGen.maxTileCount || index179 < 10) && num263 < 500; index179 = WorldGen.countTiles(x, y, lavaOk: true))
            {
              ++num263;
              x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
              y = WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY - 350);
            }
            if (num263 < 500 && WorldGen.iceCount == 0 && WorldGen.lavaCount == 0 && WorldGen.sandCount == 0)
            {
              int wallType = WorldGen.genRand.Next(2) != 0 ? 63 : 2;
              WorldGen.Spread.Wall(x, y, wallType);
            }
          }
        }
        WorldGen.maxTileCount = 1500;
        double num264 = (double) Main.maxTilesX * 0.02;
        for (int index = 0; (double) index < num264; ++index)
        {
          double num265 = (double) index / ((double) Main.maxTilesX * 0.02);
          progress.Set(num265 * 0.33 + 0.66);
          int num266 = 0;
          int x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
          int y = WorldGen.genRand.Next((int) Main.worldSurface, GenVars.lavaLine);
          int num267 = 0;
          if (Main.tile[x, y].wall == (ushort) 64)
            num267 = WorldGen.countTiles(x, y, true);
          while ((num267 >= WorldGen.maxTileCount || num267 < 10) && num266 < 1000)
          {
            ++num266;
            x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
            y = WorldGen.genRand.Next((int) Main.worldSurface, GenVars.lavaLine);
            if (!Main.wallHouse[(int) Main.tile[x, y].wall] && Main.tile[x, y].wall != (ushort) 244)
              num267 = Main.tile[x, y].wall != (ushort) 64 ? 0 : WorldGen.countTiles(x, y, true);
          }
          if (num266 < 1000)
            WorldGen.Spread.Wall2(x, y, 15);
        }
      }));
      WorldGen.AddGenerationPass("Jungle Trees", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[83].Value;
        for (int i = 0; i < Main.maxTilesX; ++i)
        {
          progress.Set((double) i / (double) Main.maxTilesX);
          for (int y = (int) Main.worldSurface - 1; y < Main.maxTilesY - 350; ++y)
          {
            if (WorldGen.genRand.Next(10) == 0 || WorldGen.drunkWorldGen)
              WorldGen.GrowUndergroundTree(i, y);
          }
        }
      }));
      WorldGen.AddGenerationPass("Floating Island Houses", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        for (int index = 0; index < GenVars.numIslandHouses; ++index)
        {
          if (!GenVars.skyLake[index])
            WorldGen.IslandHouse(GenVars.floatingIslandHouseX[index], GenVars.floatingIslandHouseY[index], GenVars.floatingIslandStyle[index]);
        }
      }));
      WorldGen.AddGenerationPass("Quick Cleanup", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        if (WorldGen.notTheBees)
          WorldGen.NotTheBees();
        Main.tileSolid[137] = false;
        Main.tileSolid[130] = false;
        for (int index180 = 20; index180 < Main.maxTilesX - 20; ++index180)
        {
          for (int y = 20; y < Main.maxTilesY - 20; ++y)
          {
            if ((double) y < Main.worldSurface && WorldGen.oceanDepths(index180, y) && Main.tile[index180, y].type == (ushort) 53 && Main.tile[index180, y].active())
            {
              if (Main.tile[index180, y].bottomSlope())
                Main.tile[index180, y].slope((byte) 0);
              for (int index181 = y + 1; index181 < y + WorldGen.genRand.Next(4, 7) && (!Main.tile[index180, index181].active() || Main.tile[index180, index181].type != (ushort) 397 && Main.tile[index180, index181].type != (ushort) 53) && (!Main.tile[index180, index181 + 1].active() || Main.tile[index180, index181 + 1].type != (ushort) 397 && Main.tile[index180, index181 + 1].type != (ushort) 53 && Main.tile[index180, index181 + 1].type != (ushort) 495) && (!Main.tile[index180, index181 + 2].active() || Main.tile[index180, index181 + 2].type != (ushort) 397 && Main.tile[index180, index181 + 2].type != (ushort) 53 && Main.tile[index180, index181 + 2].type != (ushort) 495); ++index181)
              {
                Main.tile[index180, index181].type = (ushort) 0;
                Main.tile[index180, index181].active(true);
                Main.tile[index180, index181].halfBrick(false);
                Main.tile[index180, index181].slope((byte) 0);
              }
            }
            if (Main.tile[index180, y].wall == (ushort) 187 || Main.tile[index180, y].wall == (ushort) 216)
            {
              if (Main.tile[index180, y].type == (ushort) 59 || Main.tile[index180, y].type == (ushort) 123 || Main.tile[index180, y].type == (ushort) 224)
                Main.tile[index180, y].type = (ushort) 397;
              if (Main.tile[index180, y].type == (ushort) 368 || Main.tile[index180, y].type == (ushort) 367)
                Main.tile[index180, y].type = (ushort) 397;
              if ((double) y <= Main.rockLayer)
                Main.tile[index180, y].liquid = (byte) 0;
              else if (Main.tile[index180, y].liquid > (byte) 0)
              {
                Main.tile[index180, y].liquid = byte.MaxValue;
                Main.tile[index180, y].lava(true);
              }
            }
            if ((double) y < Main.worldSurface && Main.tile[index180, y].active() && Main.tile[index180, y].type == (ushort) 53 && Main.tile[index180, y + 1].wall == (ushort) 0 && !WorldGen.SolidTile(index180, y + 1))
            {
              ushort num268 = 0;
              int num269 = 3;
              for (int index182 = index180 - num269; index182 <= index180 + num269; ++index182)
              {
                for (int index183 = y - num269; index183 <= y + num269; ++index183)
                {
                  if (Main.tile[index182, index183].wall > (ushort) 0)
                  {
                    num268 = Main.tile[index182, index183].wall;
                    break;
                  }
                }
              }
              if (num268 > (ushort) 0)
              {
                Main.tile[index180, y + 1].wall = num268;
                if (Main.tile[index180, y].wall == (ushort) 0)
                  Main.tile[index180, y].wall = num268;
              }
            }
            if (Main.tile[index180, y].type != (ushort) 19 && TileID.Sets.CanBeClearedDuringGeneration[(int) Main.tile[index180, y].type])
            {
              if (Main.tile[index180, y].topSlope() || Main.tile[index180, y].halfBrick())
              {
                if (Main.tile[index180, y].type != (ushort) 225 || !Main.tile[index180, y].halfBrick())
                {
                  if (!WorldGen.SolidTile(index180, y + 1))
                    Main.tile[index180, y].active(false);
                  if (Main.tile[index180 + 1, y].type == (ushort) 137 || Main.tile[index180 - 1, y].type == (ushort) 137)
                    Main.tile[index180, y].active(false);
                }
              }
              else if (Main.tile[index180, y].bottomSlope())
              {
                if (!WorldGen.SolidTile(index180, y - 1))
                  Main.tile[index180, y].active(false);
                if (Main.tile[index180 + 1, y].type == (ushort) 137 || Main.tile[index180 - 1, y].type == (ushort) 137)
                  Main.tile[index180, y].active(false);
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Pots", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        Main.tileSolid[137] = true;
        Main.tileSolid[130] = true;
        progress.Message = Lang.gen[35].Value;
        if (WorldGen.noTrapsWorldGen)
        {
          Main.tileSolid[138] = true;
          int num = (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0004);
          if (WorldGen.remixWorldGen)
            num /= 2;
          for (int index184 = 0; index184 < num; ++index184)
          {
            int i = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
            int index185 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 250);
            while (!Main.tile[i, index185].active() && index185 < Main.maxTilesY - 250)
              ++index185;
            int j = index185 - 1;
            if (!Main.tile[i, j].shimmer())
            {
              WorldGen.PlaceTile(i, j, 138, true);
              WorldGen.PlaceTile(i + 2, j, 138, true);
              WorldGen.PlaceTile(i + 1, j - 2, 138, true);
            }
          }
          Main.tileSolid[138] = false;
        }
        double num270 = (double) (Main.maxTilesX * Main.maxTilesY) * 0.0008;
        if (Main.starGame)
          num270 *= Main.starGameMath(0.2);
        for (int index = 0; (double) index < num270; ++index)
        {
          double num271 = (double) index / num270;
          progress.Set(num271);
          bool flag26 = false;
          int num272 = 0;
          while (!flag26)
          {
            int num273 = WorldGen.genRand.Next((int) GenVars.worldSurfaceHigh, Main.maxTilesY - 10);
            if (num271 > 0.93)
              num273 = Main.maxTilesY - 150;
            else if (num271 > 0.75)
              num273 = (int) GenVars.worldSurfaceLow;
            int x = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
            bool flag27 = false;
            for (int y = num273; y < Main.maxTilesY - 20; ++y)
            {
              if (!flag27)
              {
                if (Main.tile[x, y].active() && Main.tileSolid[(int) Main.tile[x, y].type] && !Main.tile[x, y - 1].lava() && !Main.tile[x, y - 1].shimmer())
                  flag27 = true;
              }
              else if ((double) y >= Main.worldSurface || Main.tile[x, y].wall != (ushort) 0)
              {
                int style = WorldGen.genRand.Next(0, 4);
                int num274 = 0;
                int num275 = 0;
                if (y < Main.maxTilesY - 5)
                {
                  num274 = (int) Main.tile[x, y + 1].type;
                  num275 = (int) Main.tile[x, y].wall;
                }
                if (num274 == 147 || num274 == 161 || num274 == 162)
                  style = WorldGen.genRand.Next(4, 7);
                if (num274 == 60)
                  style = WorldGen.genRand.Next(7, 10);
                if (Main.wallDungeon[(int) Main.tile[x, y].wall])
                  style = WorldGen.genRand.Next(10, 13);
                if (num274 == 41 || num274 == 43 || num274 == 44 || num274 == 481 || num274 == 482 || num274 == 483)
                  style = WorldGen.genRand.Next(10, 13);
                if (num274 == 22 || num274 == 23 || num274 == 25)
                  style = WorldGen.genRand.Next(16, 19);
                if (num274 == 199 || num274 == 203 || num274 == 204 || num274 == 200)
                  style = WorldGen.genRand.Next(22, 25);
                if (num274 == 367)
                  style = WorldGen.genRand.Next(31, 34);
                if (num274 == 226)
                  style = WorldGen.genRand.Next(28, 31);
                if (num275 == 187 || num275 == 216)
                  style = WorldGen.genRand.Next(34, 37);
                if (y > Main.UnderworldLayer)
                  style = WorldGen.genRand.Next(13, 16);
                if (!WorldGen.oceanDepths(x, y) && !Main.tile[x, y].shimmer() && WorldGen.PlacePot(x, y, style: style))
                {
                  flag26 = true;
                  break;
                }
                ++num272;
                if (num272 >= 10000)
                {
                  flag26 = true;
                  break;
                }
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Hellforge", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[36].Value;
        for (int index186 = 0; index186 < Main.maxTilesX / 200; ++index186)
        {
          double num276 = (double) index186 / (double) (Main.maxTilesX / 200);
          progress.Set(num276);
          bool flag = false;
          int num277 = 0;
          while (!flag)
          {
            int i = WorldGen.genRand.Next(1, Main.maxTilesX);
            int index187 = WorldGen.genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 30);
            try
            {
              if (Main.tile[i, index187].wall != (ushort) 13)
              {
                if (Main.tile[i, index187].wall != (ushort) 14)
                  continue;
              }
              while (!Main.tile[i, index187].active() && index187 < Main.maxTilesY - 20)
                ++index187;
              int j = index187 - 1;
              WorldGen.PlaceTile(i, j, 77);
              if (Main.tile[i, j].type == (ushort) 77)
              {
                flag = true;
              }
              else
              {
                ++num277;
                if (num277 >= 10000)
                  flag = true;
              }
            }
            catch
            {
              ++num277;
              if (num277 >= 10000)
                flag = true;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Spreading Grass", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.notTheBees && !WorldGen.remixWorldGen)
          return;
        progress.Message = Lang.gen[37].Value;
        for (int index188 = 50; index188 < Main.maxTilesX - 50; ++index188)
        {
          for (int index189 = 50; (double) index189 <= Main.worldSurface; ++index189)
          {
            if (Main.tile[index188, index189].active())
            {
              int type = (int) Main.tile[index188, index189].type;
              if (Main.tile[index188, index189].active() && type == 60)
              {
                for (int index190 = index188 - 1; index190 <= index188 + 1; ++index190)
                {
                  for (int index191 = index189 - 1; index191 <= index189 + 1; ++index191)
                  {
                    if (Main.tile[index190, index191].active() && Main.tile[index190, index191].type == (ushort) 0)
                      Main.tile[index190, index191].type = Main.tile[index190, index191 - 1].active() ? (ushort) 59 : (ushort) 60;
                  }
                }
              }
              else if (type == 1 || type == 40 || TileID.Sets.Ore[type])
              {
                int num278 = 3;
                bool flag = false;
                ushort num279 = 0;
                for (int index192 = index188 - num278; index192 <= index188 + num278; ++index192)
                {
                  for (int index193 = index189 - num278; index193 <= index189 + num278; ++index193)
                  {
                    if (Main.tile[index192, index193].active())
                    {
                      if (Main.tile[index192, index193].type == (ushort) 53 || num279 == (ushort) 53)
                        num279 = (ushort) 53;
                      else if (Main.tile[index192, index193].type == (ushort) 59 || Main.tile[index192, index193].type == (ushort) 60 || Main.tile[index192, index193].type == (ushort) 147 || Main.tile[index192, index193].type == (ushort) 161 || Main.tile[index192, index193].type == (ushort) 199 || Main.tile[index192, index193].type == (ushort) 23)
                        num279 = Main.tile[index192, index193].type;
                    }
                    else if (index193 < index189 && Main.tile[index192, index193].wall == (ushort) 0)
                      flag = true;
                  }
                }
                if (flag)
                {
                  switch (num279)
                  {
                    case 23:
                    case 199:
                      if (Main.tile[index188, index189 - 1].active())
                      {
                        num279 = (ushort) 0;
                        break;
                      }
                      break;
                    case 59:
                    case 60:
                      if (index188 >= GenVars.jungleMinX && index188 <= GenVars.jungleMaxX)
                      {
                        num279 = Main.tile[index188, index189 - 1].active() ? (ushort) 59 : (ushort) 60;
                        break;
                      }
                      break;
                  }
                  Main.tile[index188, index189].type = num279;
                }
              }
            }
          }
        }
        for (int i = 10; i < Main.maxTilesX - 10; ++i)
        {
          bool flag = true;
          for (int j = 0; (double) j < Main.worldSurface - 1.0; ++j)
          {
            if (Main.tile[i, j].active())
            {
              if (flag)
              {
                if (Main.tile[i, j].type == (ushort) 0)
                {
                  try
                  {
                    WorldGen.grassSpread = 0;
                    WorldGen.SpreadGrass(i, j);
                  }
                  catch
                  {
                    WorldGen.grassSpread = 0;
                    WorldGen.SpreadGrass(i, j, repeat: false);
                  }
                }
              }
              if ((double) j <= GenVars.worldSurfaceHigh)
                flag = false;
              else
                break;
            }
            else if (Main.tile[i, j].wall == (ushort) 0)
              flag = true;
          }
        }
        if (!WorldGen.remixWorldGen)
          return;
        for (int index194 = 5; index194 < Main.maxTilesX - 5; ++index194)
        {
          for (int index195 = (int) GenVars.rockLayerLow + WorldGen.genRand.Next(-1, 2); index195 < Main.maxTilesY - 200; ++index195)
          {
            if (Main.tile[index194, index195].type == (ushort) 0 && Main.tile[index194, index195].active() && (!Main.tile[index194 - 1, index195 - 1].active() || !Main.tile[index194, index195 - 1].active() || !Main.tile[index194 + 1, index195 - 1].active() || !Main.tile[index194 - 1, index195].active() || !Main.tile[index194 + 1, index195].active() || !Main.tile[index194 - 1, index195 + 1].active() || !Main.tile[index194, index195 + 1].active() || !Main.tile[index194 + 1, index195 + 1].active()))
              Main.tile[index194, index195].type = (ushort) 2;
          }
        }
        for (int i = 5; i < Main.maxTilesX - 5; ++i)
        {
          for (int index = (int) GenVars.rockLayerLow + WorldGen.genRand.Next(-1, 2); index < Main.maxTilesY - 200; ++index)
          {
            if (Main.tile[i, index].type == (ushort) 2 && !Main.tile[i, index - 1].active() && WorldGen.genRand.Next(20) == 0)
              WorldGen.PlaceTile(i, index - 1, 27, true);
          }
        }
        int conversionType = 1;
        if (WorldGen.crimson)
          conversionType = 4;
        int num280 = Main.maxTilesX / 7;
        for (int i = 10; i < Main.maxTilesX - 10; ++i)
        {
          for (int j = 10; j < Main.maxTilesY - 10; ++j)
          {
            if ((double) j < Main.worldSurface + (double) WorldGen.genRand.Next(3) || i < num280 + WorldGen.genRand.Next(3) || i >= Main.maxTilesX - num280 - WorldGen.genRand.Next(3))
            {
              if (WorldGen.drunkWorldGen)
              {
                if (GenVars.crimsonLeft)
                {
                  if (i < Main.maxTilesX / 2 + WorldGen.genRand.Next(-2, 3))
                    WorldGen.Convert(i, j, 4, 1);
                  else
                    WorldGen.Convert(i, j, 1, 1);
                }
                else if (i < Main.maxTilesX / 2 + WorldGen.genRand.Next(-2, 3))
                  WorldGen.Convert(i, j, 1, 1);
                else
                  WorldGen.Convert(i, j, 4, 1);
              }
              else
                WorldGen.Convert(i, j, conversionType, 1);
              Main.tile[i, j].color((byte) 0);
              Main.tile[i, j].wallColor((byte) 0);
            }
          }
        }
        if (!WorldGen.remixWorldGen)
          return;
        Main.tileSolid[225] = true;
        int num281 = (int) ((double) Main.maxTilesX * 0.31);
        int num282 = (int) ((double) Main.maxTilesX * 0.69);
        int maxTilesY1 = Main.maxTilesY;
        int num283 = Main.maxTilesY - 135;
        int maxTilesY2 = Main.maxTilesY;
        Liquid.QuickWater(-2);
        for (int index196 = num281; index196 < num282 + 15; ++index196)
        {
          for (int index197 = Main.maxTilesY - 200; index197 < num283; ++index197)
            Main.tile[index196, index197].liquid = (byte) 0;
        }
        Main.tileSolid[225] = false;
        Main.tileSolid[484] = false;
      }));
      WorldGen.AddGenerationPass("Surface Ore and Stone", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        int num284 = WorldGen.genRand.Next(Main.maxTilesX * 5 / 4200, Main.maxTilesX * 10 / 4200);
        for (int index198 = 0; index198 < num284; ++index198)
        {
          int num285 = Main.maxTilesX / 420;
          while (num285 > 0)
          {
            --num285;
            int X = WorldGen.genRand.Next(WorldGen.beachDistance, Main.maxTilesX - WorldGen.beachDistance);
            while ((double) X >= (double) Main.maxTilesX * 0.48 && (double) X <= (double) Main.maxTilesX * 0.52)
              X = WorldGen.genRand.Next(WorldGen.beachDistance, Main.maxTilesX - WorldGen.beachDistance);
            int Y = WorldGen.genRand.Next((int) GenVars.worldSurfaceLow, (int) GenVars.worldSurface);
            bool flag = false;
            for (int index199 = 0; index199 < GenVars.numOrePatch; ++index199)
            {
              if (Math.Abs(X - GenVars.orePatchX[index199]) < 200)
                flag = true;
            }
            if (!flag && WorldGen.OrePatch(X, Y))
            {
              if (GenVars.numOrePatch < GenVars.maxOrePatch - 1)
              {
                GenVars.orePatchX[GenVars.numOrePatch] = X;
                ++GenVars.numOrePatch;
                break;
              }
              break;
            }
          }
        }
        int num286 = WorldGen.genRand.Next(1, Main.maxTilesX * 7 / 4200);
        for (int index200 = 0; index200 < num286; ++index200)
        {
          int num287 = Main.maxTilesX / 420;
          while (num287 > 0)
          {
            --num287;
            int X = WorldGen.genRand.Next(WorldGen.beachDistance, Main.maxTilesX - WorldGen.beachDistance);
            while ((double) X >= (double) Main.maxTilesX * 0.47 && (double) X <= (double) Main.maxTilesX * 0.53)
              X = WorldGen.genRand.Next(WorldGen.beachDistance, Main.maxTilesX - WorldGen.beachDistance);
            int Y = WorldGen.genRand.Next((int) GenVars.worldSurfaceLow, (int) GenVars.worldSurface);
            bool flag = false;
            for (int index201 = 0; index201 < GenVars.numOrePatch; ++index201)
            {
              if (Math.Abs(X - GenVars.orePatchX[index201]) < 100)
                flag = true;
            }
            if (!flag && WorldGen.StonePatch(X, Y))
              break;
          }
        }
      }));
      WorldGen.AddGenerationPass("Place Fallen Log", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[85].Value;
        int num288 = Main.maxTilesX / 2100;
        int num289 = !WorldGen.remixWorldGen ? num288 + WorldGen.genRand.Next(-1, 2) : num288 + WorldGen.genRand.Next(0, 2);
        for (int index202 = 0; index202 < num289; ++index202)
        {
          progress.Set((double) index202 / (double) num289);
          int minValue = WorldGen.beachDistance + 20;
          int num290 = 50000;
          int num291 = 5000;
          while (num290 > 0)
          {
            --num290;
            int i = WorldGen.genRand.Next(minValue, Main.maxTilesX - minValue);
            int index203 = WorldGen.genRand.Next(10, (int) Main.worldSurface);
            if (WorldGen.remixWorldGen)
              index203 = WorldGen.genRand.Next((int) GenVars.rockLayerLow, Main.maxTilesY - 350);
            bool flag28 = false;
            if (num290 < num291)
              flag28 = true;
            if (num290 > num291 / 2)
            {
              while ((double) i > (double) Main.maxTilesX * 0.4 && (double) i < (double) Main.maxTilesX * 0.6)
                i = WorldGen.genRand.Next(minValue, Main.maxTilesX - minValue);
            }
            if (!Main.tile[i, index203].active() && Main.tile[i, index203].wall == (ushort) 0)
            {
              bool flag29 = true;
              if (WorldGen.remixWorldGen)
              {
                while (!Main.tile[i, index203].active() && Main.tile[i, index203].wall == (ushort) 0 && index203 <= Main.maxTilesY - 350)
                  ++index203;
              }
              else
              {
                while (!Main.tile[i, index203].active() && Main.tile[i, index203].wall == (ushort) 0 && (double) index203 <= Main.worldSurface)
                  ++index203;
              }
              if ((double) index203 > Main.worldSurface - 10.0 && !WorldGen.remixWorldGen)
                flag29 = false;
              else if (!flag28)
              {
                int num292 = 50;
                for (int index204 = i - num292; index204 < i + num292; ++index204)
                {
                  if (index204 > 10 && index204 < Main.maxTilesX - 10)
                  {
                    for (int index205 = index203 - num292; index205 < index203 + num292; ++index205)
                    {
                      if (index205 > 10 && index205 < Main.maxTilesY - 10)
                      {
                        int type = (int) Main.tile[index204, index205].type;
                        switch (type)
                        {
                          case 53:
                            flag29 = false;
                            continue;
                          case 189:
                            flag29 = false;
                            continue;
                          default:
                            if (Main.tileDungeon[type])
                            {
                              flag29 = false;
                              continue;
                            }
                            if (TileID.Sets.Crimson[type])
                            {
                              flag29 = false;
                              continue;
                            }
                            if (TileID.Sets.Corrupt[type])
                              flag29 = false;
                            continue;
                        }
                      }
                    }
                  }
                }
                if (flag29)
                {
                  int num293 = 10;
                  int num294 = 10;
                  for (int index206 = i - num293; index206 < i + num293; ++index206)
                  {
                    for (int index207 = index203 - num294; index207 < index203 - 1; ++index207)
                    {
                      if (Main.tile[index206, index207].active() && Main.tileSolid[(int) Main.tile[index206, index207].type])
                        flag29 = false;
                      if (Main.tile[index206, index207].wall != (ushort) 0)
                        flag29 = false;
                    }
                  }
                }
              }
              if (flag29 && (Main.tile[i, index203 - 1].liquid == (byte) 0 || num290 < num291 / 5) && (Main.tile[i, index203].type == (ushort) 2 || WorldGen.notTheBees && Main.tile[i, index203].type == (ushort) 60) && (Main.tile[i - 1, index203].type == (ushort) 2 || WorldGen.notTheBees && Main.tile[i - 1, index203].type == (ushort) 60) && (Main.tile[i + 1, index203].type == (ushort) 2 || WorldGen.notTheBees && Main.tile[i + 1, index203].type == (ushort) 60))
              {
                int j = index203 - 1;
                WorldGen.PlaceTile(i, j, 488);
                if (Main.tile[i, j].active() && Main.tile[i, j].type == (ushort) 488)
                {
                  if (WorldGen.genRand.Next(2) == 0)
                  {
                    GenVars.logX = i;
                    GenVars.logY = j;
                  }
                  num290 = -1;
                }
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Traps", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.notTheBees && !WorldGen.noTrapsWorldGen && !WorldGen.remixWorldGen)
          return;
        WorldGen.placingTraps = true;
        progress.Message = Lang.gen[34].Value;
        if (WorldGen.noTrapsWorldGen)
          progress.Message = Lang.gen[91].Value;
        double num295 = (double) Main.maxTilesX * 0.05;
        if (WorldGen.noTrapsWorldGen)
        {
          if (WorldGen.tenthAnniversaryWorldGen || WorldGen.notTheBees)
            num295 *= 5.0;
          else
            num295 *= 100.0;
        }
        else if (WorldGen.getGoodWorldGen)
          num295 *= 1.5;
        if (Main.starGame)
          num295 *= Main.starGameMath(0.2);
        for (int index208 = 0; (double) index208 < num295; ++index208)
        {
          progress.Set((double) index208 / num295 / 2.0);
          for (int index209 = 0; index209 < 1150; ++index209)
          {
            if (WorldGen.noTrapsWorldGen)
            {
              int x2 = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
              int y2 = WorldGen.genRand.Next(50, Main.maxTilesY - 50);
              if (WorldGen.remixWorldGen)
                y2 = WorldGen.genRand.Next(50, Main.maxTilesY - 210);
              if (((double) y2 > Main.worldSurface || Main.tile[x2, y2].wall > (ushort) 0) && WorldGen.placeTrap(x2, y2))
                break;
            }
            else
            {
              int index210 = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
              int index211;
              for (index211 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 210); WorldGen.oceanDepths(index210, index211); index211 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 210))
                index210 = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
              if (Main.tile[index210, index211].wall == (ushort) 0 && WorldGen.placeTrap(index210, index211))
                break;
            }
          }
        }
        if (WorldGen.noTrapsWorldGen)
        {
          double num296 = (double) (Main.maxTilesX * 3);
          if (Main.remixWorld)
            num296 = (double) (Main.maxTilesX / 3);
          if (Main.starGame)
            num296 *= Main.starGameMath(0.2);
          for (int index = 0; (double) index < num296; ++index)
          {
            if (Main.remixWorld)
              WorldGen.placeTNTBarrel(WorldGen.genRand.Next(50, Main.maxTilesX - 50), WorldGen.genRand.Next((int) Main.worldSurface, (int) ((double) (Main.maxTilesY - 350) + Main.rockLayer) / 2));
            else
              WorldGen.placeTNTBarrel(WorldGen.genRand.Next(50, Main.maxTilesX - 50), WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY - 200));
          }
        }
        double num297 = (double) Main.maxTilesX * 0.003;
        if (WorldGen.noTrapsWorldGen)
          num297 *= 5.0;
        else if (WorldGen.getGoodWorldGen)
          num297 *= 1.5;
        for (int index212 = 0; (double) index212 < num297; ++index212)
        {
          progress.Set((double) index212 / num297 / 2.0 + 0.5);
          for (int index213 = 0; index213 < 20000; ++index213)
          {
            int i = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.15), (int) ((double) Main.maxTilesX * 0.85));
            int j = WorldGen.genRand.Next((int) Main.worldSurface + 20, Main.maxTilesY - 210);
            if (Main.tile[i, j].wall == (ushort) 187 && WorldGen.PlaceSandTrap(i, j))
              break;
          }
        }
        if (WorldGen.drunkWorldGen && !WorldGen.noTrapsWorldGen && !WorldGen.notTheBees)
        {
          for (int index214 = 0; index214 < 8; ++index214)
          {
            progress.Message = Lang.gen[34].Value;
            double num298 = 100.0;
            for (int index215 = 0; (double) index215 < num298; ++index215)
            {
              progress.Set((double) index215 / num298);
              Thread.Sleep(10);
            }
          }
        }
        if (WorldGen.noTrapsWorldGen)
          Main.tileSolid[138] = true;
        WorldGen.placingTraps = false;
      }));
      WorldGen.AddGenerationPass("Piles", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[89].Value;
        Main.tileSolid[229] = false;
        Main.tileSolid[190] = false;
        Main.tileSolid[196] = false;
        Main.tileSolid[189] = false;
        Main.tileSolid[202] = false;
        Main.tileSolid[460] = false;
        Main.tileSolid[484] = false;
        if (WorldGen.noTrapsWorldGen)
          Main.tileSolid[138] = false;
        for (int index216 = 0; (double) index216 < (double) Main.maxTilesX * 0.06; ++index216)
        {
          int num299 = Main.maxTilesX / 2;
          bool flag = false;
          while (!flag && num299 > 0)
          {
            --num299;
            int index217 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            int index218;
            for (index218 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 300); WorldGen.oceanDepths(index217, index218); index218 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 300))
              index217 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            if (!Main.tile[index217, index218].active())
            {
              int Type = 186;
              while (!Main.tile[index217, index218 + 1].active() && index218 < Main.maxTilesY - 5)
                ++index218;
              int style = WorldGen.genRand.Next(22);
              switch (style)
              {
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                  style = WorldGen.genRand.Next(22);
                  break;
              }
              if ((Main.tile[index217, index218 + 1].type == (ushort) 0 || Main.tile[index217, index218 + 1].type == (ushort) 1 || Main.tileMoss[(int) Main.tile[index217, index218 + 1].type]) && WorldGen.genRand.Next(5) == 0)
              {
                style = WorldGen.genRand.Next(23, 29);
                Type = 187;
              }
              if (index218 > Main.maxTilesY - 300 || Main.wallDungeon[(int) Main.tile[index217, index218].wall] || Main.tile[index217, index218 + 1].type == (ushort) 30 || Main.tile[index217, index218 + 1].type == (ushort) 19 || Main.tile[index217, index218 + 1].type == (ushort) 25 || Main.tile[index217, index218 + 1].type == (ushort) 203)
              {
                style = WorldGen.genRand.Next(7);
                Type = 186;
              }
              if (Main.tile[index217, index218 + 1].type == (ushort) 147 || Main.tile[index217, index218 + 1].type == (ushort) 161 || Main.tile[index217, index218 + 1].type == (ushort) 162)
              {
                style = WorldGen.genRand.Next(26, 32);
                Type = 186;
              }
              if (Main.tile[index217, index218 + 1].type == (ushort) 60)
              {
                Type = 187;
                style = WorldGen.genRand.Next(6);
              }
              if ((Main.tile[index217, index218 + 1].type == (ushort) 57 || Main.tile[index217, index218 + 1].type == (ushort) 58) && WorldGen.genRand.Next(3) < 2)
              {
                Type = 187;
                style = WorldGen.genRand.Next(6, 9);
              }
              if (Main.tile[index217, index218 + 1].type == (ushort) 226)
              {
                Type = 187;
                style = WorldGen.genRand.Next(18, 23);
              }
              if (Main.tile[index217, index218 + 1].type == (ushort) 70)
              {
                style = WorldGen.genRand.Next(32, 35);
                Type = 186;
              }
              if (Main.tile[index217, index218 + 1].type == (ushort) 396 || Main.tile[index217, index218 + 1].type == (ushort) 397 || Main.tile[index217, index218 + 1].type == (ushort) 404)
              {
                style = WorldGen.genRand.Next(29, 35);
                Type = 187;
              }
              if (Main.tile[index217, index218 + 1].type == (ushort) 368)
              {
                style = WorldGen.genRand.Next(35, 41);
                Type = 187;
              }
              if (Main.tile[index217, index218 + 1].type == (ushort) 367)
              {
                style = WorldGen.genRand.Next(41, 47);
                Type = 187;
              }
              if (Type == 186 && style >= 7 && style <= 15 && WorldGen.genRand.Next(75) == 0)
              {
                Type = 187;
                style = 17;
              }
              if (Main.wallDungeon[(int) Main.tile[index217, index218].wall] && WorldGen.genRand.Next(3) != 0)
              {
                flag = true;
              }
              else
              {
                if (!Main.tile[index217, index218].shimmer())
                  WorldGen.PlaceTile(index217, index218, Type, true, style: style);
                if (Main.tile[index217, index218].type == (ushort) 186 || Main.tile[index217, index218].type == (ushort) 187)
                  flag = true;
                if (flag && Type == 186 && style <= 7)
                {
                  int num300 = WorldGen.genRand.Next(1, 5);
                  for (int index219 = 0; index219 < num300; ++index219)
                  {
                    int i = index217 + WorldGen.genRand.Next(-10, 11);
                    int j = index218 - WorldGen.genRand.Next(5);
                    if (!Main.tile[i, j].active())
                    {
                      while (!Main.tile[i, j + 1].active() && j < Main.maxTilesY - 5)
                        ++j;
                      int X = WorldGen.genRand.Next(12, 36);
                      WorldGen.PlaceSmallPile(i, j, X, 0);
                    }
                  }
                }
              }
            }
          }
        }
        for (int index220 = 0; (double) index220 < (double) Main.maxTilesX * 0.01; ++index220)
        {
          int num301 = Main.maxTilesX / 2;
          bool flag = false;
          while (!flag && num301 > 0)
          {
            --num301;
            int i9 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            int j7 = WorldGen.genRand.Next(Main.maxTilesY - 300, Main.maxTilesY - 10);
            if (!Main.tile[i9, j7].active())
            {
              int Type = 186;
              while (!Main.tile[i9, j7 + 1].active() && j7 < Main.maxTilesY - 5)
                ++j7;
              int style = WorldGen.genRand.Next(22);
              switch (style)
              {
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                  style = WorldGen.genRand.Next(22);
                  break;
              }
              if (j7 > Main.maxTilesY - 300 || Main.wallDungeon[(int) Main.tile[i9, j7].wall] || Main.tile[i9, j7 + 1].type == (ushort) 30 || Main.tile[i9, j7 + 1].type == (ushort) 19)
                style = WorldGen.genRand.Next(7);
              if ((Main.tile[i9, j7 + 1].type == (ushort) 57 || Main.tile[i9, j7 + 1].type == (ushort) 58) && WorldGen.genRand.Next(3) < 2)
              {
                Type = 187;
                style = WorldGen.genRand.Next(6, 9);
              }
              if (Main.tile[i9, j7 + 1].type == (ushort) 147 || Main.tile[i9, j7 + 1].type == (ushort) 161 || Main.tile[i9, j7 + 1].type == (ushort) 162)
                style = WorldGen.genRand.Next(26, 32);
              WorldGen.PlaceTile(i9, j7, Type, true, style: style);
              if (Main.tile[i9, j7].type == (ushort) 186 || Main.tile[i9, j7].type == (ushort) 187)
                flag = true;
              if (flag && Type == 186 && style <= 7)
              {
                int num302 = WorldGen.genRand.Next(1, 5);
                for (int index221 = 0; index221 < num302; ++index221)
                {
                  int i10 = i9 + WorldGen.genRand.Next(-10, 11);
                  int j8 = j7 - WorldGen.genRand.Next(5);
                  if (!Main.tile[i10, j8].active())
                  {
                    while (!Main.tile[i10, j8 + 1].active() && j8 < Main.maxTilesY - 5)
                      ++j8;
                    int X = WorldGen.genRand.Next(12, 36);
                    WorldGen.PlaceSmallPile(i10, j8, X, 0);
                  }
                }
              }
            }
          }
        }
        for (int index222 = 0; (double) index222 < (double) Main.maxTilesX * 0.003; ++index222)
        {
          int num = Main.maxTilesX / 2;
          bool flag = false;
          while (!flag && num > 0)
          {
            --num;
            int Type = 186;
            int index223 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            int index224;
            for (index224 = WorldGen.genRand.Next(10, (int) Main.worldSurface); WorldGen.oceanDepths(index223, index224); index224 = WorldGen.genRand.Next(10, (int) Main.worldSurface))
              index223 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            if (!Main.tile[index223, index224].active())
            {
              while (!Main.tile[index223, index224 + 1].active() && index224 < Main.maxTilesY - 5)
                ++index224;
              int style = WorldGen.genRand.Next(7, 13);
              if (index224 > Main.maxTilesY - 300 || Main.wallDungeon[(int) Main.tile[index223, index224].wall] || Main.tile[index223, index224 + 1].type == (ushort) 30 || Main.tile[index223, index224 + 1].type == (ushort) 19 || Main.tile[index223, index224 + 1].type == (ushort) 25 || Main.tile[index223, index224 + 1].type == (ushort) 203 || Main.tile[index223, index224 + 1].type == (ushort) 234 || Main.tile[index223, index224 + 1].type == (ushort) 112)
                style = -1;
              if (Main.tile[index223, index224 + 1].type == (ushort) 147 || Main.tile[index223, index224 + 1].type == (ushort) 161 || Main.tile[index223, index224 + 1].type == (ushort) 162)
                style = WorldGen.genRand.Next(26, 32);
              if (Main.tile[index223, index224 + 1].type == (ushort) 53)
              {
                Type = 187;
                style = WorldGen.genRand.Next(52, 55);
              }
              if (Main.tile[index223, index224 + 1].type == (ushort) 2 || Main.tile[index223 - 1, index224 + 1].type == (ushort) 2 || Main.tile[index223 + 1, index224 + 1].type == (ushort) 2)
              {
                Type = 187;
                style = WorldGen.genRand.Next(14, 17);
              }
              if (Main.tile[index223, index224 + 1].type == (ushort) 151 || Main.tile[index223, index224 + 1].type == (ushort) 274)
              {
                Type = 186;
                style = WorldGen.genRand.Next(7);
              }
              if (style >= 0)
                WorldGen.PlaceTile(index223, index224, Type, true, style: style);
              if ((int) Main.tile[index223, index224].type == Type)
                flag = true;
            }
          }
        }
        for (int index225 = 0; (double) index225 < (double) Main.maxTilesX * 0.0035; ++index225)
        {
          int num303 = Main.maxTilesX / 2;
          bool flag = false;
          while (!flag && num303 > 0)
          {
            --num303;
            int i11 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            int j9 = WorldGen.genRand.Next(10, (int) Main.worldSurface);
            if (!Main.tile[i11, j9].active() && Main.tile[i11, j9].wall > (ushort) 0)
            {
              int Type = 186;
              while (!Main.tile[i11, j9 + 1].active() && j9 < Main.maxTilesY - 5)
                ++j9;
              int style = WorldGen.genRand.Next(7, 13);
              if (j9 > Main.maxTilesY - 300 || Main.wallDungeon[(int) Main.tile[i11, j9].wall] || Main.tile[i11, j9 + 1].type == (ushort) 30 || Main.tile[i11, j9 + 1].type == (ushort) 19)
                style = -1;
              if (Main.tile[i11, j9 + 1].type == (ushort) 25)
                style = WorldGen.genRand.Next(7);
              if (Main.tile[i11, j9 + 1].type == (ushort) 147 || Main.tile[i11, j9 + 1].type == (ushort) 161 || Main.tile[i11, j9 + 1].type == (ushort) 162)
                style = WorldGen.genRand.Next(26, 32);
              if (Main.tile[i11, j9 + 1].type == (ushort) 2 || Main.tile[i11 - 1, j9 + 1].type == (ushort) 2 || Main.tile[i11 + 1, j9 + 1].type == (ushort) 2)
              {
                Type = 187;
                style = WorldGen.genRand.Next(14, 17);
              }
              if (Main.tile[i11, j9 + 1].type == (ushort) 151 || Main.tile[i11, j9 + 1].type == (ushort) 274)
              {
                Type = 186;
                style = WorldGen.genRand.Next(7);
              }
              if (style >= 0)
                WorldGen.PlaceTile(i11, j9, Type, true, style: style);
              if ((int) Main.tile[i11, j9].type == Type)
                flag = true;
              if (flag && style <= 7)
              {
                int num304 = WorldGen.genRand.Next(1, 5);
                for (int index226 = 0; index226 < num304; ++index226)
                {
                  int i12 = i11 + WorldGen.genRand.Next(-10, 11);
                  int j10 = j9 - WorldGen.genRand.Next(5);
                  if (!Main.tile[i12, j10].active())
                  {
                    while (!Main.tile[i12, j10 + 1].active() && j10 < Main.maxTilesY - 5)
                      ++j10;
                    int X = WorldGen.genRand.Next(12, 36);
                    WorldGen.PlaceSmallPile(i12, j10, X, 0);
                  }
                }
              }
            }
          }
        }
        for (int index227 = 0; (double) index227 < (double) Main.maxTilesX * 0.6; ++index227)
        {
          int num305 = Main.maxTilesX / 2;
          bool flag = false;
          while (!flag && num305 > 0)
          {
            --num305;
            int index228 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            int index229 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 20);
            if (Main.tile[index228, index229].wall == (ushort) 87 && WorldGen.genRand.Next(2) == 0)
            {
              index228 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
              index229 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 20);
            }
            for (; WorldGen.oceanDepths(index228, index229); index229 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 20))
              index228 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            if (!Main.tile[index228, index229].active())
            {
              while (!Main.tile[index228, index229 + 1].active() && index229 < Main.maxTilesY - 5)
                ++index229;
              int Y = WorldGen.genRand.Next(2);
              int X1 = WorldGen.genRand.Next(36);
              switch (X1)
              {
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                  X1 = WorldGen.genRand.Next(36);
                  break;
              }
              if (Y == 1)
              {
                X1 = WorldGen.genRand.Next(25);
                switch (X1)
                {
                  case 16:
                  case 17:
                  case 18:
                  case 19:
                  case 20:
                  case 21:
                  case 22:
                  case 23:
                  case 24:
                    X1 = WorldGen.genRand.Next(25);
                    break;
                }
              }
              if (index229 > Main.maxTilesY - 300)
              {
                if (Y == 0)
                  X1 = WorldGen.genRand.Next(12, 28);
                if (Y == 1)
                  X1 = WorldGen.genRand.Next(6, 16);
              }
              if (Main.wallDungeon[(int) Main.tile[index228, index229].wall] || Main.tile[index228, index229 + 1].type == (ushort) 30 || Main.tile[index228, index229 + 1].type == (ushort) 19 || Main.tile[index228, index229 + 1].type == (ushort) 25 || Main.tile[index228, index229 + 1].type == (ushort) 203 || Main.tile[index228, index229].wall == (ushort) 87)
              {
                if (Y == 0 && X1 < 12)
                  X1 += 12;
                if (Y == 1 && X1 < 6)
                  X1 += 6;
                if (Y == 1 && X1 >= 17)
                  X1 -= 10;
              }
              if (Main.tile[index228, index229 + 1].type == (ushort) 147 || Main.tile[index228, index229 + 1].type == (ushort) 161 || Main.tile[index228, index229 + 1].type == (ushort) 162)
              {
                if (Y == 0 && X1 < 12)
                  X1 += 36;
                if (Y == 1 && X1 >= 20)
                  X1 += 6;
                if (Y == 1 && X1 < 6)
                  X1 += 25;
              }
              if (Main.tile[index228, index229 + 1].type == (ushort) 151 || Main.tile[index228, index229 + 1].type == (ushort) 274)
              {
                if (Y == 0)
                  X1 = WorldGen.genRand.Next(12, 28);
                if (Y == 1)
                  X1 = WorldGen.genRand.Next(12, 19);
              }
              if (Main.tile[index228, index229 + 1].type == (ushort) 368)
              {
                if (Y == 0)
                  X1 = WorldGen.genRand.Next(60, 66);
                if (Y == 1)
                  X1 = WorldGen.genRand.Next(47, 53);
              }
              if (Main.tile[index228, index229 + 1].type == (ushort) 367)
              {
                if (Y == 0)
                  X1 = WorldGen.genRand.Next(66, 72);
                if (Y == 1)
                  X1 = WorldGen.genRand.Next(53, 59);
              }
              if (Main.wallDungeon[(int) Main.tile[index228, index229].wall] && WorldGen.genRand.Next(3) != 0)
                flag = true;
              else if (!Main.tile[index228, index229].shimmer())
                flag = WorldGen.PlaceSmallPile(index228, index229, X1, Y);
              if (flag && Y == 1 && X1 >= 6 && X1 <= 15)
              {
                int num306 = WorldGen.genRand.Next(1, 5);
                for (int index230 = 0; index230 < num306; ++index230)
                {
                  int i = index228 + WorldGen.genRand.Next(-10, 11);
                  int j = index229 - WorldGen.genRand.Next(5);
                  if (!Main.tile[i, j].active())
                  {
                    while (!Main.tile[i, j + 1].active() && j < Main.maxTilesY - 5)
                      ++j;
                    int X2 = WorldGen.genRand.Next(12, 36);
                    WorldGen.PlaceSmallPile(i, j, X2, 0);
                  }
                }
              }
            }
          }
        }
        for (int index231 = 0; (double) index231 < (double) Main.maxTilesX * 0.02; ++index231)
        {
          int num = Main.maxTilesX / 2;
          bool flag = false;
          while (!flag && num > 0)
          {
            --num;
            int index232 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            int index233;
            for (index233 = WorldGen.genRand.Next(15, (int) Main.worldSurface); WorldGen.oceanDepths(index232, index233); index233 = WorldGen.genRand.Next(15, (int) Main.worldSurface))
              index232 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            if (!Main.tile[index232, index233].active())
            {
              while (!Main.tile[index232, index233 + 1].active() && index233 < Main.maxTilesY - 5)
                ++index233;
              int Y = WorldGen.genRand.Next(2);
              int X = WorldGen.genRand.Next(11);
              if (Y == 1)
                X = WorldGen.genRand.Next(5);
              if (Main.tile[index232, index233 + 1].type == (ushort) 147 || Main.tile[index232, index233 + 1].type == (ushort) 161 || Main.tile[index232, index233 + 1].type == (ushort) 162)
              {
                if (Y == 0 && X < 12)
                  X += 36;
                if (Y == 1 && X >= 20)
                  X += 6;
                if (Y == 1 && X < 6)
                  X += 25;
              }
              if (Main.tile[index232, index233 + 1].type == (ushort) 2 && Y == 1)
                X = WorldGen.genRand.Next(38, 41);
              if (Main.tile[index232, index233 + 1].type == (ushort) 151 || Main.tile[index232, index233 + 1].type == (ushort) 274)
              {
                if (Y == 0)
                  X = WorldGen.genRand.Next(12, 28);
                if (Y == 1)
                  X = WorldGen.genRand.Next(12, 19);
              }
              if (!Main.wallDungeon[(int) Main.tile[index232, index233].wall] && Main.tile[index232, index233 + 1].type != (ushort) 30 && Main.tile[index232, index233 + 1].type != (ushort) 19 && Main.tile[index232, index233 + 1].type != (ushort) 41 && Main.tile[index232, index233 + 1].type != (ushort) 43 && Main.tile[index232, index233 + 1].type != (ushort) 44 && Main.tile[index232, index233 + 1].type != (ushort) 481 && Main.tile[index232, index233 + 1].type != (ushort) 482 && Main.tile[index232, index233 + 1].type != (ushort) 483 && Main.tile[index232, index233 + 1].type != (ushort) 45 && Main.tile[index232, index233 + 1].type != (ushort) 46 && Main.tile[index232, index233 + 1].type != (ushort) 47 && Main.tile[index232, index233 + 1].type != (ushort) 175 && Main.tile[index232, index233 + 1].type != (ushort) 176 && Main.tile[index232, index233 + 1].type != (ushort) 177 && Main.tile[index232, index233 + 1].type != (ushort) 53 && Main.tile[index232, index233 + 1].type != (ushort) 25 && Main.tile[index232, index233 + 1].type != (ushort) 203)
                flag = WorldGen.PlaceSmallPile(index232, index233, X, Y);
            }
          }
        }
        for (int index = 0; (double) index < (double) Main.maxTilesX * 0.15; ++index)
        {
          int num = Main.maxTilesX / 2;
          bool flag = false;
          while (!flag && num > 0)
          {
            --num;
            int i = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            int j = WorldGen.genRand.Next(15, (int) Main.worldSurface);
            if (!Main.tile[i, j].active() && (Main.tile[i, j].wall == (ushort) 2 || Main.tile[i, j].wall == (ushort) 40))
            {
              while (!Main.tile[i, j + 1].active() && j < Main.maxTilesY - 5)
                ++j;
              int Y = WorldGen.genRand.Next(2);
              int X = WorldGen.genRand.Next(11);
              if (Y == 1)
                X = WorldGen.genRand.Next(5);
              if (Main.tile[i, j + 1].type == (ushort) 147 || Main.tile[i, j + 1].type == (ushort) 161 || Main.tile[i, j + 1].type == (ushort) 162)
              {
                if (Y == 0 && X < 12)
                  X += 36;
                if (Y == 1 && X >= 20)
                  X += 6;
                if (Y == 1 && X < 6)
                  X += 25;
              }
              if (Main.tile[i, j + 1].type == (ushort) 2 && Y == 1)
                X = WorldGen.genRand.Next(38, 41);
              if (Main.tile[i, j + 1].type == (ushort) 151 || Main.tile[i, j + 1].type == (ushort) 274)
              {
                if (Y == 0)
                  X = WorldGen.genRand.Next(12, 28);
                if (Y == 1)
                  X = WorldGen.genRand.Next(12, 19);
              }
              if ((Main.tile[i, j].liquid != byte.MaxValue || Main.tile[i, j + 1].type != (ushort) 53 || Main.tile[i, j].wall != (ushort) 0) && !Main.wallDungeon[(int) Main.tile[i, j].wall] && Main.tile[i, j + 1].type != (ushort) 30 && Main.tile[i, j + 1].type != (ushort) 19 && Main.tile[i, j + 1].type != (ushort) 41 && Main.tile[i, j + 1].type != (ushort) 43 && Main.tile[i, j + 1].type != (ushort) 44 && Main.tile[i, j + 1].type != (ushort) 481 && Main.tile[i, j + 1].type != (ushort) 482 && Main.tile[i, j + 1].type != (ushort) 483 && Main.tile[i, j + 1].type != (ushort) 45 && Main.tile[i, j + 1].type != (ushort) 46 && Main.tile[i, j + 1].type != (ushort) 47 && Main.tile[i, j + 1].type != (ushort) 175 && Main.tile[i, j + 1].type != (ushort) 176 && Main.tile[i, j + 1].type != (ushort) 177 && Main.tile[i, j + 1].type != (ushort) 25 && Main.tile[i, j + 1].type != (ushort) 203)
                flag = WorldGen.PlaceSmallPile(i, j, X, Y);
            }
          }
        }
        Main.tileSolid[190] = true;
        Main.tileSolid[192] = true;
        Main.tileSolid[196] = true;
        Main.tileSolid[189] = true;
        Main.tileSolid[202] = true;
        Main.tileSolid[225] = true;
        Main.tileSolid[460] = true;
        Main.tileSolid[138] = true;
      }));
      WorldGen.AddGenerationPass("Spawn Point", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        int num307 = 5;
        bool flag = true;
        int num308 = Main.maxTilesX / 2;
        if (Main.tenthAnniversaryWorld && !WorldGen.remixWorldGen)
        {
          int num309 = GenVars.beachBordersWidth + 15;
          num308 = WorldGen.genRand.Next(2) != 0 ? Main.maxTilesX - num309 : num309;
        }
        while (flag)
        {
          int index234 = num308 + WorldGen.genRand.Next(-num307, num307 + 1);
          for (int index235 = 0; index235 < Main.maxTilesY; ++index235)
          {
            if (Main.tile[index234, index235].active())
            {
              Main.spawnTileX = index234;
              Main.spawnTileY = index235;
              break;
            }
          }
          flag = false;
          ++num307;
          if ((double) Main.spawnTileY > Main.worldSurface)
            flag = true;
          if (Main.tile[Main.spawnTileX, Main.spawnTileY - 1].liquid > (byte) 0)
            flag = true;
        }
        int num310 = 10;
        while ((double) Main.spawnTileY > Main.worldSurface)
        {
          int index236 = WorldGen.genRand.Next(num308 - num310, num308 + num310);
          for (int index237 = 0; index237 < Main.maxTilesY; ++index237)
          {
            if (Main.tile[index236, index237].active())
            {
              Main.spawnTileX = index236;
              Main.spawnTileY = index237;
              break;
            }
          }
          ++num310;
        }
        if (!WorldGen.remixWorldGen)
          return;
        int j = Main.maxTilesY - 10;
        while (WorldGen.SolidTile(Main.spawnTileX, j))
          --j;
        Main.spawnTileY = j + 1;
      }));
      WorldGen.AddGenerationPass("Grass Wall", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        WorldGen.maxTileCount = 3500;
        progress.Set(1.0);
        for (int index238 = 50; index238 < Main.maxTilesX - 50; ++index238)
        {
          for (int index239 = 0; (double) index239 < Main.worldSurface - 10.0; ++index239)
          {
            if (WorldGen.genRand.Next(4) == 0)
            {
              bool flag = false;
              int x = -1;
              int y = -1;
              if (Main.tile[index238, index239].active() && Main.tile[index238, index239].type == (ushort) 2 && (Main.tile[index238, index239].wall == (ushort) 2 || Main.tile[index238, index239].wall == (ushort) 63))
              {
                for (int i = index238 - 1; i <= index238 + 1; ++i)
                {
                  for (int j = index239 - 1; j <= index239 + 1; ++j)
                  {
                    if (Main.tile[i, j].wall == (ushort) 0 && !WorldGen.SolidTile(i, j))
                      flag = true;
                  }
                }
                if (flag)
                {
                  for (int i = index238 - 1; i <= index238 + 1; ++i)
                  {
                    for (int j = index239 - 1; j <= index239 + 1; ++j)
                    {
                      if ((Main.tile[i, j].wall == (ushort) 2 || Main.tile[i, j].wall == (ushort) 15) && !WorldGen.SolidTile(i, j))
                      {
                        x = i;
                        y = j;
                      }
                    }
                  }
                }
              }
              if (flag && x > -1 && y > -1)
              {
                if (WorldGen.countDirtTiles(x, y) < WorldGen.maxTileCount)
                {
                  try
                  {
                    ushort wallType = 63;
                    if (WorldGen.dontStarveWorldGen && WorldGen.genRand.Next(3) != 0)
                      wallType = (ushort) 62;
                    WorldGen.Spread.Wall2(x, y, (int) wallType);
                  }
                  catch
                  {
                  }
                }
              }
            }
          }
        }
        for (int i = 5; i < Main.maxTilesX - 5; ++i)
        {
          for (int j = 10; (double) j < Main.worldSurface - 1.0; ++j)
          {
            if (Main.tile[i, j].wall == (ushort) 63 && WorldGen.genRand.Next(10) == 0)
              Main.tile[i, j].wall = (ushort) 65;
            if (Main.tile[i, j].active() && Main.tile[i, j].type == (ushort) 0)
            {
              bool flag = false;
              for (int index240 = i - 1; index240 <= i + 1; ++index240)
              {
                for (int index241 = j - 1; index241 <= j + 1; ++index241)
                {
                  if (Main.tile[index240, index241].wall == (ushort) 63 || Main.tile[index240, index241].wall == (ushort) 65)
                  {
                    flag = true;
                    break;
                  }
                }
              }
              if (flag)
                WorldGen.SpreadGrass(i, j);
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Guide", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        if (Main.tenthAnniversaryWorld)
        {
          BirthdayParty.GenuineParty = true;
          BirthdayParty.PartyDaysOnCooldown = 5;
          if (WorldGen.getGoodWorldGen)
            Main.afterPartyOfDoom = true;
          int index242;
          if (WorldGen.remixWorldGen)
          {
            index242 = NPC.NewNPC((IEntitySource) new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 441);
            NPC.savedTaxCollector = true;
          }
          else
            index242 = NPC.NewNPC((IEntitySource) new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 22);
          Main.npc[index242].homeTileX = Main.spawnTileX;
          Main.npc[index242].homeTileY = Main.spawnTileY;
          Main.npc[index242].direction = 1;
          Main.npc[index242].homeless = true;
          Main.npc[index242].GivenName = Language.GetTextValue("GuideNames.Andrew");
          BirthdayParty.CelebratingNPCs.Add(index242);
          Point adjustedFloorPosition1 = WorldGen.GetAdjustedFloorPosition(Main.spawnTileX + 2, Main.spawnTileY);
          int index243 = NPC.NewNPC((IEntitySource) new EntitySource_WorldGen(), adjustedFloorPosition1.X * 16, adjustedFloorPosition1.Y * 16, 178);
          Main.npc[index243].homeTileX = adjustedFloorPosition1.X;
          Main.npc[index243].homeTileY = adjustedFloorPosition1.Y;
          Main.npc[index243].direction = -1;
          Main.npc[index243].homeless = true;
          Main.npc[index243].GivenName = Language.GetTextValue("SteampunkerNames.Whitney");
          BirthdayParty.CelebratingNPCs.Add(index243);
          Point adjustedFloorPosition2 = WorldGen.GetAdjustedFloorPosition(Main.spawnTileX - 2, Main.spawnTileY);
          int index244 = NPC.NewNPC((IEntitySource) new EntitySource_WorldGen(), adjustedFloorPosition2.X * 16, adjustedFloorPosition2.Y * 16, 663);
          Main.npc[index244].homeTileX = adjustedFloorPosition2.X;
          Main.npc[index244].homeTileY = adjustedFloorPosition2.Y;
          Main.npc[index244].direction = 1;
          Main.npc[index244].homeless = true;
          Main.npc[index244].GivenName = Language.GetTextValue("PrincessNames.Yorai");
          BirthdayParty.CelebratingNPCs.Add(index244);
          NPC.unlockedPrincessSpawn = true;
          Point adjustedFloorPosition3 = WorldGen.GetAdjustedFloorPosition(Main.spawnTileX + 4, Main.spawnTileY);
          int index245 = NPC.NewNPC((IEntitySource) new EntitySource_WorldGen(), adjustedFloorPosition3.X * 16, adjustedFloorPosition3.Y * 16, 208);
          Main.npc[index245].homeTileX = adjustedFloorPosition3.X;
          Main.npc[index245].homeTileY = adjustedFloorPosition3.Y;
          Main.npc[index245].direction = -1;
          Main.npc[index245].homeless = true;
          Main.npc[index245].GivenName = Language.GetTextValue("PartyGirlNames.Amanda");
          BirthdayParty.CelebratingNPCs.Add(index245);
          NPC.unlockedPartyGirlSpawn = true;
          Point adjustedFloorPosition4 = WorldGen.GetAdjustedFloorPosition(Main.spawnTileX - 4, Main.spawnTileY);
          int index246;
          if (Main.remixWorld)
          {
            index246 = NPC.NewNPC((IEntitySource) new EntitySource_WorldGen(), adjustedFloorPosition4.X * 16, adjustedFloorPosition4.Y * 16, 681);
            Main.npc[index246].GivenName = Language.GetTextValue("SlimeNames_Rainbow.Slimestar");
            NPC.unlockedSlimeRainbowSpawn = true;
          }
          else
          {
            index246 = NPC.NewNPC((IEntitySource) new EntitySource_WorldGen(), adjustedFloorPosition4.X * 16, adjustedFloorPosition4.Y * 16, 656);
            NPC.boughtBunny = true;
            Main.npc[index246].townNpcVariationIndex = 1;
          }
          Main.npc[index246].homeTileX = adjustedFloorPosition4.X;
          Main.npc[index246].homeTileY = adjustedFloorPosition4.Y;
          Main.npc[index246].direction = 1;
          Main.npc[index246].homeless = true;
        }
        else if (WorldGen.remixWorldGen)
        {
          int index = NPC.NewNPC((IEntitySource) new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 441);
          Main.npc[index].homeTileX = Main.spawnTileX;
          Main.npc[index].homeTileY = Main.spawnTileY;
          Main.npc[index].direction = 1;
          Main.npc[index].homeless = true;
          NPC.savedTaxCollector = true;
        }
        else if (WorldGen.notTheBees)
        {
          int index = NPC.NewNPC((IEntitySource) new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 17);
          Main.npc[index].homeTileX = Main.spawnTileX;
          Main.npc[index].homeTileY = Main.spawnTileY;
          Main.npc[index].direction = 1;
          Main.npc[index].homeless = true;
          NPC.unlockedMerchantSpawn = true;
        }
        else if (WorldGen.drunkWorldGen)
        {
          int index = NPC.NewNPC((IEntitySource) new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 208);
          Main.npc[index].homeTileX = Main.spawnTileX;
          Main.npc[index].homeTileY = Main.spawnTileY;
          Main.npc[index].direction = 1;
          Main.npc[index].homeless = true;
          NPC.unlockedPartyGirlSpawn = true;
        }
        else if (WorldGen.getGoodWorldGen)
        {
          int index = NPC.NewNPC((IEntitySource) new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 38);
          Main.npc[index].homeTileX = Main.spawnTileX;
          Main.npc[index].homeTileY = Main.spawnTileY;
          Main.npc[index].direction = 1;
          Main.npc[index].homeless = true;
          NPC.unlockedDemolitionistSpawn = true;
        }
        else
        {
          int index = NPC.NewNPC((IEntitySource) new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 22);
          Main.npc[index].homeTileX = Main.spawnTileX;
          Main.npc[index].homeTileY = Main.spawnTileY;
          Main.npc[index].direction = 1;
          Main.npc[index].homeless = true;
        }
      }));
      WorldGen.AddGenerationPass("Sunflowers", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[39].Value;
        double num311 = (double) Main.maxTilesX * 0.002;
        for (int index247 = 0; (double) index247 < num311; ++index247)
        {
          progress.Set((double) index247 / num311);
          int num312 = Main.maxTilesX / 2;
          int num313 = WorldGen.genRand.Next(Main.maxTilesX);
          int num314 = num313 - WorldGen.genRand.Next(10) - 7;
          int num315 = num313 + WorldGen.genRand.Next(10) + 7;
          if (num314 < 0)
            num314 = 0;
          if (num315 > Main.maxTilesX - 1)
            num315 = Main.maxTilesX - 1;
          int num316 = 1;
          int num317 = (int) Main.worldSurface - 1;
          for (int i = num314; i < num315; ++i)
          {
            for (int index248 = num316; index248 < num317; ++index248)
            {
              if (Main.tile[i, index248].type == (ushort) 2 && Main.tile[i, index248].active() && !Main.tile[i, index248 - 1].active())
                WorldGen.PlaceTile(i, index248 - 1, 27, true);
              if (Main.tile[i, index248].active())
                break;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Planting Trees", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[40].Value;
        if (!WorldGen.drunkWorldGen && !Main.tenthAnniversaryWorld)
        {
          for (int index = 0; (double) index < (double) Main.maxTilesX * 0.003; ++index)
          {
            progress.Set((double) index / ((double) Main.maxTilesX * 0.003));
            int num318 = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
            int num319 = WorldGen.genRand.Next(25, 50);
            for (int i = num318 - num319; i < num318 + num319; ++i)
            {
              for (int y = 20; (double) y < Main.worldSurface; ++y)
                WorldGen.GrowEpicTree(i, y);
            }
          }
        }
        WorldGen.AddTrees();
      }));
      WorldGen.AddGenerationPass("Herbs", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        double num = (double) Main.maxTilesX * 1.7;
        if (WorldGen.remixWorldGen)
          num *= 5.0;
        progress.Message = Lang.gen[41].Value;
        for (int index = 0; (double) index < num; ++index)
        {
          progress.Set((double) index / num);
          WorldGen.PlantAlch();
        }
      }));
      WorldGen.AddGenerationPass("Dye Plants", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        for (int index = 0; index < Main.maxTilesX; ++index)
          WorldGen.plantDye(WorldGen.genRand.Next(100, Main.maxTilesX - 100), WorldGen.genRand.Next(100, Main.UnderworldLayer));
        WorldGen.MatureTheHerbPlants();
        WorldGen.GrowGlowTulips();
      }));
      WorldGen.AddGenerationPass("Webs And Honey", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        for (int index249 = 100; index249 < Main.maxTilesX - 100; ++index249)
        {
          int num320 = (int) Main.worldSurface;
          if (WorldGen.dontStarveWorldGen)
            num320 = 50;
          for (int index250 = num320; index250 < Main.maxTilesY - 100; ++index250)
          {
            if (Main.tile[index249, index250].wall == (ushort) 86)
            {
              if (Main.tile[index249, index250].liquid > (byte) 0)
                Main.tile[index249, index250].honey(true);
              if (WorldGen.genRand.Next(3) == 0)
                WorldGen.PlaceTight(index249, index250);
            }
            if (Main.tile[index249, index250].wall == (ushort) 62)
            {
              Main.tile[index249, index250].liquid = (byte) 0;
              Main.tile[index249, index250].lava(false);
            }
            if (Main.tile[index249, index250].wall == (ushort) 62 && !Main.tile[index249, index250].active() && WorldGen.genRand.Next(10) != 0)
            {
              int num321 = WorldGen.genRand.Next(2, 5);
              int num322 = index249 - num321;
              int num323 = index249 + num321;
              int num324 = index250 - num321;
              int num325 = index250 + num321;
              bool flag = false;
              for (int i = num322; i <= num323; ++i)
              {
                for (int j = num324; j <= num325; ++j)
                {
                  if (WorldGen.SolidTile(i, j))
                  {
                    flag = true;
                    break;
                  }
                }
              }
              if (flag)
              {
                WorldGen.PlaceTile(index249, index250, 51, true);
                WorldGen.TileFrame(index249, index250);
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Weeds", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[42].Value;
        if (Main.halloween)
        {
          for (int index251 = 40; index251 < Main.maxTilesX - 40; ++index251)
          {
            for (int index252 = 50; (double) index252 < Main.worldSurface; ++index252)
            {
              if (Main.tile[index251, index252].active() && Main.tile[index251, index252].type == (ushort) 2 && WorldGen.genRand.Next(15) == 0)
              {
                WorldGen.PlacePumpkin(index251, index252 - 1);
                int num = WorldGen.genRand.Next(5);
                for (int index253 = 0; index253 < num; ++index253)
                  WorldGen.GrowPumpkin(index251, index252 - 1, 254);
              }
            }
          }
        }
        for (int i = 0; i < Main.maxTilesX; ++i)
        {
          progress.Set((double) i / (double) Main.maxTilesX);
          for (int index = 1; index < Main.maxTilesY; ++index)
          {
            if (Main.tile[i, index].type == (ushort) 2 && Main.tile[i, index].nactive())
            {
              if (!Main.tile[i, index - 1].active())
              {
                WorldGen.PlaceTile(i, index - 1, 3, true);
                Main.tile[i, index - 1].CopyPaintAndCoating(Main.tile[i, index]);
              }
            }
            else if (Main.tile[i, index].type == (ushort) 23 && Main.tile[i, index].nactive())
            {
              if (!Main.tile[i, index - 1].active())
                WorldGen.PlaceTile(i, index - 1, 24, true);
            }
            else if (Main.tile[i, index].type == (ushort) 199 && Main.tile[i, index].nactive())
            {
              if (!Main.tile[i, index - 1].active())
                WorldGen.PlaceTile(i, index - 1, 201, true);
            }
            else if (Main.tile[i, index].type == (ushort) 633 && Main.tile[i, index].nactive() && !Main.tile[i, index - 1].active())
              WorldGen.PlaceTile(i, index - 1, 637, true);
          }
        }
      }));
      WorldGen.AddGenerationPass("Glowing Mushrooms and Jungle Plants", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        for (int i = 0; i < Main.maxTilesX; ++i)
        {
          for (int y = 0; y < Main.maxTilesY; ++y)
          {
            if (Main.tile[i, y].active())
            {
              if (y >= (int) Main.worldSurface && Main.tile[i, y].type == (ushort) 70 && !Main.tile[i, y - 1].active())
              {
                WorldGen.GrowTree(i, y);
                if (!Main.tile[i, y - 1].active())
                {
                  WorldGen.GrowTree(i, y);
                  if (!Main.tile[i, y - 1].active())
                  {
                    WorldGen.GrowTree(i, y);
                    if (!Main.tile[i, y - 1].active())
                      WorldGen.PlaceTile(i, y - 1, 71, true);
                  }
                }
              }
              if (Main.tile[i, y].type == (ushort) 60 && !Main.tile[i, y - 1].active())
                WorldGen.PlaceTile(i, y - 1, 61, true);
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Jungle Plants", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        for (int index254 = 0; index254 < Main.maxTilesX * 100; ++index254)
        {
          int X2 = WorldGen.genRand.Next(40, Main.maxTilesX / 2 - 40);
          if (GenVars.dungeonSide < 0)
            X2 += Main.maxTilesX / 2;
          int index255 = WorldGen.genRand.Next(Main.maxTilesY - 300);
          while (!Main.tile[X2, index255].active() && index255 < Main.maxTilesY - 300)
            ++index255;
          if (Main.tile[X2, index255].active() && Main.tile[X2, index255].type == (ushort) 60)
          {
            int Y2 = index255 - 1;
            WorldGen.PlaceJunglePlant(X2, Y2, (ushort) 233, WorldGen.genRand.Next(8), 0);
            if (Main.tile[X2, Y2].type != (ushort) 233)
              WorldGen.PlaceJunglePlant(X2, Y2, (ushort) 233, WorldGen.genRand.Next(12), 1);
          }
        }
      }));
      WorldGen.AddGenerationPass("Vines", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[43].Value;
        for (int index256 = 5; index256 < Main.maxTilesX - 5; ++index256)
        {
          progress.Set((double) index256 / (double) Main.maxTilesX);
          int num326 = 0;
          ushort num327 = 52;
          int num328 = (int) Main.worldSurface;
          if (WorldGen.remixWorldGen)
            num328 = Main.maxTilesY - 200;
          for (int y = 0; y < num328; ++y)
          {
            if (num326 > 0 && !Main.tile[index256, y].active())
            {
              Main.tile[index256, y].active(true);
              Main.tile[index256, y].type = num327;
              Main.tile[index256, y].CopyPaintAndCoating(Main.tile[index256, y - 1]);
              --num326;
            }
            else
              num326 = 0;
            if (Main.tile[index256, y].active() && !Main.tile[index256, y].bottomSlope() && (Main.tile[index256, y].type == (ushort) 2 || Main.tile[index256, y].type == (ushort) 192 && WorldGen.genRand.Next(4) == 0) && WorldGen.GrowMoreVines(index256, y))
            {
              num327 = (ushort) 52;
              if (Main.tile[index256, y].wall == (ushort) 68 || Main.tile[index256, y].wall == (ushort) 65 || Main.tile[index256, y].wall == (ushort) 66 || Main.tile[index256, y].wall == (ushort) 63)
                num327 = (ushort) 382;
              else if (Main.tile[index256, y + 1].wall == (ushort) 68 || Main.tile[index256, y + 1].wall == (ushort) 65 || Main.tile[index256, y + 1].wall == (ushort) 66 || Main.tile[index256, y + 1].wall == (ushort) 63)
                num327 = (ushort) 382;
              if (WorldGen.remixWorldGen && WorldGen.genRand.Next(5) == 0)
                num327 = (ushort) 382;
              if (WorldGen.genRand.Next(5) < 3)
                num326 = WorldGen.genRand.Next(1, 10);
            }
          }
          int num329 = 0;
          for (int index257 = 5; index257 < Main.maxTilesY - 5; ++index257)
          {
            if (num329 > 0 && !Main.tile[index256, index257].active())
            {
              Main.tile[index256, index257].active(true);
              Main.tile[index256, index257].type = (ushort) 62;
              --num329;
            }
            else
              num329 = 0;
            if (Main.tile[index256, index257].active() && Main.tile[index256, index257].type == (ushort) 60 && !Main.tile[index256, index257].bottomSlope() && WorldGen.GrowMoreVines(index256, index257))
            {
              if (WorldGen.notTheBees && index257 < Main.maxTilesY - 10 && Main.tile[index256, index257 - 1].active() && !Main.tile[index256, index257 - 1].bottomSlope() && Main.tile[index256 + 1, index257 - 1].active() && !Main.tile[index256 + 1, index257 - 1].bottomSlope() && (Main.tile[index256, index257 - 1].type == (ushort) 60 || Main.tile[index256, index257 - 1].type == (ushort) 444 || Main.tile[index256, index257 - 1].type == (ushort) 230))
              {
                bool flag = true;
                for (int index258 = index256; index258 < index256 + 2; ++index258)
                {
                  for (int index259 = index257 + 1; index259 < index257 + 3; ++index259)
                  {
                    if (Main.tile[index258, index259].active() && (!Main.tileCut[(int) Main.tile[index258, index259].type] || Main.tile[index258, index259].type == (ushort) 444))
                    {
                      flag = false;
                      break;
                    }
                    if (Main.tile[index258, index259].liquid > (byte) 0 || Main.wallHouse[(int) Main.tile[index258, index259].wall])
                    {
                      flag = false;
                      break;
                    }
                  }
                  if (!flag)
                    break;
                }
                if (flag)
                {
                  if (WorldGen.CountNearBlocksTypes(index256, index257, WorldGen.genRand.Next(3, 10), 1, 444) > 0)
                    flag = false;
                }
                if (flag)
                {
                  for (int i = index256; i < index256 + 2; ++i)
                  {
                    for (int j = index257 + 1; j < index257 + 3; ++j)
                      WorldGen.KillTile(i, j);
                  }
                  for (int index260 = index256; index260 < index256 + 2; ++index260)
                  {
                    for (int index261 = index257 + 1; index261 < index257 + 3; ++index261)
                    {
                      Main.tile[index260, index261].active(true);
                      Main.tile[index260, index261].type = (ushort) 444;
                      Main.tile[index260, index261].frameX = (short) ((index260 - index256) * 18);
                      Main.tile[index260, index261].frameY = (short) ((index261 - index257 - 1) * 18);
                    }
                  }
                  continue;
                }
              }
              else if (index256 < Main.maxTilesX - 1 && index257 < Main.maxTilesY - 2 && Main.tile[index256 + 1, index257].active() && Main.tile[index256 + 1, index257].type == (ushort) 60 && !Main.tile[index256 + 1, index257].bottomSlope() && WorldGen.genRand.Next(40) == 0)
              {
                bool flag = true;
                for (int index262 = index256; index262 < index256 + 2; ++index262)
                {
                  for (int index263 = index257 + 1; index263 < index257 + 3; ++index263)
                  {
                    if (Main.tile[index262, index263].active() && (!Main.tileCut[(int) Main.tile[index262, index263].type] || Main.tile[index262, index263].type == (ushort) 444))
                    {
                      flag = false;
                      break;
                    }
                    if (Main.tile[index262, index263].liquid > (byte) 0 || Main.wallHouse[(int) Main.tile[index262, index263].wall])
                    {
                      flag = false;
                      break;
                    }
                  }
                  if (!flag)
                    break;
                }
                if (flag)
                {
                  if (WorldGen.CountNearBlocksTypes(index256, index257, 20, 1, 444) > 0)
                    flag = false;
                }
                if (flag)
                {
                  for (int i = index256; i < index256 + 2; ++i)
                  {
                    for (int j = index257 + 1; j < index257 + 3; ++j)
                      WorldGen.KillTile(i, j);
                  }
                  for (int index264 = index256; index264 < index256 + 2; ++index264)
                  {
                    for (int index265 = index257 + 1; index265 < index257 + 3; ++index265)
                    {
                      Main.tile[index264, index265].active(true);
                      Main.tile[index264, index265].type = (ushort) 444;
                      Main.tile[index264, index265].frameX = (short) ((index264 - index256) * 18);
                      Main.tile[index264, index265].frameY = (short) ((index265 - index257 - 1) * 18);
                    }
                  }
                  continue;
                }
              }
              if (WorldGen.genRand.Next(5) < 3)
                num329 = WorldGen.genRand.Next(1, 10);
            }
          }
          int num330 = 0;
          for (int y = 0; y < Main.maxTilesY; ++y)
          {
            if (num330 > 0 && !Main.tile[index256, y].active())
            {
              Main.tile[index256, y].active(true);
              Main.tile[index256, y].type = (ushort) 528;
              --num330;
            }
            else
              num330 = 0;
            if (Main.tile[index256, y].active() && Main.tile[index256, y].type == (ushort) 70 && WorldGen.genRand.Next(5) == 0 && !Main.tile[index256, y].bottomSlope() && WorldGen.GrowMoreVines(index256, y) && WorldGen.genRand.Next(5) < 3)
              num330 = WorldGen.genRand.Next(1, 10);
          }
          int num331 = 0;
          for (int y = 0; y < Main.maxTilesY; ++y)
          {
            if (num331 > 0 && !Main.tile[index256, y].active())
            {
              Main.tile[index256, y].active(true);
              Main.tile[index256, y].type = (ushort) 636;
              --num331;
            }
            else
              num331 = 0;
            if (Main.tile[index256, y].active() && !Main.tile[index256, y].bottomSlope() && Main.tile[index256, y].type == (ushort) 23 && WorldGen.GrowMoreVines(index256, y) && WorldGen.genRand.Next(5) < 3)
              num331 = WorldGen.genRand.Next(1, 10);
          }
          int num332 = 0;
          for (int y = 0; y < Main.maxTilesY; ++y)
          {
            if (num332 > 0 && !Main.tile[index256, y].active())
            {
              Main.tile[index256, y].active(true);
              Main.tile[index256, y].type = (ushort) 205;
              --num332;
            }
            else
              num332 = 0;
            if (Main.tile[index256, y].active() && !Main.tile[index256, y].bottomSlope() && Main.tile[index256, y].type == (ushort) 199 && WorldGen.GrowMoreVines(index256, y) && WorldGen.genRand.Next(5) < 3)
              num332 = WorldGen.genRand.Next(1, 10);
          }
          int num333 = 0;
          for (int y = 0; y < Main.maxTilesY; ++y)
          {
            if (num333 > 0 && !Main.tile[index256, y].active())
            {
              Main.tile[index256, y].active(true);
              Main.tile[index256, y].type = (ushort) 638;
              --num333;
            }
            else
              num333 = 0;
            if (Main.tile[index256, y].active() && !Main.tile[index256, y].bottomSlope() && Main.tile[index256, y].type == (ushort) 633 && WorldGen.GrowMoreVines(index256, y) && WorldGen.genRand.Next(5) < 3)
              num333 = WorldGen.genRand.Next(1, 10);
          }
        }
      }));
      WorldGen.AddGenerationPass("Flowers", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[44].Value;
        int num334 = (int) ((double) Main.maxTilesX * 0.004);
        if (WorldGen.remixWorldGen)
          num334 *= 6;
        for (int index266 = 0; index266 < num334; ++index266)
        {
          progress.Set((double) index266 / (double) num334);
          int index267 = WorldGen.genRand.Next(100, Main.maxTilesX - 100);
          int num335 = WorldGen.genRand.Next(15, 30);
          int num336 = WorldGen.genRand.Next(15, 30);
          if (WorldGen.remixWorldGen)
          {
            int num337 = WorldGen.genRand.Next(15, 45);
            int num338 = WorldGen.genRand.Next(15, 45);
            int num339 = WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY - 350);
            if (GenVars.logX >= 0)
            {
              index267 = GenVars.logX;
              num339 = GenVars.logY;
              GenVars.logX = -1;
            }
            int num340 = WorldGen.genRand.NextFromList<int>(21, 24, 27, 30, 33, 36, 39, 42);
            for (int i = index267 - num337; i < index267 + num337; ++i)
            {
              for (int j = num339 - num338; j < num339 + num338; ++j)
              {
                if (Main.tile[i, j].type != (ushort) 488 && !Main.tileSolid[(int) Main.tile[i, j].type])
                {
                  if (Main.tile[i, j].type == (ushort) 3)
                  {
                    Main.tile[i, j].frameX = (short) ((num340 + WorldGen.genRand.Next(3)) * 18);
                    if (WorldGen.genRand.Next(3) != 0)
                      Main.tile[i, j].type = (ushort) 73;
                  }
                  else if (Main.tile[i, j + 1].wall == (ushort) 0 && (Main.tile[i, j + 1].type == (ushort) 2 || (Main.tile[i, j + 1].type == (ushort) 40 || Main.tile[i, j + 1].type == (ushort) 1 || TileID.Sets.Ore[(int) Main.tile[i, j + 1].type]) && !Main.tile[i, j].active()) && (!Main.tile[i, j].active() || Main.tile[i, j].type == (ushort) 185 || Main.tile[i, j].type == (ushort) 186 || Main.tile[i, j].type == (ushort) 187 || Main.tile[i, j].type == (ushort) 5 && (double) i < (double) Main.maxTilesX * 0.48 || (double) i > (double) Main.maxTilesX * 0.52))
                  {
                    if (Main.tile[i, j + 1].type == (ushort) 40 || Main.tile[i, j + 1].type == (ushort) 1 || TileID.Sets.Ore[(int) Main.tile[i, j + 1].type])
                    {
                      Main.tile[i, j + 1].type = (ushort) 2;
                      if (Main.tile[i, j + 2].type == (ushort) 40 || Main.tile[i, j + 2].type == (ushort) 1 || TileID.Sets.Ore[(int) Main.tile[i, j + 2].type])
                        Main.tile[i, j + 2].type = (ushort) 2;
                    }
                    WorldGen.KillTile(i, j);
                    if (WorldGen.genRand.Next(2) == 0)
                    {
                      Main.tile[i, j + 1].slope((byte) 0);
                      Main.tile[i, j + 1].halfBrick(false);
                    }
                    WorldGen.PlaceTile(i, j, 3);
                    if (Main.tile[i, j].active() && Main.tile[i, j].type == (ushort) 3)
                    {
                      Main.tile[i, j].frameX = (short) ((num340 + WorldGen.genRand.Next(3)) * 18);
                      if (WorldGen.genRand.Next(3) != 0)
                        Main.tile[i, j].type = (ushort) 73;
                    }
                    if (Main.tile[i, j + 2].type == (ushort) 40 || Main.tile[i, j + 2].type == (ushort) 1 || TileID.Sets.Ore[(int) Main.tile[i, j + 2].type])
                      Main.tile[i, j + 2].type = (ushort) 0;
                  }
                }
              }
            }
          }
          else
          {
            for (int index268 = num336; (double) index268 < Main.worldSurface - (double) num336 - 1.0; ++index268)
            {
              if (Main.tile[index267, index268].active())
              {
                if (GenVars.logX >= 0)
                {
                  index267 = GenVars.logX;
                  index268 = GenVars.logY;
                  GenVars.logX = -1;
                }
                int num341 = WorldGen.genRand.NextFromList<int>(21, 24, 27, 30, 33, 36, 39, 42);
                for (int i = index267 - num335; i < index267 + num335; ++i)
                {
                  for (int j = index268 - num336; j < index268 + num336; ++j)
                  {
                    if (Main.tile[i, j].type != (ushort) 488 && !Main.tileSolid[(int) Main.tile[i, j].type])
                    {
                      if (Main.tile[i, j].type == (ushort) 3)
                      {
                        Main.tile[i, j].frameX = (short) ((num341 + WorldGen.genRand.Next(3)) * 18);
                        if (WorldGen.genRand.Next(3) != 0)
                          Main.tile[i, j].type = (ushort) 73;
                      }
                      else if (Main.tile[i, j + 1].wall == (ushort) 0 && (Main.tile[i, j + 1].type == (ushort) 2 || (Main.tile[i, j + 1].type == (ushort) 40 || Main.tile[i, j + 1].type == (ushort) 1 || TileID.Sets.Ore[(int) Main.tile[i, j + 1].type]) && !Main.tile[i, j].active()) && (!Main.tile[i, j].active() || Main.tile[i, j].type == (ushort) 185 || Main.tile[i, j].type == (ushort) 186 || Main.tile[i, j].type == (ushort) 187 || Main.tile[i, j].type == (ushort) 5 && (double) i < (double) Main.maxTilesX * 0.48 || (double) i > (double) Main.maxTilesX * 0.52))
                      {
                        if (Main.tile[i, j + 1].type == (ushort) 40 || Main.tile[i, j + 1].type == (ushort) 1 || TileID.Sets.Ore[(int) Main.tile[i, j + 1].type])
                        {
                          Main.tile[i, j + 1].type = (ushort) 2;
                          if (Main.tile[i, j + 2].type == (ushort) 40 || Main.tile[i, j + 2].type == (ushort) 1 || TileID.Sets.Ore[(int) Main.tile[i, j + 2].type])
                            Main.tile[i, j + 2].type = (ushort) 2;
                        }
                        WorldGen.KillTile(i, j);
                        if (WorldGen.genRand.Next(2) == 0)
                        {
                          Main.tile[i, j + 1].slope((byte) 0);
                          Main.tile[i, j + 1].halfBrick(false);
                        }
                        WorldGen.PlaceTile(i, j, 3);
                        if (Main.tile[i, j].active() && Main.tile[i, j].type == (ushort) 3)
                        {
                          Main.tile[i, j].frameX = (short) ((num341 + WorldGen.genRand.Next(3)) * 18);
                          if (WorldGen.genRand.Next(3) != 0)
                            Main.tile[i, j].type = (ushort) 73;
                        }
                        if (Main.tile[i, j + 2].type == (ushort) 40 || Main.tile[i, j + 2].type == (ushort) 1 || TileID.Sets.Ore[(int) Main.tile[i, j + 2].type])
                          Main.tile[i, j + 2].type = (ushort) 0;
                      }
                    }
                  }
                }
                break;
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Mushrooms", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[45].Value;
        int num342 = (int) ((double) Main.maxTilesX * 0.002);
        if (WorldGen.remixWorldGen)
          num342 *= 9;
        for (int index269 = 0; index269 < num342; ++index269)
        {
          progress.Set((double) index269 / (double) num342);
          int index270 = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
          int num343 = WorldGen.genRand.Next(4, 10);
          int num344 = WorldGen.genRand.Next(15, 30);
          if (WorldGen.remixWorldGen)
          {
            int num345 = WorldGen.genRand.Next(8, 17);
            int num346 = WorldGen.genRand.Next(8, 17);
            int index271 = WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY - 350);
            if (Main.tile[index270, index271].active())
            {
              for (int index272 = index270 - num345; index272 < index270 + num345; ++index272)
              {
                for (int index273 = index271 - num346; index273 < index271 + num346 && index272 >= 10 && index273 >= 0 && index272 <= Main.maxTilesX - 10 && index273 <= Main.maxTilesY - 10; ++index273)
                {
                  if (Main.tile[index272, index273].type == (ushort) 3 || Main.tile[index272, index273].type == (ushort) 24)
                    Main.tile[index272, index273].frameX = (short) 144;
                  else if (Main.tile[index272, index273].type == (ushort) 201)
                    Main.tile[index272, index273].frameX = (short) 270;
                }
              }
            }
          }
          else
          {
            for (int index274 = 1; (double) index274 < Main.worldSurface - 1.0; ++index274)
            {
              if (Main.tile[index270, index274].active())
              {
                for (int index275 = index270 - num343; index275 < index270 + num343; ++index275)
                {
                  for (int index276 = index274 - num344; index276 < index274 + num344 && index275 >= 10 && index276 >= 0 && index275 <= Main.maxTilesX - 10 && index276 <= Main.maxTilesY - 10; ++index276)
                  {
                    if (Main.tile[index275, index276].type == (ushort) 3 || Main.tile[index275, index276].type == (ushort) 24)
                      Main.tile[index275, index276].frameX = (short) 144;
                    else if (Main.tile[index275, index276].type == (ushort) 201)
                      Main.tile[index275, index276].frameX = (short) 270;
                  }
                }
                break;
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Gems In Ice Biome", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        for (int index277 = 0; (double) index277 < (double) Main.maxTilesX * 0.25; ++index277)
        {
          int index278 = !WorldGen.remixWorldGen ? WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, GenVars.lavaLine) : WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 300);
          int index279 = WorldGen.genRand.Next(GenVars.snowMinX[index278], GenVars.snowMaxX[index278]);
          if (Main.tile[index279, index278].active() && (Main.tile[index279, index278].type == (ushort) 147 || Main.tile[index279, index278].type == (ushort) 161 || Main.tile[index279, index278].type == (ushort) 162 || Main.tile[index279, index278].type == (ushort) 224))
          {
            int num347 = WorldGen.genRand.Next(1, 4);
            int num348 = WorldGen.genRand.Next(1, 4);
            int num349 = WorldGen.genRand.Next(1, 4);
            int num350 = WorldGen.genRand.Next(1, 4);
            int num351 = WorldGen.genRand.Next(12);
            int style = num351 >= 3 ? (num351 >= 6 ? (num351 >= 8 ? (num351 >= 10 ? (num351 >= 11 ? 5 : 4) : 3) : 2) : 1) : 0;
            for (int i = index279 - num347; i < index279 + num348; ++i)
            {
              for (int j = index278 - num349; j < index278 + num350; ++j)
              {
                if (!Main.tile[i, j].active())
                  WorldGen.PlaceTile(i, j, 178, true, style: style);
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Random Gems", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        for (int index = 0; index < Main.maxTilesX; ++index)
        {
          int i = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
          int j = WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY - 300);
          if (!Main.tile[i, j].active() && !Main.tile[i, j].lava() && !Main.wallDungeon[(int) Main.tile[i, j].wall] && Main.tile[i, j].wall != (ushort) 27)
          {
            int num = WorldGen.genRand.Next(12);
            int style = num >= 3 ? (num >= 6 ? (num >= 8 ? (num >= 10 ? (num >= 11 ? 5 : 4) : 3) : 2) : 1) : 0;
            WorldGen.PlaceTile(i, j, 178, true, style: style);
          }
        }
        for (int index280 = 0; index280 < Main.maxTilesX; ++index280)
        {
          int index281 = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
          int index282 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 300);
          if (!Main.tile[index281, index282].active() && !Main.tile[index281, index282].lava() && (Main.tile[index281, index282].wall == (ushort) 216 || Main.tile[index281, index282].wall == (ushort) 187))
          {
            int num352 = WorldGen.genRand.Next(1, 4);
            int num353 = WorldGen.genRand.Next(1, 4);
            int num354 = WorldGen.genRand.Next(1, 4);
            int num355 = WorldGen.genRand.Next(1, 4);
            for (int i = index281 - num352; i < index281 + num353; ++i)
            {
              for (int j = index282 - num354; j < index282 + num355; ++j)
              {
                if (!Main.tile[i, j].active())
                  WorldGen.PlaceTile(i, j, 178, true, style: 6);
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Moss Grass", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        for (int index283 = 5; index283 < Main.maxTilesX - 5; ++index283)
        {
          for (int index284 = 5; index284 < Main.maxTilesY - 5; ++index284)
          {
            if (Main.tile[index283, index284].active() && Main.tileMoss[(int) Main.tile[index283, index284].type])
            {
              for (int index285 = 0; index285 < 4; ++index285)
              {
                int i = index283;
                int j = index284;
                if (index285 == 0)
                  --i;
                if (index285 == 1)
                  ++i;
                if (index285 == 2)
                  --j;
                if (index285 == 3)
                  ++j;
                if (!Main.tile[i, j].active())
                  WorldGen.PlaceTile(i, j, 184, true);
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Muds Walls In Jungle", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        int num356 = 0;
        int num357 = 0;
        bool flag30 = false;
        for (int index286 = 5; index286 < Main.maxTilesX - 5; ++index286)
        {
          for (int index287 = 0; (double) index287 < Main.worldSurface + 20.0; ++index287)
          {
            if (Main.tile[index286, index287].active() && Main.tile[index286, index287].type == (ushort) 60)
            {
              num356 = index286;
              flag30 = true;
              break;
            }
          }
          if (flag30)
            break;
        }
        bool flag31 = false;
        for (int index288 = Main.maxTilesX - 5; index288 > 5; --index288)
        {
          for (int index289 = 0; (double) index289 < Main.worldSurface + 20.0; ++index289)
          {
            if (Main.tile[index288, index289].active() && Main.tile[index288, index289].type == (ushort) 60)
            {
              num357 = index288;
              flag31 = true;
              break;
            }
          }
          if (flag31)
            break;
        }
        GenVars.jungleMinX = num356;
        GenVars.jungleMaxX = num357;
        for (int index290 = num356; index290 <= num357; ++index290)
        {
          for (int index291 = 0; (double) index291 < Main.worldSurface + 20.0; ++index291)
          {
            if ((index290 >= num356 + 2 && index290 <= num357 - 2 || WorldGen.genRand.Next(2) != 0) && (index290 >= num356 + 3 && index290 <= num357 - 3 || WorldGen.genRand.Next(3) != 0) && (Main.tile[index290, index291].wall == (ushort) 2 || Main.tile[index290, index291].wall == (ushort) 59))
              Main.tile[index290, index291].wall = (ushort) 15;
          }
        }
      }));
      WorldGen.AddGenerationPass("Larva", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        Main.tileSolid[229] = true;
        progress.Set(1.0);
        for (int index292 = 0; index292 < GenVars.numLarva; ++index292)
        {
          int i = GenVars.larvaX[index292];
          int j = GenVars.larvaY[index292];
          for (int index293 = i - 1; index293 <= i + 1; ++index293)
          {
            for (int index294 = j - 2; index294 <= j + 1; ++index294)
            {
              if (index294 != j + 1)
              {
                Main.tile[index293, index294].active(false);
              }
              else
              {
                Main.tile[index293, index294].active(true);
                Main.tile[index293, index294].type = (ushort) 225;
                Main.tile[index293, index294].slope((byte) 0);
                Main.tile[index293, index294].halfBrick(false);
              }
            }
          }
          WorldGen.PlaceTile(i, j, 231, true);
        }
        Main.tileSolid[232] = true;
        Main.tileSolid[162] = true;
      }));
      WorldGen.AddGenerationPass("Settle Liquids Again", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.getGoodWorldGen)
          Main.tileSolid[56] = true;
        progress.Message = Lang.gen[27].Value;
        if (WorldGen.notTheBees)
          WorldGen.NotTheBees();
        Liquid.worldGenTilesIgnoreWater(true);
        Liquid.QuickWater(3);
        WorldGen.WaterCheck();
        int num358 = 0;
        Liquid.quickSettle = true;
        int num359 = 10;
        while (num358 < num359)
        {
          int num360 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
          ++num358;
          double num361 = 0.0;
          int num362 = num360 * 5;
          while (Liquid.numLiquid > 0)
          {
            --num362;
            if (num362 >= 0)
            {
              double num363 = (double) (num360 - (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer)) / (double) num360;
              if (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer > num360)
                num360 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
              if (num363 > num361)
                num361 = num363;
              else
                num363 = num361;
              if (num358 == 1)
                progress.Set(num363 / 3.0 + 0.33);
              Liquid.UpdateLiquid();
            }
            else
              break;
          }
          WorldGen.WaterCheck();
          progress.Set((double) num358 / (double) num359 / 3.0 + 0.66);
        }
        Liquid.quickSettle = false;
        Liquid.worldGenTilesIgnoreWater(false);
        Main.tileSolid[484] = false;
      }));
      WorldGen.AddGenerationPass("Cactus, Palm Trees, & Coral", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[38].Value;
        int num364 = 8;
        if (WorldGen.remixWorldGen)
          num364 = 2;
        int num365 = 400;
        int num366 = WorldGen.genRand.Next(3, 13);
        int num367 = WorldGen.genRand.Next(3, 13);
        WorldGen.genRand.Next(2, 6);
        WorldGen.genRand.Next(2, 6);
        int num368 = 380;
        for (int index295 = 0; index295 < GenVars.numOasis; ++index295)
        {
          int num369 = (int) ((double) GenVars.oasisWidth[index295] * 1.5);
          for (int index296 = GenVars.oasisPosition[index295].X - num369; index296 <= GenVars.oasisPosition[index295].X + num369; ++index296)
          {
            for (int index297 = GenVars.oasisPosition[index295].Y - GenVars.oasisHeight; index297 <= GenVars.oasisPosition[index295].Y + GenVars.oasisHeight; ++index297)
            {
              double num370 = 1.0;
              int num371 = 8;
              for (int x = index296 - num371; x <= index296 + num371; ++x)
              {
                for (int y = index297 - num371; y <= index297 + num371; ++y)
                {
                  if (WorldGen.InWorld(x, y) && Main.tile[x, y] != null && Main.tile[x, y].active() && Main.tile[x, y].type == (ushort) 323)
                    num370 = 0.13;
                }
              }
              if (WorldGen.genRand.NextDouble() < num370)
                WorldGen.GrowPalmTree(index296, index297);
              if (WorldGen.PlantSeaOat(index296, index297))
              {
                if (WorldGen.genRand.Next(2) == 0)
                  WorldGen.GrowSeaOat(index296, index297);
                if (WorldGen.genRand.Next(2) == 0)
                  WorldGen.GrowSeaOat(index296, index297);
              }
              WorldGen.PlaceOasisPlant(index296, index297);
            }
          }
        }
        for (int index298 = 0; index298 < 3; ++index298)
        {
          progress.Set((double) index298 / 3.0);
          int num372;
          int num373;
          bool flag;
          int maxValue4;
          switch (index298)
          {
            case 1:
              num372 = num365;
              num373 = Main.maxTilesX - num365;
              flag = true;
              maxValue4 = num364;
              break;
            case 2:
              num372 = Main.maxTilesX - num368;
              num373 = Main.maxTilesX - 5;
              flag = false;
              maxValue4 = num367;
              break;
            default:
              num372 = 5;
              num373 = num368;
              flag = false;
              maxValue4 = num366;
              break;
          }
          double num374 = Main.worldSurface - 1.0;
          if (WorldGen.remixWorldGen)
            num374 = (double) (Main.maxTilesY - 50);
          for (int index299 = num372; index299 < num373; ++index299)
          {
            if (WorldGen.genRand.Next(maxValue4) == 0)
            {
              for (int index300 = 0; (double) index300 < num374; ++index300)
              {
                Tile tile3 = Main.tile[index299, index300];
                if (tile3.active() && (tile3.type == (ushort) 53 || tile3.type == (ushort) 112 || tile3.type == (ushort) 234))
                {
                  Tile tile4 = Main.tile[index299, index300 - 1];
                  if (!tile4.active() && tile4.wall == (ushort) 0)
                  {
                    if (flag)
                    {
                      if (WorldGen.remixWorldGen)
                      {
                        if ((double) index300 > Main.worldSurface)
                        {
                          if (WorldGen.SolidTile(index299, index300) && Main.tile[index299, index300 + 1].type == (ushort) 53 && Main.tile[index299, index300 + 2].type == (ushort) 53)
                          {
                            int maxValue5 = 3;
                            WorldGen.GrowPalmTree(index299, index300);
                            if (!Main.tile[index299, index300 - 1].active() && WorldGen.genRand.Next(maxValue5) == 0)
                              WorldGen.PlantCactus(index299, index300);
                          }
                        }
                        else
                        {
                          int num375 = 0;
                          for (int index301 = index299 - WorldGen.cactusWaterWidth; index301 < index299 + WorldGen.cactusWaterWidth; ++index301)
                          {
                            for (int index302 = index300 - WorldGen.cactusWaterHeight; index302 < index300 + WorldGen.cactusWaterHeight; ++index302)
                              num375 += (int) Main.tile[index301, index302].liquid;
                          }
                          if (num375 / (int) byte.MaxValue > WorldGen.cactusWaterLimit)
                          {
                            if (WorldGen.genRand.Next(4) == 0)
                              WorldGen.GrowPalmTree(index299, index300);
                          }
                          else
                            WorldGen.PlantCactus(index299, index300);
                        }
                      }
                      else
                      {
                        int num376 = 0;
                        for (int index303 = index299 - WorldGen.cactusWaterWidth; index303 < index299 + WorldGen.cactusWaterWidth; ++index303)
                        {
                          for (int index304 = index300 - WorldGen.cactusWaterHeight; index304 < index300 + WorldGen.cactusWaterHeight; ++index304)
                            num376 += (int) Main.tile[index303, index304].liquid;
                        }
                        if (num376 / (int) byte.MaxValue > WorldGen.cactusWaterLimit)
                        {
                          if (WorldGen.genRand.Next(4) == 0)
                            WorldGen.GrowPalmTree(index299, index300);
                        }
                        else
                          WorldGen.PlantCactus(index299, index300);
                      }
                    }
                    else
                    {
                      if (Main.tile[index299, index300 - 2].liquid == byte.MaxValue && Main.tile[index299, index300 - 3].liquid == byte.MaxValue && Main.tile[index299, index300 - 4].liquid == byte.MaxValue)
                      {
                        if (WorldGen.genRand.Next(2) == 0)
                        {
                          WorldGen.PlaceTile(index299, index300 - 1, 81, true);
                          break;
                        }
                        WorldGen.PlaceTile(index299, index300 - 1, 324, true, style: WorldGen.RollRandomSeaShellStyle());
                        break;
                      }
                      if (Main.tile[index299, index300 - 2].liquid == (byte) 0 && (double) index300 < Main.worldSurface)
                      {
                        WorldGen.PlaceTile(index299, index300 - 1, 324, true, style: WorldGen.RollRandomSeaShellStyle());
                        break;
                      }
                    }
                  }
                }
              }
            }
            else
            {
              for (int index305 = 0; (double) index305 < num374; ++index305)
              {
                if (WorldGen.PlantSeaOat(index299, index305))
                {
                  if (WorldGen.genRand.Next(2) == 0)
                    WorldGen.GrowSeaOat(index299, index305);
                  if (WorldGen.genRand.Next(2) == 0)
                    WorldGen.GrowSeaOat(index299, index305);
                }
                WorldGen.PlaceOasisPlant(index299, index305);
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Tile Cleanup", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[84].Value;
        for (int i = 40; i < Main.maxTilesX - 40; ++i)
        {
          progress.Set((double) (i - 40) / (double) (Main.maxTilesX - 80));
          for (int j = 40; j < Main.maxTilesY - 40; ++j)
          {
            if (Main.tile[i, j].active() && Main.tile[i, j].topSlope() && (Main.tile[i, j].leftSlope() && Main.tile[i + 1, j].halfBrick() || Main.tile[i, j].rightSlope() && Main.tile[i - 1, j].halfBrick()))
            {
              Main.tile[i, j].slope((byte) 0);
              Main.tile[i, j].halfBrick(true);
            }
            if (Main.tile[i, j].active() && Main.tile[i, j].liquid > (byte) 0 && TileID.Sets.SlowlyDiesInWater[(int) Main.tile[i, j].type])
              WorldGen.KillTile(i, j);
            if (!Main.tile[i, j].active() && Main.tile[i, j].liquid == (byte) 0 && WorldGen.genRand.Next(3) != 0 && WorldGen.SolidTile(i, j - 1))
            {
              int num377 = WorldGen.genRand.Next(15, 21);
              for (int index = j - 2; index >= j - num377; --index)
              {
                if (Main.tile[i, index].liquid >= (byte) 128 && !Main.tile[i, index].shimmer())
                {
                  int num378 = 373;
                  if (Main.tile[i, index].lava())
                    num378 = 374;
                  else if (Main.tile[i, index].honey())
                    num378 = 375;
                  if (WorldGen.genRand.Next(j - index) <= 1)
                  {
                    if (Main.tile[i, j].wall == (ushort) 86)
                      num378 = 375;
                    Main.tile[i, j].type = (ushort) num378;
                    Main.tile[i, j].frameX = (short) 0;
                    Main.tile[i, j].frameY = (short) 0;
                    Main.tile[i, j].active(true);
                    break;
                  }
                }
              }
              if (!Main.tile[i, j].active())
              {
                int num379 = WorldGen.genRand.Next(3, 11);
                for (int index = j + 1; index <= j + num379; ++index)
                {
                  if (Main.tile[i, index].liquid >= (byte) 200 && !Main.tile[i, index].shimmer())
                  {
                    int num380 = 373;
                    if (Main.tile[i, index].lava())
                      num380 = 374;
                    else if (Main.tile[i, index].honey())
                      num380 = 375;
                    if (WorldGen.genRand.Next((index - j) * 3) <= 1)
                    {
                      Main.tile[i, j].type = (ushort) num380;
                      Main.tile[i, j].frameX = (short) 0;
                      Main.tile[i, j].frameY = (short) 0;
                      Main.tile[i, j].active(true);
                      break;
                    }
                  }
                }
              }
              if (!Main.tile[i, j].active() && WorldGen.genRand.Next(4) == 0)
              {
                Tile tile = Main.tile[i, j - 1];
                if (TileID.Sets.Conversion.Sandstone[(int) tile.type] || TileID.Sets.Conversion.HardenedSand[(int) tile.type])
                {
                  Main.tile[i, j].type = (ushort) 461;
                  Main.tile[i, j].frameX = (short) 0;
                  Main.tile[i, j].frameY = (short) 0;
                  Main.tile[i, j].active(true);
                }
              }
            }
            if (Main.tile[i, j].type == (ushort) 137)
            {
              int num381 = (int) Main.tile[i, j].frameY / 18;
              if (num381 <= 2 || num381 == 5)
              {
                int num382 = -1;
                if (Main.tile[i, j].frameX >= (short) 18)
                  num382 = 1;
                if (Main.tile[i + num382, j].halfBrick() || Main.tile[i + num382, j].slope() != (byte) 0)
                  Main.tile[i + num382, j].active(false);
              }
            }
            else if (Main.tile[i, j].type == (ushort) 162 && Main.tile[i, j + 1].liquid == (byte) 0 && WorldGen.CanKillTile(i, j))
              Main.tile[i, j].active(false);
            if (Main.tile[i, j].wall == (ushort) 13 || Main.tile[i, j].wall == (ushort) 14)
              Main.tile[i, j].liquid = (byte) 0;
            if (Main.tile[i, j].type == (ushort) 31)
            {
              int num383 = (int) Main.tile[i, j].frameX / 18;
              int num384 = 0;
              int num385 = i;
              int num386 = num384 + num383 / 2;
              int num387 = !WorldGen.drunkWorldGen ? (WorldGen.crimson ? 1 : 0) : (Main.tile[i, j].wall != (ushort) 83 ? 0 : 1);
              int num388 = num383 % 2;
              int num389 = num385 - num388;
              int num390 = (int) Main.tile[i, j].frameY / 18;
              int num391 = 0;
              int num392 = j;
              int num393 = num391 + num390 / 2;
              int num394 = num390 % 2;
              int num395 = num392 - num394;
              for (int index306 = 0; index306 < 2; ++index306)
              {
                for (int index307 = 0; index307 < 2; ++index307)
                {
                  int index308 = num389 + index306;
                  int index309 = num395 + index307;
                  Main.tile[index308, index309].active(true);
                  Main.tile[index308, index309].slope((byte) 0);
                  Main.tile[index308, index309].halfBrick(false);
                  Main.tile[index308, index309].type = (ushort) 31;
                  Main.tile[index308, index309].frameX = (short) (index306 * 18 + 36 * num387);
                  Main.tile[index308, index309].frameY = (short) (index307 * 18 + 36 * num393);
                }
              }
            }
            if (Main.tile[i, j].type == (ushort) 12)
            {
              int num396 = (int) Main.tile[i, j].frameX / 18;
              int num397 = 0;
              int num398 = i;
              int num399 = num397 + num396 / 2;
              int num400 = num396 % 2;
              int num401 = num398 - num400;
              int num402 = (int) Main.tile[i, j].frameY / 18;
              int num403 = 0;
              int num404 = j;
              int num405 = num403 + num402 / 2;
              int num406 = num402 % 2;
              int num407 = num404 - num406;
              for (int index310 = 0; index310 < 2; ++index310)
              {
                for (int index311 = 0; index311 < 2; ++index311)
                {
                  int index312 = num401 + index310;
                  int index313 = num407 + index311;
                  Main.tile[index312, index313].active(true);
                  Main.tile[index312, index313].slope((byte) 0);
                  Main.tile[index312, index313].halfBrick(false);
                  Main.tile[index312, index313].type = (ushort) 12;
                  Main.tile[index312, index313].frameX = (short) (index310 * 18 + 36 * num399);
                  Main.tile[index312, index313].frameY = (short) (index311 * 18 + 36 * num405);
                }
                if (!Main.tile[index310, j + 2].active())
                {
                  Main.tile[index310, j + 2].active(true);
                  if (!Main.tileSolid[(int) Main.tile[index310, j + 2].type] || Main.tileSolidTop[(int) Main.tile[index310, j + 2].type])
                    Main.tile[index310, j + 2].type = (ushort) 0;
                }
                Main.tile[index310, j + 2].slope((byte) 0);
                Main.tile[index310, j + 2].halfBrick(false);
              }
            }
            if (Main.tile[i, j].type == (ushort) 639)
            {
              int num408 = (int) Main.tile[i, j].frameX / 18;
              int num409 = 0;
              int num410 = i;
              int num411 = num409 + num408 / 2;
              int num412 = num408 % 2;
              int num413 = num410 - num412;
              int num414 = (int) Main.tile[i, j].frameY / 18;
              int num415 = 0;
              int num416 = j;
              int num417 = num415 + num414 / 2;
              int num418 = num414 % 2;
              int num419 = num416 - num418;
              for (int index314 = 0; index314 < 2; ++index314)
              {
                for (int index315 = 0; index315 < 2; ++index315)
                {
                  int index316 = num413 + index314;
                  int index317 = num419 + index315;
                  Main.tile[index316, index317].active(true);
                  Main.tile[index316, index317].slope((byte) 0);
                  Main.tile[index316, index317].halfBrick(false);
                  Main.tile[index316, index317].type = (ushort) 639;
                  Main.tile[index316, index317].frameX = (short) (index314 * 18 + 36 * num411);
                  Main.tile[index316, index317].frameY = (short) (index315 * 18 + 36 * num417);
                }
                if (!Main.tile[index314, j + 2].active())
                {
                  Main.tile[index314, j + 2].active(true);
                  if (!Main.tileSolid[(int) Main.tile[index314, j + 2].type] || Main.tileSolidTop[(int) Main.tile[index314, j + 2].type])
                    Main.tile[index314, j + 2].type = (ushort) 0;
                }
                Main.tile[index314, j + 2].slope((byte) 0);
                Main.tile[index314, j + 2].halfBrick(false);
              }
            }
            if (TileID.Sets.BasicChest[(int) Main.tile[i, j].type])
            {
              int num420 = (int) Main.tile[i, j].frameX / 18;
              int num421 = 0;
              ushort num422 = 21;
              int num423 = i;
              int Y = j - (int) Main.tile[i, j].frameY / 18;
              if (Main.tile[i, j].type == (ushort) 467)
                num422 = (ushort) 467;
              for (; num420 >= 2; num420 -= 2)
                ++num421;
              int X = num423 - num420;
              int chest = Chest.FindChest(X, Y);
              if (chest != -1)
              {
                switch (Main.chest[chest].item[0].type)
                {
                  case 1156:
                    num421 = 23;
                    break;
                  case 1260:
                    num421 = 26;
                    break;
                  case 1569:
                    num421 = 25;
                    break;
                  case 1571:
                    num421 = 24;
                    break;
                  case 1572:
                    num421 = 27;
                    break;
                }
              }
              for (int index318 = 0; index318 < 2; ++index318)
              {
                for (int index319 = 0; index319 < 2; ++index319)
                {
                  int index320 = X + index318;
                  int index321 = Y + index319;
                  Main.tile[index320, index321].active(true);
                  Main.tile[index320, index321].slope((byte) 0);
                  Main.tile[index320, index321].halfBrick(false);
                  Main.tile[index320, index321].type = num422;
                  Main.tile[index320, index321].frameX = (short) (index318 * 18 + 36 * num421);
                  Main.tile[index320, index321].frameY = (short) (index319 * 18);
                }
                if (!Main.tile[index318, j + 2].active())
                {
                  Main.tile[index318, j + 2].active(true);
                  if (!Main.tileSolid[(int) Main.tile[index318, j + 2].type] || Main.tileSolidTop[(int) Main.tile[index318, j + 2].type])
                    Main.tile[index318, j + 2].type = (ushort) 0;
                }
                Main.tile[index318, j + 2].slope((byte) 0);
                Main.tile[index318, j + 2].halfBrick(false);
              }
            }
            if (Main.tile[i, j].type == (ushort) 28)
            {
              int num424 = (int) Main.tile[i, j].frameX / 18;
              int num425 = 0;
              int num426 = i;
              for (; num424 >= 2; num424 -= 2)
                ++num425;
              int num427 = num426 - num424;
              int num428 = (int) Main.tile[i, j].frameY / 18;
              int num429 = 0;
              int num430 = j;
              for (; num428 >= 2; num428 -= 2)
                ++num429;
              int num431 = num430 - num428;
              for (int index322 = 0; index322 < 2; ++index322)
              {
                for (int index323 = 0; index323 < 2; ++index323)
                {
                  int index324 = num427 + index322;
                  int index325 = num431 + index323;
                  Main.tile[index324, index325].active(true);
                  Main.tile[index324, index325].slope((byte) 0);
                  Main.tile[index324, index325].halfBrick(false);
                  Main.tile[index324, index325].type = (ushort) 28;
                  Main.tile[index324, index325].frameX = (short) (index322 * 18 + 36 * num425);
                  Main.tile[index324, index325].frameY = (short) (index323 * 18 + 36 * num429);
                }
                if (!Main.tile[index322, j + 2].active())
                {
                  Main.tile[index322, j + 2].active(true);
                  if (!Main.tileSolid[(int) Main.tile[index322, j + 2].type] || Main.tileSolidTop[(int) Main.tile[index322, j + 2].type])
                    Main.tile[index322, j + 2].type = (ushort) 0;
                }
                Main.tile[index322, j + 2].slope((byte) 0);
                Main.tile[index322, j + 2].halfBrick(false);
              }
            }
            if (Main.tile[i, j].type == (ushort) 26)
            {
              int num432 = (int) Main.tile[i, j].frameX / 18;
              int num433 = 0;
              int num434 = i;
              int num435 = j - (int) Main.tile[i, j].frameY / 18;
              for (; num432 >= 3; num432 -= 3)
                ++num433;
              int num436 = num434 - num432;
              int num437 = !WorldGen.drunkWorldGen ? (!WorldGen.crimson ? 0 : 1) : (Main.tile[i, j].wall != (ushort) 83 ? 0 : 1);
              for (int index326 = 0; index326 < 3; ++index326)
              {
                for (int index327 = 0; index327 < 2; ++index327)
                {
                  int index328 = num436 + index326;
                  int index329 = num435 + index327;
                  Main.tile[index328, index329].active(true);
                  Main.tile[index328, index329].slope((byte) 0);
                  Main.tile[index328, index329].halfBrick(false);
                  Main.tile[index328, index329].type = (ushort) 26;
                  Main.tile[index328, index329].frameX = (short) (index326 * 18 + 54 * num437);
                  Main.tile[index328, index329].frameY = (short) (index327 * 18);
                }
                if (!Main.tile[num436 + index326, num435 + 2].active() || !Main.tileSolid[(int) Main.tile[num436 + index326, num435 + 2].type] || Main.tileSolidTop[(int) Main.tile[num436 + index326, num435 + 2].type])
                {
                  Main.tile[num436 + index326, num435 + 2].active(true);
                  if (!TileID.Sets.Platforms[(int) Main.tile[num436 + index326, num435 + 2].type])
                  {
                    if (Main.tile[num436 + index326, num435 + 2].type == (ushort) 484)
                      Main.tile[num436 + index326, num435 + 2].type = (ushort) 397;
                    else if (TileID.Sets.Boulders[(int) Main.tile[num436 + index326, num435 + 2].type] || !Main.tileSolid[(int) Main.tile[num436 + index326, num435 + 2].type] || Main.tileSolidTop[(int) Main.tile[num436 + index326, num435 + 2].type])
                      Main.tile[num436 + index326, num435 + 2].type = (ushort) 0;
                  }
                }
                Main.tile[num436 + index326, num435 + 2].slope((byte) 0);
                Main.tile[num436 + index326, num435 + 2].halfBrick(false);
                if (Main.tile[num436 + index326, num435 + 3].type == (ushort) 28 && (int) Main.tile[num436 + index326, num435 + 3].frameY % 36 >= 18)
                {
                  Main.tile[num436 + index326, num435 + 3].type = (ushort) 0;
                  Main.tile[num436 + index326, num435 + 3].active(false);
                }
              }
              for (int index = 0; index < 3; ++index)
              {
                if ((Main.tile[num436 - 1, num435 + index].type == (ushort) 28 || Main.tile[num436 - 1, num435 + index].type == (ushort) 12 || Main.tile[num436 - 1, num435 + index].type == (ushort) 639) && (int) Main.tile[num436 - 1, num435 + index].frameX % 36 < 18)
                {
                  Main.tile[num436 - 1, num435 + index].type = (ushort) 0;
                  Main.tile[num436 - 1, num435 + index].active(false);
                }
                if ((Main.tile[num436 + 3, num435 + index].type == (ushort) 28 || Main.tile[num436 + 3, num435 + index].type == (ushort) 12 || Main.tile[num436 - 1, num435 + index].type == (ushort) 639) && (int) Main.tile[num436 + 3, num435 + index].frameX % 36 >= 18)
                {
                  Main.tile[num436 + 3, num435 + index].type = (ushort) 0;
                  Main.tile[num436 + 3, num435 + index].active(false);
                }
              }
            }
            if (Main.tile[i, j].type == (ushort) 237 && Main.tile[i, j + 1].type == (ushort) 232)
              Main.tile[i, j + 1].type = (ushort) 226;
            if (Main.tile[i, j].wall == (ushort) 87)
              Main.tile[i, j].liquid = (byte) 0;
          }
        }
      }));
      WorldGen.AddGenerationPass("Lihzahrd Altars", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        for (int index330 = 0; index330 < 3; ++index330)
        {
          for (int index331 = 0; index331 < 2; ++index331)
          {
            int index332 = GenVars.lAltarX + index330;
            int index333 = GenVars.lAltarY + index331;
            Main.tile[index332, index333].active(true);
            Main.tile[index332, index333].type = (ushort) 237;
            Main.tile[index332, index333].frameX = (short) (index330 * 18);
            Main.tile[index332, index333].frameY = (short) (index331 * 18);
          }
          Main.tile[GenVars.lAltarX + index330, GenVars.lAltarY + 2].active(true);
          Main.tile[GenVars.lAltarX + index330, GenVars.lAltarY + 2].slope((byte) 0);
          Main.tile[GenVars.lAltarX + index330, GenVars.lAltarY + 2].halfBrick(false);
          Main.tile[GenVars.lAltarX + index330, GenVars.lAltarY + 2].type = (ushort) 226;
        }
        for (int index334 = 0; index334 < 3; ++index334)
        {
          for (int index335 = 0; index335 < 2; ++index335)
            WorldGen.SquareTileFrame(GenVars.lAltarX + index334, GenVars.lAltarY + index335);
        }
      }));
      WorldGen.AddGenerationPass("Micro Biomes", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[76].Value;
        double num438 = (double) (Main.maxTilesX * Main.maxTilesY) / 5040000.0;
        double num439 = 10.0;
        if (WorldGen.getGoodWorldGen || WorldGen.noTrapsWorldGen)
          num439 *= 3.0;
        DeadMansChestBiome biome3 = GenVars.configuration.CreateBiome<DeadMansChestBiome>();
        List<int> possibleChestsToTrapify = biome3.GetPossibleChestsToTrapify(GenVars.structures);
        int random4 = passConfig.Get<WorldGenRange>("DeadManChests").GetRandom(WorldGen.genRand);
        int num440 = 0;
        int num441 = 3000;
        while (num440 < random4 && possibleChestsToTrapify.Count > 0)
        {
          --num441;
          if (num441 > 0)
          {
            int index = possibleChestsToTrapify[WorldGen.genRand.Next(possibleChestsToTrapify.Count)];
            Point origin = new Point(Main.chest[index].x, Main.chest[index].y);
            biome3.Place(origin, GenVars.structures);
            ++num440;
            possibleChestsToTrapify.Remove(index);
          }
          else
            break;
        }
        progress.Set(1.0 / num439);
        if (!WorldGen.notTheBees || WorldGen.remixWorldGen)
        {
          ThinIceBiome biome4 = GenVars.configuration.CreateBiome<ThinIceBiome>();
          int random5 = passConfig.Get<WorldGenRange>("ThinIcePatchCount").GetRandom(WorldGen.genRand);
          int num442 = 0;
          int num443 = 1000;
          int num444 = 0;
          while (num444 < random5)
          {
            if (biome4.Place(WorldGen.RandomWorldPoint((int) Main.worldSurface + 20, 50, 200, 50), GenVars.structures))
            {
              ++num444;
              num442 = 0;
            }
            else
            {
              ++num442;
              if (num442 > num443)
              {
                ++num444;
                num442 = 0;
              }
            }
          }
        }
        progress.Set(0.1);
        progress.Set(2.0 / num439);
        EnchantedSwordBiome biome5 = GenVars.configuration.CreateBiome<EnchantedSwordBiome>();
        int random6 = passConfig.Get<WorldGenRange>("SwordShrineAttempts").GetRandom(WorldGen.genRand);
        double num445 = passConfig.Get<double>("SwordShrinePlacementChance");
        if (WorldGen.tenthAnniversaryWorldGen)
        {
          random6 *= 2;
          num445 /= 2.0;
        }
        for (int index = 0; index < random6; ++index)
        {
          if (index == 0 && WorldGen.tenthAnniversaryWorldGen || WorldGen.genRand.NextDouble() <= num445)
          {
            int num446 = 0;
            while (num446++ <= Main.maxTilesX)
            {
              Point origin;
              origin.Y = (int) GenVars.worldSurface + WorldGen.genRand.Next(50, 100);
              origin.X = WorldGen.genRand.Next(2) != 0 ? WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.7), Main.maxTilesX - 50) : WorldGen.genRand.Next(50, (int) ((double) Main.maxTilesX * 0.3));
              if (biome5.Place(origin, GenVars.structures))
                break;
            }
          }
        }
        progress.Set(0.2);
        progress.Set(3.0 / num439);
        if (!WorldGen.notTheBees || WorldGen.remixWorldGen)
        {
          CampsiteBiome biome6 = GenVars.configuration.CreateBiome<CampsiteBiome>();
          int random7 = passConfig.Get<WorldGenRange>("CampsiteCount").GetRandom(WorldGen.genRand);
          int num447 = 1000;
          int num448 = 0;
          while (num448 < random7)
          {
            --num447;
            if (num447 > 0)
            {
              if (biome6.Place(WorldGen.RandomWorldPoint((int) Main.worldSurface, WorldGen.beachDistance, 200, WorldGen.beachDistance), GenVars.structures))
                ++num448;
            }
            else
              break;
          }
        }
        progress.Set(4.0 / num439);
        if (!WorldGen.notTheBees || WorldGen.remixWorldGen)
        {
          MiningExplosivesBiome biome7 = GenVars.configuration.CreateBiome<MiningExplosivesBiome>();
          int num449 = passConfig.Get<WorldGenRange>("ExplosiveTrapCount").GetRandom(WorldGen.genRand);
          if ((WorldGen.getGoodWorldGen || WorldGen.noTrapsWorldGen) && !WorldGen.notTheBees)
            num449 = (int) ((double) num449 * 1.5);
          int num450 = 3000;
          int num451 = 0;
          while (num451 < num449)
          {
            --num450;
            if (num450 > 0)
            {
              if (WorldGen.remixWorldGen)
              {
                if (biome7.Place(WorldGen.RandomWorldPoint((int) Main.worldSurface, WorldGen.beachDistance, (int) GenVars.rockLayer, WorldGen.beachDistance), GenVars.structures))
                  ++num451;
              }
              else if (biome7.Place(WorldGen.RandomWorldPoint((int) GenVars.rockLayer, WorldGen.beachDistance, 200, WorldGen.beachDistance), GenVars.structures))
                ++num451;
            }
            else
              break;
          }
        }
        progress.Set(0.3);
        progress.Set(5.0 / num439);
        MahoganyTreeBiome biome8 = GenVars.configuration.CreateBiome<MahoganyTreeBiome>();
        int random8 = passConfig.Get<WorldGenRange>("LivingTreeCount").GetRandom(WorldGen.genRand);
        int num452 = 0;
        for (int index = 0; num452 < random8 && index < 20000; ++index)
        {
          if (biome8.Place(WorldGen.RandomWorldPoint((int) Main.worldSurface + 50, 50, 500, 50), GenVars.structures))
            ++num452;
        }
        progress.Set(0.4);
        progress.Set(6.0 / num439);
        progress.Set(7.0 / num439);
        TrackGenerator trackGenerator = new TrackGenerator();
        int random9 = passConfig.Get<WorldGenRange>("LongTrackCount").GetRandom(WorldGen.genRand);
        WorldGenRange worldGenRange1 = passConfig.Get<WorldGenRange>("LongTrackLength");
        int maxTilesX = Main.maxTilesX;
        int num453 = 0;
        int num454 = 0;
        while (num454 < random9)
        {
          if (trackGenerator.Place(WorldGen.RandomWorldPoint((int) Main.worldSurface, 10, 200, 10), worldGenRange1.ScaledMinimum, worldGenRange1.ScaledMaximum))
          {
            ++num454;
            num453 = 0;
          }
          else
          {
            ++num453;
            if (num453 > maxTilesX)
            {
              ++num454;
              num453 = 0;
            }
          }
        }
        progress.Set(8.0 / num439);
        int random10 = passConfig.Get<WorldGenRange>("StandardTrackCount").GetRandom(WorldGen.genRand);
        WorldGenRange worldGenRange2 = passConfig.Get<WorldGenRange>("StandardTrackLength");
        int num455 = 0;
        int num456 = 0;
        while (num456 < random10)
        {
          if (trackGenerator.Place(WorldGen.RandomWorldPoint((int) Main.worldSurface, 10, 200, 10), worldGenRange2.ScaledMinimum, worldGenRange2.ScaledMaximum))
          {
            ++num456;
            num455 = 0;
          }
          else
          {
            ++num455;
            if (num455 > maxTilesX)
            {
              ++num456;
              num455 = 0;
            }
          }
        }
        progress.Set(9.0 / num439);
        if (!WorldGen.notTheBees)
        {
          double num457 = (double) Main.maxTilesX * 0.02;
          double num458;
          if (WorldGen.noTrapsWorldGen)
            num458 = num439 * 5.0;
          else if (WorldGen.getGoodWorldGen)
            num458 = num439 * 2.0;
          for (int index = 0; (double) index < num457; ++index)
          {
            int num459 = 0;
            while (num459 < 10150 && !WorldGen.placeLavaTrap(WorldGen.genRand.Next(200, Main.maxTilesX - 200), WorldGen.genRand.Next(GenVars.lavaLine - 100, Main.maxTilesY - 210)))
              ++num459;
          }
        }
        progress.Set(1.0);
      }));
      WorldGen.AddGenerationPass("Water Plants", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[88].Value;
        int num460 = (int) Main.worldSurface;
        if (WorldGen.remixWorldGen)
          num460 = Main.maxTilesY - 200;
        for (int x = 20; x < Main.maxTilesX - 20; ++x)
        {
          progress.Set((double) x / (double) Main.maxTilesX);
          for (int index336 = 1; index336 < num460; ++index336)
          {
            if (WorldGen.genRand.Next(5) == 0 && Main.tile[x, index336].liquid > (byte) 0)
            {
              if (!Main.tile[x, index336].active())
              {
                if (WorldGen.genRand.Next(2) == 0)
                {
                  WorldGen.PlaceLilyPad(x, index336);
                }
                else
                {
                  Point point = WorldGen.PlaceCatTail(x, index336);
                  if (WorldGen.InWorld(point.X, point.Y))
                  {
                    int num461 = WorldGen.genRand.Next(14);
                    for (int index337 = 0; index337 < num461; ++index337)
                      WorldGen.GrowCatTail(point.X, point.Y);
                    WorldGen.SquareTileFrame(point.X, point.Y);
                  }
                }
              }
              if ((!Main.tile[x, index336].active() || Main.tile[x, index336].type == (ushort) 61 || Main.tile[x, index336].type == (ushort) 74) && WorldGen.PlaceBamboo(x, index336))
              {
                int num462 = WorldGen.genRand.Next(10, 20);
                int num463 = 0;
                while (num463 < num462 && WorldGen.PlaceBamboo(x, index336 - num463))
                  ++num463;
              }
            }
          }
          for (int underworldLayer = Main.UnderworldLayer; (double) underworldLayer > Main.worldSurface; --underworldLayer)
          {
            if (Main.tile[x, underworldLayer].type == (ushort) 53 && WorldGen.genRand.Next(3) != 0)
              WorldGen.GrowCheckSeaweed(x, underworldLayer);
            else if (Main.tile[x, underworldLayer].type == (ushort) 549)
              WorldGen.GrowCheckSeaweed(x, underworldLayer);
          }
        }
      }));
      WorldGen.AddGenerationPass("Stalac", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1.0);
        for (int index = 20; index < Main.maxTilesX - 20; ++index)
        {
          for (int worldSurface = (int) Main.worldSurface; worldSurface < Main.maxTilesY - 20; ++worldSurface)
          {
            if ((Main.tenthAnniversaryWorld || WorldGen.drunkWorldGen || WorldGen.genRand.Next(5) == 0) && Main.tile[index, worldSurface - 1].liquid == (byte) 0)
            {
              int num = WorldGen.genRand.Next(7);
              int treeTileType = 0;
              switch (num)
              {
                case 0:
                  treeTileType = 583;
                  break;
                case 1:
                  treeTileType = 584;
                  break;
                case 2:
                  treeTileType = 585;
                  break;
                case 3:
                  treeTileType = 586;
                  break;
                case 4:
                  treeTileType = 587;
                  break;
                case 5:
                  treeTileType = 588;
                  break;
                case 6:
                  treeTileType = 589;
                  break;
              }
              WorldGen.TryGrowingTreeByType(treeTileType, index, worldSurface);
            }
            if (!WorldGen.oceanDepths(index, worldSurface) && !Main.tile[index, worldSurface].active() && WorldGen.genRand.Next(5) == 0)
            {
              if ((Main.tile[index, worldSurface - 1].type == (ushort) 1 || Main.tile[index, worldSurface - 1].type == (ushort) 147 || Main.tile[index, worldSurface - 1].type == (ushort) 161 || Main.tile[index, worldSurface - 1].type == (ushort) 25 || Main.tile[index, worldSurface - 1].type == (ushort) 203 || Main.tileStone[(int) Main.tile[index, worldSurface - 1].type] || Main.tileMoss[(int) Main.tile[index, worldSurface - 1].type]) && !Main.tile[index, worldSurface].active() && !Main.tile[index, worldSurface + 1].active())
                Main.tile[index, worldSurface - 1].slope((byte) 0);
              if ((Main.tile[index, worldSurface + 1].type == (ushort) 1 || Main.tile[index, worldSurface + 1].type == (ushort) 147 || Main.tile[index, worldSurface + 1].type == (ushort) 161 || Main.tile[index, worldSurface + 1].type == (ushort) 25 || Main.tile[index, worldSurface + 1].type == (ushort) 203 || Main.tileStone[(int) Main.tile[index, worldSurface + 1].type] || Main.tileMoss[(int) Main.tile[index, worldSurface + 1].type]) && !Main.tile[index, worldSurface].active() && !Main.tile[index, worldSurface - 1].active())
                Main.tile[index, worldSurface + 1].slope((byte) 0);
              WorldGen.PlaceTight(index, worldSurface);
            }
          }
          for (int y = 5; y < (int) Main.worldSurface; ++y)
          {
            if ((Main.tile[index, y - 1].type == (ushort) 147 || Main.tile[index, y - 1].type == (ushort) 161) && WorldGen.genRand.Next(5) == 0)
            {
              if (!Main.tile[index, y].active() && !Main.tile[index, y + 1].active())
                Main.tile[index, y - 1].slope((byte) 0);
              WorldGen.PlaceTight(index, y);
            }
            if ((Main.tile[index, y - 1].type == (ushort) 25 || Main.tile[index, y - 1].type == (ushort) 203) && WorldGen.genRand.Next(5) == 0)
            {
              if (!Main.tile[index, y].active() && !Main.tile[index, y + 1].active())
                Main.tile[index, y - 1].slope((byte) 0);
              WorldGen.PlaceTight(index, y);
            }
            if ((Main.tile[index, y + 1].type == (ushort) 25 || Main.tile[index, y + 1].type == (ushort) 203) && WorldGen.genRand.Next(5) == 0)
            {
              if (!Main.tile[index, y].active() && !Main.tile[index, y - 1].active())
                Main.tile[index, y + 1].slope((byte) 0);
              WorldGen.PlaceTight(index, y);
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Remove Broken Traps", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.noTrapsWorldGen && !WorldGen.tenthAnniversaryWorldGen && !WorldGen.notTheBees)
          return;
        progress.Message = Lang.gen[82].Value;
        List<Point> pointsWeAlreadyWentOver = new List<Point>();
        int num464 = 50;
        for (int x = num464; x < Main.maxTilesX - num464; ++x)
        {
          double num465 = (double) (x - num464) / (double) (Main.maxTilesX - num464 * 2);
          progress.Set(num465);
          for (int y = 50; y < Main.maxTilesY - 50; ++y)
          {
            if (Main.tile[x, y].wire() && !pointsWeAlreadyWentOver.Contains(new Point(x, y)))
              WorldGen.ClearBrokenTraps(new Point(x, y), pointsWeAlreadyWentOver);
          }
        }
      }));
      WorldGen.AddGenerationPass("Final Cleanup", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        Main.tileSolid[484] = false;
        WorldGen.FillWallHolesInArea(new Microsoft.Xna.Framework.Rectangle(0, 0, Main.maxTilesX, (int) Main.worldSurface));
        progress.Message = Lang.gen[86].Value;
        for (int index338 = 0; index338 < Main.maxTilesX; ++index338)
        {
          progress.Set((double) index338 / (double) Main.maxTilesX);
          for (int index339 = 0; index339 < Main.maxTilesY; ++index339)
          {
            if (Main.tile[index338, index339].active() && !WorldGen.SolidTile(index338, index339 + 1) && (Main.tile[index338, index339].type == (ushort) 53 || Main.tile[index338, index339].type == (ushort) 112 || Main.tile[index338, index339].type == (ushort) 234 || Main.tile[index338, index339].type == (ushort) 224 || Main.tile[index338, index339].type == (ushort) 123))
            {
              if ((double) index339 < Main.worldSurface + 10.0 && !Main.tile[index338, index339 + 1].active() && Main.tile[index338, index339 + 1].wall != (ushort) 191 && !WorldGen.oceanDepths(index338, index339))
              {
                int num = 10;
                int index340 = index339 + 1;
                for (int index341 = index340; index341 < index340 + 10; ++index341)
                {
                  if (Main.tile[index338, index341].active() && Main.tile[index338, index341].type == (ushort) 314)
                  {
                    num = 0;
                    break;
                  }
                }
                for (; !Main.tile[index338, index340].active() && num > 0 && index340 < Main.maxTilesY - 50; --num)
                {
                  Main.tile[index338, index340 - 1].slope((byte) 0);
                  Main.tile[index338, index340 - 1].halfBrick(false);
                  Main.tile[index338, index340].active(true);
                  Main.tile[index338, index340].type = Main.tile[index338, index339].type;
                  Main.tile[index338, index340].slope((byte) 0);
                  Main.tile[index338, index340].halfBrick(false);
                  ++index340;
                }
                if (num == 0 && !Main.tile[index338, index340].active())
                {
                  switch (Main.tile[index338, index339].type)
                  {
                    case 53:
                      Main.tile[index338, index340].type = (ushort) 397;
                      Main.tile[index338, index340].active(true);
                      break;
                    case 112:
                      Main.tile[index338, index340].type = (ushort) 398;
                      Main.tile[index338, index340].active(true);
                      break;
                    case 123:
                      Main.tile[index338, index340].type = (ushort) 1;
                      Main.tile[index338, index340].active(true);
                      break;
                    case 224:
                      Main.tile[index338, index340].type = (ushort) 147;
                      Main.tile[index338, index340].active(true);
                      break;
                    case 234:
                      Main.tile[index338, index340].type = (ushort) 399;
                      Main.tile[index338, index340].active(true);
                      break;
                  }
                }
                else if (Main.tile[index338, index340].active() && Main.tileSolid[(int) Main.tile[index338, index340].type] && !Main.tileSolidTop[(int) Main.tile[index338, index340].type])
                {
                  Main.tile[index338, index340].slope((byte) 0);
                  Main.tile[index338, index340].halfBrick(false);
                }
              }
              else if (Main.tileSolid[(int) Main.tile[index338, index339 + 1].type] && !Main.tileSolidTop[(int) Main.tile[index338, index339 + 1].type] && (Main.tile[index338, index339 + 1].topSlope() || Main.tile[index338, index339 + 1].halfBrick()))
              {
                Main.tile[index338, index339 + 1].slope((byte) 0);
                Main.tile[index338, index339 + 1].halfBrick(false);
              }
              else
              {
                switch (Main.tile[index338, index339].type)
                {
                  case 53:
                    Main.tile[index338, index339].type = (ushort) 397;
                    break;
                  case 112:
                    Main.tile[index338, index339].type = (ushort) 398;
                    break;
                  case 123:
                    Main.tile[index338, index339].type = (ushort) 1;
                    break;
                  case 224:
                    Main.tile[index338, index339].type = (ushort) 147;
                    break;
                  case 234:
                    Main.tile[index338, index339].type = (ushort) 399;
                    break;
                }
              }
              if (Main.tile[index338, index339 - 1].type == (ushort) 323)
                WorldGen.TileFrame(index338, index339 - 1);
            }
            if ((Main.tile[index338, index339].wall == (ushort) 187 || Main.tile[index338, index339].wall == (ushort) 216) && Main.tile[index338, index339].liquid > (byte) 0 && !WorldGen.remixWorldGen)
            {
              Main.tile[index338, index339].liquid = byte.MaxValue;
              Main.tile[index338, index339].lava(true);
            }
            if (Main.tile[index338, index339].type == (ushort) 485 || Main.tile[index338, index339].type == (ushort) 187 || Main.tile[index338, index339].type == (ushort) 165)
              WorldGen.TileFrame(index338, index339);
            if (Main.tile[index338, index339].type == (ushort) 28)
              WorldGen.TileFrame(index338, index339);
            if (Main.tile[index338, index339].type == (ushort) 10 || Main.tile[index338, index339].type == (ushort) 11)
              WorldGen.TileFrame(index338, index339);
            if (Main.tile[index338, index339].type == (ushort) 26)
              WorldGen.TileFrame(index338, index339);
            if (TileID.Sets.IsATreeTrunk[(int) Main.tile[index338, index339].type] || Main.tile[index338, index339].type == (ushort) 323)
              WorldGen.TileFrame(index338, index339);
            if (Main.tile[index338, index339].type == (ushort) 137)
            {
              Main.tile[index338, index339].slope((byte) 0);
              Main.tile[index338, index339].halfBrick(false);
            }
            if (Main.tile[index338, index339].active() && TileID.Sets.Boulders[(int) Main.tile[index338, index339].type])
            {
              int num466 = (int) Main.tile[index338, index339].frameX / 18;
              int num467 = index338 - num466;
              int num468 = (int) Main.tile[index338, index339].frameY / 18;
              int num469 = index339 - num468;
              bool flag = false;
              for (int index342 = 0; index342 < 2; ++index342)
              {
                Tile tile = Main.tile[num467 + index342, num469 - 1];
                if (tile != null && tile.active() && tile.type == (ushort) 26)
                {
                  flag = true;
                  break;
                }
                for (int index343 = 0; index343 < 2; ++index343)
                {
                  int index344 = num467 + index342;
                  int index345 = num469 + index343;
                  Main.tile[index344, index345].active(true);
                  Main.tile[index344, index345].slope((byte) 0);
                  Main.tile[index344, index345].halfBrick(false);
                  Main.tile[index344, index345].type = Main.tile[index338, index339].type;
                  Main.tile[index344, index345].frameX = (short) (index342 * 18);
                  Main.tile[index344, index345].frameY = (short) (index343 * 18);
                }
              }
              if (flag)
              {
                ushort num470 = 0;
                if (Main.tile[index338, index339].type == (ushort) 484)
                  num470 = (ushort) 397;
                for (int index346 = 0; index346 < 2; ++index346)
                {
                  for (int index347 = 0; index347 < 2; ++index347)
                  {
                    int index348 = num467 + index346;
                    int index349 = num469 + index347;
                    Main.tile[index348, index349].active(true);
                    Main.tile[index348, index349].slope((byte) 0);
                    Main.tile[index348, index349].halfBrick(false);
                    Main.tile[index348, index349].type = num470;
                    Main.tile[index348, index349].frameX = (short) 0;
                    Main.tile[index348, index349].frameY = (short) 0;
                  }
                }
              }
            }
            if (Main.tile[index338, index339].type == (ushort) 323 && Main.tile[index338, index339].liquid > (byte) 0)
              WorldGen.KillTile(index338, index339);
            if (Main.wallDungeon[(int) Main.tile[index338, index339].wall])
            {
              Main.tile[index338, index339].lava(false);
              if (Main.tile[index338, index339].active() && Main.tile[index338, index339].type == (ushort) 56)
              {
                WorldGen.KillTile(index338, index339);
                Main.tile[index338, index339].lava(false);
                Main.tile[index338, index339].liquid = byte.MaxValue;
              }
            }
            if (Main.tile[index338, index339].active() && Main.tile[index338, index339].type == (ushort) 314)
            {
              int num471 = 15;
              int num472 = 1;
              for (int index350 = index339; index339 - index350 < num471; --index350)
                Main.tile[index338, index350].liquid = (byte) 0;
              for (int index351 = index339; index351 - index339 < num472; ++index351)
                Main.tile[index338, index351].liquid = (byte) 0;
            }
            if (Main.tile[index338, index339].active() && Main.tile[index338, index339].type == (ushort) 332 && !Main.tile[index338, index339 + 1].active())
            {
              Main.tile[index338, index339 + 1].ClearEverything();
              Main.tile[index338, index339 + 1].active(true);
              Main.tile[index338, index339 + 1].type = (ushort) 332;
            }
            if (index338 > WorldGen.beachDistance && index338 < Main.maxTilesX - WorldGen.beachDistance && (double) index339 < Main.worldSurface && Main.tile[index338, index339].liquid > (byte) 0 && Main.tile[index338, index339].liquid < byte.MaxValue && Main.tile[index338 - 1, index339].liquid < byte.MaxValue && Main.tile[index338 + 1, index339].liquid < byte.MaxValue && Main.tile[index338, index339 + 1].liquid < byte.MaxValue && !TileID.Sets.Clouds[(int) Main.tile[index338 - 1, index339].type] && !TileID.Sets.Clouds[(int) Main.tile[index338 + 1, index339].type] && !TileID.Sets.Clouds[(int) Main.tile[index338, index339 + 1].type])
              Main.tile[index338, index339].liquid = (byte) 0;
          }
        }
        int num473 = 0;
        int num474;
        switch (WorldGen.GetWorldSize())
        {
          case 1:
            num474 = 6;
            break;
          case 2:
            num474 = 9;
            break;
          default:
            num474 = 3;
            break;
        }
        if (WorldGen.tenthAnniversaryWorldGen)
          num474 *= 5;
        int num475 = 50;
        int minValue3 = num475;
        int minValue4 = num475;
        int maxValue6 = Main.maxTilesX - num475;
        int maxValue7 = Main.maxTilesY - 200;
        int num476 = 3000;
        while (num473 < num474)
        {
          --num476;
          if (num476 > 0)
          {
            int index352 = WorldGen.genRand.Next(minValue3, maxValue6);
            int index353 = WorldGen.genRand.Next(minValue4, maxValue7);
            Tile tile = Main.tile[index352, index353];
            if (tile.active() && tile.type >= (ushort) 0 && (int) tile.type < (int) TileID.Count)
            {
              bool flag = TileID.Sets.Dirt[(int) tile.type];
              if (WorldGen.notTheBees)
                flag = flag || TileID.Sets.Mud[(int) tile.type];
              if (flag)
              {
                ++num473;
                tile.ClearTile();
                tile.active(true);
                tile.type = (ushort) 668;
              }
            }
          }
          else
            break;
        }
        if (WorldGen.noTrapsWorldGen)
          WorldGen.FinishNoTraps();
        if (Main.tenthAnniversaryWorld)
          WorldGen.FinishTenthAnniversaryWorld();
        if (WorldGen.drunkWorldGen)
          WorldGen.FinishDrunkGen();
        if (WorldGen.notTheBees)
        {
          WorldGen.NotTheBees();
          WorldGen.FinishNotTheBees();
        }
        if (WorldGen.getGoodWorldGen)
          WorldGen.FinishGetGoodWorld();
        if (WorldGen.remixWorldGen)
          WorldGen.FinishRemixWorld();
        WorldGen.ShimmerCleanUp();
        WorldGen.notTheBees = false;
        WorldGen.getGoodWorldGen = false;
        WorldGen.noTileActions = false;
        Main.tileSolid[659] = true;
        Main.tileSolid[(int) GenVars.crackedType] = true;
        Main.tileSolid[484] = true;
        WorldGen.gen = false;
        Main.AnglerQuestSwap();
        WorldGen.skipFramingDuringGen = false;
        progress.Message = Lang.gen[87].Value;
      }));
      WorldGen._generator.GenerateWorld(customProgressObject);
      WorldGen.ConsumePostGenActions(GenVars.structures);
      Main.WorldFileMetadata = FileMetadata.FromCurrentSettings(FileType.World);
      Main.NotifyOfEvent(GameNotificationType.WorldGen);
      WorldGen.drunkWorldGenText = false;
    }

    private static Point GetAdjustedFloorPosition(int x, int y)
    {
      int topLeftX = x - 1;
      int topLeftY = y - 2;
      bool isEmpty = false;
      bool hasFloor = false;
      while (!isEmpty && topLeftY > Main.spawnTileY - 10)
      {
        WorldGen.Scan3By3(topLeftX, topLeftY, out isEmpty, out hasFloor);
        if (!isEmpty)
          --topLeftY;
      }
      while (!hasFloor && topLeftY < Main.spawnTileY + 10)
      {
        WorldGen.Scan3By3(topLeftX, topLeftY, out isEmpty, out hasFloor);
        if (!hasFloor)
          ++topLeftY;
      }
      return new Point(topLeftX + 1, topLeftY + 2);
    }

    private static void Scan3By3(int topLeftX, int topLeftY, out bool isEmpty, out bool hasFloor)
    {
      isEmpty = true;
      hasFloor = false;
      for (int index1 = 0; index1 < 3; ++index1)
      {
        for (int index2 = 0; index2 < 3; ++index2)
        {
          if (WorldGen.SolidTile(topLeftX + index1, topLeftY + index2))
          {
            isEmpty = false;
            goto label_8;
          }
        }
      }
label_8:
      for (int index = 0; index < 3; ++index)
      {
        if (WorldGen.SolidTile(topLeftX + index, topLeftY + 3))
        {
          hasFloor = true;
          break;
        }
      }
    }

    private static void FinishTenthAnniversaryWorld()
    {
      if (!WorldGen.remixWorldGen)
      {
        if (!WorldGen.getGoodWorldGen && !WorldGen.drunkWorldGen)
          WorldGen.ConvertSkyIslands(2, true);
        WorldGen.PaintTheDungeon((byte) 24, (byte) 24);
        WorldGen.PaintTheLivingTrees((byte) 12, (byte) 12);
        WorldGen.PaintTheTemple((byte) 10, (byte) 5);
        WorldGen.PaintTheClouds((byte) 12, (byte) 12);
        WorldGen.PaintTheSand((byte) 7, (byte) 7);
        WorldGen.PaintThePyramids((byte) 12, (byte) 12);
      }
      WorldGen.PaintTheTrees();
      WorldGen.PaintTheMushrooms();
      if (!WorldGen.getGoodWorldGen)
      {
        for (int index1 = 50; index1 < Main.maxTilesX - 50; ++index1)
        {
          for (int index2 = 50; index2 < Main.maxTilesY - 50; ++index2)
          {
            Tile tile = Main.tile[index1, index2];
            if (WorldGen.genRand.Next(4) == 0 && tile.active() && tile.type == (ushort) 138 && tile.frameX == (short) 0 && tile.frameY == (short) 0)
            {
              Main.tile[index1, index2].type = (ushort) 665;
              Main.tile[index1, index2 + 1].type = (ushort) 665;
              Main.tile[index1 + 1, index2].type = (ushort) 665;
              Main.tile[index1 + 1, index2 + 1].type = (ushort) 665;
            }
          }
        }
      }
      if (WorldGen.getGoodWorldGen)
        return;
      WorldGen.ImproveAllChestContents();
    }

    private static void PaintTheMushrooms()
    {
      int num1 = Main.maxTilesY - 20;
      byte num2 = (byte) WorldGen.genRand.Next(1, 13);
      if (WorldGen.remixWorldGen)
      {
        byte num3 = 2;
        num1 = Main.maxTilesY - 500;
        int num4 = WorldGen.genRand.Next(5, 31);
        if (WorldGen.genRand.Next(2) == 0)
          num4 = WorldGen.genRand.Next(5, 16);
        for (int index1 = 20; index1 < Main.maxTilesX - 20; ++index1)
        {
          if (index1 % num4 == 0)
          {
            ++num3;
            if (num3 > (byte) 12)
              num3 = (byte) 1;
          }
          for (int index2 = Main.maxTilesY - 450; index2 < Main.maxTilesY - 20; ++index2)
          {
            Tile tile = Main.tile[index1, index2];
            if (tile.active() && (tile.type == (ushort) 70 || tile.type == (ushort) 578 || tile.type == (ushort) 190 || tile.type == (ushort) 71 || tile.type == (ushort) 528 || tile.type == (ushort) 519 && tile.frameY == (short) 90))
              tile.color(num3);
            if (tile.wall == (ushort) 80 || tile.wall == (ushort) 74)
              tile.wallColor(num3);
          }
        }
      }
      byte num5 = (byte) WorldGen.genRand.Next(1, 13);
      int num6 = 0;
      for (int index3 = 20; index3 < Main.maxTilesX - 20; ++index3)
      {
        for (int index4 = 20; index4 < num1; ++index4)
        {
          Tile tile = Main.tile[index3, index4];
          if (tile.active() && (tile.type == (ushort) 70 || tile.type == (ushort) 578 || tile.type == (ushort) 190 || tile.type == (ushort) 71 || tile.type == (ushort) 528 || tile.type == (ushort) 519 && tile.frameY == (short) 90))
          {
            tile.color(num5);
            num6 = 10;
          }
          if (tile.wall == (ushort) 80 || tile.wall == (ushort) 74)
          {
            tile.wallColor(num5);
            num6 = 10;
          }
        }
        --num6;
        if (num6 == 0)
        {
          num5 += (byte) WorldGen.genRand.Next(1, 3);
          if (num5 > (byte) 12)
            num5 = (byte) 1;
        }
      }
    }

    private static void PaintTheTrees()
    {
      int num = 20;
      if (WorldGen.remixWorldGen)
        num = (int) Main.worldSurface;
      byte color = (byte) WorldGen.genRand.Next(1, 13);
      bool flag1 = false;
      for (int index1 = 20; index1 < Main.maxTilesX - 20; ++index1)
      {
        bool flag2 = false;
        for (int index2 = num; index2 < Main.maxTilesY - 20; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile.active() && (tile.type == (ushort) 5 || tile.type == (ushort) 323 || tile.type == (ushort) 596 || tile.type == (ushort) 616))
          {
            tile.color(color);
            flag2 = true;
            flag1 = true;
          }
        }
        if (flag1 && !flag2)
        {
          flag1 = false;
          ++color;
          if (color > (byte) 12)
            color = (byte) 1;
        }
      }
    }

    private static void PaintTheSand(byte tilePaintColor, byte wallPaintColor)
    {
      for (int index1 = 20; index1 < Main.maxTilesX - 20; ++index1)
      {
        for (int index2 = 20; index2 < Main.maxTilesY - 20; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile.active() && (tile.type == (ushort) 53 || tile.type == (ushort) 396 || tile.type == (ushort) 397))
          {
            tile.color(tilePaintColor);
            if ((double) index2 > Main.worldSurface)
            {
              if (Main.tile[index1, index2 - 1].type == (ushort) 165 || Main.tile[index1, index2 - 1].type == (ushort) 185 || Main.tile[index1, index2 - 1].type == (ushort) 186 || Main.tile[index1, index2 - 1].type == (ushort) 187)
                Main.tile[index1, index2 - 1].color(tilePaintColor);
              if (Main.tile[index1, index2 - 2].type == (ushort) 165 || Main.tile[index1, index2 - 2].type == (ushort) 185 || Main.tile[index1, index2 - 2].type == (ushort) 186 || Main.tile[index1, index2 - 2].type == (ushort) 187)
                Main.tile[index1, index2 - 2].color(tilePaintColor);
              if (Main.tile[index1, index2 + 1].type == (ushort) 165)
                Main.tile[index1, index2 + 1].color(tilePaintColor);
              if (Main.tile[index1, index2 + 2].type == (ushort) 165)
                Main.tile[index1, index2 + 2].color(tilePaintColor);
            }
          }
          if (tile.wall == (ushort) 187 || tile.wall == (ushort) 216)
            tile.wallColor(tilePaintColor);
        }
      }
    }

    private static void PaintThePurityGrass(byte tilePaintColor, byte wallPaintColor)
    {
      for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
      {
        for (int index2 = 0; index2 < Main.maxTilesY; ++index2)
        {
          Tile tile1 = Main.tile[index1, index2];
          if (tile1.active())
          {
            if (tile1.type == (ushort) 2)
              tile1.color(tilePaintColor);
            else if (tile1.type == (ushort) 185 || tile1.type == (ushort) 186 || tile1.type == (ushort) 187)
            {
              Tile tile2 = tile1;
              int num = index2;
              while (num < Main.maxTilesY - 20 && (tile2.type == (ushort) 185 || tile2.type == (ushort) 186 || tile2.type == (ushort) 187 || tile2.type == (ushort) 3 || tile2.type == (ushort) 73))
                tile2 = Main.tile[index1, ++num];
              if (tile2.type == (ushort) 2)
                tile1.color(tilePaintColor);
            }
          }
          if (tile1.wall == (ushort) 66 || tile1.wall == (ushort) 63)
            tile1.wallColor(wallPaintColor);
        }
      }
    }

    private static void PaintThePyramids(byte tilePaintColor, byte wallPaintColor)
    {
      for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
      {
        for (int index2 = 0; index2 < Main.maxTilesY; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile.active() && tile.type == (ushort) 151)
            tile.color(tilePaintColor);
          if (tile.wall == (ushort) 34)
            tile.wallColor(wallPaintColor);
        }
      }
    }

    private static void PaintTheTemple(byte tilePaintColor, byte wallPaintColor)
    {
      for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
      {
        for (int index2 = 0; index2 < Main.maxTilesY; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile.active())
          {
            bool flag = false;
            if (tile.type == (ushort) 226)
              flag = true;
            if (tile.type == (ushort) 137)
            {
              switch ((int) tile.frameY / 18)
              {
                case 1:
                case 2:
                case 3:
                case 4:
                  flag = true;
                  break;
              }
            }
            if (flag)
              tile.color(tilePaintColor);
          }
          if (tile.wall == (ushort) 87)
            tile.wallColor(wallPaintColor);
        }
      }
    }

    private static void PaintTheClouds(byte tilePaintColor, byte wallPaintColor)
    {
      for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
      {
        for (int index2 = 0; index2 < Main.maxTilesY; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile.active() && (tile.type == (ushort) 189 || tile.type == (ushort) 196 || tile.type == (ushort) 460))
            tile.color(tilePaintColor);
          if (tile.wall == (ushort) 73)
            tile.wallColor(wallPaintColor);
        }
      }
    }

    private static void PaintTheDungeon(byte tilePaintColor, byte wallPaintColor)
    {
      for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
      {
        for (int index2 = 0; index2 < Main.maxTilesY; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile.active())
          {
            if (Main.tileDungeon[(int) tile.type] || TileID.Sets.CrackedBricks[(int) tile.type])
              tile.color(tilePaintColor);
            if (tile.type == (ushort) 19)
            {
              switch ((int) tile.frameY / 18)
              {
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                  tile.color(tilePaintColor);
                  break;
              }
            }
          }
          if (Main.wallDungeon[(int) tile.wall])
            tile.wallColor(wallPaintColor);
        }
      }
    }

    private static void PaintTheLivingTrees(
      byte livingTreePaintColor,
      byte livingTreeWallPaintColor)
    {
      for (int i = 0; i < Main.maxTilesX; ++i)
      {
        for (int j = 0; j < Main.maxTilesY; ++j)
        {
          Tile tile1 = Main.tile[i, j];
          if (tile1.active())
          {
            if (tile1.wall == (ushort) 244)
              tile1.color(livingTreePaintColor);
            else if (tile1.type == (ushort) 192 || tile1.type == (ushort) 191)
              tile1.color(livingTreePaintColor);
            else if (tile1.type == (ushort) 52 || tile1.type == (ushort) 382)
            {
              int x = i;
              int y = j;
              WorldGen.GetVineTop(i, j, out x, out y);
              if (Main.tile[x, y].type == (ushort) 192)
                tile1.color(livingTreePaintColor);
            }
            else if (tile1.type == (ushort) 187)
            {
              Tile tile2 = tile1;
              int num = 0;
              for (; tile2.type == (ushort) 187; tile2 = Main.tile[i, j + num])
                ++num;
              if (tile2.type == (ushort) 192)
                tile1.color(livingTreePaintColor);
            }
          }
          if (tile1.wall == (ushort) 244)
            tile1.wallColor(livingTreeWallPaintColor);
        }
      }
    }

    private static void ConvertSkyIslands(int convertType, bool growTrees)
    {
      int num = 0;
      for (int index1 = 20; (double) index1 < Main.worldSurface; ++index1)
      {
        for (int index2 = 20; index2 < Main.maxTilesX - 20; ++index2)
        {
          Tile tile = Main.tile[index2, index1];
          if (tile.active() && TileID.Sets.Clouds[(int) tile.type])
          {
            num = index1;
            break;
          }
        }
      }
      for (int i = 20; i <= Main.maxTilesX - 20; ++i)
      {
        for (int index = 20; index < num; ++index)
        {
          Tile tile1 = Main.tile[i, index];
          Tile tile2 = Main.tile[i, index - 1];
          if (tile1.active() && tile1.type == (ushort) 2)
          {
            if (tile2.type == (ushort) 596 || tile2.type == (ushort) 616)
              WorldGen.KillTile(i, index - 1);
            WorldGen.Convert(i, index, convertType, 1);
            switch (tile2.type)
            {
              case 82:
              case 83:
              case 185:
              case 186:
              case 187:
              case 227:
                WorldGen.KillTile(i, index - 1);
                break;
            }
            if (growTrees && WorldGen._genRand.Next(3) == 0)
              WorldGen.GrowTree(i, index);
          }
        }
      }
    }

    private static void ImproveAllChestContents()
    {
      for (int index1 = 0; index1 < 8000; ++index1)
      {
        Chest chest = Main.chest[index1];
        if (chest != null)
        {
          for (int index2 = 0; index2 < 40; ++index2)
          {
            Item obj = chest.item[index2];
            if (obj != null && !obj.IsAir)
              WorldGen.GiveItemGoodPrefixes(obj);
          }
        }
      }
    }

    private static void GiveItemGoodPrefixes(Item item)
    {
      if (item.accessory)
        WorldGen.PrefixItemFromOptions(item, WorldGen.TenthAnniversaryWorldInfo.GoodPrefixIdsForAccessory);
      if (item.melee)
        WorldGen.PrefixItemFromOptions(item, WorldGen.TenthAnniversaryWorldInfo.GoodPrefixIdsForMeleeWeapon);
      if (item.ranged)
        WorldGen.PrefixItemFromOptions(item, WorldGen.TenthAnniversaryWorldInfo.GoodPrefixIdsForRangedWeapon);
      if (item.magic)
        WorldGen.PrefixItemFromOptions(item, WorldGen.TenthAnniversaryWorldInfo.GoodPrefixIdsForMagicWeapon);
      if (!item.summon)
        return;
      WorldGen.PrefixItemFromOptions(item, WorldGen.TenthAnniversaryWorldInfo.GoodPrefixIdsForSummonerWeapon);
    }

    private static void PrefixItemFromOptions(Item item, int[] options)
    {
      byte prefix = item.prefix;
      if (!item.Prefix(-3))
        return;
      List<int> intList = new List<int>((IEnumerable<int>) options);
      while (intList.Count > 0)
      {
        int index = WorldGen._genRand.Next(intList.Count);
        int prefixWeWant = intList[index];
        item.Prefix(prefixWeWant);
        if ((int) item.prefix == prefixWeWant)
          return;
        intList.RemoveAt(index);
      }
      item.Prefix((int) prefix);
    }

    private static void NotTheBees()
    {
      int num = Main.maxTilesX / 7;
      if (!WorldGen.notTheBees)
        return;
      for (int x = 0; x < Main.maxTilesX; ++x)
      {
        for (int y = 0; y < Main.maxTilesY - 180; ++y)
        {
          if (!WorldGen.remixWorldGen || x >= num + WorldGen.genRand.Next(3) && x < Main.maxTilesX - num - WorldGen.genRand.Next(3) && ((double) y <= (Main.worldSurface * 2.0 + Main.rockLayer) / 3.0 + (double) WorldGen.genRand.Next(3) || y >= Main.maxTilesY - 350 - WorldGen.genRand.Next(3)))
          {
            if (Main.tile[x, y].type == (ushort) 52)
              Main.tile[x, y].type = (ushort) 62;
            if ((WorldGen.SolidOrSlopedTile(x, y) || TileID.Sets.CrackedBricks[(int) Main.tile[x, y].type]) && !TileID.Sets.Ore[(int) Main.tile[x, y].type] && Main.tile[x, y].type != (ushort) 123 && Main.tile[x, y].type != (ushort) 40)
            {
              if (Main.tile[x, y].type == (ushort) 191 || Main.tile[x, y].type == (ushort) 383)
              {
                if (!WorldGen.remixWorldGen)
                  Main.tile[x, y].type = (ushort) 383;
              }
              else if (Main.tile[x, y].type == (ushort) 192 || Main.tile[x, y].type == (ushort) 384)
              {
                if (!WorldGen.remixWorldGen)
                  Main.tile[x, y].type = (ushort) 384;
              }
              else if (Main.tile[x, y].type != (ushort) 151 && Main.tile[x, y].type != (ushort) 662 && Main.tile[x, y].type != (ushort) 661 && Main.tile[x, y].type != (ushort) 189 && Main.tile[x, y].type != (ushort) 196 && Main.tile[x, y].type != (ushort) 120 && Main.tile[x, y].type != (ushort) 158 && Main.tile[x, y].type != (ushort) 175 && Main.tile[x, y].type != (ushort) 45 && Main.tile[x, y].type != (ushort) 119)
              {
                if (Main.tile[x, y].type >= (ushort) 63 && Main.tile[x, y].type <= (ushort) 68)
                  Main.tile[x, y].type = (ushort) 230;
                else if (Main.tile[x, y].type != (ushort) 57 && Main.tile[x, y].type != (ushort) 76 && Main.tile[x, y].type != (ushort) 75 && Main.tile[x, y].type != (ushort) 229 && Main.tile[x, y].type != (ushort) 230 && Main.tile[x, y].type != (ushort) 407 && Main.tile[x, y].type != (ushort) 404)
                {
                  if (Main.tile[x, y].type == (ushort) 224)
                    Main.tile[x, y].type = (ushort) 229;
                  else if (Main.tile[x, y].type == (ushort) 53)
                  {
                    if (x < WorldGen.beachDistance + WorldGen.genRand.Next(3) || x > Main.maxTilesX - WorldGen.beachDistance - WorldGen.genRand.Next(3))
                      Main.tile[x, y].type = (ushort) 229;
                  }
                  else if ((x <= WorldGen.beachDistance - WorldGen.genRand.Next(3) || x >= Main.maxTilesX - WorldGen.beachDistance + WorldGen.genRand.Next(3) || Main.tile[x, y].type != (ushort) 397 && Main.tile[x, y].type != (ushort) 396) && Main.tile[x, y].type != (ushort) 10 && Main.tile[x, y].type != (ushort) 203 && Main.tile[x, y].type != (ushort) 25 && Main.tile[x, y].type != (ushort) 137 && Main.tile[x, y].type != (ushort) 138 && Main.tile[x, y].type != (ushort) 141)
                  {
                    if (Main.tileDungeon[(int) Main.tile[x, y].type] || TileID.Sets.CrackedBricks[(int) Main.tile[x, y].type])
                      Main.tile[x, y].color((byte) 14);
                    else if (Main.tile[x, y].type == (ushort) 226)
                      Main.tile[x, y].color((byte) 15);
                    else if (Main.tile[x, y].type != (ushort) 202 && Main.tile[x, y].type != (ushort) 70 && Main.tile[x, y].type != (ushort) 48 && Main.tile[x, y].type != (ushort) 232)
                    {
                      if (TileID.Sets.Conversion.Grass[(int) Main.tile[x, y].type] || Main.tile[x, y].type == (ushort) 60 || Main.tile[x, y].type == (ushort) 70)
                        Main.tile[x, y].type = y <= GenVars.lavaLine + WorldGen.genRand.Next(-2, 3) + 2 ? (ushort) 60 : (ushort) 70;
                      else if (Main.tile[x, y].type == (ushort) 0 || Main.tile[x, y].type == (ushort) 59)
                        Main.tile[x, y].type = (ushort) 59;
                      else if (Main.tile[x, y].type != (ushort) 633)
                      {
                        if (y > GenVars.lavaLine + WorldGen.genRand.Next(-2, 3) + 2)
                          Main.tile[x, y].type = (ushort) 230;
                        else if (!WorldGen.remixWorldGen || (double) y > Main.worldSurface + (double) WorldGen.genRand.Next(-1, 2))
                          Main.tile[x, y].type = (ushort) 225;
                      }
                    }
                  }
                }
              }
            }
            if (Main.tile[x, y].wall != (ushort) 15 && Main.tile[x, y].wall != (ushort) 64 && Main.tile[x, y].wall != (ushort) 204 && Main.tile[x, y].wall != (ushort) 205 && Main.tile[x, y].wall != (ushort) 206 && Main.tile[x, y].wall != (ushort) 207 && Main.tile[x, y].wall != (ushort) 23 && Main.tile[x, y].wall != (ushort) 24 && Main.tile[x, y].wall != (ushort) 42 && Main.tile[x, y].wall != (ushort) 10 && Main.tile[x, y].wall != (ushort) 21 && Main.tile[x, y].wall != (ushort) 82 && Main.tile[x, y].wall != (ushort) 187 && Main.tile[x, y].wall != (ushort) 216 && Main.tile[x, y].wall != (ushort) 34 && Main.tile[x, y].wall != (ushort) 244)
            {
              if (Main.tile[x, y].wall == (ushort) 87)
                Main.tile[x, y].wallColor((byte) 15);
              else if (Main.wallDungeon[(int) Main.tile[x, y].wall])
                Main.tile[x, y].wallColor((byte) 14);
              else if (Main.tile[x, y].wall == (ushort) 2)
                Main.tile[x, y].wall = (ushort) 2;
              else if (Main.tile[x, y].wall == (ushort) 196)
                Main.tile[x, y].wall = (ushort) 196;
              else if (Main.tile[x, y].wall == (ushort) 197)
                Main.tile[x, y].wall = (ushort) 197;
              else if (Main.tile[x, y].wall == (ushort) 198)
                Main.tile[x, y].wall = (ushort) 198;
              else if (Main.tile[x, y].wall == (ushort) 199)
                Main.tile[x, y].wall = (ushort) 199;
              else if (Main.tile[x, y].wall == (ushort) 63)
                Main.tile[x, y].wall = (ushort) 64;
              else if (Main.tile[x, y].wall != (ushort) 3 && Main.tile[x, y].wall != (ushort) 83 && Main.tile[x, y].wall != (ushort) 73 && Main.tile[x, y].wall != (ushort) 62 && Main.tile[x, y].wall != (ushort) 13 && Main.tile[x, y].wall != (ushort) 14 && Main.tile[x, y].wall > (ushort) 0 && (!WorldGen.remixWorldGen || (double) y > Main.worldSurface + (double) WorldGen.genRand.Next(-1, 2)))
                Main.tile[x, y].wall = (ushort) 86;
            }
            if (Main.tile[x, y].liquid > (byte) 0 && y <= GenVars.lavaLine + 2)
            {
              if ((double) y > Main.rockLayer && (x < WorldGen.beachDistance + 200 || x > Main.maxTilesX - WorldGen.beachDistance - 200))
                Main.tile[x, y].honey(false);
              else if (Main.wallDungeon[(int) Main.tile[x, y].wall])
                Main.tile[x, y].honey(false);
              else
                Main.tile[x, y].honey(true);
            }
          }
        }
      }
    }

    private static void FinishNotTheBees()
    {
      if (!WorldGen.notTheBees)
        return;
      int num1 = 0;
      for (int index1 = 20; (double) index1 < Main.worldSurface; ++index1)
      {
        for (int index2 = 20; index2 < Main.maxTilesX - 20; ++index2)
        {
          if (Main.tile[index2, index1].active() && TileID.Sets.Clouds[(int) Main.tile[index2, index1].type])
          {
            num1 = index1;
            break;
          }
        }
      }
      for (int i1 = 25; i1 < Main.maxTilesX - 25; ++i1)
      {
        for (int j = 25; j < Main.maxTilesY - 25; ++j)
        {
          if (Main.tile[i1, j].type == (ushort) 571)
            WorldGen.TileFrame(i1, j);
          int num2 = 20;
          if (WorldGen.remixWorldGen)
            num2 = 10;
          if (Main.tile[i1, j].type == (ushort) 25 || WorldGen.remixWorldGen && Main.tile[i1, j].type == (ushort) 23 && (double) j < Main.worldSurface)
          {
            for (int i2 = i1 - num2; i2 <= i1 + num2; ++i2)
            {
              for (int index = j - num2; index <= j + num2; ++index)
              {
                if (Main.tile[i2, index].type == (ushort) 60)
                {
                  if (Main.tile[i2, index + 1].type == (ushort) 444)
                    WorldGen.KillTile(i2, index + 1);
                  Main.tile[i2, index].type = (ushort) 661;
                  if (Main.tile[i2, index - 1].type == (ushort) 61 || Main.tile[i2, index - 1].type == (ushort) 74)
                  {
                    Main.tile[i2, index - 1].active(false);
                    WorldGen.PlaceTile(i2, index - 1, 24);
                  }
                }
                else if (Main.tile[i2, index - 1].type == (ushort) 233 || Main.tile[i2, index - 1].type == (ushort) 82)
                  WorldGen.KillTile(i2, index - 1);
              }
            }
          }
          else if (Main.tile[i1, j].type == (ushort) 203 || WorldGen.remixWorldGen && Main.tile[i1, j].type == (ushort) 199 && (double) j < Main.worldSurface)
          {
            for (int i3 = i1 - num2; i3 <= i1 + num2; ++i3)
            {
              for (int index = j - num2; index <= j + num2; ++index)
              {
                if (Main.tile[i3, index].type == (ushort) 60)
                {
                  if (Main.tile[i3, index + 1].type == (ushort) 444)
                    WorldGen.KillTile(i3, index + 1);
                  Main.tile[i3, index].type = (ushort) 662;
                  if (Main.tile[i3, index - 1].type == (ushort) 61 || Main.tile[i3, index - 1].type == (ushort) 74)
                  {
                    Main.tile[i3, index - 1].active(false);
                    WorldGen.PlaceTile(i3, index - 1, 201);
                  }
                  else if (Main.tile[i3, index - 1].type == (ushort) 233 || Main.tile[i3, index - 1].type == (ushort) 82)
                    WorldGen.KillTile(i3, index - 1);
                }
              }
            }
          }
          if (Main.tile[i1, j].type == (ushort) 382 || Main.tile[i1, j].type == (ushort) 52)
            Main.tile[i1, j].type = (ushort) 62;
          if (j > GenVars.lavaLine + WorldGen.genRand.Next(-2, 3) + 2)
          {
            if (!WorldGen.remixWorldGen)
              WorldGen.SpreadGrass(i1, j, 59, 70);
          }
          else
            WorldGen.SpreadGrass(i1, j, 59, 60);
          if ((double) j > Main.rockLayer + 20.0 + (double) WorldGen.genRand.Next(-2, 3) && j <= GenVars.lavaLine + 2 - 20 - WorldGen.genRand.Next(-2, 3) && (i1 < WorldGen.beachDistance + 200 - 20 - WorldGen.genRand.Next(-2, 3) || i1 > Main.maxTilesX - WorldGen.beachDistance - 200 + 20 + WorldGen.genRand.Next(-2, 3)))
          {
            if (Main.tile[i1, j].liquid > (byte) 0)
            {
              Main.tile[i1, j].honey(false);
              Main.tile[i1, j].lava(false);
            }
            if (Main.tile[i1, j].type == (ushort) 59)
            {
              bool flag = false;
              for (int index3 = i1 - 1; index3 <= i1 + 1; ++index3)
              {
                for (int index4 = j - 1; index4 <= j + 1; ++index4)
                {
                  if (Main.tile[index3, index4].type == (ushort) 60)
                    flag = true;
                }
              }
              if (!flag)
                Main.tile[i1, j].type = (double) j >= (Main.rockLayer + (double) GenVars.lavaLine) / 2.0 ? (ushort) 147 : (ushort) 161;
            }
          }
          if (!WorldGen.remixWorldGen)
          {
            if ((Main.tile[i1, j].type == (ushort) 7 || Main.tile[i1, j].type == (ushort) 166 || Main.tile[i1, j].type == (ushort) 6 || Main.tile[i1, j].type == (ushort) 167) && (double) j > ((double) GenVars.lavaLine + Main.rockLayer * 2.0) / 3.0 + (double) WorldGen.genRand.Next(-2, 3) + 2.0)
              Main.tile[i1, j].type = (ushort) 0;
          }
          else if (!WorldGen.remixWorldGen && (Main.tile[i1, j].type == (ushort) 123 || Main.tile[i1, j].type == (ushort) 40) && (double) j > ((double) GenVars.lavaLine + Main.rockLayer) / 2.0 + (double) WorldGen.genRand.Next(-2, 3) + 2.0)
            Main.tile[i1, j].type = (ushort) 1;
          if (j > num1 && (Main.tile[i1, j].liquid == (byte) 0 || !Main.tile[i1, j].lava() && !Main.tile[i1, j].shimmer()))
          {
            if (WorldGen.getGoodWorldGen)
            {
              if (WorldGen.genRand.Next(150) == 0)
                WorldGen.PlaceTile(i1, j, 231, true);
            }
            else if (WorldGen.genRand.Next(25) == 0)
              WorldGen.PlaceTile(i1, j, 231, true);
          }
        }
      }
      for (int index5 = 20; index5 < num1; ++index5)
      {
        for (int index6 = 20; index6 <= Main.maxTilesX - 20; ++index6)
        {
          Main.tile[index6, index5].honey(false);
          if (Main.tile[index6, index5].type == (ushort) 375)
            Main.tile[index6, index5].type = (ushort) 373;
          if (!WorldGen.remixWorldGen)
          {
            if (Main.tile[index6, index5].type == (ushort) 60)
            {
              Main.tile[index6, index5].type = (ushort) 2;
              if (WorldGen.genRand.Next(2) == 0)
                WorldGen.GrowTreeWithSettings(index6, index5, WorldGen.GrowTreeSettings.Profiles.VanityTree_Willow);
              else
                WorldGen.GrowTreeWithSettings(index6, index5, WorldGen.GrowTreeSettings.Profiles.VanityTree_Sakura);
              if (!Main.tile[index6, index5 - 1].active())
                WorldGen.PlaceTile(index6, index5 - 1, 3);
            }
            if (Main.tile[index6, index5].type == (ushort) 59)
              Main.tile[index6, index5].type = (ushort) 0;
          }
          else
            WorldGen.GrowTree(index6, index5);
        }
      }
    }

    private static void FinishGetGoodWorld()
    {
      int num1 = 0;
      for (int index1 = 20; (double) index1 < Main.worldSurface; ++index1)
      {
        for (int index2 = 20; index2 < Main.maxTilesX - 20; ++index2)
        {
          if (Main.tile[index2, index1].active() && TileID.Sets.Clouds[(int) Main.tile[index2, index1].type])
          {
            num1 = index1;
            break;
          }
        }
      }
      byte num2 = (byte) WorldGen.genRand.Next(13, 25);
      for (int index3 = 0; index3 < Main.maxTilesX; ++index3)
      {
        bool flag = false;
        for (int index4 = 0; index4 < Main.maxTilesY; ++index4)
        {
          if (Main.tile[index3, index4].active() && Main.tileDungeon[(int) Main.tile[index3, index4].type])
          {
            if (Main.tile[index3, index4].type == (ushort) 44)
            {
              num2 = (byte) WorldGen.genRand.Next(13, 15);
              if (WorldGen.genRand.Next(2) == 0)
                num2 = (byte) WorldGen.genRand.Next(23, 25);
            }
            if (Main.tile[index3, index4].type == (ushort) 43)
              num2 = (byte) WorldGen.genRand.Next(15, 19);
            if (Main.tile[index3, index4].type == (ushort) 41)
              num2 = (byte) WorldGen.genRand.Next(19, 23);
          }
        }
        if (flag)
          break;
      }
      for (int i = 0; i < Main.maxTilesX; ++i)
      {
        for (int index = 5; index < Main.maxTilesY - 5; ++index)
        {
          if (Main.tile[i, index].active() && (Main.tileDungeon[(int) Main.tile[i, index].type] || TileID.Sets.CrackedBricks[(int) Main.tile[i, index].type]))
            Main.tile[i, index].color(num2);
          if (Main.wallDungeon[(int) Main.tile[i, index].wall])
            Main.tile[i, index].wallColor(num2);
          if (Main.tile[i, index].active())
          {
            bool flag = false;
            if (Main.tile[i, index].type == (ushort) 226)
              flag = true;
            if (Main.tile[i, index].type == (ushort) 137)
            {
              switch ((int) Main.tile[i, index].frameY / 18)
              {
                case 1:
                case 2:
                case 3:
                case 4:
                  flag = true;
                  break;
              }
            }
            if (flag)
              Main.tile[i, index].color((byte) 17);
          }
          if (Main.tile[i, index].wall == (ushort) 87)
            Main.tile[i, index].wallColor((byte) 25);
          if (Main.tile[i, index].active())
          {
            if (!WorldGen.remixWorldGen && Main.tile[i, index].type == (ushort) 57 && WorldGen.genRand.Next(15) == 0)
            {
              if (Main.tile[i, index - 1].type == (ushort) 57)
                Main.tile[i, index].active(false);
              Main.tile[i, index].liquid = byte.MaxValue;
              Main.tile[i, index].lava(true);
            }
            if (index < num1 && Main.tile[i, index].type == (ushort) 2)
            {
              Main.tile[i, index].type = !WorldGen.crimson ? (ushort) 23 : (ushort) 199;
              if (Main.tile[i, index - 1].type == (ushort) 3)
                Main.tile[i, index - 1].active(false);
              if (Main.tile[i, index - 1].type == (ushort) 73)
                Main.tile[i, index - 1].active(false);
              if (Main.tile[i, index - 1].type == (ushort) 27)
                WorldGen.KillTile(i, index - 1);
              if (Main.tile[i, index - 1].type == (ushort) 596)
                WorldGen.KillTile(i, index - 1);
              if (Main.tile[i, index - 1].type == (ushort) 616)
                WorldGen.KillTile(i, index - 1);
              if (Main.tile[i, index - 1].type == (ushort) 82)
                WorldGen.KillTile(i, index - 1);
              if (Main.tile[i, index - 1].type == (ushort) 83)
                WorldGen.KillTile(i, index - 1);
              if (Main.tile[i, index - 1].type == (ushort) 186)
                WorldGen.KillTile(i, index - 1);
              if (Main.tile[i, index - 1].type == (ushort) 187)
                WorldGen.KillTile(i, index - 1);
              if (Main.tile[i, index - 1].type == (ushort) 185)
                WorldGen.KillTile(i, index - 1);
              if (Main.tile[i, index - 1].type == (ushort) 227)
                WorldGen.KillTile(i, index - 1);
            }
          }
        }
      }
      for (int index5 = 0; index5 < 8000 && Main.chest[index5] != null; ++index5)
      {
        if (WorldGen.genRand.Next(10) == 0 && Main.chest[index5].item[1].stack != 0)
        {
          for (int index6 = 1; index6 < 40; ++index6)
          {
            if (Main.chest[index5].item[index6].stack == 0)
            {
              Main.chest[index5].item[index6].SetDefaults(678);
              break;
            }
          }
        }
      }
    }

    private static void FinishNoTraps()
    {
      Main.tileSolid[138] = false;
      for (int index1 = 50; index1 < Main.maxTilesX - 50; ++index1)
      {
        for (int index2 = 50; index2 < Main.maxTilesY - 50; ++index2)
        {
          Tile tile1 = Main.tile[index1, index2];
          if (WorldGen.genRand.Next(5) == 0 && tile1.active() && tile1.type == (ushort) 12 && tile1.frameX == (short) 0 && tile1.frameY == (short) 0)
          {
            Main.tile[index1, index2].type = (ushort) 665;
            Main.tile[index1, index2 + 1].type = (ushort) 665;
            Main.tile[index1 + 1, index2].type = (ushort) 665;
            Main.tile[index1 + 1, index2 + 1].type = (ushort) 665;
          }
          if (index1 % 2 == 0 && index2 % 2 == 0 && Main.tile[index1, index2].active() && (Main.tile[index1, index2].type == (ushort) 105 || Main.tile[index1, index2].type == (ushort) 467 && (Main.tile[index1, index2].frameX == (short) 144 || Main.tile[index1, index2].frameX == (short) 162)))
          {
            bool flag1 = false;
            for (int index3 = index1 - 1; index3 <= index1 + 1; ++index3)
            {
              for (int index4 = index2 - 1; index4 <= index2 + 1; ++index4)
              {
                if (Main.tile[index3, index4].wire())
                  flag1 = true;
              }
            }
            if (!flag1)
            {
              bool flag2 = false;
              int num1 = 25;
              int i = -1;
              int j = -1;
              for (int index5 = 0; index5 < num1 * num1; ++index5)
              {
                i = WorldGen.genRand.Next(index1 - num1, index1 + num1 + 1);
                j = WorldGen.genRand.Next(index2 - num1, index2 + num1 + 1);
                if (Main.tile[i, j].wire())
                {
                  flag2 = true;
                  break;
                }
              }
              if (flag2)
              {
                int index6 = index1;
                int index7 = index2;
                Main.tile[index6, index7].wire(true);
                while (index6 != i)
                {
                  if (index6 < i)
                    ++index6;
                  if (index6 > i)
                    --index6;
                  Main.tile[index6, index7].wire(true);
                }
                while (index7 != j)
                {
                  if (index7 < j)
                    ++index7;
                  if (index7 > j)
                    --index7;
                  Main.tile[index6, index7].wire(true);
                }
              }
              else if (Main.tile[index1, index2].type == (ushort) 105)
              {
                int num2 = 15;
                bool flag3 = false;
                for (int index8 = 0; index8 < num2 * num2; ++index8)
                {
                  i = index1 + WorldGen.genRand.Next(-num2, num2 + 1);
                  j = index2 + WorldGen.genRand.Next(-num2, num2 + 1);
                  WorldGen.PlaceTile(i, j, 135, true, true, style: WorldGen.genRand.Next(2, 4));
                  if (Main.tile[i, j].type == (ushort) 135)
                  {
                    flag3 = true;
                    break;
                  }
                }
                if (flag3)
                {
                  int index9 = index1;
                  int index10 = index2;
                  Main.tile[index9, index10].wire(true);
                  while (index9 != i)
                  {
                    if (index9 < i)
                      ++index9;
                    if (index9 > i)
                      --index9;
                    Main.tile[index9, index10].wire(true);
                  }
                  while (index10 != j)
                  {
                    if (index10 < j)
                      ++index10;
                    if (index10 > j)
                      --index10;
                    Main.tile[index9, index10].wire(true);
                  }
                }
              }
            }
            if (Main.tile[index1, index2].type == (ushort) 467)
            {
              int num3 = 8;
              for (int index11 = 0; index11 < num3 * num3; ++index11)
              {
                int i1 = index1 + WorldGen.genRand.Next(-num3, num3 + 1);
                int j1 = index2 + WorldGen.genRand.Next(-num3, num3 + 1);
                if (Main.tile[i1, j1].type == (ushort) 0 || Main.tile[i1, j1].type == (ushort) 1 || TileID.Sets.Ore[(int) Main.tile[i1, j1].type] || Main.tile[i1, j1].type == (ushort) 59 || Main.tile[i1, j1].type == (ushort) 151)
                {
                  bool flag4 = true;
                  for (int i2 = i1 - 1; i2 <= i1 + 1; ++i2)
                  {
                    for (int j2 = j1 - 1; j2 <= j1 + 1; ++j2)
                    {
                      if (!WorldGen.SolidTile(i2, j2))
                        flag4 = false;
                    }
                  }
                  if (flag4)
                  {
                    Tile tile2 = Main.tile[i1, j1];
                    tile2.type = (ushort) 141;
                    int num4;
                    short num5 = (short) (num4 = 0);
                    tile2.frameY = (short) num4;
                    tile2.frameX = num5;
                    tile2.slope((byte) 0);
                    tile2.halfBrick(false);
                    WorldGen.TileFrame(i1, j1, true);
                    if (Main.tile[i1, j1].type == (ushort) 141)
                    {
                      int index12 = index1;
                      int index13 = index2;
                      Main.tile[index12, index13].wire(true);
                      while (index12 != i1)
                      {
                        if (index12 < i1)
                          ++index12;
                        if (index12 > i1)
                          --index12;
                        Main.tile[index12, index13].wire(true);
                      }
                      while (index13 != j1)
                      {
                        if (index13 < j1)
                          ++index13;
                        if (index13 > j1)
                          --index13;
                        Main.tile[index12, index13].wire(true);
                      }
                      break;
                    }
                  }
                }
              }
            }
            else
              ++index2;
          }
        }
      }
      Main.tileSolid[138] = true;
      for (int index14 = 0; index14 < 8000 && Main.chest[index14] != null; ++index14)
      {
        if (WorldGen.genRand.Next(20) == 0 && Main.chest[index14].item[1].stack != 0)
        {
          for (int index15 = 1; index15 < 40; ++index15)
          {
            if (Main.chest[index14].item[index15].stack == 0)
            {
              Main.chest[index14].item[index15].SetDefaults(5346);
              break;
            }
          }
        }
      }
    }

    private static void FinishDrunkGen()
    {
      byte color = (byte) WorldGen.genRand.Next(13, 25);
      byte num1 = 16;
      for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
      {
        bool flag = false;
        for (int index2 = 0; index2 < Main.maxTilesY; ++index2)
        {
          if (Main.tile[index1, index2].active() && Main.tileDungeon[(int) Main.tile[index1, index2].type])
          {
            if (Main.tile[index1, index2].type == (ushort) 44)
            {
              color = (byte) WorldGen.genRand.Next(13, 15);
              if (WorldGen.genRand.Next(2) == 0)
                color = (byte) WorldGen.genRand.Next(23, 25);
            }
            if (Main.tile[index1, index2].type == (ushort) 43)
              color = (byte) WorldGen.genRand.Next(15, 19);
            if (Main.tile[index1, index2].type == (ushort) 41)
              color = (byte) WorldGen.genRand.Next(19, 23);
          }
        }
        if (flag)
          break;
      }
      for (int index3 = 10; index3 < Main.maxTilesX - 10; ++index3)
      {
        for (int index4 = 10; index4 < Main.maxTilesY - 10; ++index4)
        {
          if (Main.tile[index3, index4].active() && (Main.tileDungeon[(int) Main.tile[index3, index4].type] || TileID.Sets.CrackedBricks[(int) Main.tile[index3, index4].type]))
            Main.tile[index3, index4].color(color);
          if (Main.wallDungeon[(int) Main.tile[index3, index4].wall])
            Main.tile[index3, index4].wallColor((byte) 25);
          if (Main.tile[index3, index4].active())
          {
            if (Main.tile[index3, index4].type == (ushort) 60)
            {
              int num2 = 1;
              for (int index5 = index3 - num2; index5 <= index3 + num2; ++index5)
              {
                for (int index6 = index4 - num2; index6 <= index4 + num2; ++index6)
                {
                  if (Main.tile[index5, index6].type == (ushort) 147 || Main.tile[index5, index6].type == (ushort) 161)
                    Main.tile[index5, index6].type = (ushort) 59;
                }
              }
            }
            bool flag = false;
            if (Main.tile[index3, index4].type == (ushort) 226)
              flag = true;
            if (Main.tile[index3, index4].type == (ushort) 137)
            {
              switch ((int) Main.tile[index3, index4].frameY / 18)
              {
                case 1:
                case 2:
                case 3:
                case 4:
                  flag = true;
                  break;
              }
            }
            if (flag)
              Main.tile[index3, index4].color(num1);
          }
          if (Main.tile[index3, index4].wall == (ushort) 87)
            Main.tile[index3, index4].wallColor(num1);
        }
      }
      for (int index7 = 0; index7 < 8000 && Main.chest[index7] != null; ++index7)
      {
        if (WorldGen.genRand.Next(15) == 0 && Main.chest[index7].item[1].stack != 0)
        {
          for (int index8 = 1; index8 < 40; ++index8)
          {
            if (Main.chest[index7].item[index8].stack == 0)
            {
              Main.chest[index7].item[index8].SetDefaults(5001);
              break;
            }
          }
        }
        if (WorldGen.genRand.Next(30) == 0 && Main.chest[index7].item[1].stack != 0)
        {
          for (int index9 = 1; index9 < 40; ++index9)
          {
            if (Main.chest[index7].item[index9].stack == 0)
            {
              Main.chest[index7].item[index9].SetDefaults(678);
              break;
            }
          }
        }
      }
    }

    private static void FinishRemixWorld()
    {
      for (int i = 25; i < Main.maxTilesX - 25; ++i)
      {
        for (int j = 25; j < Main.maxTilesY - 25; ++j)
        {
          int conversionType = 1;
          if (WorldGen.crimson)
            conversionType = 4;
          if (WorldGen.notTheBees && (double) j < Main.worldSurface)
          {
            if (Main.tile[i, j].honey())
            {
              if (Main.tileLavaDeath[(int) Main.tile[i, j].type])
                WorldGen.KillTile(i, j);
              Main.tile[i, j].lava(true);
            }
            if (Main.tile[i, j].type == (ushort) 375)
              Main.tile[i, j].type = (ushort) 374;
            if (Main.tile[i, j].type == (ushort) 230 || Main.tile[i, j].type == (ushort) 229 || Main.tile[i, j].type == (ushort) 659 || Main.tile[i, j].type == (ushort) 56)
              WorldGen.KillTile(i, j);
            if (Main.tile[i, j].type == (ushort) 82 || Main.tile[i, j].type == (ushort) 83 || Main.tile[i, j].type == (ushort) 84)
              WorldGen.TileFrame(i, j);
          }
          if ((double) j < Main.worldSurface + (double) WorldGen.genRand.Next(3))
          {
            if (WorldGen.drunkWorldGen)
            {
              if (GenVars.crimsonLeft)
              {
                if (i < Main.maxTilesX / 2 + WorldGen.genRand.Next(-2, 3))
                  WorldGen.Convert(i, j, 4, 1);
                else
                  WorldGen.Convert(i, j, 1, 1);
              }
              else if (i < Main.maxTilesX / 2 + WorldGen.genRand.Next(-2, 3))
                WorldGen.Convert(i, j, 1, 1);
              else
                WorldGen.Convert(i, j, 4, 1);
            }
            else
              WorldGen.Convert(i, j, conversionType, 1);
          }
          if ((double) j < Main.worldSurface - (double) WorldGen.genRand.Next(19, 22) && (Main.tile[i, j].wall == (ushort) 178 || Main.tile[i, j].wall == (ushort) 180))
            Main.tile[i, j].wall = (ushort) 0;
          if (Main.tile[i, j].active() && Main.tile[i, j].type == (ushort) 56)
            WorldGen.KillTile(i, j);
          if (Main.tile[i, j].type == (ushort) 189 || Main.tile[i, j].type == (ushort) 196 || Main.tile[i, j].type == (ushort) 202)
            Main.tile[i, j].type = !WorldGen.drunkWorldGen ? (!WorldGen.crimson ? (ushort) 474 : (ushort) 195) : (!GenVars.crimsonLeft ? (i >= Main.maxTilesX / 2 + WorldGen.genRand.Next(-2, 3) ? (ushort) 195 : (ushort) 474) : (i >= Main.maxTilesX / 2 + WorldGen.genRand.Next(-2, 3) ? (ushort) 474 : (ushort) 195));
          if (Main.tile[i, j].wall == (ushort) 73 || Main.tile[i, j].wall == (ushort) 82)
            Main.tile[i, j].wall = !WorldGen.drunkWorldGen ? (!WorldGen.crimson ? (ushort) 233 : (ushort) 77) : (!GenVars.crimsonLeft ? (i >= Main.maxTilesX / 2 + WorldGen.genRand.Next(-2, 3) ? (ushort) 77 : (ushort) 233) : (i >= Main.maxTilesX / 2 + WorldGen.genRand.Next(-2, 3) ? (ushort) 233 : (ushort) 77));
          if ((double) j > Main.rockLayer && j < Main.maxTilesY - 350 && Main.tile[i, j].type == (ushort) 0 && Main.tile[i, j].active() && (!Main.tile[i - 1, j - 1].active() || !WorldGen.SolidTile(i, j - 1) || !Main.tile[i + 1, j - 1].active() || !Main.tile[i - 1, j].active() || !Main.tile[i + 1, j].active() || !Main.tile[i - 1, j + 1].active() || !Main.tile[i, j + 1].active() || !Main.tile[i + 1, j + 1].active()))
            Main.tile[i, j].type = (ushort) 2;
        }
      }
      Liquid.QuickWater(-2);
      int num1 = (int) ((double) Main.maxTilesX * 0.38);
      int num2 = (int) ((double) Main.maxTilesX * 0.62);
      int maxTilesY1 = Main.maxTilesY;
      int num3 = Main.maxTilesY - 135;
      int maxTilesY2 = Main.maxTilesY;
      for (int index1 = num1; index1 < num2 + 15; ++index1)
      {
        for (int index2 = Main.maxTilesY - 200; index2 < num3 + 10; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          if (Main.tile[index1, index2].type == (ushort) 58)
            Main.tile[index1, index2].type = (ushort) 57;
        }
      }
      WorldGen.AddTrees(true);
      for (int index3 = 0; index3 < Main.maxTilesX; ++index3)
      {
        byte color1 = 22;
        byte color2 = 22;
        if (WorldGen.drunkWorldGen)
        {
          if (GenVars.crimsonLeft && index3 < Main.maxTilesX / 2 || !GenVars.crimsonLeft && index3 > Main.maxTilesX / 2)
          {
            color2 = (byte) 13;
            color1 = (byte) 13;
          }
        }
        else if (WorldGen.crimson)
        {
          color2 = (byte) 13;
          color1 = (byte) 13;
        }
        for (int index4 = 0; index4 < Main.maxTilesY; ++index4)
        {
          if (Main.tile[index3, index4].active() && (Main.tileDungeon[(int) Main.tile[index3, index4].type] || TileID.Sets.CrackedBricks[(int) Main.tile[index3, index4].type]))
            Main.tile[index3, index4].color(color1);
          if (Main.wallDungeon[(int) Main.tile[index3, index4].wall])
          {
            Main.tile[index3, index4].wallColor((byte) 25);
            if (Main.tile[index3, index4].type == (ushort) 19 && Main.tile[index3, index4].frameY != (short) 180)
              Main.tile[index3, index4].color(color1);
          }
          if (Main.tile[index3, index4].active())
          {
            bool flag = false;
            if (Main.tenthAnniversaryWorld)
            {
              if (Main.tile[index3, index4].type == (ushort) 191)
                flag = true;
              if (Main.tile[index3, index4].active() && Main.tile[index3, index4].type == (ushort) 151)
                Main.tile[index3, index4].color(color1);
            }
            if (Main.tile[index3, index4].type == (ushort) 226)
              flag = true;
            if (Main.tile[index3, index4].type == (ushort) 137)
            {
              switch ((int) Main.tile[index3, index4].frameY / 18)
              {
                case 1:
                case 2:
                case 3:
                case 4:
                  flag = true;
                  break;
              }
            }
            if (flag)
              Main.tile[index3, index4].color(color2);
          }
          if (Main.tile[index3, index4].wall == (ushort) 244)
            Main.tile[index3, index4].wallColor((byte) 25);
          if (Main.tile[index3, index4].wall == (ushort) 34)
            Main.tile[index3, index4].wallColor((byte) 25);
          if (Main.tile[index3, index4].wall == (ushort) 87)
          {
            Main.tile[index3, index4].wallColor((byte) 25);
            Main.tile[index3, index4].color(color2);
          }
        }
      }
      double num4 = (double) Main.maxTilesX / 4200.0 * (double) WorldGen.genRand.Next(2, 5);
      for (int index5 = 0; (double) index5 < num4; ++index5)
      {
        int num5 = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.39), (int) ((double) Main.maxTilesX * 0.61));
        int num6 = WorldGen.genRand.Next(10, 31);
        for (int index6 = num5 - num6; index6 <= num5 + num6; ++index6)
        {
          for (int index7 = Main.maxTilesY - 250; index7 < Main.maxTilesY - 25; ++index7)
          {
            if (Main.tile[index6, index7].type == (ushort) 637)
              Main.tile[index6, index7].frameX = (short) (18 * Main.rand.Next(6, 11));
          }
        }
      }
      if (WorldGen.notTheBees)
      {
        for (int index8 = 3; index8 < Main.maxTilesX - 3; ++index8)
        {
          bool flag = true;
          for (int index9 = 0; (double) index9 < Main.worldSurface; ++index9)
          {
            if (flag)
            {
              if (Main.tile[index8, index9].wall == (ushort) 86)
                Main.tile[index8, index9].wall = (ushort) 0;
              if (Main.tile[index8, index9].active())
                flag = false;
            }
            else if (Main.tile[index8, index9].wall == (ushort) 0 && Main.tile[index8, index9 + 1].wall == (ushort) 0 && Main.tile[index8, index9 + 2].wall == (ushort) 0 && Main.tile[index8, index9 + 3].wall == (ushort) 0 && Main.tile[index8, index9 + 4].wall == (ushort) 0 && Main.tile[index8 - 1, index9].wall == (ushort) 0 && Main.tile[index8 + 1, index9].wall == (ushort) 0 && Main.tile[index8 - 2, index9].wall == (ushort) 0 && Main.tile[index8 + 2, index9].wall == (ushort) 0 && !Main.tile[index8, index9].active() && !Main.tile[index8, index9 + 1].active() && !Main.tile[index8, index9 + 2].active() && !Main.tile[index8, index9 + 3].active())
              flag = true;
          }
        }
      }
      Liquid.QuickWater(-2);
      for (int x = 0; x < Main.maxTilesX; ++x)
      {
        for (int y = 0; y < Main.maxTilesY; ++y)
        {
          if (Main.tile[x, y].type == (ushort) 518)
            WorldGen.CheckLilyPad(x, y);
        }
      }
    }

    public static bool IsItATrap(Tile tile) => tile.actuator() || tile.active() && TileID.Sets.IsAMechanism[(int) tile.type];

    public static bool IsItATrigger(Tile tile) => tile.active() && (TileID.Sets.IsATrigger[(int) tile.type] || tile.type == (ushort) 467 && (int) tile.frameX / 36 == 4 || tile.type == (ushort) 314 && Minecart.IsPressurePlate(tile));

    public static void ClearAllBrokenTraps()
    {
      List<Point> pointsWeAlreadyWentOver = new List<Point>();
      for (int x = 50; x < Main.maxTilesX - 50; ++x)
      {
        for (int y = 50; y < Main.maxTilesY - 50; ++y)
        {
          if (Main.tile[x, y].wire() && !pointsWeAlreadyWentOver.Contains(new Point(x, y)))
            WorldGen.ClearBrokenTraps(new Point(x, y), pointsWeAlreadyWentOver);
        }
      }
    }

    public static void ClearBrokenTraps(Point startTileCoords, List<Point> pointsWeAlreadyWentOver)
    {
      List<Point> t1 = new List<Point>();
      List<Point> t2 = new List<Point>();
      List<Point> pointList = new List<Point>();
      bool flag1 = false;
      bool flag2 = false;
      t2.Add(startTileCoords);
      while (t2.Count > 0)
      {
        Utils.Swap<List<Point>>(ref t1, ref t2);
        while (t1.Count > 0)
        {
          Point point1 = t1[0];
          t1.RemoveAt(0);
          if (WorldGen.InWorld(point1.X, point1.Y, 5))
          {
            Tile tile = Main.tile[point1.X, point1.Y];
            if (tile.wire())
            {
              pointsWeAlreadyWentOver.Add(point1);
              pointList.Add(point1);
              if (WorldGen.IsItATrap(tile))
                flag1 = true;
              if (WorldGen.IsItATrigger(tile))
                flag2 = true;
              if (!(flag2 & flag1))
              {
                Point point2 = new Point(point1.X - 1, point1.Y);
                if (!pointList.Contains(point2))
                  t2.Add(point2);
                point2 = new Point(point1.X + 1, point1.Y);
                if (!pointList.Contains(point2))
                  t2.Add(point2);
                point2 = new Point(point1.X, point1.Y - 1);
                if (!pointList.Contains(point2))
                  t2.Add(point2);
                point2 = new Point(point1.X, point1.Y + 1);
                if (!pointList.Contains(point2))
                  t2.Add(point2);
              }
              else
                break;
            }
          }
        }
        if (flag2 & flag1)
          break;
      }
      if (flag2 && flag1)
        return;
      foreach (Point point in pointList)
      {
        Tile tile = Main.tile[point.X, point.Y];
        tile.wire(false);
        if (WorldGen.IsItATrap(tile))
        {
          if (tile.actuator())
            Main.tile[point.X, point.Y].actuator(false);
          else if (tile.type != (ushort) 105)
            WorldGen.KillTile(point.X, point.Y);
        }
        else if (WorldGen.IsItATrigger(tile))
        {
          if (tile.type == (ushort) 314)
            tile.frameX = (short) 1;
          else
            WorldGen.KillTile(point.X, point.Y);
        }
      }
    }

    private static double TuneOceanDepth(int count, double depth, bool floridaStyle = false)
    {
      if (!floridaStyle)
      {
        if (count < 3)
          depth += (double) WorldGen.genRand.Next(10, 20) * 0.2;
        else if (count < 6)
          depth += (double) WorldGen.genRand.Next(10, 20) * 0.15;
        else if (count < 9)
          depth += (double) WorldGen.genRand.Next(10, 20) * 0.1;
        else if (count < 15)
          depth += (double) WorldGen.genRand.Next(10, 20) * 0.07;
        else if (count < 50)
          depth += (double) WorldGen.genRand.Next(10, 20) * 0.05;
        else if (count < 75)
          depth += (double) WorldGen.genRand.Next(10, 20) * 0.04;
        else if (count < 100)
          depth += (double) WorldGen.genRand.Next(10, 20) * 0.03;
        else if (count < 125)
          depth += (double) WorldGen.genRand.Next(10, 20) * 0.02;
        else if (count < 150)
          depth += (double) WorldGen.genRand.Next(10, 20) * 0.01;
        else if (count < 175)
          depth += (double) WorldGen.genRand.Next(10, 20) * 0.005;
        else if (count < 200)
          depth += (double) WorldGen.genRand.Next(10, 20) * 0.001;
        else if (count < 230)
          depth += (double) WorldGen.genRand.Next(10, 20) * 0.01;
        else if (count < 235)
          depth += (double) WorldGen.genRand.Next(10, 20) * 0.05;
        else if (count < 240)
          depth += (double) WorldGen.genRand.Next(10, 20) * 0.1;
        else if (count < 245)
          depth += (double) WorldGen.genRand.Next(10, 20) * 0.05;
        else if (count < (int) byte.MaxValue)
          depth += (double) WorldGen.genRand.Next(10, 20) * 0.01;
      }
      else if (count < 3)
        depth += (double) WorldGen.genRand.Next(10, 20) * 0.001;
      else if (count < 6)
        depth += (double) WorldGen.genRand.Next(10, 20) * 0.002;
      else if (count < 9)
        depth += (double) WorldGen.genRand.Next(10, 20) * 0.004;
      else if (count < 15)
        depth += (double) WorldGen.genRand.Next(10, 20) * 0.007;
      else if (count < 50)
        depth += (double) WorldGen.genRand.Next(10, 20) * 0.01;
      else if (count < 75)
        depth += (double) WorldGen.genRand.Next(10, 20) * 0.014;
      else if (count < 100)
        depth += (double) WorldGen.genRand.Next(10, 20) * 0.019;
      else if (count < 125)
        depth += (double) WorldGen.genRand.Next(10, 20) * 0.027;
      else if (count < 150)
        depth += (double) WorldGen.genRand.Next(10, 20) * 0.038;
      else if (count < 175)
        depth += (double) WorldGen.genRand.Next(10, 20) * 0.052;
      else if (count < 200)
        depth += (double) WorldGen.genRand.Next(10, 20) * 0.08;
      else if (count < 230)
        depth += (double) WorldGen.genRand.Next(10, 20) * 0.12;
      else if (count < 235)
        depth += (double) WorldGen.genRand.Next(10, 20) * 0.16;
      else if (count < 240)
        depth += (double) WorldGen.genRand.Next(10, 20) * 0.27;
      else if (count < 245)
        depth += (double) WorldGen.genRand.Next(10, 20) * 0.43;
      else if (count < (int) byte.MaxValue)
        depth += (double) WorldGen.genRand.Next(10, 20) * 0.6;
      return depth;
    }

    public static void QueuePostGenAction(Action<StructureMap> action) => WorldGen._postGenActions.Enqueue(action);

    public static void ConsumePostGenActions(StructureMap structures)
    {
      while (WorldGen._postGenActions.Count > 0)
        WorldGen._postGenActions.Dequeue()(structures);
    }

    public static Point RandomRectanglePoint(Microsoft.Xna.Framework.Rectangle rectangle) => new Point(WorldGen.genRand.Next(rectangle.X, rectangle.X + rectangle.Width), WorldGen.genRand.Next(rectangle.Y, rectangle.Y + rectangle.Height));

    public static Point RandomRectanglePoint(int x, int y, int width, int height) => new Point(WorldGen.genRand.Next(x, x + width), WorldGen.genRand.Next(y, y + height));

    public static Point RandomWorldPoint(int padding) => WorldGen.RandomWorldPoint(padding, padding, padding, padding);

    public static Point RandomWorldPoint(int top = 0, int right = 0, int bottom = 0, int left = 0) => new Point(WorldGen.genRand.Next(left, Main.maxTilesX - right), WorldGen.genRand.Next(top, Main.maxTilesY - bottom));

    public static bool GrowPalmTree(int i, int y)
    {
      int index1 = y;
      if (!WorldGen.InWorld(i, y))
        return false;
      while (Main.tile[i, index1].type == (ushort) 20)
      {
        ++index1;
        if (Main.tile[i, index1] == null)
          return false;
      }
      Tile tile1 = Main.tile[i, index1];
      Tile tile2 = Main.tile[i, index1 - 1];
      byte color = 0;
      if (Main.tenthAnniversaryWorld && !WorldGen.gen)
        color = (byte) WorldGen.genRand.Next(1, 13);
      int num1 = (int) tile1.slope();
      tile1.halfBrick();
      if (!tile1.active() || tile1.halfBrick() || tile1.slope() != (byte) 0 || tile2.wall != (ushort) 0 || tile2.liquid != (byte) 0 || tile1.type != (ushort) 53 && tile1.type != (ushort) 234 && tile1.type != (ushort) 116 && tile1.type != (ushort) 112 || !WorldGen.EmptyTileCheck(i, i, index1 - 2, index1 - 1, 20) || !WorldGen.EmptyTileCheck(i - 1, i + 1, index1 - 30, index1 - 3, 20))
        return false;
      int ySize = WorldGen.genRand.Next(10, 21);
      int num2 = WorldGen.genRand.Next(-8, 9) * 2;
      short num3 = 0;
      for (int index2 = 0; index2 < ySize; ++index2)
      {
        Tile tile3 = Main.tile[i, index1 - 1 - index2];
        if (index2 == 0)
        {
          tile3.active(true);
          tile3.type = (ushort) 323;
          tile3.frameX = (short) 66;
          tile3.frameY = (short) 0;
          tile3.color(color);
        }
        else if (index2 == ySize - 1)
        {
          tile3.active(true);
          tile3.type = (ushort) 323;
          tile3.frameX = (short) (22 * WorldGen.genRand.Next(4, 7));
          tile3.frameY = num3;
          tile3.color(color);
        }
        else
        {
          if ((int) num3 != num2)
          {
            double num4 = (double) index2 / (double) ySize;
            if (num4 >= 0.25 && (num4 < 0.5 && WorldGen.genRand.Next(13) == 0 || num4 < 0.7 && WorldGen.genRand.Next(9) == 0 || num4 < 0.95 && WorldGen.genRand.Next(5) == 0 || true))
            {
              short num5 = (short) Math.Sign(num2);
              num3 += (short) ((int) num5 * 2);
            }
          }
          tile3.active(true);
          tile3.type = (ushort) 323;
          tile3.frameX = (short) (22 * WorldGen.genRand.Next(0, 3));
          tile3.frameY = num3;
          tile3.color(color);
        }
      }
      WorldGen.RangeFrame(i - 2, index1 - ySize - 1, i + 2, index1 + 1);
      NetMessage.SendTileSquare(-1, i, index1 - ySize, 1, ySize);
      return true;
    }

    public static bool IsPalmOasisTree(int x) => x >= WorldGen.beachDistance && x <= Main.maxTilesX - WorldGen.beachDistance;

    public static bool GrowEpicTree(int i, int y)
    {
      int index1 = y;
      while (Main.tile[i, index1].type == (ushort) 20)
        ++index1;
      if (Main.tile[i, index1].active() && !Main.tile[i, index1].halfBrick() && Main.tile[i, index1].slope() == (byte) 0 && Main.tile[i, index1].type == (ushort) 2 && Main.tile[i, index1 - 1].wall == (ushort) 0 && Main.tile[i, index1 - 1].liquid == (byte) 0 && (Main.tile[i - 1, index1].active() && (Main.tile[i - 1, index1].type == (ushort) 2 || Main.tile[i - 1, index1].type == (ushort) 23 || Main.tile[i - 1, index1].type == (ushort) 60 || Main.tile[i - 1, index1].type == (ushort) 109) || Main.tile[i + 1, index1].active() && (Main.tile[i + 1, index1].type == (ushort) 2 || Main.tile[i + 1, index1].type == (ushort) 23 || Main.tile[i + 1, index1].type == (ushort) 60 || Main.tile[i + 1, index1].type == (ushort) 109)))
      {
        int num1 = 2;
        if (WorldGen.EmptyTileCheck(i - num1, i + num1, index1 - 55, index1 - 1, 20))
        {
          bool flag1 = false;
          bool flag2 = false;
          int num2 = WorldGen.genRand.Next(20, 30);
          if (WorldGen.drunkWorldGen)
            num2 = WorldGen.genRand.Next(3, 7);
          for (int index2 = index1 - num2; index2 < index1; ++index2)
          {
            Main.tile[i, index2].frameNumber((byte) WorldGen.genRand.Next(3));
            Main.tile[i, index2].active(true);
            Main.tile[i, index2].type = (ushort) 5;
            int num3 = WorldGen.genRand.Next(3);
            int num4 = WorldGen.genRand.Next(10);
            if (index2 == index1 - 1 || index2 == index1 - num2)
              num4 = 0;
            while (((num4 == 5 ? 1 : (num4 == 7 ? 1 : 0)) & (flag1 ? 1 : 0)) != 0 || ((num4 == 6 ? 1 : (num4 == 7 ? 1 : 0)) & (flag2 ? 1 : 0)) != 0)
              num4 = WorldGen.genRand.Next(10);
            flag1 = false;
            flag2 = false;
            if (num4 == 5 || num4 == 7)
              flag1 = true;
            if (num4 == 6 || num4 == 7)
              flag2 = true;
            switch (num4)
            {
              case 1:
                if (num3 == 0)
                {
                  Main.tile[i, index2].frameX = (short) 0;
                  Main.tile[i, index2].frameY = (short) 66;
                }
                if (num3 == 1)
                {
                  Main.tile[i, index2].frameX = (short) 0;
                  Main.tile[i, index2].frameY = (short) 88;
                }
                if (num3 == 2)
                {
                  Main.tile[i, index2].frameX = (short) 0;
                  Main.tile[i, index2].frameY = (short) 110;
                  break;
                }
                break;
              case 2:
                if (num3 == 0)
                {
                  Main.tile[i, index2].frameX = (short) 22;
                  Main.tile[i, index2].frameY = (short) 0;
                }
                if (num3 == 1)
                {
                  Main.tile[i, index2].frameX = (short) 22;
                  Main.tile[i, index2].frameY = (short) 22;
                }
                if (num3 == 2)
                {
                  Main.tile[i, index2].frameX = (short) 22;
                  Main.tile[i, index2].frameY = (short) 44;
                  break;
                }
                break;
              case 3:
                if (num3 == 0)
                {
                  Main.tile[i, index2].frameX = (short) 44;
                  Main.tile[i, index2].frameY = (short) 66;
                }
                if (num3 == 1)
                {
                  Main.tile[i, index2].frameX = (short) 44;
                  Main.tile[i, index2].frameY = (short) 88;
                }
                if (num3 == 2)
                {
                  Main.tile[i, index2].frameX = (short) 44;
                  Main.tile[i, index2].frameY = (short) 110;
                  break;
                }
                break;
              case 4:
                if (num3 == 0)
                {
                  Main.tile[i, index2].frameX = (short) 22;
                  Main.tile[i, index2].frameY = (short) 66;
                }
                if (num3 == 1)
                {
                  Main.tile[i, index2].frameX = (short) 22;
                  Main.tile[i, index2].frameY = (short) 88;
                }
                if (num3 == 2)
                {
                  Main.tile[i, index2].frameX = (short) 22;
                  Main.tile[i, index2].frameY = (short) 110;
                  break;
                }
                break;
              case 5:
                if (num3 == 0)
                {
                  Main.tile[i, index2].frameX = (short) 88;
                  Main.tile[i, index2].frameY = (short) 0;
                }
                if (num3 == 1)
                {
                  Main.tile[i, index2].frameX = (short) 88;
                  Main.tile[i, index2].frameY = (short) 22;
                }
                if (num3 == 2)
                {
                  Main.tile[i, index2].frameX = (short) 88;
                  Main.tile[i, index2].frameY = (short) 44;
                  break;
                }
                break;
              case 6:
                if (num3 == 0)
                {
                  Main.tile[i, index2].frameX = (short) 66;
                  Main.tile[i, index2].frameY = (short) 66;
                }
                if (num3 == 1)
                {
                  Main.tile[i, index2].frameX = (short) 66;
                  Main.tile[i, index2].frameY = (short) 88;
                }
                if (num3 == 2)
                {
                  Main.tile[i, index2].frameX = (short) 66;
                  Main.tile[i, index2].frameY = (short) 110;
                  break;
                }
                break;
              case 7:
                if (num3 == 0)
                {
                  Main.tile[i, index2].frameX = (short) 110;
                  Main.tile[i, index2].frameY = (short) 66;
                }
                if (num3 == 1)
                {
                  Main.tile[i, index2].frameX = (short) 110;
                  Main.tile[i, index2].frameY = (short) 88;
                }
                if (num3 == 2)
                {
                  Main.tile[i, index2].frameX = (short) 110;
                  Main.tile[i, index2].frameY = (short) 110;
                  break;
                }
                break;
              default:
                if (num3 == 0)
                {
                  Main.tile[i, index2].frameX = (short) 0;
                  Main.tile[i, index2].frameY = (short) 0;
                }
                if (num3 == 1)
                {
                  Main.tile[i, index2].frameX = (short) 0;
                  Main.tile[i, index2].frameY = (short) 22;
                }
                if (num3 == 2)
                {
                  Main.tile[i, index2].frameX = (short) 0;
                  Main.tile[i, index2].frameY = (short) 44;
                  break;
                }
                break;
            }
            if (num4 == 5 || num4 == 7)
            {
              Main.tile[i - 1, index2].active(true);
              Main.tile[i - 1, index2].type = (ushort) 5;
              int num5 = WorldGen.genRand.Next(3);
              if (WorldGen.genRand.Next(3) < 2)
              {
                if (num5 == 0)
                {
                  Main.tile[i - 1, index2].frameX = (short) 44;
                  Main.tile[i - 1, index2].frameY = (short) 198;
                }
                if (num5 == 1)
                {
                  Main.tile[i - 1, index2].frameX = (short) 44;
                  Main.tile[i - 1, index2].frameY = (short) 220;
                }
                if (num5 == 2)
                {
                  Main.tile[i - 1, index2].frameX = (short) 44;
                  Main.tile[i - 1, index2].frameY = (short) 242;
                }
              }
              else
              {
                if (num5 == 0)
                {
                  Main.tile[i - 1, index2].frameX = (short) 66;
                  Main.tile[i - 1, index2].frameY = (short) 0;
                }
                if (num5 == 1)
                {
                  Main.tile[i - 1, index2].frameX = (short) 66;
                  Main.tile[i - 1, index2].frameY = (short) 22;
                }
                if (num5 == 2)
                {
                  Main.tile[i - 1, index2].frameX = (short) 66;
                  Main.tile[i - 1, index2].frameY = (short) 44;
                }
              }
            }
            if (num4 == 6 || num4 == 7)
            {
              Main.tile[i + 1, index2].active(true);
              Main.tile[i + 1, index2].type = (ushort) 5;
              int num6 = WorldGen.genRand.Next(3);
              if (WorldGen.genRand.Next(3) < 2)
              {
                if (num6 == 0)
                {
                  Main.tile[i + 1, index2].frameX = (short) 66;
                  Main.tile[i + 1, index2].frameY = (short) 198;
                }
                if (num6 == 1)
                {
                  Main.tile[i + 1, index2].frameX = (short) 66;
                  Main.tile[i + 1, index2].frameY = (short) 220;
                }
                if (num6 == 2)
                {
                  Main.tile[i + 1, index2].frameX = (short) 66;
                  Main.tile[i + 1, index2].frameY = (short) 242;
                }
              }
              else
              {
                if (num6 == 0)
                {
                  Main.tile[i + 1, index2].frameX = (short) 88;
                  Main.tile[i + 1, index2].frameY = (short) 66;
                }
                if (num6 == 1)
                {
                  Main.tile[i + 1, index2].frameX = (short) 88;
                  Main.tile[i + 1, index2].frameY = (short) 88;
                }
                if (num6 == 2)
                {
                  Main.tile[i + 1, index2].frameX = (short) 88;
                  Main.tile[i + 1, index2].frameY = (short) 110;
                }
              }
            }
          }
          int num7 = WorldGen.genRand.Next(3);
          bool flag3 = false;
          bool flag4 = false;
          if (Main.tile[i - 1, index1].active() && !Main.tile[i - 1, index1].halfBrick() && Main.tile[i - 1, index1].slope() == (byte) 0 && (Main.tile[i - 1, index1].type == (ushort) 2 || Main.tile[i - 1, index1].type == (ushort) 23 || Main.tile[i - 1, index1].type == (ushort) 60 || Main.tile[i - 1, index1].type == (ushort) 109))
            flag3 = true;
          if (Main.tile[i + 1, index1].active() && !Main.tile[i + 1, index1].halfBrick() && Main.tile[i + 1, index1].slope() == (byte) 0 && (Main.tile[i + 1, index1].type == (ushort) 2 || Main.tile[i + 1, index1].type == (ushort) 23 || Main.tile[i + 1, index1].type == (ushort) 60 || Main.tile[i + 1, index1].type == (ushort) 109))
            flag4 = true;
          if (!flag3)
          {
            if (num7 == 0)
              num7 = 2;
            if (num7 == 1)
              num7 = 3;
          }
          if (!flag4)
          {
            if (num7 == 0)
              num7 = 1;
            if (num7 == 2)
              num7 = 3;
          }
          if (flag3 && !flag4)
            num7 = 2;
          if (flag4 && !flag3)
            num7 = 1;
          if (num7 == 0 || num7 == 1)
          {
            Main.tile[i + 1, index1 - 1].active(true);
            Main.tile[i + 1, index1 - 1].type = (ushort) 5;
            int num8 = WorldGen.genRand.Next(3);
            if (num8 == 0)
            {
              Main.tile[i + 1, index1 - 1].frameX = (short) 22;
              Main.tile[i + 1, index1 - 1].frameY = (short) 132;
            }
            if (num8 == 1)
            {
              Main.tile[i + 1, index1 - 1].frameX = (short) 22;
              Main.tile[i + 1, index1 - 1].frameY = (short) 154;
            }
            if (num8 == 2)
            {
              Main.tile[i + 1, index1 - 1].frameX = (short) 22;
              Main.tile[i + 1, index1 - 1].frameY = (short) 176;
            }
          }
          if (num7 == 0 || num7 == 2)
          {
            Main.tile[i - 1, index1 - 1].active(true);
            Main.tile[i - 1, index1 - 1].type = (ushort) 5;
            int num9 = WorldGen.genRand.Next(3);
            if (num9 == 0)
            {
              Main.tile[i - 1, index1 - 1].frameX = (short) 44;
              Main.tile[i - 1, index1 - 1].frameY = (short) 132;
            }
            if (num9 == 1)
            {
              Main.tile[i - 1, index1 - 1].frameX = (short) 44;
              Main.tile[i - 1, index1 - 1].frameY = (short) 154;
            }
            if (num9 == 2)
            {
              Main.tile[i - 1, index1 - 1].frameX = (short) 44;
              Main.tile[i - 1, index1 - 1].frameY = (short) 176;
            }
          }
          int num10 = WorldGen.genRand.Next(3);
          switch (num7)
          {
            case 0:
              if (num10 == 0)
              {
                Main.tile[i, index1 - 1].frameX = (short) 88;
                Main.tile[i, index1 - 1].frameY = (short) 132;
              }
              if (num10 == 1)
              {
                Main.tile[i, index1 - 1].frameX = (short) 88;
                Main.tile[i, index1 - 1].frameY = (short) 154;
              }
              if (num10 == 2)
              {
                Main.tile[i, index1 - 1].frameX = (short) 88;
                Main.tile[i, index1 - 1].frameY = (short) 176;
                break;
              }
              break;
            case 1:
              if (num10 == 0)
              {
                Main.tile[i, index1 - 1].frameX = (short) 0;
                Main.tile[i, index1 - 1].frameY = (short) 132;
              }
              if (num10 == 1)
              {
                Main.tile[i, index1 - 1].frameX = (short) 0;
                Main.tile[i, index1 - 1].frameY = (short) 154;
              }
              if (num10 == 2)
              {
                Main.tile[i, index1 - 1].frameX = (short) 0;
                Main.tile[i, index1 - 1].frameY = (short) 176;
                break;
              }
              break;
            case 2:
              if (num10 == 0)
              {
                Main.tile[i, index1 - 1].frameX = (short) 66;
                Main.tile[i, index1 - 1].frameY = (short) 132;
              }
              if (num10 == 1)
              {
                Main.tile[i, index1 - 1].frameX = (short) 66;
                Main.tile[i, index1 - 1].frameY = (short) 154;
              }
              if (num10 == 2)
              {
                Main.tile[i, index1 - 1].frameX = (short) 66;
                Main.tile[i, index1 - 1].frameY = (short) 176;
                break;
              }
              break;
          }
          if (WorldGen.genRand.Next(13) != 0)
          {
            int num11 = WorldGen.genRand.Next(3);
            if (num11 == 0)
            {
              Main.tile[i, index1 - num2].frameX = (short) 22;
              Main.tile[i, index1 - num2].frameY = (short) 198;
            }
            if (num11 == 1)
            {
              Main.tile[i, index1 - num2].frameX = (short) 22;
              Main.tile[i, index1 - num2].frameY = (short) 220;
            }
            if (num11 == 2)
            {
              Main.tile[i, index1 - num2].frameX = (short) 22;
              Main.tile[i, index1 - num2].frameY = (short) 242;
            }
          }
          else
          {
            int num12 = WorldGen.genRand.Next(3);
            if (num12 == 0)
            {
              Main.tile[i, index1 - num2].frameX = (short) 0;
              Main.tile[i, index1 - num2].frameY = (short) 198;
            }
            if (num12 == 1)
            {
              Main.tile[i, index1 - num2].frameX = (short) 0;
              Main.tile[i, index1 - num2].frameY = (short) 220;
            }
            if (num12 == 2)
            {
              Main.tile[i, index1 - num2].frameX = (short) 0;
              Main.tile[i, index1 - num2].frameY = (short) 242;
            }
          }
          WorldGen.RangeFrame(i - 2, index1 - num2 - 1, i + 2, index1 + 1);
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, i, (int) ((double) index1 - (double) num2 * 0.5), num2 + 1);
          return true;
        }
      }
      return false;
    }

    public static bool Pyramid(int i, int j)
    {
      ushort num1 = 151;
      if (Main.tile[i, j].type == (ushort) 151 || Main.tile[i, j].wall == (ushort) 151)
        return false;
      int num2 = j - WorldGen.genRand.Next(0, 7);
      int num3 = WorldGen.genRand.Next(9, 13);
      int num4 = 1;
      int num5 = j + WorldGen.genRand.Next(75, 125);
      for (int index1 = num2; index1 < num5; ++index1)
      {
        for (int index2 = i - num4; index2 < i + num4 - 1; ++index2)
        {
          Main.tile[index2, index1].type = num1;
          Main.tile[index2, index1].active(true);
          Main.tile[index2, index1].halfBrick(false);
          Main.tile[index2, index1].slope((byte) 0);
        }
        ++num4;
      }
      for (int i1 = i - num4 - 5; i1 <= i + num4 + 5; ++i1)
      {
        for (int j1 = j - 1; j1 <= num5 + 1; ++j1)
        {
          bool flag = true;
          for (int index3 = i1 - 1; index3 <= i1 + 1; ++index3)
          {
            for (int index4 = j1 - 1; index4 <= j1 + 1; ++index4)
            {
              if ((int) Main.tile[index3, index4].type != (int) num1)
                flag = false;
            }
          }
          if (flag)
          {
            Main.tile[i1, j1].wall = (ushort) 34;
            WorldGen.SquareWallFrame(i1, j1);
          }
        }
      }
      int num6 = 1;
      if (WorldGen.genRand.Next(2) == 0)
        num6 = -1;
      int num7 = i - num3 * num6;
      int j2 = j + num3;
      int num8 = WorldGen.genRand.Next(5, 8);
      bool flag1 = true;
      int num9 = WorldGen.genRand.Next(20, 30);
      while (flag1)
      {
        flag1 = false;
        bool flag2 = false;
        for (int index5 = j2; index5 <= j2 + num8; ++index5)
        {
          int index6 = num7;
          if (Main.tile[index6, index5 - 1].type == (ushort) 53)
            flag2 = true;
          if ((int) Main.tile[index6, index5].type == (int) num1)
          {
            Main.tile[index6, index5 + 1].wall = (ushort) 34;
            Main.tile[index6 + num6, index5].wall = (ushort) 34;
            Main.tile[index6, index5].active(false);
            flag1 = true;
          }
          if (flag2)
          {
            Main.tile[index6, index5].type = (ushort) 53;
            Main.tile[index6, index5].active(true);
            Main.tile[index6, index5].halfBrick(false);
            Main.tile[index6, index5].slope((byte) 0);
          }
        }
        num7 -= num6;
      }
      int index7 = i - num3 * num6;
      bool flag3 = true;
      bool flag4 = false;
      bool flag5 = true;
      while (flag5)
      {
        for (int index8 = j2; index8 <= j2 + num8; ++index8)
        {
          int index9 = index7;
          Main.tile[index9, index8].active(false);
        }
        index7 += num6;
        ++j2;
        --num9;
        if (j2 >= num5 - num8 * 2)
          num9 = 10;
        if (num9 <= 0)
        {
          bool flag6 = false;
          if (!flag3 && !flag4)
          {
            flag4 = true;
            flag6 = true;
            int num10 = WorldGen.genRand.Next(7, 13);
            int num11 = WorldGen.genRand.Next(23, 28);
            int num12 = num11;
            int num13 = index7;
            while (num11 > 0)
            {
              for (int index10 = j2 - num10 + num8; index10 <= j2 + num8; ++index10)
              {
                if (num11 == num12 || num11 == 1)
                {
                  if (index10 >= j2 - num10 + num8 + 2)
                    Main.tile[index7, index10].active(false);
                }
                else if (num11 == num12 - 1 || num11 == 2 || num11 == num12 - 2 || num11 == 3)
                {
                  if (index10 >= j2 - num10 + num8 + 1)
                    Main.tile[index7, index10].active(false);
                }
                else
                  Main.tile[index7, index10].active(false);
              }
              --num11;
              index7 += num6;
            }
            int num14 = index7 - num6;
            int minValue = num14;
            int maxValue = num13;
            if (num14 > num13)
            {
              minValue = num13;
              maxValue = num14;
            }
            int contain = WorldGen.genRand.Next(3);
            if (contain == 0)
              contain = WorldGen.genRand.Next(3);
            if (Main.tenthAnniversaryWorld && contain == 0)
              contain = 1;
            switch (contain)
            {
              case 0:
                contain = 848;
                break;
              case 1:
                contain = 857;
                break;
              case 2:
                contain = 934;
                break;
            }
            WorldGen.AddBuriedChest((minValue + maxValue) / 2, j2, contain, Style: 1);
            int num15 = WorldGen.genRand.Next(1, 10);
            for (int index11 = 0; index11 < num15; ++index11)
              WorldGen.PlaceSmallPile(WorldGen.genRand.Next(minValue, maxValue), j2 + num8, WorldGen.genRand.Next(16, 19), 1);
            WorldGen.PlaceTile(minValue + 2, j2 - num10 + num8 + 1, 91, true, style: WorldGen.genRand.Next(4, 7));
            WorldGen.PlaceTile(minValue + 3, j2 - num10 + num8, 91, true, style: WorldGen.genRand.Next(4, 7));
            WorldGen.PlaceTile(maxValue - 2, j2 - num10 + num8 + 1, 91, true, style: WorldGen.genRand.Next(4, 7));
            WorldGen.PlaceTile(maxValue - 3, j2 - num10 + num8, 91, true, style: WorldGen.genRand.Next(4, 7));
            for (int x = minValue; x <= maxValue; ++x)
              WorldGen.PlacePot(x, j2 + num8, style: WorldGen.genRand.Next(25, 28));
          }
          if (flag3)
          {
            flag3 = false;
            num6 *= -1;
            num9 = WorldGen.genRand.Next(15, 20);
          }
          else if (flag6)
          {
            num9 = WorldGen.genRand.Next(10, 15);
          }
          else
          {
            num6 *= -1;
            num9 = WorldGen.genRand.Next(20, 40);
          }
        }
        if (j2 >= num5 - num8)
          flag5 = false;
      }
      int num16 = WorldGen.genRand.Next(100, 200);
      int num17 = WorldGen.genRand.Next(500, 800);
      bool flag7 = true;
      int num18 = num8;
      int num19 = WorldGen.genRand.Next(10, 50);
      if (num6 == 1)
        index7 -= num18;
      int num20 = WorldGen.genRand.Next(5, 10);
      while (flag7)
      {
        --num16;
        --num17;
        --num19;
        for (int index12 = index7 - num20 - WorldGen.genRand.Next(0, 2); index12 <= index7 + num18 + num20 + WorldGen.genRand.Next(0, 2); ++index12)
        {
          int index13 = j2;
          if (index12 >= index7 && index12 <= index7 + num18)
          {
            Main.tile[index12, index13].active(false);
          }
          else
          {
            Main.tile[index12, index13].type = num1;
            Main.tile[index12, index13].active(true);
            Main.tile[index12, index13].halfBrick(false);
            Main.tile[index12, index13].slope((byte) 0);
          }
          if (index12 >= index7 - 1 && index12 <= index7 + 1 + num18)
            Main.tile[index12, index13].wall = (ushort) 34;
        }
        ++j2;
        index7 += num6;
        if (num16 <= 0)
        {
          flag7 = false;
          for (int index14 = index7 + 1; index14 <= index7 + num18 - 1; ++index14)
          {
            if (Main.tile[index14, j2].active())
              flag7 = true;
          }
        }
        if (num19 < 0)
        {
          num19 = WorldGen.genRand.Next(10, 50);
          num6 *= -1;
        }
        if (num17 <= 0)
          flag7 = false;
      }
      return true;
    }

    public static bool GrowLivingTree(int i, int j, bool patch = false)
    {
      int index1 = 0;
      int[] numArray1 = new int[1000];
      int[] numArray2 = new int[1000];
      int[] numArray3 = new int[1000];
      int[] numArray4 = new int[1000];
      int index2 = 0;
      int[] numArray5 = new int[2000];
      int[] numArray6 = new int[2000];
      bool[] flagArray = new bool[2000];
      if (!WorldGen.SolidTile(i, j + 1) || Main.tile[i, j].active() || Main.tile[i, j + 1].type != (ushort) 0 && Main.tile[i, j + 1].type != (ushort) 2 && Main.tile[i, j + 1].type != (ushort) 1 && Main.tile[i, j + 1].type != (ushort) 40 && !TileID.Sets.Ore[(int) Main.tile[i, j + 1].type] && (!WorldGen.remixWorldGen || !WorldGen.notTheBees || Main.tile[i, j + 1].type != (ushort) 60 && Main.tile[i, j + 1].type != (ushort) 59) || j < 150)
        return false;
      int num1 = i - WorldGen.genRand.Next(2, 3);
      int num2 = i + WorldGen.genRand.Next(2, 3);
      if (WorldGen.genRand.Next(5) == 0)
      {
        if (WorldGen.genRand.Next(2) == 0)
          --num1;
        else
          ++num2;
      }
      int num3 = num2 - num1;
      bool flag1 = num3 >= 4;
      int num4 = i - 50;
      int num5 = i + 50;
      if (patch)
      {
        num4 = i - 20;
        num5 = i + 20;
        num1 = i - WorldGen.genRand.Next(1, 3);
        num2 = i + WorldGen.genRand.Next(1, 3);
        flag1 = num3 >= 4;
      }
      for (int index3 = num4; index3 <= num5; ++index3)
      {
        for (int index4 = 5; index4 < j - 5; ++index4)
        {
          if (Main.tile[index3, index4].active())
          {
            if (!patch)
              return false;
            switch (Main.tile[index3, index4].type)
            {
              case 0:
              case 1:
              case 2:
              case 191:
              case 192:
                continue;
              default:
                return false;
            }
          }
        }
      }
      int num6 = num1;
      int num7 = num2;
      int minl = num1;
      int minr = num2;
      bool flag2 = true;
      int num8 = WorldGen.genRand.Next(-8, -4);
      int num9 = WorldGen.genRand.Next(2);
      int index5 = j;
      int num10 = WorldGen.genRand.Next(5, 15);
      Main.tileSolid[48] = false;
      while (flag2)
      {
        ++num8;
        if (num8 > num10)
        {
          num10 = WorldGen.genRand.Next(5, 15);
          num8 = 0;
          numArray2[index1] = index5 + WorldGen.genRand.Next(5);
          if (WorldGen.genRand.Next(5) == 0)
            num9 = num9 != 0 ? 0 : 1;
          if (num9 == 0)
          {
            numArray3[index1] = -1;
            numArray1[index1] = num1;
            numArray4[index1] = num2 - num1;
            if (WorldGen.genRand.Next(2) == 0)
              ++num1;
            ++num6;
            num9 = 1;
          }
          else
          {
            numArray3[index1] = 1;
            numArray1[index1] = num2;
            numArray4[index1] = num2 - num1;
            if (WorldGen.genRand.Next(2) == 0)
              --num2;
            --num7;
            num9 = 0;
          }
          if (num6 == num7)
            flag2 = false;
          ++index1;
        }
        for (int index6 = num1; index6 <= num2; ++index6)
        {
          Main.tile[index6, index5].type = (ushort) 191;
          Main.tile[index6, index5].active(true);
          Main.tile[index6, index5].halfBrick(false);
        }
        --index5;
      }
      for (int index7 = 0; index7 < index1 - 1; ++index7)
      {
        int index8 = numArray1[index7] + numArray3[index7];
        int index9 = numArray2[index7];
        int num11 = (int) ((double) numArray4[index7] * (1.0 + (double) WorldGen.genRand.Next(20, 30) * 0.1));
        Main.tile[index8, index9 + 1].type = (ushort) 191;
        Main.tile[index8, index9 + 1].active(true);
        Main.tile[index8, index9 + 1].halfBrick(false);
        int num12 = WorldGen.genRand.Next(3, 5);
        while (num11 > 0)
        {
          --num11;
          Main.tile[index8, index9].type = (ushort) 191;
          Main.tile[index8, index9].active(true);
          Main.tile[index8, index9].halfBrick(false);
          if (WorldGen.genRand.Next(10) == 0)
          {
            if (WorldGen.genRand.Next(2) == 0)
              --index9;
            else
              ++index9;
          }
          else
            index8 += numArray3[index7];
          if (num12 > 0)
            --num12;
          else if (WorldGen.genRand.Next(2) == 0)
          {
            num12 = WorldGen.genRand.Next(2, 5);
            if (WorldGen.genRand.Next(2) == 0)
            {
              Main.tile[index8, index9].type = (ushort) 191;
              Main.tile[index8, index9].active(true);
              Main.tile[index8, index9].halfBrick(false);
              Main.tile[index8, index9 - 1].type = (ushort) 191;
              Main.tile[index8, index9 - 1].active(true);
              Main.tile[index8, index9 - 1].halfBrick(false);
              numArray5[index2] = index8;
              numArray6[index2] = index9;
              ++index2;
            }
            else
            {
              Main.tile[index8, index9].type = (ushort) 191;
              Main.tile[index8, index9].active(true);
              Main.tile[index8, index9].halfBrick(false);
              Main.tile[index8, index9 + 1].type = (ushort) 191;
              Main.tile[index8, index9 + 1].active(true);
              Main.tile[index8, index9 + 1].halfBrick(false);
              numArray5[index2] = index8;
              numArray6[index2] = index9;
              ++index2;
            }
          }
          if (num11 == 0)
          {
            numArray5[index2] = index8;
            numArray6[index2] = index9;
            ++index2;
          }
        }
      }
      int index10 = (num1 + num2) / 2;
      int index11 = index5;
      int num13 = WorldGen.genRand.Next(num3 * 3, num3 * 5);
      int num14 = 0;
      int num15 = 0;
      for (; num13 > 0; --num13)
      {
        Main.tile[index10, index11].type = (ushort) 191;
        Main.tile[index10, index11].active(true);
        Main.tile[index10, index11].halfBrick(false);
        if (num14 > 0)
          --num14;
        if (num15 > 0)
          --num15;
        for (int index12 = -1; index12 < 2; ++index12)
        {
          if (index12 != 0 && (index12 < 0 && num14 == 0 || index12 > 0 && num15 == 0) && WorldGen.genRand.Next(2) == 0)
          {
            int index13 = index10;
            int index14 = index11;
            int num16 = WorldGen.genRand.Next(num3, num3 * 3);
            if (index12 < 0)
              num14 = WorldGen.genRand.Next(3, 5);
            if (index12 > 0)
              num15 = WorldGen.genRand.Next(3, 5);
            int num17 = 0;
            while (num16 > 0)
            {
              --num16;
              index13 += index12;
              Main.tile[index13, index14].type = (ushort) 191;
              Main.tile[index13, index14].active(true);
              Main.tile[index13, index14].halfBrick(false);
              if (num16 == 0)
              {
                numArray5[index2] = index13;
                numArray6[index2] = index14;
                flagArray[index2] = true;
                ++index2;
              }
              if (WorldGen.genRand.Next(5) == 0)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  --index14;
                else
                  ++index14;
                Main.tile[index13, index14].type = (ushort) 191;
                Main.tile[index13, index14].active(true);
                Main.tile[index13, index14].halfBrick(false);
              }
              if (num17 > 0)
                --num17;
              else if (WorldGen.genRand.Next(3) == 0)
              {
                num17 = WorldGen.genRand.Next(2, 4);
                int index15 = index13;
                int num18 = index14;
                int index16 = WorldGen.genRand.Next(2) != 0 ? num18 + 1 : num18 - 1;
                Main.tile[index15, index16].type = (ushort) 191;
                Main.tile[index15, index16].active(true);
                Main.tile[index15, index16].halfBrick(false);
                numArray5[index2] = index15;
                numArray6[index2] = index16;
                flagArray[index2] = true;
                int index17 = index2 + 1;
                numArray5[index17] = index15 + WorldGen.genRand.Next(-5, 6);
                numArray6[index17] = index16 + WorldGen.genRand.Next(-5, 6);
                flagArray[index17] = true;
                index2 = index17 + 1;
              }
            }
          }
        }
        numArray5[index2] = index10;
        numArray6[index2] = index11;
        ++index2;
        if (WorldGen.genRand.Next(4) == 0)
        {
          if (WorldGen.genRand.Next(2) == 0)
            --index10;
          else
            ++index10;
          Main.tile[index10, index11].type = (ushort) 191;
          Main.tile[index10, index11].active(true);
          Main.tile[index10, index11].halfBrick(false);
        }
        --index11;
      }
      for (int i1 = minl; i1 <= minr; ++i1)
      {
        int num19 = WorldGen.genRand.Next(1, 6);
        int j1 = j + 1;
        while (num19 > 0)
        {
          if (WorldGen.SolidTile(i1, j1))
            --num19;
          Main.tile[i1, j1].type = (ushort) 191;
          Main.tile[i1, j1].active(true);
          Main.tile[i1, j1].halfBrick(false);
          ++j1;
        }
        int num20 = j1;
        int num21 = WorldGen.genRand.Next(2, num3 + 1);
        for (int index18 = 0; index18 < num21; ++index18)
        {
          int index19 = num20;
          int num22 = (minl + minr) / 2;
          int num23 = 1;
          int num24 = i1 >= num22 ? 1 : -1;
          if (i1 == num22 || num3 > 6 && (i1 == num22 - 1 || i1 == num22 + 1))
            num24 = 0;
          int num25 = num24;
          int index20 = i1;
          int num26 = WorldGen.genRand.Next((int) ((double) num3 * 3.5), num3 * 6);
          while (num26 > 0)
          {
            --num26;
            index20 += num24;
            if (Main.tile[index20, index19].wall != (ushort) 244)
            {
              Main.tile[index20, index19].type = (ushort) 191;
              Main.tile[index20, index19].active(true);
              Main.tile[index20, index19].halfBrick(false);
            }
            index19 += num23;
            if (Main.tile[index20, index19].wall != (ushort) 244)
            {
              Main.tile[index20, index19].type = (ushort) 191;
              Main.tile[index20, index19].active(true);
              Main.tile[index20, index19].halfBrick(false);
            }
            if (!Main.tile[index20, index19 + 1].active())
            {
              num24 = 0;
              num23 = 1;
            }
            if (WorldGen.genRand.Next(3) == 0)
              num24 = num25 >= 0 ? (num25 <= 0 ? WorldGen.genRand.Next(-1, 2) : (num24 != 0 ? 0 : 1)) : (num24 != 0 ? 0 : -1);
            if (WorldGen.genRand.Next(3) == 0)
              num23 = num23 != 0 ? 0 : 1;
          }
        }
      }
      if (WorldGen.remixWorldGen)
        index2 = 0;
      for (int index21 = 0; index21 < index2; ++index21)
      {
        int num27 = (int) ((double) WorldGen.genRand.Next(5, 8) * (1.0 + (double) num3 * 0.05));
        if (flagArray[index21])
          num27 = WorldGen.genRand.Next(6, 12) + num3;
        int num28 = numArray5[index21] - num27 * 2;
        int num29 = numArray5[index21] + num27 * 2;
        int num30 = numArray6[index21] - num27 * 2;
        int num31 = numArray6[index21] + num27 * 2;
        double num32 = 2.0 - (double) WorldGen.genRand.Next(5) * 0.1;
        for (int i2 = num28; i2 <= num29; ++i2)
        {
          for (int index22 = num30; index22 <= num31; ++index22)
          {
            if (Main.tile[i2, index22].type != (ushort) 191)
            {
              if (flagArray[index21])
              {
                Vector2D vector2D = Vector2D.op_Subtraction(new Vector2D((double) numArray5[index21], (double) numArray6[index21]), new Vector2D((double) i2, (double) index22));
                if (((Vector2D) ref vector2D).Length() < (double) num27 * 0.9)
                {
                  Main.tile[i2, index22].type = (ushort) 192;
                  Main.tile[i2, index22].active(true);
                  Main.tile[i2, index22].halfBrick(false);
                }
              }
              else if ((double) Math.Abs(numArray5[index21] - i2) + (double) Math.Abs(numArray6[index21] - index22) * num32 < (double) num27)
              {
                Main.tile[i2, index22].type = (ushort) 192;
                Main.tile[i2, index22].active(true);
                Main.tile[i2, index22].halfBrick(false);
              }
            }
          }
          if (WorldGen.genRand.Next(30) == 0)
          {
            int j2 = num30;
            if (!Main.tile[i2, j2].active())
            {
              while (!Main.tile[i2, j2 + 1].active() && j2 < num31)
                ++j2;
              if (Main.tile[i2, j2 + 1].type == (ushort) 192)
                WorldGen.PlaceTile(i2, j2, 187, true, style: WorldGen.genRand.Next(50, 52));
            }
          }
          if (!flagArray[index21] && WorldGen.genRand.Next(15) == 0)
          {
            int j3 = num31;
            int num33 = j3 + 100;
            if (!Main.tile[i2, j3].active())
            {
              while (!Main.tile[i2, j3 + 1].active() && j3 < num33)
                ++j3;
              if (Main.tile[i2, j3 + 1].type != (ushort) 192)
              {
                if (WorldGen.genRand.Next(2) == 0)
                {
                  WorldGen.PlaceTile(i2, j3, 187, true, style: WorldGen.genRand.Next(47, 50));
                }
                else
                {
                  int Y = WorldGen.genRand.Next(2);
                  int X = 72;
                  if (Y == 1)
                    X = WorldGen.genRand.Next(59, 62);
                  WorldGen.PlaceSmallPile(i2, j3, X, Y);
                }
              }
            }
          }
        }
      }
      if (flag1)
      {
        bool flag3 = false;
        for (int j4 = j; j4 < j + 20 && (double) j4 < Main.worldSurface - 2.0; ++j4)
        {
          for (int i3 = minl; i3 <= minr; ++i3)
          {
            if (Main.tile[i3, j4].wall == (ushort) 0 && !WorldGen.SolidTile(i3, j4))
              flag3 = true;
          }
        }
        if (!flag3)
          WorldGen.GrowLivingTree_MakePassage(j, num3, ref minl, ref minr, patch);
      }
      Main.tileSolid[48] = true;
      return true;
    }

    public static bool GrowDungeonTree(int i, int j, bool patch = false)
    {
      int index1 = 0;
      int[] numArray1 = new int[1000];
      int[] numArray2 = new int[1000];
      int[] numArray3 = new int[1000];
      int[] numArray4 = new int[1000];
      int index2 = 0;
      int[] numArray5 = new int[2000];
      int[] numArray6 = new int[2000];
      bool[] flagArray = new bool[2000];
      int num1 = i - WorldGen.genRand.Next(2, 3);
      int num2 = i + WorldGen.genRand.Next(2, 3);
      if (WorldGen.genRand.Next(5) == 0)
      {
        if (WorldGen.genRand.Next(2) == 0)
          --num1;
        else
          ++num2;
      }
      int num3 = num2 - num1;
      int num4 = num1;
      int num5 = num2;
      int minl = num1;
      int minr = num2;
      bool flag = true;
      int num6 = WorldGen.genRand.Next(-8, -4);
      int num7 = WorldGen.genRand.Next(2);
      int index3 = j;
      int num8 = WorldGen.genRand.Next(5, 15);
      Main.tileSolid[48] = false;
      while (flag)
      {
        ++num6;
        if (num6 > num8)
        {
          num8 = WorldGen.genRand.Next(5, 15);
          num6 = 0;
          numArray2[index1] = index3 + WorldGen.genRand.Next(5);
          if (WorldGen.genRand.Next(5) == 0)
            num7 = num7 != 0 ? 0 : 1;
          if (num7 == 0)
          {
            numArray3[index1] = -1;
            numArray1[index1] = num1;
            numArray4[index1] = num2 - num1;
            if (WorldGen.genRand.Next(2) == 0)
              ++num1;
            ++num4;
            num7 = 1;
          }
          else
          {
            numArray3[index1] = 1;
            numArray1[index1] = num2;
            numArray4[index1] = num2 - num1;
            if (WorldGen.genRand.Next(2) == 0)
              --num2;
            --num5;
            num7 = 0;
          }
          if (num4 == num5)
            flag = false;
          ++index1;
        }
        for (int index4 = num1; index4 <= num2; ++index4)
        {
          Main.tile[index4, index3].type = (ushort) 191;
          Main.tile[index4, index3].active(true);
          Main.tile[index4, index3].halfBrick(false);
          Main.tile[index4, index3].slope((byte) 0);
          Main.tile[index4, index3].color((byte) 28);
        }
        --index3;
      }
      for (int index5 = 0; index5 < index1 - 1; ++index5)
      {
        int index6 = numArray1[index5] + numArray3[index5];
        int index7 = numArray2[index5];
        int num9 = (int) ((double) numArray4[index5] * (1.0 + (double) WorldGen.genRand.Next(20, 30) * 0.1));
        Main.tile[index6, index7 + 1].type = (ushort) 191;
        Main.tile[index6, index7 + 1].active(true);
        Main.tile[index6, index7 + 1].halfBrick(false);
        Main.tile[index6, index7 + 1].color((byte) 28);
        int num10 = WorldGen.genRand.Next(3, 5);
        while (num9 > 0)
        {
          --num9;
          Main.tile[index6, index7].type = (ushort) 191;
          Main.tile[index6, index7].active(true);
          Main.tile[index6, index7].halfBrick(false);
          Main.tile[index6, index7].color((byte) 28);
          Main.tile[index6, index7].slope((byte) 0);
          if (WorldGen.genRand.Next(10) == 0)
          {
            if (WorldGen.genRand.Next(2) == 0)
              --index7;
            else
              ++index7;
          }
          else
            index6 += numArray3[index5];
          if (num10 > 0)
            --num10;
          else if (WorldGen.genRand.Next(2) == 0)
          {
            num10 = WorldGen.genRand.Next(2, 5);
            if (WorldGen.genRand.Next(2) == 0)
            {
              Main.tile[index6, index7].type = (ushort) 191;
              Main.tile[index6, index7].active(true);
              Main.tile[index6, index7].halfBrick(false);
              Main.tile[index6, index7].color((byte) 28);
              Main.tile[index6, index7].slope((byte) 0);
              Main.tile[index6, index7 - 1].type = (ushort) 191;
              Main.tile[index6, index7 - 1].active(true);
              Main.tile[index6, index7 - 1].halfBrick(false);
              Main.tile[index6, index7 - 1].color((byte) 28);
              numArray5[index2] = index6;
              numArray6[index2] = index7;
              ++index2;
            }
            else
            {
              Main.tile[index6, index7].type = (ushort) 191;
              Main.tile[index6, index7].active(true);
              Main.tile[index6, index7].halfBrick(false);
              Main.tile[index6, index7].color((byte) 28);
              Main.tile[index6, index7].slope((byte) 0);
              Main.tile[index6, index7 + 1].type = (ushort) 191;
              Main.tile[index6, index7 + 1].active(true);
              Main.tile[index6, index7 + 1].halfBrick(false);
              Main.tile[index6, index7 + 1].color((byte) 28);
              numArray5[index2] = index6;
              numArray6[index2] = index7;
              ++index2;
            }
          }
          if (num9 == 0)
          {
            numArray5[index2] = index6;
            numArray6[index2] = index7;
            ++index2;
          }
        }
      }
      int index8 = (num1 + num2) / 2;
      int index9 = index3;
      int num11 = WorldGen.genRand.Next(num3 * 3, num3 * 5);
      int num12 = 0;
      int num13 = 0;
      for (; num11 > 0; --num11)
      {
        Main.tile[index8, index9].type = (ushort) 191;
        Main.tile[index8, index9].active(true);
        Main.tile[index8, index9].halfBrick(false);
        Main.tile[index8, index9].color((byte) 28);
        if (num12 > 0)
          --num12;
        if (num13 > 0)
          --num13;
        for (int index10 = -1; index10 < 2; ++index10)
        {
          if (index10 != 0 && (index10 < 0 && num12 == 0 || index10 > 0 && num13 == 0) && WorldGen.genRand.Next(2) == 0)
          {
            int index11 = index8;
            int index12 = index9;
            int num14 = WorldGen.genRand.Next(num3, num3 * 3);
            if (index10 < 0)
              num12 = WorldGen.genRand.Next(3, 5);
            if (index10 > 0)
              num13 = WorldGen.genRand.Next(3, 5);
            int num15 = 0;
            while (num14 > 0)
            {
              --num14;
              index11 += index10;
              Main.tile[index11, index12].type = (ushort) 191;
              Main.tile[index11, index12].active(true);
              Main.tile[index11, index12].halfBrick(false);
              Main.tile[index11, index12].color((byte) 28);
              if (num14 == 0)
              {
                numArray5[index2] = index11;
                numArray6[index2] = index12;
                flagArray[index2] = true;
                ++index2;
              }
              if (WorldGen.genRand.Next(5) == 0)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  --index12;
                else
                  ++index12;
                Main.tile[index11, index12].type = (ushort) 191;
                Main.tile[index11, index12].active(true);
                Main.tile[index11, index12].halfBrick(false);
                Main.tile[index11, index12].color((byte) 28);
              }
              if (num15 > 0)
                --num15;
              else if (WorldGen.genRand.Next(3) == 0)
              {
                num15 = WorldGen.genRand.Next(2, 4);
                int index13 = index11;
                int num16 = index12;
                int index14 = WorldGen.genRand.Next(2) != 0 ? num16 + 1 : num16 - 1;
                Main.tile[index13, index14].type = (ushort) 191;
                Main.tile[index13, index14].active(true);
                Main.tile[index13, index14].halfBrick(false);
                Main.tile[index13, index14].color((byte) 28);
                numArray5[index2] = index13;
                numArray6[index2] = index14;
                flagArray[index2] = true;
                int index15 = index2 + 1;
                numArray5[index15] = index13 + WorldGen.genRand.Next(-5, 6);
                numArray6[index15] = index14 + WorldGen.genRand.Next(-5, 6);
                flagArray[index15] = true;
                index2 = index15 + 1;
              }
            }
          }
        }
        numArray5[index2] = index8;
        numArray6[index2] = index9;
        ++index2;
        if (WorldGen.genRand.Next(4) == 0)
        {
          if (WorldGen.genRand.Next(2) == 0)
            --index8;
          else
            ++index8;
          Main.tile[index8, index9].type = (ushort) 191;
          Main.tile[index8, index9].active(true);
          Main.tile[index8, index9].halfBrick(false);
          Main.tile[index8, index9].color((byte) 28);
        }
        --index9;
      }
      for (int i1 = minl; i1 <= minr; ++i1)
      {
        int num17 = WorldGen.genRand.Next(1, 6);
        int j1 = j + 1;
        while (num17 > 0)
        {
          if (WorldGen.SolidTile(i1, j1))
            --num17;
          Main.tile[i1, j1].type = (ushort) 191;
          Main.tile[i1, j1].active(true);
          Main.tile[i1, j1].halfBrick(false);
          Main.tile[i1, j1].slope((byte) 0);
          ++j1;
        }
        int num18 = j1;
        int num19 = WorldGen.genRand.Next(2, num3 + 1);
        for (int index16 = 0; index16 < num19; ++index16)
        {
          int index17 = num18;
          int num20 = (minl + minr) / 2;
          int num21 = 1;
          int num22 = i1 >= num20 ? 1 : -1;
          if (i1 == num20 || num3 > 6 && (i1 == num20 - 1 || i1 == num20 + 1))
            num22 = 0;
          int num23 = num22;
          int index18 = i1;
          int num24 = WorldGen.genRand.Next((int) ((double) num3 * 3.5), num3 * 6);
          while (num24 > 0)
          {
            --num24;
            index18 += num22;
            if (Main.tile[index18, index17].wall != (ushort) 244)
            {
              Main.tile[index18, index17].type = (ushort) 191;
              Main.tile[index18, index17].active(true);
              Main.tile[index18, index17].halfBrick(false);
              Main.tile[index18, index17].slope((byte) 0);
            }
            index17 += num21;
            if (Main.tile[index18, index17].wall != (ushort) 244)
            {
              Main.tile[index18, index17].type = (ushort) 191;
              Main.tile[index18, index17].active(true);
              Main.tile[index18, index17].halfBrick(false);
              Main.tile[index18, index17].slope((byte) 0);
            }
            if (!Main.tile[index18, index17 + 1].active())
            {
              num22 = 0;
              num21 = 1;
            }
            if (WorldGen.genRand.Next(3) == 0)
              num22 = num23 >= 0 ? (num23 <= 0 ? WorldGen.genRand.Next(-1, 2) : (num22 != 0 ? 0 : 1)) : (num22 != 0 ? 0 : -1);
            if (WorldGen.genRand.Next(3) == 0)
              num21 = num21 != 0 ? 0 : 1;
          }
        }
      }
      if (!WorldGen.remixWorldGen)
      {
        for (int index19 = 0; index19 < index2; ++index19)
        {
          int num25 = (int) ((double) WorldGen.genRand.Next(5, 8) * (1.0 + (double) num3 * 0.05));
          if (flagArray[index19])
            num25 = WorldGen.genRand.Next(6, 12) + num3;
          int num26 = numArray5[index19] - num25 * 2;
          int num27 = numArray5[index19] + num25 * 2;
          int num28 = numArray6[index19] - num25 * 2;
          int num29 = numArray6[index19] + num25 * 2;
          double num30 = 2.0 - (double) WorldGen.genRand.Next(5) * 0.1;
          for (int index20 = num26; index20 <= num27; ++index20)
          {
            for (int index21 = num28; index21 <= num29; ++index21)
            {
              if (Main.tile[index20, index21].type != (ushort) 191)
              {
                if (flagArray[index19])
                {
                  Vector2D vector2D = Vector2D.op_Subtraction(new Vector2D((double) numArray5[index19], (double) numArray6[index19]), new Vector2D((double) index20, (double) index21));
                  if (((Vector2D) ref vector2D).Length() < (double) num25 * 0.9)
                  {
                    Main.tile[index20, index21].type = (ushort) 192;
                    Main.tile[index20, index21].active(true);
                    Main.tile[index20, index21].halfBrick(false);
                    Main.tile[index20, index21].color((byte) 28);
                  }
                }
                else if ((double) Math.Abs(numArray5[index19] - index20) + (double) Math.Abs(numArray6[index19] - index21) * num30 < (double) num25)
                {
                  Main.tile[index20, index21].type = (ushort) 192;
                  Main.tile[index20, index21].active(true);
                  Main.tile[index20, index21].halfBrick(false);
                  Main.tile[index20, index21].color((byte) 28);
                }
              }
            }
          }
        }
      }
      WorldGen.GrowDungeonTree_MakePassage(j, num3, ref minl, ref minr, patch);
      Main.tileSolid[48] = true;
      return true;
    }

    private static bool GrowLivingTree_HorizontalTunnel(int i, int j)
    {
      int num1 = i;
      int y = j;
      int num2 = num1;
      int num3 = num1;
      int num4 = 80;
      bool flag1 = false;
      int num5 = 1;
      if (WorldGen.genRand.Next(2) == 0)
        num5 *= -1;
      for (int index1 = 0; index1 < 2; ++index1)
      {
        bool flag2 = false;
        if (num2 == num1 && num5 > 0)
        {
          for (int x = num1 + 5; x < num1 + num4; ++x)
          {
            if (!WorldGen.InWorld(x, y, 10))
              return false;
            if ((double) y < Main.worldSurface)
            {
              int index2 = y - 7;
              while (index2 <= y + 7 && Main.tile[x, index2].wall != (ushort) 0)
                ++index2;
            }
            if (Main.tile[x, j].type == (ushort) 48)
            {
              flag1 = true;
              break;
            }
            if (Main.tile[x, j].type == (ushort) 191)
            {
              for (int index3 = y - 2; index3 <= y; ++index3)
              {
                if (Main.tile[x + 2, index3].wall != (ushort) 244)
                  flag2 = true;
              }
              if (!flag2)
              {
                index1 = 2;
                num3 = x + 2;
                break;
              }
              break;
            }
            if (!Main.tile[x, j].active())
            {
              bool flag3 = true;
              for (int index4 = y - 2; index4 <= y; ++index4)
              {
                if ((double) y < Main.worldSurface + 3.0 && (Main.tile[x + 1, index4].wall == (ushort) 0 || Main.tile[x + 2, index4].wall == (ushort) 0 || Main.tile[x + 3, index4].wall == (ushort) 0))
                  return false;
                if (Main.tile[x, index4].active() || Main.tile[x + 1, index4].active() || Main.tile[x + 2, index4].active())
                  flag3 = false;
              }
              if (flag3)
              {
                index1 = 2;
                num3 = x;
                break;
              }
            }
          }
        }
        bool flag4 = false;
        if (num3 == num1 && num5 < 0)
        {
          for (int x = num1 - 5; x > num1 - num4; --x)
          {
            if (!WorldGen.InWorld(x, y, 10))
              return false;
            if ((double) y < Main.worldSurface)
            {
              int index5 = y - 7;
              while (index5 <= y + 7 && Main.tile[x, index5].wall != (ushort) 0)
                ++index5;
            }
            if (Main.tile[x, j].type == (ushort) 48)
            {
              flag1 = true;
              break;
            }
            if (Main.tile[x, y].type == (ushort) 191)
            {
              for (int index6 = y - 2; index6 <= y; ++index6)
              {
                if (Main.tile[x - 3, index6].wall != (ushort) 244)
                  flag4 = true;
              }
              if (!flag4)
              {
                index1 = 2;
                num2 = x - 2;
                break;
              }
              break;
            }
            if (!Main.tile[x, j].active())
            {
              bool flag5 = true;
              for (int index7 = y - 2; index7 <= y; ++index7)
              {
                if ((double) y < Main.worldSurface + 3.0 && (Main.tile[x - 1, index7].wall == (ushort) 0 || Main.tile[x - 2, index7].wall == (ushort) 0 || Main.tile[x - 3, index7].wall == (ushort) 0))
                  return false;
                if (Main.tile[x, index7].active() || Main.tile[x - 1, index7].active() || Main.tile[x - 2, index7].active())
                  flag5 = false;
              }
              if (flag5)
              {
                index1 = 2;
                num2 = x;
                break;
              }
            }
          }
        }
        num5 *= -1;
      }
      if (num2 == num3)
        return false;
      bool flag6 = false;
      bool flag7 = false;
      for (int j1 = y - 5; j1 <= y + 1; ++j1)
      {
        for (int i1 = num2; i1 <= num3; ++i1)
        {
          int num6 = 2;
          if (Math.Abs(i1 - num3) > 3 && Math.Abs(i1 - num2) > 3)
            num6 = 4;
          if (Main.tile[i1, j1].wall != (ushort) 244 && Main.tile[i1, j1].type != (ushort) 19 && Main.tile[i1, j1].type != (ushort) 15 && Main.tile[i1, j1].type != (ushort) 304 && Main.tile[i1, j1].type != (ushort) 21 && Main.tile[i1, j1].type != (ushort) 10)
          {
            if (!Main.wallDungeon[(int) Main.tile[i1, j1].wall] && (!Main.tile[i1, j1].active() || !Main.wallDungeon[(int) Main.tile[i1, j1 - 1].wall] && !Main.wallDungeon[(int) Main.tile[i1, j1 + 1].wall]))
            {
              Main.tile[i1, j1].active(true);
              Main.tile[i1, j1].type = (ushort) 191;
              Main.tile[i1, j1].halfBrick(false);
            }
            if (Main.tile[i1, j1 - 1].type == (ushort) 40)
              Main.tile[i1, j1 - 1].type = (ushort) 0;
            if (Main.tile[i1, j1 + 1].type == (ushort) 40)
              Main.tile[i1, j1 + 1].type = (ushort) 0;
          }
          if (j1 >= y - num6 && j1 <= y && Main.tile[i1, j1].type != (ushort) 19 && Main.tile[i1, j1].type != (ushort) 15 && Main.tile[i1, j1].type != (ushort) 304 && Main.tile[i1, j1].type != (ushort) 21 && Main.tile[i1, j1].type != (ushort) 10 && Main.tile[i1, j1 - 1].type != (ushort) 15 && Main.tile[i1, j1 - 1].type != (ushort) 304 && Main.tile[i1, j1 - 1].type != (ushort) 21 && Main.tile[i1, j1 - 1].type != (ushort) 10 && Main.tile[i1, j1 + 1].type != (ushort) 10)
          {
            if (!Main.wallDungeon[(int) Main.tile[i1, j1].wall])
              Main.tile[i1, j1].wall = (ushort) 244;
            Main.tile[i1, j1].liquid = (byte) 0;
            Main.tile[i1, j1].active(false);
          }
          if (j1 == y)
          {
            int style = 7;
            if (Main.wallDungeon[(int) Main.tile[i1, j1].wall] || Main.wallDungeon[(int) Main.tile[i1, j1 - 1].wall] || Main.wallDungeon[(int) Main.tile[i1, j1 - 2].wall])
              style = 13;
            if (i1 <= num2 + 4 && !flag6)
            {
              if (Main.tile[i1 - 1, j1].type == (ushort) 10 || Main.tile[i1 + 1, j1].type == (ushort) 10)
                flag6 = true;
              else if (WorldGen.genRand.Next(3) == 0)
              {
                WorldGen.PlaceTile(i1, j1, 10, true, style: style);
                if (Main.tile[i1, j1].type == (ushort) 10)
                  flag6 = true;
              }
            }
            if (i1 >= num3 - 4 && !flag7)
            {
              if (Main.tile[i1 - 1, j1].type == (ushort) 10 || Main.tile[i1 + 1, j1].type == (ushort) 10)
                flag7 = true;
              else if (WorldGen.genRand.Next(3) == 0)
              {
                WorldGen.PlaceTile(i1, j1, 10, true, style: style);
                if (Main.tile[i1, j1].type == (ushort) 10)
                  flag7 = true;
              }
            }
          }
        }
      }
      return true;
    }

    private static void GrowDungeonTree_MakePassage(
      int j,
      int W,
      ref int minl,
      ref int minr,
      bool noSecretRoom = false)
    {
      int num1 = minl;
      int num2 = minr;
      int num3 = (minl + minr) / 2;
      int num4 = 5;
      int j1 = j - 6;
      int num5 = 0;
      bool flag = true;
      WorldGen.genRand.Next(5, 16);
label_1:
      int num6;
      int style;
      while (true)
      {
        int num7;
        do
        {
          do
          {
            ++j1;
            if (j1 <= GenVars.dungeonY - 5)
            {
              num6 = (minl + minr) / 2;
              int num8 = 1;
              if (j1 > j && W <= 4)
                ++num8;
              for (int i = minl - num8; i <= minr + num8; ++i)
              {
                if (i > num6 - 2 && i <= num6 + 1)
                {
                  if (j1 > j - 4)
                  {
                    if (Main.tile[i, j1].type != (ushort) 19 && Main.tile[i, j1].type != (ushort) 15 && Main.tile[i, j1].type != (ushort) 304 && Main.tile[i, j1].type != (ushort) 21 && Main.tile[i, j1].type != (ushort) 10 && Main.tile[i, j1 - 1].type != (ushort) 15 && Main.tile[i, j1 - 1].type != (ushort) 304 && Main.tile[i, j1 - 1].type != (ushort) 21 && Main.tile[i, j1 - 1].type != (ushort) 10 && Main.tile[i, j1 + 1].type != (ushort) 10)
                      Main.tile[i, j1].active(false);
                    if (!Main.wallDungeon[(int) Main.tile[i, j1].wall])
                      Main.tile[i, j1].wall = (ushort) 244;
                    if (!Main.wallDungeon[(int) Main.tile[i - 1, j1].wall] && (Main.tile[i - 1, j1].wall > (ushort) 0 || (double) j1 >= Main.worldSurface))
                      Main.tile[i - 1, j1].wall = (ushort) 244;
                    if (!Main.wallDungeon[(int) Main.tile[i + 1, j1].wall] && (Main.tile[i + 1, j1].wall > (ushort) 0 || (double) j1 >= Main.worldSurface))
                      Main.tile[i + 1, j1].wall = (ushort) 244;
                    if (j1 == j && i > num6 - 2 && i <= num6 + 1)
                    {
                      Main.tile[i, j1 + 1].active(false);
                      WorldGen.PlaceTile(i, j1 + 1, 19, true, style: 23);
                    }
                  }
                }
                else
                {
                  if (Main.tile[i, j1].type != (ushort) 15 && Main.tile[i, j1].type != (ushort) 304 && Main.tile[i, j1].type != (ushort) 21 && Main.tile[i, j1].type != (ushort) 10 && Main.tile[i - 1, j1].type != (ushort) 10 && Main.tile[i + 1, j1].type != (ushort) 10)
                  {
                    if (!Main.wallDungeon[(int) Main.tile[i, j1].wall])
                    {
                      Main.tile[i, j1].type = (ushort) 191;
                      Main.tile[i, j1].active(true);
                      Main.tile[i, j1].halfBrick(false);
                    }
                    if (Main.tile[i - 1, j1].type == (ushort) 40)
                      Main.tile[i - 1, j1].type = (ushort) 0;
                    if (Main.tile[i + 1, j1].type == (ushort) 40)
                      Main.tile[i + 1, j1].type = (ushort) 0;
                  }
                  if (j1 <= j && j1 > j - 4 && i > minl - num8 && i <= minr + num8 - 1)
                    Main.tile[i, j1].wall = (ushort) 244;
                }
                if (!WorldGen.gen)
                {
                  WorldGen.SquareTileFrame(i, j1);
                  WorldGen.SquareWallFrame(i, j1);
                }
              }
              ++num5;
            }
            else
              goto label_50;
          }
          while (num5 < 6);
          num5 = 0;
          num7 = WorldGen.genRand.Next(3);
          if (num7 == 0)
            num7 = -1;
          if (flag)
            num7 = 2;
          if (num7 == -1 && Main.tile[minl - num4, j1].wall == (ushort) 244)
            num7 = 1;
          else if (num7 == 1 && Main.tile[minr + num4, j1].wall == (ushort) 244)
            num7 = -1;
          if (num7 == 2)
          {
            flag = false;
            style = 23;
            if (Main.wallDungeon[(int) Main.tile[minl, j1 + 1].wall] || Main.wallDungeon[(int) Main.tile[minl + 1, j1 + 1].wall] || Main.wallDungeon[(int) Main.tile[minl + 2, j1 + 1].wall])
              style = 12;
          }
          else
            goto label_49;
        }
        while (!WorldGen.SolidTile(minl - 1, j1 + 1) && !WorldGen.SolidTile(minr + 1, j1 + 1) && style == 12);
        break;
label_49:
        minl += num7;
        minr += num7;
      }
      for (int i = minl; i <= minr; ++i)
      {
        if (i > num6 - 2 && i <= num6 + 1)
        {
          Main.tile[i, j1 + 1].active(false);
          Main.tile[i, j1 + 1].halfBrick(false);
          Main.tile[i, j1 + 1].slope((byte) 0);
          WorldGen.PlaceTile(i, j1 + 1, 19, true, style: style);
        }
      }
      goto label_1;
label_50:
      minl = num1;
      minr = num2;
      int num9 = (minl + minr) / 2;
      for (int index1 = minl; index1 <= minr; ++index1)
      {
        for (int index2 = j - 3; index2 <= j; ++index2)
        {
          Main.tile[index1, index2].active(false);
          if (!Main.wallDungeon[(int) Main.tile[index1, index2].wall])
            Main.tile[index1, index2].wall = (ushort) 244;
        }
      }
    }

    private static void GrowLivingTree_MakePassage(
      int j,
      int W,
      ref int minl,
      ref int minr,
      bool noSecretRoom = false)
    {
      bool flag1 = noSecretRoom;
      int num1 = minl;
      int num2 = minr;
      bool flag2 = false;
      int num3 = (minl + minr) / 2;
      int num4 = 5;
      int index1 = j - 6;
      int num5 = 50;
      int num6 = WorldGen.genRand.Next(400, 700);
      int num7 = 0;
      bool flag3 = true;
      int num8 = WorldGen.genRand.Next(5, 16);
      while (num6 > 0)
      {
        ++index1;
        --num6;
        --num5;
        int i1 = (minl + minr) / 2;
        if (!Main.tile[minl, index1].active() && Main.tile[minl, index1].wall == (ushort) 244 && !Main.tile[minr, index1].active() && Main.tile[minr, index1].wall == (ushort) 244)
          break;
        int num9 = 1;
        if (index1 > j && W <= 4)
          ++num9;
        for (int i2 = minl - num9; i2 <= minr + num9; ++i2)
        {
          if (Main.wallDungeon[(int) Main.tile[i2, index1].wall])
          {
            flag1 = true;
            flag2 = true;
          }
          if (i2 > i1 - 2 && i2 <= i1 + 1)
          {
            if (index1 > j - 4)
            {
              if (Main.tile[i2, index1].type != (ushort) 19 && Main.tile[i2, index1].type != (ushort) 15 && Main.tile[i2, index1].type != (ushort) 304 && Main.tile[i2, index1].type != (ushort) 21 && Main.tile[i2, index1].type != (ushort) 10 && Main.tile[i2, index1 - 1].type != (ushort) 15 && Main.tile[i2, index1 - 1].type != (ushort) 304 && Main.tile[i2, index1 - 1].type != (ushort) 21 && Main.tile[i2, index1 - 1].type != (ushort) 10 && Main.tile[i2, index1 + 1].type != (ushort) 10)
                Main.tile[i2, index1].active(false);
              if (!Main.wallDungeon[(int) Main.tile[i2, index1].wall])
                Main.tile[i2, index1].wall = (ushort) 244;
              if (!Main.wallDungeon[(int) Main.tile[i2 - 1, index1].wall] && (Main.tile[i2 - 1, index1].wall > (ushort) 0 || (double) index1 >= Main.worldSurface))
                Main.tile[i2 - 1, index1].wall = (ushort) 244;
              if (!Main.wallDungeon[(int) Main.tile[i2 + 1, index1].wall] && (Main.tile[i2 + 1, index1].wall > (ushort) 0 || (double) index1 >= Main.worldSurface))
                Main.tile[i2 + 1, index1].wall = (ushort) 244;
              if (index1 == j && i2 > i1 - 2 && i2 <= i1 + 1)
              {
                Main.tile[i2, index1 + 1].active(false);
                WorldGen.PlaceTile(i2, index1 + 1, 19, true, style: 23);
              }
            }
          }
          else
          {
            if (Main.tile[i2, index1].type != (ushort) 15 && Main.tile[i2, index1].type != (ushort) 304 && Main.tile[i2, index1].type != (ushort) 21 && Main.tile[i2, index1].type != (ushort) 10 && Main.tile[i2 - 1, index1].type != (ushort) 10 && Main.tile[i2 + 1, index1].type != (ushort) 10)
            {
              if (!Main.wallDungeon[(int) Main.tile[i2, index1].wall])
              {
                Main.tile[i2, index1].type = (ushort) 191;
                Main.tile[i2, index1].active(true);
                Main.tile[i2, index1].halfBrick(false);
              }
              if (Main.tile[i2 - 1, index1].type == (ushort) 40)
                Main.tile[i2 - 1, index1].type = (ushort) 0;
              if (Main.tile[i2 + 1, index1].type == (ushort) 40)
                Main.tile[i2 + 1, index1].type = (ushort) 0;
            }
            if (index1 <= j && index1 > j - 4 && i2 > minl - num9 && i2 <= minr + num9 - 1)
              Main.tile[i2, index1].wall = (ushort) 244;
          }
          if (!WorldGen.gen)
          {
            WorldGen.SquareTileFrame(i2, index1);
            WorldGen.SquareWallFrame(i2, index1);
          }
        }
        ++num7;
        if (num7 >= 6)
        {
          num7 = 0;
          int num10 = WorldGen.genRand.Next(3);
          if (num10 == 0)
            num10 = -1;
          if (flag3)
            num10 = 2;
          if (num10 == -1 && Main.tile[minl - num4, index1].wall == (ushort) 244)
            num10 = 1;
          else if (num10 == 1 && Main.tile[minr + num4, index1].wall == (ushort) 244)
            num10 = -1;
          if (num10 == 2)
          {
            flag3 = false;
            int style = 23;
            if (Main.wallDungeon[(int) Main.tile[minl, index1 + 1].wall] || Main.wallDungeon[(int) Main.tile[minl + 1, index1 + 1].wall] || Main.wallDungeon[(int) Main.tile[minl + 2, index1 + 1].wall])
              style = 12;
            for (int i3 = minl; i3 <= minr; ++i3)
            {
              if (i3 > i1 - 2 && i3 <= i1 + 1)
              {
                Main.tile[i3, index1 + 1].active(false);
                WorldGen.PlaceTile(i3, index1 + 1, 19, true, style: style);
              }
            }
          }
          else
          {
            minl += num10;
            minr += num10;
          }
          if (noSecretRoom)
          {
            --num8;
            if (num8 <= 0)
              num8 = !WorldGen.GrowLivingTree_HorizontalTunnel(i1, index1) ? WorldGen.genRand.Next(2, 11) : WorldGen.genRand.Next(5, 21);
          }
          if (num5 <= 0 && !flag1)
          {
            flag1 = true;
            WorldGen.GrowLivingTreePassageRoom(minl, minr, index1);
          }
        }
        if (flag2)
        {
          bool flag4 = true;
          for (int i4 = minl; i4 <= minr; ++i4)
          {
            for (int j1 = index1 + 1; j1 <= index1 + 2; ++j1)
            {
              if (WorldGen.SolidTile(i4, j1))
                flag4 = false;
            }
          }
          if (flag4)
            num6 = 0;
        }
        else if (num5 <= 0)
        {
          bool flag5 = true;
          for (int i5 = minl; i5 <= minr; ++i5)
          {
            for (int j2 = index1 + 1; j2 <= index1 + 4; ++j2)
            {
              if (WorldGen.SolidTile(i5, j2))
                flag5 = false;
            }
          }
          if (flag5)
            num6 = 0;
        }
      }
      minl = num1;
      minr = num2;
      int num11 = (minl + minr) / 2;
      for (int index2 = minl; index2 <= minr; ++index2)
      {
        for (int index3 = j - 3; index3 <= j; ++index3)
        {
          Main.tile[index2, index3].active(false);
          bool flag6 = true;
          for (int index4 = index2 - 1; index4 <= index2 + 1; ++index4)
          {
            for (int index5 = index3 - 1; index5 <= index3 + 1; ++index5)
            {
              if (!Main.tile[index4, index5].active() && Main.tile[index4, index5].wall == (ushort) 0)
                flag6 = false;
            }
          }
          if (flag6 && !Main.wallDungeon[(int) Main.tile[index2, index3].wall])
            Main.tile[index2, index3].wall = (ushort) 244;
        }
      }
    }

    private static void GrowLivingTreePassageRoom(int minl, int minr, int Y)
    {
      int num1 = WorldGen.genRand.Next(2);
      if (num1 == 0)
        num1 = -1;
      int num2 = Y - 2;
      int num3 = Y;
      int num4 = (minl + minr) / 2;
      if (num1 < 0)
        --num4;
      if (num1 > 0)
        ++num4;
      int num5 = WorldGen.genRand.Next(15, 30);
      int num6 = num4 + num5;
      if (num1 < 0)
      {
        num6 = num4;
        num4 -= num5;
      }
      for (int index1 = num4; index1 < num6; ++index1)
      {
        for (int index2 = Y - 20; index2 < Y + 10; ++index2)
        {
          if (Main.tile[index1, index2].wall == (ushort) 0 && !Main.tile[index1, index2].active() && (double) index2 < Main.worldSurface)
            return;
        }
      }
      GenVars.dMinX = num4;
      GenVars.dMaxX = num6;
      if (num1 < 0)
        GenVars.dMinX -= 40;
      else
        GenVars.dMaxX += 40;
      for (int index3 = num4; index3 <= num6; ++index3)
      {
        for (int index4 = num2 - 2; index4 <= num3 + 2; ++index4)
        {
          if (Main.tile[index3 - 1, index4].type == (ushort) 40)
            Main.tile[index3 - 1, index4].type = (ushort) 0;
          if (Main.tile[index3 + 1, index4].type == (ushort) 40)
            Main.tile[index3 + 1, index4].type = (ushort) 0;
          if (Main.tile[index3, index4 - 1].type == (ushort) 40)
            Main.tile[index3, index4 - 1].type = (ushort) 0;
          if (Main.tile[index3, index4 + 1].type == (ushort) 40)
            Main.tile[index3, index4 + 1].type = (ushort) 0;
          if (Main.tile[index3, index4].wall != (ushort) 244 && Main.tile[index3, index4].type != (ushort) 19)
          {
            Main.tile[index3, index4].active(true);
            Main.tile[index3, index4].type = (ushort) 191;
            Main.tile[index3, index4].halfBrick(false);
          }
          if (index4 >= num2 && index4 <= num3)
          {
            Main.tile[index3, index4].liquid = (byte) 0;
            Main.tile[index3, index4].wall = (ushort) 244;
            Main.tile[index3, index4].active(false);
          }
        }
      }
      int i1 = (minl + minr) / 2 + 3 * num1;
      int j = Y;
      WorldGen.PlaceTile(i1, j, 10, true, style: 7);
      int num7 = WorldGen.genRand.Next(5, 9);
      int num8 = WorldGen.genRand.Next(4, 6);
      int num9;
      int num10;
      if (num1 < 0)
      {
        num9 = num4 + num7;
        num10 = num4 - num7;
      }
      else
      {
        num10 = num6 - num7;
        num9 = num6 + num7;
      }
      int num11 = num3 - num8;
      for (int index5 = num10 - 2; index5 <= num9 + 2; ++index5)
      {
        for (int index6 = num11 - 2; index6 <= num3 + 2; ++index6)
        {
          if (Main.tile[index5 - 1, index6].type == (ushort) 40)
            Main.tile[index5 - 1, index6].type = (ushort) 40;
          if (Main.tile[index5 + 1, index6].type == (ushort) 40)
            Main.tile[index5 + 1, index6].type = (ushort) 40;
          if (Main.tile[index5, index6 - 1].type == (ushort) 40)
            Main.tile[index5, index6 - 1].type = (ushort) 40;
          if (Main.tile[index5, index6 + 1].type == (ushort) 40)
            Main.tile[index5, index6 + 1].type = (ushort) 40;
          if (Main.tile[index5, index6].wall != (ushort) 244 && Main.tile[index5, index6].type != (ushort) 19)
          {
            Main.tile[index5, index6].active(true);
            Main.tile[index5, index6].type = (ushort) 191;
            Main.tile[index5, index6].halfBrick(false);
          }
          if (index6 >= num11 && index6 <= num3 && index5 >= num10 && index5 <= num9)
          {
            Main.tile[index5, index6].liquid = (byte) 0;
            Main.tile[index5, index6].wall = (ushort) 244;
            Main.tile[index5, index6].active(false);
          }
        }
      }
      int i2 = num10 - 2;
      if (num1 < 0)
        i2 = num9 + 2;
      WorldGen.PlaceTile(i2, j, 10, true, style: 7);
      int i3 = num9;
      if (num1 < 0)
        i3 = num10;
      int maxValue = 2;
      if (WorldGen.genRand.Next(maxValue) == 0)
      {
        maxValue += 2;
        WorldGen.PlaceTile(i3, Y, 15, true, style: 5);
        if (num1 < 0)
        {
          Main.tile[i3, Y - 1].frameX += (short) 18;
          Main.tile[i3, Y].frameX += (short) 18;
        }
      }
      int i4 = num9 - 2;
      if (num1 < 0)
        i4 = num10 + 2;
      WorldGen.PlaceTile(i4, Y, 304, true);
      int i5 = num9 - 4;
      if (num1 < 0)
        i5 = num10 + 4;
      if (WorldGen.genRand.Next(maxValue) == 0)
      {
        WorldGen.PlaceTile(i5, Y, 15, true, style: 5);
        if (num1 > 0)
        {
          Main.tile[i5, Y - 1].frameX += (short) 18;
          Main.tile[i5, Y].frameX += (short) 18;
        }
      }
      int i6 = num9 - 7;
      if (num1 < 0)
        i6 = num10 + 8;
      int contain = 832;
      if (WorldGen.genRand.Next(3) == 0)
        contain = 4281;
      if (WorldGen.remixWorldGen)
      {
        int num12 = WorldGen.genRand.Next(1, 3);
        for (int index = 0; index < num12; ++index)
        {
          bool flag = false;
          while (!flag)
          {
            int num13 = WorldGen.genRand.Next(Main.maxTilesX / 8, Main.maxTilesX - Main.maxTilesX / 8);
            int num14 = WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY - 350);
            if (!WorldGen.IsTileNearby(num13, num14, 53, 20) && !WorldGen.IsTileNearby(num13, num14, 147, 20) && !WorldGen.IsTileNearby(num13, num14, 59, 20))
              flag = WorldGen.AddBuriedChest(num13, num14, contain, Style: 12);
          }
        }
        if (WorldGen.crimson)
          WorldGen.AddBuriedChest(i6, Y, Style: 14);
        else
          WorldGen.AddBuriedChest(i6, Y, Style: 7);
      }
      else
        WorldGen.AddBuriedChest(i6, Y, contain, Style: 12);
    }

    public static void TreeGrowFXCheck(int x, int y)
    {
      int treeHeight = 1;
      int passStyle = -1;
      Tile topTile = (Tile) null;
      for (int index = -1; index > -100; --index)
      {
        Tile tile = Main.tile[x, y + index];
        if (tile.active() && TileID.Sets.GetsCheckedForLeaves[(int) tile.type])
        {
          topTile = tile;
          ++treeHeight;
        }
        else
          break;
      }
      for (int index = 1; index < 5; ++index)
      {
        Tile t = Main.tile[x, y + index];
        if (t.active() && TileID.Sets.GetsCheckedForLeaves[(int) t.type])
        {
          ++treeHeight;
        }
        else
        {
          WorldGen.GetTreeLeaf(x, topTile, t, ref treeHeight, out int _, out passStyle);
          break;
        }
      }
      if (treeHeight <= 0 || passStyle <= 0)
        return;
      if (Main.netMode == 2)
        NetMessage.SendData(112, number: 1, number2: ((float) x), number3: ((float) y), number4: ((float) treeHeight), number5: passStyle);
      if (Main.netMode != 0)
        return;
      WorldGen.TreeGrowFX(x, y, treeHeight, passStyle);
    }

    public static void GetTreeLeaf(
      int x,
      Tile topTile,
      Tile t,
      ref int treeHeight,
      out int treeFrame,
      out int passStyle)
    {
      treeFrame = 0;
      passStyle = -1;
      if (topTile.frameX == (short) 22 || topTile.frameX == (short) 44 || topTile.frameX == (short) 66)
      {
        if (topTile.frameY == (short) 220)
          treeFrame = 1;
        else if (topTile.frameY == (short) 242)
          treeFrame = 2;
      }
      if (topTile.frameX == (short) 44 || topTile.frameX == (short) 66)
      {
        if (topTile.frameY == (short) 220)
          treeFrame = 1;
        else if (topTile.frameY == (short) 242)
          treeFrame = 2;
      }
      switch (topTile.type)
      {
        case 583:
        case 584:
        case 585:
        case 586:
        case 587:
        case 588:
        case 589:
          passStyle = 1249 + ((int) topTile.type - 583);
          break;
        case 596:
          passStyle = 1248;
          break;
        case 616:
          passStyle = 1257;
          break;
        case 634:
          passStyle = 1278;
          break;
      }
      if (passStyle > -1)
        return;
      switch (t.type)
      {
        case 2:
        case 477:
          passStyle = 910;
          break;
        case 23:
        case 112:
          passStyle = 915;
          break;
        case 53:
          passStyle = 911;
          break;
        case 60:
          passStyle = 914;
          break;
        case 70:
          passStyle = 912;
          break;
        case 109:
        case 492:
          int num1 = 917;
          if (WorldGen.GetHollowTreeFoliageStyle() != 20)
          {
            if (x % 3 == 1)
              treeFrame += 3;
            if (x % 3 == 2)
              treeFrame += 6;
            switch (treeFrame)
            {
              case 0:
                passStyle = 2;
                break;
              case 1:
                passStyle = 1;
                break;
              case 2:
                passStyle = 7;
                break;
              case 3:
                passStyle = 4;
                break;
              case 4:
                passStyle = 5;
                break;
              case 5:
                passStyle = 6;
                break;
              case 6:
                passStyle = 3;
                break;
              case 7:
                passStyle = 8;
                break;
              case 8:
                passStyle = 0;
                break;
            }
          }
          else
          {
            int num2 = 196;
            if (x % 6 == 1)
              treeFrame += 3;
            else if (x % 6 == 2)
              treeFrame += 6;
            else if (x % 6 == 3)
              treeFrame += 9;
            else if (x % 6 == 4)
              treeFrame += 12;
            else if (x % 6 == 5)
              treeFrame += 15;
            switch (treeFrame)
            {
              case 0:
                passStyle = num2;
                break;
              case 1:
                passStyle = num2;
                break;
              case 2:
                passStyle = num2;
                break;
              case 3:
                passStyle = num2 + 1;
                break;
              case 4:
                passStyle = num2 + 2;
                break;
              case 5:
                passStyle = num2 + 1;
                break;
              case 6:
                passStyle = num2 + 3;
                break;
              case 7:
                passStyle = num2 + 4;
                break;
              case 8:
                passStyle = num2 + 5;
                break;
              case 9:
                passStyle = num2 + 6;
                break;
              case 10:
                passStyle = num2 + 6;
                break;
              case 11:
                passStyle = num2 + 6;
                break;
              case 12:
                passStyle = num2 + 7;
                break;
              case 13:
                passStyle = num2 + 7;
                break;
              case 14:
                passStyle = num2 + 7;
                break;
              case 15:
                passStyle = num2 + 8;
                break;
              case 16:
                passStyle = num2 + 8;
                break;
              case 17:
                passStyle = num2 + 8;
                break;
            }
          }
          passStyle += num1;
          treeHeight += 5;
          break;
        case 116:
          passStyle = 919;
          break;
        case 147:
          passStyle = 913;
          break;
        case 199:
        case 234:
          passStyle = 916;
          break;
        case 633:
          passStyle = 1278;
          break;
      }
    }

    public static void TreeGrowFX(int x, int y, int height, int treeGore, bool hitTree = false)
    {
      Vector2 vector2_1 = new Vector2((float) x, (float) y) * 16f + new Vector2(8f, 8f);
      int Type = treeGore;
      if (treeGore == 1278)
      {
        WorldGen.TreeGrowFX_AshShake(x, y, height, hitTree);
      }
      else
      {
        for (int index1 = 0; index1 > -height; --index1)
        {
          float max = 10f;
          Vector2 vector2_2 = new Vector2(5f, 7f);
          Gore.NewGore(vector2_1 + new Vector2(-16f, (float) (index1 * 16)) - vector2_2, Utils.RandomVector2(Main.rand, -max, max), Type, (float) (0.699999988079071 + (double) Main.rand.NextFloat() * 0.60000002384185791));
          Gore.NewGore(vector2_1 + new Vector2(0.0f, (float) (index1 * 16)) - vector2_2, Utils.RandomVector2(Main.rand, -max, max), Type, (float) (0.699999988079071 + (double) Main.rand.NextFloat() * 0.60000002384185791));
          Gore.NewGore(vector2_1 + new Vector2(16f, (float) (index1 * 16)) - vector2_2, Utils.RandomVector2(Main.rand, -max, max), Type, (float) (0.699999988079071 + (double) Main.rand.NextFloat() * 0.60000002384185791));
          if (index1 == -height + 1)
          {
            int num = 20;
            if (hitTree)
              num = 5;
            for (int index2 = 0; index2 < num; ++index2)
              Gore.NewGore(vector2_1 + new Vector2(0.0f, (float) (index1 * 16 - 40)) + Utils.RandomVector2(Main.rand, -40f, 40f) - vector2_2, Utils.RandomVector2(Main.rand, -10f, 10f), Type, (float) (0.699999988079071 + (double) Main.rand.NextFloat() * 0.60000002384185791));
          }
        }
      }
    }

    private static void TreeGrowFX_AshShake(int x, int y, int height, bool hitTree = false)
    {
      Vector2 vector2 = new Vector2((float) x, (float) y) * 16f + new Vector2(8f, 8f);
      for (int index1 = 0; index1 > -height; --index1)
      {
        if (index1 >= -height / 2 && Main.rand.Next(3) != 0)
        {
          int num = hitTree ? 10 : 5;
          for (int index2 = 0; index2 < num; ++index2)
            Dust.NewDustDirect(vector2 + new Vector2(-16f, (float) (index1 * 16)) + Utils.RandomVector2(Main.rand, -30f, 30f), 4, 4, 31, SpeedY: -3f, Alpha: 100).velocity = Main.rand.NextVector2Circular(2f, 2f) + new Vector2(0.0f, -0.6f);
        }
        if ((double) index1 >= (double) -height * 0.699999988079071 && Main.rand.Next(3) != 0)
        {
          int num = hitTree ? 16 : 10;
          for (int index3 = 0; index3 < num; ++index3)
          {
            Dust dust = Dust.NewDustDirect(vector2 + new Vector2(-16f, (float) (index1 * 16)) + Utils.RandomVector2(Main.rand, -30f, 30f), 4, 4, 6, SpeedY: -4f, Scale: ((float) (1.0 + 0.699999988079071 * (double) Main.rand.NextFloat())));
            dust.velocity = Main.rand.NextVector2Circular(2f, 2f) + new Vector2(0.0f, -0.6f);
            if (Main.rand.Next(2) == 0)
            {
              dust.velocity *= 2f;
              dust.noGravity = true;
            }
            dust.velocity += new Vector2(0.0f, hitTree ? -1f : -2f);
          }
        }
        if (!hitTree)
          Gore.NewGoreDirect(vector2 + new Vector2(-16f, (float) (index1 * 16 - 40)) + Utils.RandomVector2(Main.rand, -40f, 40f) * new Vector2(0.5f, 1f), Vector2.Zero, 61 + Main.rand.Next(3)).velocity *= 0.5f;
      }
    }

    public static bool IsTileALeafyTreeTop(int i, int j)
    {
      Tile tileSafely = Framing.GetTileSafely(i, j);
      return tileSafely.active() && TileID.Sets.GetsCheckedForLeaves[(int) tileSafely.type] && (tileSafely.type == (ushort) 323 && tileSafely.frameX >= (short) 88 || tileSafely.frameX == (short) 22 && tileSafely.frameY >= (short) 198 && tileSafely.frameY <= (short) 242);
    }

    public static bool IsTileTypeFitForTree(ushort type)
    {
      switch (type)
      {
        case 2:
        case 23:
        case 60:
        case 70:
        case 109:
        case 147:
        case 199:
        case 477:
        case 492:
        case 633:
        case 661:
        case 662:
          return true;
        default:
          return false;
      }
    }

    public static bool GrowTree(int i, int y)
    {
      int index1 = y;
      while (Main.tile[i, index1].type == (ushort) 20)
        ++index1;
      if ((Main.tile[i - 1, index1 - 1].liquid != (byte) 0 || Main.tile[i, index1 - 1].liquid != (byte) 0 || Main.tile[i + 1, index1 - 1].liquid != (byte) 0) && !WorldGen.notTheBees || !Main.tile[i, index1].nactive() || Main.tile[i, index1].halfBrick() || Main.tile[i, index1].slope() != (byte) 0 || !WorldGen.IsTileTypeFitForTree(Main.tile[i, index1].type) || (!Main.remixWorld || (double) index1 <= Main.worldSurface) && Main.tile[i, index1 - 1].wall != (ushort) 0 && !WorldGen.DefaultTreeWallTest((int) Main.tile[i, index1 - 1].wall) || (!Main.tile[i - 1, index1].active() || !WorldGen.IsTileTypeFitForTree(Main.tile[i - 1, index1].type)) && (!Main.tile[i + 1, index1].active() || !WorldGen.IsTileTypeFitForTree(Main.tile[i + 1, index1].type)))
        return false;
      TileColorCache cache = Main.tile[i, index1].BlockColorAndCoating();
      if (Main.tenthAnniversaryWorld && !WorldGen.gen)
        cache.Color = (byte) WorldGen.genRand.Next(1, 13);
      int num1 = 2;
      int ySize = WorldGen.genRand.Next(5, 17);
      int num2 = ySize + 4;
      if (Main.tile[i, index1].type == (ushort) 60)
        num2 += 5;
      bool flag1 = false;
      if (Main.tile[i, index1].type == (ushort) 70 && WorldGen.EmptyTileCheck(i - num1, i + num1, index1 - num2, index1 - 3, 20) && WorldGen.EmptyTileCheck(i - 1, i + 1, index1 - 2, index1 - 1, 20))
        flag1 = true;
      if (WorldGen.EmptyTileCheck(i - num1, i + num1, index1 - num2, index1 - 1, 20))
        flag1 = true;
      if (!flag1)
        return false;
      bool flag2 = Main.remixWorld && (double) index1 < Main.worldSurface;
      bool flag3 = false;
      bool flag4 = false;
      for (int index2 = index1 - ySize; index2 < index1; ++index2)
      {
        Main.tile[i, index2].frameNumber((byte) WorldGen.genRand.Next(3));
        Main.tile[i, index2].active(true);
        Main.tile[i, index2].type = (ushort) 5;
        Main.tile[i, index2].UseBlockColors(cache);
        int num3 = WorldGen.genRand.Next(3);
        int num4 = WorldGen.genRand.Next(10);
        if (index2 == index1 - 1 || index2 == index1 - ySize)
          num4 = 0;
        while (((num4 == 5 ? 1 : (num4 == 7 ? 1 : 0)) & (flag3 ? 1 : 0)) != 0 || ((num4 == 6 ? 1 : (num4 == 7 ? 1 : 0)) & (flag4 ? 1 : 0)) != 0)
          num4 = WorldGen.genRand.Next(10);
        flag3 = false;
        flag4 = false;
        if (num4 == 5 || num4 == 7)
          flag3 = true;
        if (num4 == 6 || num4 == 7)
          flag4 = true;
        switch (num4)
        {
          case 1:
            if (num3 == 0)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num3 == 1)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num3 == 2)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          case 2:
            if (num3 == 0)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 0;
            }
            if (num3 == 1)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 22;
            }
            if (num3 == 2)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 44;
              break;
            }
            break;
          case 3:
            if (num3 == 0)
            {
              Main.tile[i, index2].frameX = (short) 44;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num3 == 1)
            {
              Main.tile[i, index2].frameX = (short) 44;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num3 == 2)
            {
              Main.tile[i, index2].frameX = (short) 44;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          case 4:
            if (num3 == 0)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num3 == 1)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num3 == 2)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          case 5:
            if (num3 == 0)
            {
              Main.tile[i, index2].frameX = (short) 88;
              Main.tile[i, index2].frameY = (short) 0;
            }
            if (num3 == 1)
            {
              Main.tile[i, index2].frameX = (short) 88;
              Main.tile[i, index2].frameY = (short) 22;
            }
            if (num3 == 2)
            {
              Main.tile[i, index2].frameX = (short) 88;
              Main.tile[i, index2].frameY = (short) 44;
              break;
            }
            break;
          case 6:
            if (num3 == 0)
            {
              Main.tile[i, index2].frameX = (short) 66;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num3 == 1)
            {
              Main.tile[i, index2].frameX = (short) 66;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num3 == 2)
            {
              Main.tile[i, index2].frameX = (short) 66;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          case 7:
            if (num3 == 0)
            {
              Main.tile[i, index2].frameX = (short) 110;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num3 == 1)
            {
              Main.tile[i, index2].frameX = (short) 110;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num3 == 2)
            {
              Main.tile[i, index2].frameX = (short) 110;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          default:
            if (num3 == 0)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 0;
            }
            if (num3 == 1)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 22;
            }
            if (num3 == 2)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 44;
              break;
            }
            break;
        }
        if (num4 == 5 || num4 == 7)
        {
          Main.tile[i - 1, index2].active(true);
          Main.tile[i - 1, index2].type = (ushort) 5;
          Main.tile[i - 1, index2].UseBlockColors(cache);
          int num5 = WorldGen.genRand.Next(3);
          if (WorldGen.genRand.Next(3) < 2 && !flag2)
          {
            if (num5 == 0)
            {
              Main.tile[i - 1, index2].frameX = (short) 44;
              Main.tile[i - 1, index2].frameY = (short) 198;
            }
            if (num5 == 1)
            {
              Main.tile[i - 1, index2].frameX = (short) 44;
              Main.tile[i - 1, index2].frameY = (short) 220;
            }
            if (num5 == 2)
            {
              Main.tile[i - 1, index2].frameX = (short) 44;
              Main.tile[i - 1, index2].frameY = (short) 242;
            }
          }
          else
          {
            if (num5 == 0)
            {
              Main.tile[i - 1, index2].frameX = (short) 66;
              Main.tile[i - 1, index2].frameY = (short) 0;
            }
            if (num5 == 1)
            {
              Main.tile[i - 1, index2].frameX = (short) 66;
              Main.tile[i - 1, index2].frameY = (short) 22;
            }
            if (num5 == 2)
            {
              Main.tile[i - 1, index2].frameX = (short) 66;
              Main.tile[i - 1, index2].frameY = (short) 44;
            }
          }
        }
        if (num4 == 6 || num4 == 7)
        {
          Main.tile[i + 1, index2].active(true);
          Main.tile[i + 1, index2].type = (ushort) 5;
          Main.tile[i + 1, index2].UseBlockColors(cache);
          int num6 = WorldGen.genRand.Next(3);
          if (WorldGen.genRand.Next(3) < 2 && !flag2)
          {
            if (num6 == 0)
            {
              Main.tile[i + 1, index2].frameX = (short) 66;
              Main.tile[i + 1, index2].frameY = (short) 198;
            }
            if (num6 == 1)
            {
              Main.tile[i + 1, index2].frameX = (short) 66;
              Main.tile[i + 1, index2].frameY = (short) 220;
            }
            if (num6 == 2)
            {
              Main.tile[i + 1, index2].frameX = (short) 66;
              Main.tile[i + 1, index2].frameY = (short) 242;
            }
          }
          else
          {
            if (num6 == 0)
            {
              Main.tile[i + 1, index2].frameX = (short) 88;
              Main.tile[i + 1, index2].frameY = (short) 66;
            }
            if (num6 == 1)
            {
              Main.tile[i + 1, index2].frameX = (short) 88;
              Main.tile[i + 1, index2].frameY = (short) 88;
            }
            if (num6 == 2)
            {
              Main.tile[i + 1, index2].frameX = (short) 88;
              Main.tile[i + 1, index2].frameY = (short) 110;
            }
          }
        }
      }
      int num7 = WorldGen.genRand.Next(3);
      bool flag5 = false;
      bool flag6 = false;
      if (Main.tile[i - 1, index1].nactive() && !Main.tile[i - 1, index1].halfBrick() && Main.tile[i - 1, index1].slope() == (byte) 0 && WorldGen.IsTileTypeFitForTree(Main.tile[i - 1, index1].type))
        flag5 = true;
      if (Main.tile[i + 1, index1].nactive() && !Main.tile[i + 1, index1].halfBrick() && Main.tile[i + 1, index1].slope() == (byte) 0 && WorldGen.IsTileTypeFitForTree(Main.tile[i + 1, index1].type))
        flag6 = true;
      if (!flag5)
      {
        if (num7 == 0)
          num7 = 2;
        if (num7 == 1)
          num7 = 3;
      }
      if (!flag6)
      {
        if (num7 == 0)
          num7 = 1;
        if (num7 == 2)
          num7 = 3;
      }
      if (flag5 && !flag6)
        num7 = 2;
      if (flag6 && !flag5)
        num7 = 1;
      if (num7 == 0 || num7 == 1)
      {
        Main.tile[i + 1, index1 - 1].active(true);
        Main.tile[i + 1, index1 - 1].type = (ushort) 5;
        Main.tile[i + 1, index1 - 1].UseBlockColors(cache);
        int num8 = WorldGen.genRand.Next(3);
        if (num8 == 0)
        {
          Main.tile[i + 1, index1 - 1].frameX = (short) 22;
          Main.tile[i + 1, index1 - 1].frameY = (short) 132;
        }
        if (num8 == 1)
        {
          Main.tile[i + 1, index1 - 1].frameX = (short) 22;
          Main.tile[i + 1, index1 - 1].frameY = (short) 154;
        }
        if (num8 == 2)
        {
          Main.tile[i + 1, index1 - 1].frameX = (short) 22;
          Main.tile[i + 1, index1 - 1].frameY = (short) 176;
        }
      }
      if (num7 == 0 || num7 == 2)
      {
        Main.tile[i - 1, index1 - 1].active(true);
        Main.tile[i - 1, index1 - 1].type = (ushort) 5;
        Main.tile[i - 1, index1 - 1].UseBlockColors(cache);
        int num9 = WorldGen.genRand.Next(3);
        if (num9 == 0)
        {
          Main.tile[i - 1, index1 - 1].frameX = (short) 44;
          Main.tile[i - 1, index1 - 1].frameY = (short) 132;
        }
        if (num9 == 1)
        {
          Main.tile[i - 1, index1 - 1].frameX = (short) 44;
          Main.tile[i - 1, index1 - 1].frameY = (short) 154;
        }
        if (num9 == 2)
        {
          Main.tile[i - 1, index1 - 1].frameX = (short) 44;
          Main.tile[i - 1, index1 - 1].frameY = (short) 176;
        }
      }
      int num10 = WorldGen.genRand.Next(3);
      switch (num7)
      {
        case 0:
          if (num10 == 0)
          {
            Main.tile[i, index1 - 1].frameX = (short) 88;
            Main.tile[i, index1 - 1].frameY = (short) 132;
          }
          if (num10 == 1)
          {
            Main.tile[i, index1 - 1].frameX = (short) 88;
            Main.tile[i, index1 - 1].frameY = (short) 154;
          }
          if (num10 == 2)
          {
            Main.tile[i, index1 - 1].frameX = (short) 88;
            Main.tile[i, index1 - 1].frameY = (short) 176;
            break;
          }
          break;
        case 1:
          if (num10 == 0)
          {
            Main.tile[i, index1 - 1].frameX = (short) 0;
            Main.tile[i, index1 - 1].frameY = (short) 132;
          }
          if (num10 == 1)
          {
            Main.tile[i, index1 - 1].frameX = (short) 0;
            Main.tile[i, index1 - 1].frameY = (short) 154;
          }
          if (num10 == 2)
          {
            Main.tile[i, index1 - 1].frameX = (short) 0;
            Main.tile[i, index1 - 1].frameY = (short) 176;
            break;
          }
          break;
        case 2:
          if (num10 == 0)
          {
            Main.tile[i, index1 - 1].frameX = (short) 66;
            Main.tile[i, index1 - 1].frameY = (short) 132;
          }
          if (num10 == 1)
          {
            Main.tile[i, index1 - 1].frameX = (short) 66;
            Main.tile[i, index1 - 1].frameY = (short) 154;
          }
          if (num10 == 2)
          {
            Main.tile[i, index1 - 1].frameX = (short) 66;
            Main.tile[i, index1 - 1].frameY = (short) 176;
            break;
          }
          break;
      }
      if (WorldGen.genRand.Next(13) != 0 && !flag2)
      {
        int num11 = WorldGen.genRand.Next(3);
        if (num11 == 0)
        {
          Main.tile[i, index1 - ySize].frameX = (short) 22;
          Main.tile[i, index1 - ySize].frameY = (short) 198;
        }
        if (num11 == 1)
        {
          Main.tile[i, index1 - ySize].frameX = (short) 22;
          Main.tile[i, index1 - ySize].frameY = (short) 220;
        }
        if (num11 == 2)
        {
          Main.tile[i, index1 - ySize].frameX = (short) 22;
          Main.tile[i, index1 - ySize].frameY = (short) 242;
        }
      }
      else
      {
        int num12 = WorldGen.genRand.Next(3);
        if (num12 == 0)
        {
          Main.tile[i, index1 - ySize].frameX = (short) 0;
          Main.tile[i, index1 - ySize].frameY = (short) 198;
        }
        if (num12 == 1)
        {
          Main.tile[i, index1 - ySize].frameX = (short) 0;
          Main.tile[i, index1 - ySize].frameY = (short) 220;
        }
        if (num12 == 2)
        {
          Main.tile[i, index1 - ySize].frameX = (short) 0;
          Main.tile[i, index1 - ySize].frameY = (short) 242;
        }
      }
      WorldGen.RangeFrame(i - 2, index1 - ySize - 1, i + 2, index1 + 1);
      if (Main.netMode == 2)
        NetMessage.SendTileSquare(-1, i - 1, index1 - ySize, 3, ySize);
      return true;
    }

    public static bool DefaultTreeWallTest(int wallType) => wallType >= 0 && wallType < (int) WallID.Count && WallID.Sets.AllowsPlantsToGrow[wallType];

    public static bool GemTreeWallTest(int wallType)
    {
      if (WorldGen.DefaultTreeWallTest(wallType))
        return true;
      switch (wallType)
      {
        case 2:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 61:
        case 185:
        case 196:
        case 197:
        case 198:
        case 199:
        case 208:
        case 209:
        case 210:
        case 211:
        case 212:
        case 213:
        case 214:
        case 215:
          return true;
        default:
          return false;
      }
    }

    public static bool GemTreeGroundTest(int tileType) => tileType >= 0 && (TileID.Sets.Conversion.Stone[tileType] || TileID.Sets.Conversion.Moss[tileType]);

    public static bool VanityTreeGroundTest(int tileType) => tileType >= 0 && TileID.Sets.Conversion.Grass[tileType];

    public static bool AshTreeGroundTest(int tileType) => tileType >= 0 && tileType == 633;

    public static bool TryGrowingTreeByType(int treeTileType, int checkedX, int checkedY)
    {
      bool flag = false;
      switch (treeTileType)
      {
        case 5:
          flag = WorldGen.GrowTree(checkedX, checkedY);
          break;
        case 583:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.GemTree_Topaz);
          break;
        case 584:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.GemTree_Amethyst);
          break;
        case 585:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.GemTree_Sappphire);
          break;
        case 586:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.GemTree_Emerald);
          break;
        case 587:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.GemTree_Ruby);
          break;
        case 588:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.GemTree_Diamond);
          break;
        case 589:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.GemTree_Amber);
          break;
        case 596:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.VanityTree_Sakura);
          break;
        case 616:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.VanityTree_Willow);
          break;
        case 634:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.Tree_Ash);
          break;
      }
      return flag;
    }

    public static bool GrowTreeWithSettings(
      int checkedX,
      int checkedY,
      WorldGen.GrowTreeSettings settings)
    {
      int index1 = checkedY;
      while ((int) Main.tile[checkedX, index1].type == (int) settings.SaplingTileType)
        ++index1;
      if (Main.tile[checkedX - 1, index1 - 1].liquid != (byte) 0 || Main.tile[checkedX, index1 - 1].liquid != (byte) 0 || Main.tile[checkedX + 1, index1 - 1].liquid != (byte) 0)
        return false;
      Tile tile1 = Main.tile[checkedX, index1];
      if ((!tile1.nactive() || tile1.halfBrick() ? 0 : (tile1.slope() == (byte) 0 ? 1 : 0)) == 0)
        return false;
      bool flag1 = settings.WallTest((int) Main.tile[checkedX, index1 - 1].wall);
      if (!settings.GroundTest((int) tile1.type) || !flag1 || (!Main.tile[checkedX - 1, index1].active() || !settings.GroundTest((int) Main.tile[checkedX - 1, index1].type) ? (!Main.tile[checkedX + 1, index1].active() ? 0 : (settings.GroundTest((int) Main.tile[checkedX + 1, index1].type) ? 1 : 0)) : 1) == 0)
        return false;
      TileColorCache cache = Main.tile[checkedX, index1].BlockColorAndCoating();
      if (Main.tenthAnniversaryWorld && !WorldGen.gen && (settings.TreeTileType == (ushort) 596 || settings.TreeTileType == (ushort) 616))
        cache.Color = (byte) WorldGen.genRand.Next(1, 13);
      int num1 = 2;
      int ySize = WorldGen.genRand.Next(settings.TreeHeightMin, settings.TreeHeightMax + 1);
      int num2 = ySize + settings.TreeTopPaddingNeeded;
      if (!WorldGen.EmptyTileCheck(checkedX - num1, checkedX + num1, index1 - num2, index1 - 1, 20))
        return false;
      bool flag2 = false;
      bool flag3 = false;
      for (int index2 = index1 - ySize; index2 < index1; ++index2)
      {
        Tile tile2 = Main.tile[checkedX, index2];
        tile2.frameNumber((byte) WorldGen.genRand.Next(3));
        tile2.active(true);
        tile2.type = settings.TreeTileType;
        tile2.UseBlockColors(cache);
        int num3 = WorldGen.genRand.Next(3);
        int num4 = WorldGen.genRand.Next(10);
        if (index2 == index1 - 1 || index2 == index1 - ySize)
          num4 = 0;
        while (((num4 == 5 ? 1 : (num4 == 7 ? 1 : 0)) & (flag2 ? 1 : 0)) != 0 || ((num4 == 6 ? 1 : (num4 == 7 ? 1 : 0)) & (flag3 ? 1 : 0)) != 0)
          num4 = WorldGen.genRand.Next(10);
        flag2 = false;
        flag3 = false;
        if (num4 == 5 || num4 == 7)
          flag2 = true;
        if (num4 == 6 || num4 == 7)
          flag3 = true;
        switch (num4)
        {
          case 1:
            if (num3 == 0)
            {
              tile2.frameX = (short) 0;
              tile2.frameY = (short) 66;
            }
            if (num3 == 1)
            {
              tile2.frameX = (short) 0;
              tile2.frameY = (short) 88;
            }
            if (num3 == 2)
            {
              tile2.frameX = (short) 0;
              tile2.frameY = (short) 110;
              break;
            }
            break;
          case 2:
            if (num3 == 0)
            {
              tile2.frameX = (short) 22;
              tile2.frameY = (short) 0;
            }
            if (num3 == 1)
            {
              tile2.frameX = (short) 22;
              tile2.frameY = (short) 22;
            }
            if (num3 == 2)
            {
              tile2.frameX = (short) 22;
              tile2.frameY = (short) 44;
              break;
            }
            break;
          case 3:
            if (num3 == 0)
            {
              tile2.frameX = (short) 44;
              tile2.frameY = (short) 66;
            }
            if (num3 == 1)
            {
              tile2.frameX = (short) 44;
              tile2.frameY = (short) 88;
            }
            if (num3 == 2)
            {
              tile2.frameX = (short) 44;
              tile2.frameY = (short) 110;
              break;
            }
            break;
          case 4:
            if (num3 == 0)
            {
              tile2.frameX = (short) 22;
              tile2.frameY = (short) 66;
            }
            if (num3 == 1)
            {
              tile2.frameX = (short) 22;
              tile2.frameY = (short) 88;
            }
            if (num3 == 2)
            {
              tile2.frameX = (short) 22;
              tile2.frameY = (short) 110;
              break;
            }
            break;
          case 5:
            if (num3 == 0)
            {
              tile2.frameX = (short) 88;
              tile2.frameY = (short) 0;
            }
            if (num3 == 1)
            {
              tile2.frameX = (short) 88;
              tile2.frameY = (short) 22;
            }
            if (num3 == 2)
            {
              tile2.frameX = (short) 88;
              tile2.frameY = (short) 44;
              break;
            }
            break;
          case 6:
            if (num3 == 0)
            {
              tile2.frameX = (short) 66;
              tile2.frameY = (short) 66;
            }
            if (num3 == 1)
            {
              tile2.frameX = (short) 66;
              tile2.frameY = (short) 88;
            }
            if (num3 == 2)
            {
              tile2.frameX = (short) 66;
              tile2.frameY = (short) 110;
              break;
            }
            break;
          case 7:
            if (num3 == 0)
            {
              tile2.frameX = (short) 110;
              tile2.frameY = (short) 66;
            }
            if (num3 == 1)
            {
              tile2.frameX = (short) 110;
              tile2.frameY = (short) 88;
            }
            if (num3 == 2)
            {
              tile2.frameX = (short) 110;
              tile2.frameY = (short) 110;
              break;
            }
            break;
          default:
            if (num3 == 0)
            {
              tile2.frameX = (short) 0;
              tile2.frameY = (short) 0;
            }
            if (num3 == 1)
            {
              tile2.frameX = (short) 0;
              tile2.frameY = (short) 22;
            }
            if (num3 == 2)
            {
              tile2.frameX = (short) 0;
              tile2.frameY = (short) 44;
              break;
            }
            break;
        }
        if (num4 == 5 || num4 == 7)
        {
          Tile tile3 = Main.tile[checkedX - 1, index2];
          tile3.active(true);
          tile3.type = settings.TreeTileType;
          tile3.UseBlockColors(cache);
          int num5 = WorldGen.genRand.Next(3);
          if (WorldGen.genRand.Next(3) < 2)
          {
            if (num5 == 0)
            {
              tile3.frameX = (short) 44;
              tile3.frameY = (short) 198;
            }
            if (num5 == 1)
            {
              tile3.frameX = (short) 44;
              tile3.frameY = (short) 220;
            }
            if (num5 == 2)
            {
              tile3.frameX = (short) 44;
              tile3.frameY = (short) 242;
            }
          }
          else
          {
            if (num5 == 0)
            {
              tile3.frameX = (short) 66;
              tile3.frameY = (short) 0;
            }
            if (num5 == 1)
            {
              tile3.frameX = (short) 66;
              tile3.frameY = (short) 22;
            }
            if (num5 == 2)
            {
              tile3.frameX = (short) 66;
              tile3.frameY = (short) 44;
            }
          }
        }
        if (num4 == 6 || num4 == 7)
        {
          Tile tile4 = Main.tile[checkedX + 1, index2];
          tile4.active(true);
          tile4.type = settings.TreeTileType;
          tile4.UseBlockColors(cache);
          int num6 = WorldGen.genRand.Next(3);
          if (WorldGen.genRand.Next(3) < 2)
          {
            if (num6 == 0)
            {
              tile4.frameX = (short) 66;
              tile4.frameY = (short) 198;
            }
            if (num6 == 1)
            {
              tile4.frameX = (short) 66;
              tile4.frameY = (short) 220;
            }
            if (num6 == 2)
            {
              tile4.frameX = (short) 66;
              tile4.frameY = (short) 242;
            }
          }
          else
          {
            if (num6 == 0)
            {
              tile4.frameX = (short) 88;
              tile4.frameY = (short) 66;
            }
            if (num6 == 1)
            {
              tile4.frameX = (short) 88;
              tile4.frameY = (short) 88;
            }
            if (num6 == 2)
            {
              tile4.frameX = (short) 88;
              tile4.frameY = (short) 110;
            }
          }
        }
      }
      bool flag4 = false;
      bool flag5 = false;
      if (Main.tile[checkedX - 1, index1].nactive() && !Main.tile[checkedX - 1, index1].halfBrick() && Main.tile[checkedX - 1, index1].slope() == (byte) 0 && WorldGen.IsTileTypeFitForTree(Main.tile[checkedX - 1, index1].type))
        flag4 = true;
      if (Main.tile[checkedX + 1, index1].nactive() && !Main.tile[checkedX + 1, index1].halfBrick() && Main.tile[checkedX + 1, index1].slope() == (byte) 0 && WorldGen.IsTileTypeFitForTree(Main.tile[checkedX + 1, index1].type))
        flag5 = true;
      if (WorldGen.genRand.Next(3) == 0)
        flag4 = false;
      if (WorldGen.genRand.Next(3) == 0)
        flag5 = false;
      if (flag5)
      {
        Main.tile[checkedX + 1, index1 - 1].active(true);
        Main.tile[checkedX + 1, index1 - 1].type = settings.TreeTileType;
        Main.tile[checkedX + 1, index1 - 1].UseBlockColors(cache);
        int num7 = WorldGen.genRand.Next(3);
        if (num7 == 0)
        {
          Main.tile[checkedX + 1, index1 - 1].frameX = (short) 22;
          Main.tile[checkedX + 1, index1 - 1].frameY = (short) 132;
        }
        if (num7 == 1)
        {
          Main.tile[checkedX + 1, index1 - 1].frameX = (short) 22;
          Main.tile[checkedX + 1, index1 - 1].frameY = (short) 154;
        }
        if (num7 == 2)
        {
          Main.tile[checkedX + 1, index1 - 1].frameX = (short) 22;
          Main.tile[checkedX + 1, index1 - 1].frameY = (short) 176;
        }
      }
      if (flag4)
      {
        Main.tile[checkedX - 1, index1 - 1].active(true);
        Main.tile[checkedX - 1, index1 - 1].type = settings.TreeTileType;
        Main.tile[checkedX - 1, index1 - 1].UseBlockColors(cache);
        int num8 = WorldGen.genRand.Next(3);
        if (num8 == 0)
        {
          Main.tile[checkedX - 1, index1 - 1].frameX = (short) 44;
          Main.tile[checkedX - 1, index1 - 1].frameY = (short) 132;
        }
        if (num8 == 1)
        {
          Main.tile[checkedX - 1, index1 - 1].frameX = (short) 44;
          Main.tile[checkedX - 1, index1 - 1].frameY = (short) 154;
        }
        if (num8 == 2)
        {
          Main.tile[checkedX - 1, index1 - 1].frameX = (short) 44;
          Main.tile[checkedX - 1, index1 - 1].frameY = (short) 176;
        }
      }
      int num9 = WorldGen.genRand.Next(3);
      if (flag4 & flag5)
      {
        if (num9 == 0)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 88;
          Main.tile[checkedX, index1 - 1].frameY = (short) 132;
        }
        if (num9 == 1)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 88;
          Main.tile[checkedX, index1 - 1].frameY = (short) 154;
        }
        if (num9 == 2)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 88;
          Main.tile[checkedX, index1 - 1].frameY = (short) 176;
        }
      }
      else if (flag4)
      {
        if (num9 == 0)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 0;
          Main.tile[checkedX, index1 - 1].frameY = (short) 132;
        }
        if (num9 == 1)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 0;
          Main.tile[checkedX, index1 - 1].frameY = (short) 154;
        }
        if (num9 == 2)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 0;
          Main.tile[checkedX, index1 - 1].frameY = (short) 176;
        }
      }
      else if (flag5)
      {
        if (num9 == 0)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 66;
          Main.tile[checkedX, index1 - 1].frameY = (short) 132;
        }
        if (num9 == 1)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 66;
          Main.tile[checkedX, index1 - 1].frameY = (short) 154;
        }
        if (num9 == 2)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 66;
          Main.tile[checkedX, index1 - 1].frameY = (short) 176;
        }
      }
      if (WorldGen.genRand.Next(13) != 0)
      {
        int num10 = WorldGen.genRand.Next(3);
        if (num10 == 0)
        {
          Main.tile[checkedX, index1 - ySize].frameX = (short) 22;
          Main.tile[checkedX, index1 - ySize].frameY = (short) 198;
        }
        if (num10 == 1)
        {
          Main.tile[checkedX, index1 - ySize].frameX = (short) 22;
          Main.tile[checkedX, index1 - ySize].frameY = (short) 220;
        }
        if (num10 == 2)
        {
          Main.tile[checkedX, index1 - ySize].frameX = (short) 22;
          Main.tile[checkedX, index1 - ySize].frameY = (short) 242;
        }
      }
      else
      {
        int num11 = WorldGen.genRand.Next(3);
        if (num11 == 0)
        {
          Main.tile[checkedX, index1 - ySize].frameX = (short) 0;
          Main.tile[checkedX, index1 - ySize].frameY = (short) 198;
        }
        if (num11 == 1)
        {
          Main.tile[checkedX, index1 - ySize].frameX = (short) 0;
          Main.tile[checkedX, index1 - ySize].frameY = (short) 220;
        }
        if (num11 == 2)
        {
          Main.tile[checkedX, index1 - ySize].frameX = (short) 0;
          Main.tile[checkedX, index1 - ySize].frameY = (short) 242;
        }
      }
      WorldGen.RangeFrame(checkedX - 2, index1 - ySize - 1, checkedX + 2, index1 + 1);
      if (Main.netMode == 2)
        NetMessage.SendTileSquare(-1, checkedX - 1, index1 - ySize, 3, ySize);
      return true;
    }

    public static void GrowUndergroundTree(int i, int y)
    {
      int index1 = y;
      if (Main.tile[i, index1].type != (ushort) 60 || !Main.tile[i, index1].nactive() || Main.tile[i, index1].halfBrick() || Main.tile[i, index1].slope() != (byte) 0 || Main.tile[i, index1].type != (ushort) 60 || (!Main.tile[i - 1, index1].active() || Main.tile[i - 1, index1].type != (ushort) 60) && (!Main.tile[i + 1, index1].active() || Main.tile[i + 1, index1].type != (ushort) 60))
        return;
      int num1 = 1;
      int ySize = WorldGen.genRand.Next(5, 15);
      int num2 = ySize + 2;
      if (Main.tile[i, index1].type == (ushort) 60)
        num2 += 5;
      if (!WorldGen.EmptyTileCheck(i - num1, i + num1, index1 - num2, index1 - 1, 20))
        return;
      bool flag1 = false;
      bool flag2 = false;
      for (int index2 = index1 - ySize; index2 < index1; ++index2)
      {
        Main.tile[i, index2].frameNumber((byte) WorldGen.genRand.Next(3));
        Main.tile[i, index2].active(true);
        Main.tile[i, index2].type = (ushort) 5;
        int num3 = WorldGen.genRand.Next(3);
        int num4 = WorldGen.genRand.Next(10);
        if (index2 == index1 - 1 || index2 == index1 - ySize)
          num4 = 0;
        while (((num4 == 5 ? 1 : (num4 == 7 ? 1 : 0)) & (flag1 ? 1 : 0)) != 0 || ((num4 == 6 ? 1 : (num4 == 7 ? 1 : 0)) & (flag2 ? 1 : 0)) != 0)
          num4 = WorldGen.genRand.Next(10);
        flag1 = false;
        flag2 = false;
        if (num4 == 5 || num4 == 7)
          flag1 = true;
        if (num4 == 6 || num4 == 7)
          flag2 = true;
        switch (num4)
        {
          case 1:
            if (num3 == 0)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num3 == 1)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num3 == 2)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          case 2:
            if (num3 == 0)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 0;
            }
            if (num3 == 1)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 22;
            }
            if (num3 == 2)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 44;
              break;
            }
            break;
          case 3:
            if (num3 == 0)
            {
              Main.tile[i, index2].frameX = (short) 44;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num3 == 1)
            {
              Main.tile[i, index2].frameX = (short) 44;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num3 == 2)
            {
              Main.tile[i, index2].frameX = (short) 44;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          case 4:
            if (num3 == 0)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num3 == 1)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num3 == 2)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          case 5:
            if (num3 == 0)
            {
              Main.tile[i, index2].frameX = (short) 88;
              Main.tile[i, index2].frameY = (short) 0;
            }
            if (num3 == 1)
            {
              Main.tile[i, index2].frameX = (short) 88;
              Main.tile[i, index2].frameY = (short) 22;
            }
            if (num3 == 2)
            {
              Main.tile[i, index2].frameX = (short) 88;
              Main.tile[i, index2].frameY = (short) 44;
              break;
            }
            break;
          case 6:
            if (num3 == 0)
            {
              Main.tile[i, index2].frameX = (short) 66;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num3 == 1)
            {
              Main.tile[i, index2].frameX = (short) 66;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num3 == 2)
            {
              Main.tile[i, index2].frameX = (short) 66;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          case 7:
            if (num3 == 0)
            {
              Main.tile[i, index2].frameX = (short) 110;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num3 == 1)
            {
              Main.tile[i, index2].frameX = (short) 110;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num3 == 2)
            {
              Main.tile[i, index2].frameX = (short) 110;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          default:
            if (num3 == 0)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 0;
            }
            if (num3 == 1)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 22;
            }
            if (num3 == 2)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 44;
              break;
            }
            break;
        }
        if (num4 == 5 || num4 == 7)
        {
          Main.tile[i - 1, index2].active(true);
          Main.tile[i - 1, index2].type = (ushort) 5;
          int num5 = WorldGen.genRand.Next(3);
          if (WorldGen.genRand.Next(3) < 2)
          {
            if (num5 == 0)
            {
              Main.tile[i - 1, index2].frameX = (short) 44;
              Main.tile[i - 1, index2].frameY = (short) 198;
            }
            if (num5 == 1)
            {
              Main.tile[i - 1, index2].frameX = (short) 44;
              Main.tile[i - 1, index2].frameY = (short) 220;
            }
            if (num5 == 2)
            {
              Main.tile[i - 1, index2].frameX = (short) 44;
              Main.tile[i - 1, index2].frameY = (short) 242;
            }
          }
          else
          {
            if (num5 == 0)
            {
              Main.tile[i - 1, index2].frameX = (short) 66;
              Main.tile[i - 1, index2].frameY = (short) 0;
            }
            if (num5 == 1)
            {
              Main.tile[i - 1, index2].frameX = (short) 66;
              Main.tile[i - 1, index2].frameY = (short) 22;
            }
            if (num5 == 2)
            {
              Main.tile[i - 1, index2].frameX = (short) 66;
              Main.tile[i - 1, index2].frameY = (short) 44;
            }
          }
        }
        if (num4 == 6 || num4 == 7)
        {
          Main.tile[i + 1, index2].active(true);
          Main.tile[i + 1, index2].type = (ushort) 5;
          int num6 = WorldGen.genRand.Next(3);
          if (WorldGen.genRand.Next(3) < 2)
          {
            if (num6 == 0)
            {
              Main.tile[i + 1, index2].frameX = (short) 66;
              Main.tile[i + 1, index2].frameY = (short) 198;
            }
            if (num6 == 1)
            {
              Main.tile[i + 1, index2].frameX = (short) 66;
              Main.tile[i + 1, index2].frameY = (short) 220;
            }
            if (num6 == 2)
            {
              Main.tile[i + 1, index2].frameX = (short) 66;
              Main.tile[i + 1, index2].frameY = (short) 242;
            }
          }
          else
          {
            if (num6 == 0)
            {
              Main.tile[i + 1, index2].frameX = (short) 88;
              Main.tile[i + 1, index2].frameY = (short) 66;
            }
            if (num6 == 1)
            {
              Main.tile[i + 1, index2].frameX = (short) 88;
              Main.tile[i + 1, index2].frameY = (short) 88;
            }
            if (num6 == 2)
            {
              Main.tile[i + 1, index2].frameX = (short) 88;
              Main.tile[i + 1, index2].frameY = (short) 110;
            }
          }
        }
      }
      int num7 = WorldGen.genRand.Next(3);
      bool flag3 = false;
      bool flag4 = false;
      if (Main.tile[i - 1, index1].nactive() && !Main.tile[i - 1, index1].halfBrick() && Main.tile[i - 1, index1].slope() == (byte) 0 && (Main.tile[i - 1, index1].type == (ushort) 2 || Main.tile[i - 1, index1].type == (ushort) 23 || Main.tile[i - 1, index1].type == (ushort) 60 || Main.tile[i - 1, index1].type == (ushort) 109 || Main.tile[i - 1, index1].type == (ushort) 147))
        flag3 = true;
      if (Main.tile[i + 1, index1].nactive() && !Main.tile[i + 1, index1].halfBrick() && Main.tile[i + 1, index1].slope() == (byte) 0 && (Main.tile[i + 1, index1].type == (ushort) 2 || Main.tile[i + 1, index1].type == (ushort) 23 || Main.tile[i + 1, index1].type == (ushort) 60 || Main.tile[i + 1, index1].type == (ushort) 109 || Main.tile[i + 1, index1].type == (ushort) 147))
        flag4 = true;
      if (!flag3)
      {
        if (num7 == 0)
          num7 = 2;
        if (num7 == 1)
          num7 = 3;
      }
      if (!flag4)
      {
        if (num7 == 0)
          num7 = 1;
        if (num7 == 2)
          num7 = 3;
      }
      if (flag3 && !flag4)
        num7 = 2;
      if (flag4 && !flag3)
        num7 = 1;
      if (num7 == 0 || num7 == 1)
      {
        Main.tile[i + 1, index1 - 1].active(true);
        Main.tile[i + 1, index1 - 1].type = (ushort) 5;
        int num8 = WorldGen.genRand.Next(3);
        if (num8 == 0)
        {
          Main.tile[i + 1, index1 - 1].frameX = (short) 22;
          Main.tile[i + 1, index1 - 1].frameY = (short) 132;
        }
        if (num8 == 1)
        {
          Main.tile[i + 1, index1 - 1].frameX = (short) 22;
          Main.tile[i + 1, index1 - 1].frameY = (short) 154;
        }
        if (num8 == 2)
        {
          Main.tile[i + 1, index1 - 1].frameX = (short) 22;
          Main.tile[i + 1, index1 - 1].frameY = (short) 176;
        }
      }
      if (num7 == 0 || num7 == 2)
      {
        Main.tile[i - 1, index1 - 1].active(true);
        Main.tile[i - 1, index1 - 1].type = (ushort) 5;
        int num9 = WorldGen.genRand.Next(3);
        if (num9 == 0)
        {
          Main.tile[i - 1, index1 - 1].frameX = (short) 44;
          Main.tile[i - 1, index1 - 1].frameY = (short) 132;
        }
        if (num9 == 1)
        {
          Main.tile[i - 1, index1 - 1].frameX = (short) 44;
          Main.tile[i - 1, index1 - 1].frameY = (short) 154;
        }
        if (num9 == 2)
        {
          Main.tile[i - 1, index1 - 1].frameX = (short) 44;
          Main.tile[i - 1, index1 - 1].frameY = (short) 176;
        }
      }
      int num10 = WorldGen.genRand.Next(3);
      switch (num7)
      {
        case 0:
          if (num10 == 0)
          {
            Main.tile[i, index1 - 1].frameX = (short) 88;
            Main.tile[i, index1 - 1].frameY = (short) 132;
          }
          if (num10 == 1)
          {
            Main.tile[i, index1 - 1].frameX = (short) 88;
            Main.tile[i, index1 - 1].frameY = (short) 154;
          }
          if (num10 == 2)
          {
            Main.tile[i, index1 - 1].frameX = (short) 88;
            Main.tile[i, index1 - 1].frameY = (short) 176;
            break;
          }
          break;
        case 1:
          if (num10 == 0)
          {
            Main.tile[i, index1 - 1].frameX = (short) 0;
            Main.tile[i, index1 - 1].frameY = (short) 132;
          }
          if (num10 == 1)
          {
            Main.tile[i, index1 - 1].frameX = (short) 0;
            Main.tile[i, index1 - 1].frameY = (short) 154;
          }
          if (num10 == 2)
          {
            Main.tile[i, index1 - 1].frameX = (short) 0;
            Main.tile[i, index1 - 1].frameY = (short) 176;
            break;
          }
          break;
        case 2:
          if (num10 == 0)
          {
            Main.tile[i, index1 - 1].frameX = (short) 66;
            Main.tile[i, index1 - 1].frameY = (short) 132;
          }
          if (num10 == 1)
          {
            Main.tile[i, index1 - 1].frameX = (short) 66;
            Main.tile[i, index1 - 1].frameY = (short) 154;
          }
          if (num10 == 2)
          {
            Main.tile[i, index1 - 1].frameX = (short) 66;
            Main.tile[i, index1 - 1].frameY = (short) 176;
            break;
          }
          break;
      }
      if (WorldGen.genRand.Next(8) != 0)
      {
        int num11 = WorldGen.genRand.Next(3);
        if (num11 == 0)
        {
          Main.tile[i, index1 - ySize].frameX = (short) 22;
          Main.tile[i, index1 - ySize].frameY = (short) 198;
        }
        if (num11 == 1)
        {
          Main.tile[i, index1 - ySize].frameX = (short) 22;
          Main.tile[i, index1 - ySize].frameY = (short) 220;
        }
        if (num11 == 2)
        {
          Main.tile[i, index1 - ySize].frameX = (short) 22;
          Main.tile[i, index1 - ySize].frameY = (short) 242;
        }
      }
      else
      {
        int num12 = WorldGen.genRand.Next(3);
        if (num12 == 0)
        {
          Main.tile[i, index1 - ySize].frameX = (short) 0;
          Main.tile[i, index1 - ySize].frameY = (short) 198;
        }
        if (num12 == 1)
        {
          Main.tile[i, index1 - ySize].frameX = (short) 0;
          Main.tile[i, index1 - ySize].frameY = (short) 220;
        }
        if (num12 == 2)
        {
          Main.tile[i, index1 - ySize].frameX = (short) 0;
          Main.tile[i, index1 - ySize].frameY = (short) 242;
        }
      }
      WorldGen.RangeFrame(i - 2, index1 - ySize - 1, i + 2, index1 + 1);
      if (Main.netMode != 2 || WorldGen.gen)
        return;
      NetMessage.SendTileSquare(-1, i - 1, index1 - ySize, 3, ySize);
    }

    public static bool GrowShroom(int i, int y)
    {
      int index1 = y;
      if (Main.tile[i - 1, index1 - 1].lava() || Main.tile[i - 1, index1 - 1].lava() || Main.tile[i + 1, index1 - 1].lava() || !Main.tile[i, index1].nactive() || Main.tile[i, index1].type != (ushort) 70 || Main.tile[i, index1 - 1].wall != (ushort) 0 || !Main.tile[i - 1, index1].active() || Main.tile[i - 1, index1].type != (ushort) 70 || !Main.tile[i + 1, index1].active() || Main.tile[i + 1, index1].type != (ushort) 70 || !WorldGen.EmptyTileCheck(i - 2, i + 2, index1 - 13, index1 - 3, 71) || !WorldGen.EmptyTileCheck(i - 1, i + 1, index1 - 3, index1 - 1, 71))
        return false;
      if (WorldGen.gen && WorldGen.genRand.Next(3) != 0)
      {
        Main.tile[i, index1].halfBrick(false);
        Main.tile[i, index1].slope((byte) 0);
      }
      if (Main.tile[i, index1].halfBrick() || Main.tile[i, index1].slope() != (byte) 0)
        return false;
      int ySize = WorldGen.genRand.Next(4, 11);
      for (int index2 = index1 - ySize; index2 < index1; ++index2)
      {
        Main.tile[i, index2].frameNumber((byte) WorldGen.genRand.Next(3));
        Main.tile[i, index2].active(true);
        Main.tile[i, index2].type = (ushort) 72;
        int num = WorldGen.genRand.Next(3);
        if (num == 0)
        {
          Main.tile[i, index2].frameX = (short) 0;
          Main.tile[i, index2].frameY = (short) 0;
        }
        if (num == 1)
        {
          Main.tile[i, index2].frameX = (short) 0;
          Main.tile[i, index2].frameY = (short) 18;
        }
        if (num == 2)
        {
          Main.tile[i, index2].frameX = (short) 0;
          Main.tile[i, index2].frameY = (short) 36;
        }
      }
      int num1 = WorldGen.genRand.Next(3);
      if (num1 == 0)
      {
        Main.tile[i, index1 - ySize].frameX = (short) 36;
        Main.tile[i, index1 - ySize].frameY = (short) 0;
      }
      if (num1 == 1)
      {
        Main.tile[i, index1 - ySize].frameX = (short) 36;
        Main.tile[i, index1 - ySize].frameY = (short) 18;
      }
      if (num1 == 2)
      {
        Main.tile[i, index1 - ySize].frameX = (short) 36;
        Main.tile[i, index1 - ySize].frameY = (short) 36;
      }
      WorldGen.RangeFrame(i - 2, index1 - ySize - 1, i + 2, index1 + 1);
      if (Main.netMode == 2)
        NetMessage.SendTileSquare(-1, i - 1, index1 - ySize, 3, ySize);
      return true;
    }

    public static void AddTrees(bool undergroundOnly = false)
    {
      double num1 = 0.1 + WorldGen.genRand.NextDouble() * 0.35;
      double num2 = 0.1 + WorldGen.genRand.NextDouble() * 0.35;
      int num3 = 20;
      int worldSurface1 = (int) Main.worldSurface;
      if (!undergroundOnly)
      {
        for (int index1 = 1; index1 < Main.maxTilesX - 1; ++index1)
        {
          for (int index2 = num3; index2 < worldSurface1; ++index2)
          {
            if (index1 < 380)
            {
              if (WorldGen.genRand.NextDouble() < num1 && Main.tile[index1, index2].liquid == (byte) 0)
                WorldGen.GrowPalmTree(index1, index2);
            }
            else if (index1 > Main.maxTilesX - 380 && WorldGen.genRand.NextDouble() < num2 && Main.tile[index1, index2].liquid == (byte) 0)
              WorldGen.GrowPalmTree(index1, index2);
            int maxValue = 20;
            if (WorldGen.drunkWorldGen)
              maxValue /= 3;
            if (WorldGen.remixWorldGen)
              maxValue /= 2;
            if (Main.tile[index1, index2].type == (ushort) 2 && (Main.tenthAnniversaryWorld || WorldGen.genRand.Next(maxValue) == 0))
            {
              if (WorldGen.genRand.Next(2) == 0)
                WorldGen.GrowTreeWithSettings(index1, index2, WorldGen.GrowTreeSettings.Profiles.VanityTree_Willow);
              else
                WorldGen.GrowTreeWithSettings(index1, index2, WorldGen.GrowTreeSettings.Profiles.VanityTree_Sakura);
            }
            else
              WorldGen.GrowTree(index1, index2);
          }
          if (WorldGen.genRand.Next(3) == 0)
            ++index1;
          if (WorldGen.genRand.Next(4) == 0)
            ++index1;
        }
      }
      if (!WorldGen.remixWorldGen)
        return;
      int worldSurface2 = (int) Main.worldSurface;
      int num4 = Main.maxTilesY - 300;
      for (int index3 = 1; index3 < Main.maxTilesX - 1; ++index3)
      {
        for (int index4 = worldSurface2; index4 < num4; ++index4)
        {
          int maxValue = 7;
          if (Main.tile[index3, index4].type == (ushort) 2 && (Main.tenthAnniversaryWorld || WorldGen.genRand.Next(maxValue) == 0))
          {
            if (WorldGen.genRand.Next(2) == 0)
              WorldGen.GrowTreeWithSettings(index3, index4, WorldGen.GrowTreeSettings.Profiles.VanityTree_Willow);
            else
              WorldGen.GrowTreeWithSettings(index3, index4, WorldGen.GrowTreeSettings.Profiles.VanityTree_Sakura);
          }
          else
            WorldGen.GrowTree(index3, index4);
        }
      }
    }

    public static void ExplodeMine(int i, int j, bool fromWiring)
    {
      int type = (int) Main.tile[i, j].type;
      WorldGen.KillTile(i, j, noItem: true);
      NetMessage.SendTileSquare(-1, i, j);
      Projectile.NewProjectile(WorldGen.GetProjectileSource_PlayerOrWires(i, j, fromWiring, Main.LocalPlayer), (float) (i * 16 + 8), (float) (j * 16 + 8), 0.0f, 0.0f, 164, 250, 10f, Main.myPlayer);
    }

    public static bool EmptyTileCheck(int startX, int endX, int startY, int endY, int ignoreID = -1)
    {
      if (startX < 0 || endX >= Main.maxTilesX || startY < 0 || endY >= Main.maxTilesY)
        return false;
      bool flag = false;
      if (ignoreID != -1 && TileID.Sets.CommonSapling[ignoreID])
        flag = true;
label_20:
      for (int index1 = startX; index1 < endX + 1; ++index1)
      {
        for (int index2 = startY; index2 < endY + 1; ++index2)
        {
          if (Main.tile[index1, index2].active())
          {
            switch (ignoreID)
            {
              case -1:
                return false;
              case 11:
                if (Main.tile[index1, index2].type != (ushort) 11)
                  return false;
                continue;
              case 71:
                if (Main.tile[index1, index2].type != (ushort) 71)
                  return false;
                continue;
              default:
                if (flag)
                {
                  if (!TileID.Sets.CommonSapling[(int) Main.tile[index1, index2].type])
                  {
                    switch (Main.tile[index1, index2].type)
                    {
                      case 3:
                      case 24:
                      case 32:
                      case 61:
                      case 62:
                      case 69:
                      case 71:
                      case 73:
                      case 74:
                      case 82:
                      case 83:
                      case 84:
                      case 110:
                      case 113:
                      case 184:
                      case 201:
                      case 233:
                      case 352:
                      case 485:
                      case 529:
                      case 530:
                      case 637:
                      case 655:
                        continue;
                      default:
                        return false;
                    }
                  }
                  else
                    goto label_20;
                }
                else
                  continue;
            }
          }
        }
      }
      return true;
    }

    public static void StartHardmode()
    {
      if (Main.netMode == 1 || Main.hardMode)
        return;
      Main.hardMode = true;
      ThreadPool.QueueUserWorkItem(new WaitCallback(WorldGen.smCallBack), (object) 1);
    }

    public static void TryProtectingSpawnedItems()
    {
      for (int index = 0; index < 400; ++index)
      {
        Item obj = Main.item[index];
        if (WorldGen.EligibleForSpawnProtection(obj))
          obj.timeSinceItemSpawned -= 18000;
      }
    }

    private static bool EligibleForSpawnProtection(Item item) => item.active && ItemID.Sets.OverflowProtectionTimeOffset[item.type] == 0;

    public static void UndoSpawnedItemProtection()
    {
      for (int index = 0; index < 400; ++index)
      {
        Item obj = Main.item[index];
        if (WorldGen.EligibleForSpawnProtection(obj) && obj.timeSinceItemSpawned < 0)
          obj.timeSinceItemSpawned += 18000;
      }
    }

    public static void smCallBack(object threadContext)
    {
      WorldGen.IsGeneratingHardMode = true;
      WorldGen.TryProtectingSpawnedItems();
      if (Main.rand == null)
        Main.rand = new UnifiedRandom((int) DateTime.Now.Ticks);
      double num1 = (double) WorldGen.genRand.Next(300, 400) * 0.001;
      double num2 = (double) WorldGen.genRand.Next(200, 300) * 0.001;
      int i1 = (int) ((double) Main.maxTilesX * num1);
      int i2 = (int) ((double) Main.maxTilesX * (1.0 - num1));
      int num3 = 1;
      if (WorldGen.genRand.Next(2) == 0)
      {
        i2 = (int) ((double) Main.maxTilesX * num1);
        i1 = (int) ((double) Main.maxTilesX * (1.0 - num1));
        num3 = -1;
      }
      int num4 = 1;
      if (GenVars.dungeonX < Main.maxTilesX / 2)
        num4 = -1;
      if (num4 < 0)
      {
        if (i2 < i1)
          i2 = (int) ((double) Main.maxTilesX * num2);
        else
          i1 = (int) ((double) Main.maxTilesX * num2);
      }
      else if (i2 > i1)
        i2 = (int) ((double) Main.maxTilesX * (1.0 - num2));
      else
        i1 = (int) ((double) Main.maxTilesX * (1.0 - num2));
      if (Main.remixWorld)
      {
        int num5 = Main.maxTilesX / 7;
        int num6 = Main.maxTilesX / 14;
        if (Main.dungeonX < Main.maxTilesX / 2)
        {
          for (int i3 = Main.maxTilesX - num5 - num6; i3 < Main.maxTilesX; ++i3)
          {
            for (int j = (int) Main.worldSurface + WorldGen.genRand.Next(-1, 2); j < Main.maxTilesY - 10; ++j)
            {
              if (i3 > Main.maxTilesX - num5)
                WorldGen.Convert(i3, j, 2, 1);
              else if (TileID.Sets.Crimson[(int) Main.tile[i3, j].type] || TileID.Sets.Corrupt[(int) Main.tile[i3, j].type])
                WorldGen.Convert(i3, j, 2, 1);
            }
          }
        }
        else
        {
          for (int i4 = 0; i4 < num5 + num6; ++i4)
          {
            for (int j = (int) Main.worldSurface + WorldGen.genRand.Next(-1, 2); j < Main.maxTilesY - 10; ++j)
            {
              if (i4 < num5)
                WorldGen.Convert(i4, j, 2, 1);
              else if (TileID.Sets.Crimson[(int) Main.tile[i4, j].type] || TileID.Sets.Corrupt[(int) Main.tile[i4, j].type])
                WorldGen.Convert(i4, j, 2, 1);
            }
          }
        }
      }
      else
      {
        WorldGen.GERunner(i1, 0, (double) (3 * num3), 5.0);
        WorldGen.GERunner(i2, 0, (double) (3 * -num3), 5.0, false);
      }
      int num7 = (int) (25.0 * ((double) Main.maxTilesX / 4200.0));
      ShapeData data = new ShapeData();
      int num8 = 0;
      while (num7 > 0)
      {
        if (++num8 % 15000 == 0)
          --num7;
        Point point = WorldGen.RandomWorldPoint((int) Main.worldSurface - 100, 1, 190, 1);
        Tile tile1 = Main.tile[point.X, point.Y];
        Tile tile2 = Main.tile[point.X, point.Y - 1];
        ushort type = 0;
        if (TileID.Sets.Crimson[(int) tile1.type])
          type = (ushort) (192 + WorldGen.genRand.Next(4));
        else if (TileID.Sets.Corrupt[(int) tile1.type])
          type = (ushort) (188 + WorldGen.genRand.Next(4));
        else if (TileID.Sets.Hallow[(int) tile1.type])
          type = (ushort) (200 + WorldGen.genRand.Next(4));
        if (tile1.active() && type != (ushort) 0 && !tile2.active())
        {
          bool flag = WorldUtils.Gen(new Point(point.X, point.Y - 1), (GenShape) new ShapeFloodFill(1000), Actions.Chain((GenAction) new Modifiers.IsNotSolid(), (GenAction) new Modifiers.OnlyWalls(new ushort[31]
          {
            (ushort) 0,
            (ushort) 54,
            (ushort) 55,
            (ushort) 56,
            (ushort) 57,
            (ushort) 58,
            (ushort) 59,
            (ushort) 61,
            (ushort) 185,
            (ushort) 212,
            (ushort) 213,
            (ushort) 214,
            (ushort) 215,
            (ushort) 2,
            (ushort) 196,
            (ushort) 197,
            (ushort) 198,
            (ushort) 199,
            (ushort) 15,
            (ushort) 40,
            (ushort) 71,
            (ushort) 64,
            (ushort) 204,
            (ushort) 205,
            (ushort) 206,
            (ushort) 207,
            (ushort) 208,
            (ushort) 209,
            (ushort) 210,
            (ushort) 211,
            (ushort) 71
          }), new Actions.Blank().Output(data)));
          if (data.Count > 50 & flag)
          {
            WorldUtils.Gen(new Point(point.X, point.Y), (GenShape) new ModShapes.OuterOutline(data, useInterior: true), (GenAction) new Actions.PlaceWall(type));
            --num7;
          }
          data.Clear();
        }
      }
      switch (Main.netMode)
      {
        case 0:
          Main.NewText(Lang.misc[15].Value, (byte) 50, B: (byte) 130);
          break;
        case 2:
          ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[15].Key), new Color(50, (int) byte.MaxValue, 130));
          break;
      }
      AchievementsHelper.NotifyProgressionEvent(9);
      if (Main.netMode == 2)
        Netplay.ResetSections();
      WorldGen.UndoSpawnedItemProtection();
      WorldGen.IsGeneratingHardMode = false;
    }

    public static bool PlaceDoor(int i, int j, int type, int style = 0)
    {
      int num1 = style / 36;
      int num2 = style % 36;
      int num3 = 54 * num1;
      int num4 = 54 * num2;
      try
      {
        if (!Main.tile[i, j - 2].nactive() || !Main.tileSolid[(int) Main.tile[i, j - 2].type] || !WorldGen.SolidTile(i, j + 2))
          return false;
        Main.tile[i, j - 1].active(true);
        Main.tile[i, j - 1].type = (ushort) 10;
        Main.tile[i, j - 1].frameY = (short) num4;
        Main.tile[i, j - 1].frameX = (short) (num3 + WorldGen.genRand.Next(3) * 18);
        Main.tile[i, j].active(true);
        Main.tile[i, j].type = (ushort) 10;
        Main.tile[i, j].frameY = (short) (num4 + 18);
        Main.tile[i, j].frameX = (short) (num3 + WorldGen.genRand.Next(3) * 18);
        Main.tile[i, j + 1].active(true);
        Main.tile[i, j + 1].type = (ushort) 10;
        Main.tile[i, j + 1].frameY = (short) (num4 + 36);
        Main.tile[i, j + 1].frameX = (short) (num3 + WorldGen.genRand.Next(3) * 18);
        return true;
      }
      catch
      {
        return false;
      }
    }

    public static bool CloseDoor(int i, int j, bool forced = false)
    {
      int num1 = 0;
      int num2 = i;
      if (Main.tile[i, j] == null)
        Main.tile[i, j] = new Tile();
      int frameX = (int) Main.tile[i, j].frameX;
      Tile tile = Main.tile[i, j];
      if (tile.type != (ushort) 11)
        return false;
      int frameY = (int) tile.frameY;
      int num3 = 0;
      int num4 = 0;
      while (frameY >= 54)
      {
        frameY -= 54;
        ++num3;
      }
      if (frameX >= 72)
      {
        int num5 = num3 + 36 * (frameX / 72);
        num4 += 54 * (frameX / 72);
      }
      int y = j - frameY / 18;
      switch (frameX % 72)
      {
        case 0:
          num2 = i;
          num1 = 1;
          break;
        case 18:
          num2 = i - 1;
          num1 = 1;
          break;
        case 36:
          num2 = i + 1;
          num1 = -1;
          break;
        case 54:
          num2 = i;
          num1 = -1;
          break;
      }
      int num6 = num2;
      if (num1 == -1)
        num6 = num2 - 1;
      if (!forced)
      {
        for (int j1 = y; j1 < y + 3; ++j1)
        {
          if (!Collision.EmptyTile(num2, j1, true))
            return false;
        }
      }
      for (int index1 = num6; index1 < num6 + 2; ++index1)
      {
        for (int index2 = y; index2 < y + 3; ++index2)
        {
          if (index1 == num2)
          {
            if (Main.tile[index1, index2] == null)
              Main.tile[index1, index2] = new Tile();
            Main.tile[index1, index2].type = (ushort) 10;
            Main.tile[index1, index2].frameX = (short) (WorldGen.genRand.Next(3) * 18 + num4);
          }
          else
          {
            if (Main.tile[index1, index2] == null)
              Main.tile[index1, index2] = new Tile();
            Main.tile[index1, index2].active(false);
          }
        }
      }
      if (Main.netMode != 1 && Wiring.running)
      {
        Wiring.SkipWire(num2, y);
        Wiring.SkipWire(num2, y + 1);
        Wiring.SkipWire(num2, y + 2);
      }
      for (int i1 = num2 - 1; i1 <= num2 + 1; ++i1)
      {
        for (int j2 = y - 1; j2 <= y + 2; ++j2)
          WorldGen.TileFrame(i1, j2);
      }
      SoundEngine.PlaySound(9, i * 16, j * 16);
      return true;
    }

    public static bool AddLifeCrystal(int i, int j)
    {
      for (int index = j; index < Main.maxTilesY; ++index)
      {
        if (Main.tile[i, index].active() && Main.tileSolid[(int) Main.tile[i, index].type])
        {
          int endX = i;
          int endY = index - 1;
          if (Main.tile[endX, endY - 1].lava() || Main.tile[endX - 1, endY - 1].lava() || Main.tile[endX, endY - 1].shimmer() || !WorldGen.EmptyTileCheck(endX - 1, endX, endY - 1, endY) || Main.wallDungeon[(int) Main.tile[endX, endY].wall])
            return false;
          Tile tile1 = Main.tile[endX - 1, endY + 1];
          Tile tile2 = Main.tile[endX, endY + 1];
          if (!tile1.nactive() || !Main.tileSolid[(int) tile1.type] || !tile2.nactive() || !Main.tileSolid[(int) tile2.type])
            return false;
          if (tile1.blockType() != 0)
          {
            tile1.slope((byte) 0);
            tile1.halfBrick(false);
          }
          if (tile2.blockType() != 0)
          {
            tile2.slope((byte) 0);
            tile2.halfBrick(false);
          }
          Main.tile[endX - 1, endY - 1].active(true);
          Main.tile[endX - 1, endY - 1].type = (ushort) 12;
          Main.tile[endX - 1, endY - 1].frameX = (short) 0;
          Main.tile[endX - 1, endY - 1].frameY = (short) 0;
          Main.tile[endX, endY - 1].active(true);
          Main.tile[endX, endY - 1].type = (ushort) 12;
          Main.tile[endX, endY - 1].frameX = (short) 18;
          Main.tile[endX, endY - 1].frameY = (short) 0;
          Main.tile[endX - 1, endY].active(true);
          Main.tile[endX - 1, endY].type = (ushort) 12;
          Main.tile[endX - 1, endY].frameX = (short) 0;
          Main.tile[endX - 1, endY].frameY = (short) 18;
          Main.tile[endX, endY].active(true);
          Main.tile[endX, endY].type = (ushort) 12;
          Main.tile[endX, endY].frameX = (short) 18;
          Main.tile[endX, endY].frameY = (short) 18;
          return true;
        }
      }
      return false;
    }

    public static void AddShadowOrb(int x, int y)
    {
      if (x < 10 || x > Main.maxTilesX - 10 || y < 10 || y > Main.maxTilesY - 10)
        return;
      for (int index1 = x - 1; index1 < x + 1; ++index1)
      {
        for (int index2 = y - 1; index2 < y + 1; ++index2)
        {
          if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 31)
            return;
        }
      }
      short num = 0;
      if (WorldGen.crimson)
        num += (short) 36;
      Main.tile[x - 1, y - 1].active(true);
      Main.tile[x - 1, y - 1].type = (ushort) 31;
      Main.tile[x - 1, y - 1].frameX = num;
      Main.tile[x - 1, y - 1].frameY = (short) 0;
      Main.tile[x, y - 1].active(true);
      Main.tile[x, y - 1].type = (ushort) 31;
      Main.tile[x, y - 1].frameX = (short) (18 + (int) num);
      Main.tile[x, y - 1].frameY = (short) 0;
      Main.tile[x - 1, y].active(true);
      Main.tile[x - 1, y].type = (ushort) 31;
      Main.tile[x - 1, y].frameX = num;
      Main.tile[x - 1, y].frameY = (short) 18;
      Main.tile[x, y].active(true);
      Main.tile[x, y].type = (ushort) 31;
      Main.tile[x, y].frameX = (short) (18 + (int) num);
      Main.tile[x, y].frameY = (short) 18;
    }

    public static void AddHellHouses()
    {
      int num1 = (int) ((double) Main.maxTilesX * 0.25);
      for (int i = 100; i < Main.maxTilesX - 100; ++i)
      {
        if ((!WorldGen.drunkWorldGen && !WorldGen.remixWorldGen || i <= num1 || i >= Main.maxTilesX - num1) && (WorldGen.drunkWorldGen || WorldGen.remixWorldGen || i >= num1 && i <= Main.maxTilesX - num1))
        {
          int j = Main.maxTilesY - 40;
          while (Main.tile[i, j].active() || Main.tile[i, j].liquid > (byte) 0)
            --j;
          if (Main.tile[i, j + 1].active())
          {
            ushort tileType = (ushort) WorldGen.genRand.Next(75, 77);
            byte wallType = 13;
            if (WorldGen.genRand.Next(5) > 0)
              tileType = (ushort) 75;
            if (tileType == (ushort) 75)
              wallType = (byte) 14;
            if (WorldGen.getGoodWorldGen)
              tileType = (ushort) 76;
            WorldGen.HellFort(i, j, tileType, wallType);
            i += WorldGen.genRand.Next(30, 130);
            if (WorldGen.genRand.Next(10) == 0)
              i += WorldGen.genRand.Next(0, 200);
          }
        }
      }
      float num2 = (float) (Main.maxTilesX / 4200);
      for (int index1 = 0; (double) index1 < 200.0 * (double) num2; ++index1)
      {
        int num3 = 0;
        bool flag1 = false;
        while (!flag1)
        {
          ++num3;
          int index2 = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.2), (int) ((double) Main.maxTilesX * 0.8));
          int j = WorldGen.genRand.Next(Main.maxTilesY - 300, Main.maxTilesY - 20);
          if (Main.tile[index2, j].active() && (Main.tile[index2, j].type == (ushort) 75 || Main.tile[index2, j].type == (ushort) 76))
          {
            int num4 = 0;
            if (Main.tile[index2 - 1, j].wall > (ushort) 0)
              num4 = -1;
            else if (Main.tile[index2 + 1, j].wall > (ushort) 0)
              num4 = 1;
            if (!Main.tile[index2 + num4, j].active() && !Main.tile[index2 + num4, j + 1].active())
            {
              bool flag2 = false;
              for (int index3 = index2 - 8; index3 < index2 + 8; ++index3)
              {
                for (int index4 = j - 8; index4 < j + 8; ++index4)
                {
                  if (Main.tile[index3, index4].active() && Main.tile[index3, index4].type == (ushort) 4)
                  {
                    flag2 = true;
                    break;
                  }
                }
              }
              if (!flag2)
              {
                WorldGen.PlaceTile(index2 + num4, j, 4, true, true, style: 7);
                flag1 = true;
              }
            }
          }
          if (num3 > 1000)
            flag1 = true;
        }
      }
      double num5 = 4200000.0 / (double) Main.maxTilesX;
      for (int index5 = 0; (double) index5 < num5; ++index5)
      {
        int num6 = 0;
        int i1 = WorldGen.genRand.Next(num1, Main.maxTilesX - num1);
        int j = WorldGen.genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
        while (Main.tile[i1, j].wall != (ushort) 13 && Main.tile[i1, j].wall != (ushort) 14 || Main.tile[i1, j].active())
        {
          i1 = WorldGen.genRand.Next(num1, Main.maxTilesX - num1);
          j = WorldGen.genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
          if (WorldGen.drunkWorldGen || WorldGen.remixWorldGen)
            i1 = WorldGen.genRand.Next(2) != 0 ? WorldGen.genRand.Next(Main.maxTilesX - num1, Main.maxTilesX - 50) : WorldGen.genRand.Next(50, num1);
          ++num6;
          if (num6 > 100000)
            break;
        }
        if (num6 <= 100000 && (Main.tile[i1, j].wall == (ushort) 13 || Main.tile[i1, j].wall == (ushort) 14) && !Main.tile[i1, j].active())
        {
          while (!WorldGen.SolidTile(i1, j) && j < Main.maxTilesY - 20)
            ++j;
          int index6 = j - 1;
          int i2 = i1;
          int i3 = i1;
          while (!Main.tile[i2, index6].active() && WorldGen.SolidTile(i2, index6 + 1))
            --i2;
          int num7 = i2 + 1;
          while (!Main.tile[i3, index6].active() && WorldGen.SolidTile(i3, index6 + 1))
            ++i3;
          int num8 = i3 - 1;
          int num9 = num8 - num7;
          int index7 = (num8 + num7) / 2;
          if (!Main.tile[index7, index6].active() && (Main.tile[index7, index6].wall == (ushort) 13 || Main.tile[index7, index6].wall == (ushort) 14) && WorldGen.SolidTile(index7, index6 + 1))
          {
            int style1 = 16;
            int style2 = 13;
            int style3 = 14;
            int style4 = 49;
            int style5 = 4;
            int style6 = 8;
            int style7 = 15;
            int style8 = 9;
            int style9 = 10;
            int style10 = 17;
            int style11 = 25;
            int style12 = 25;
            int style13 = 23;
            int style14 = 25;
            int num10 = WorldGen.genRand.Next(13);
            int num11 = 0;
            int num12 = 0;
            if (num10 == 0)
            {
              num11 = 5;
              num12 = 4;
            }
            if (num10 == 1)
            {
              num11 = 4;
              num12 = 3;
            }
            if (num10 == 2)
            {
              num11 = 3;
              num12 = 5;
            }
            if (num10 == 3)
            {
              num11 = 4;
              num12 = 6;
            }
            if (num10 == 4)
            {
              num11 = 3;
              num12 = 3;
            }
            if (num10 == 5)
            {
              num11 = 5;
              num12 = 3;
            }
            if (num10 == 6)
            {
              num11 = 5;
              num12 = 4;
            }
            if (num10 == 7)
            {
              num11 = 5;
              num12 = 4;
            }
            if (num10 == 8)
            {
              num11 = 5;
              num12 = 4;
            }
            if (num10 == 9)
            {
              num11 = 3;
              num12 = 5;
            }
            if (num10 == 10)
            {
              num11 = 5;
              num12 = 3;
            }
            if (num10 == 11)
            {
              num11 = 2;
              num12 = 4;
            }
            if (num10 == 12)
            {
              num11 = 3;
              num12 = 3;
            }
            for (int index8 = index7 - num11; index8 <= index7 + num11; ++index8)
            {
              for (int index9 = index6 - num12; index9 <= index6; ++index9)
              {
                if (Main.tile[index8, index9].active())
                {
                  num10 = -1;
                  break;
                }
              }
            }
            if ((double) num9 < (double) num11 * 1.75)
              num10 = -1;
            switch (num10)
            {
              case 0:
                WorldGen.PlaceTile(index7, index6, 14, true, style: style2);
                int num13 = WorldGen.genRand.Next(6);
                if (num13 < 3)
                  WorldGen.PlaceTile(index7 + num13, index6 - 2, 33, true, style: style12);
                if (Main.tile[index7, index6].active())
                {
                  if (!Main.tile[index7 - 2, index6].active())
                  {
                    WorldGen.PlaceTile(index7 - 2, index6, 15, true, style: style1);
                    if (Main.tile[index7 - 2, index6].active())
                    {
                      Main.tile[index7 - 2, index6].frameX += (short) 18;
                      Main.tile[index7 - 2, index6 - 1].frameX += (short) 18;
                    }
                  }
                  if (!Main.tile[index7 + 2, index6].active())
                  {
                    WorldGen.PlaceTile(index7 + 2, index6, 15, true, style: style1);
                    continue;
                  }
                  continue;
                }
                continue;
              case 1:
                WorldGen.PlaceTile(index7, index6, 18, true, style: style3);
                int num14 = WorldGen.genRand.Next(4);
                if (num14 < 2)
                  WorldGen.PlaceTile(index7 + num14, index6 - 1, 33, true, style: style12);
                if (Main.tile[index7, index6].active())
                {
                  if (WorldGen.genRand.Next(2) == 0)
                  {
                    if (!Main.tile[index7 - 1, index6].active())
                    {
                      WorldGen.PlaceTile(index7 - 1, index6, 15, true, style: style1);
                      if (Main.tile[index7 - 1, index6].active())
                      {
                        Main.tile[index7 - 1, index6].frameX += (short) 18;
                        Main.tile[index7 - 1, index6 - 1].frameX += (short) 18;
                        continue;
                      }
                      continue;
                    }
                    continue;
                  }
                  if (!Main.tile[index7 + 2, index6].active())
                  {
                    WorldGen.PlaceTile(index7 + 2, index6, 15, true, style: style1);
                    continue;
                  }
                  continue;
                }
                continue;
              case 2:
                WorldGen.PlaceTile(index7, index6, 105, true, style: style4);
                continue;
              case 3:
                WorldGen.PlaceTile(index7, index6, 101, true, style: style5);
                continue;
              case 4:
                if (WorldGen.genRand.Next(2) == 0)
                {
                  WorldGen.PlaceTile(index7, index6, 15, true, style: style1);
                  Main.tile[index7, index6].frameX += (short) 18;
                  Main.tile[index7, index6 - 1].frameX += (short) 18;
                  continue;
                }
                WorldGen.PlaceTile(index7, index6, 15, true, style: style1);
                continue;
              case 5:
                if (WorldGen.genRand.Next(2) == 0)
                {
                  WorldGen.Place4x2(index7, index6, (ushort) 79, 1, style6);
                  continue;
                }
                WorldGen.Place4x2(index7, index6, (ushort) 79, style: style6);
                continue;
              case 6:
                WorldGen.PlaceTile(index7, index6, 87, true, style: style7);
                continue;
              case 7:
                WorldGen.PlaceTile(index7, index6, 88, true, style: style8);
                continue;
              case 8:
                WorldGen.PlaceTile(index7, index6, 89, true, style: style9);
                continue;
              case 9:
                WorldGen.PlaceTile(index7, index6, 104, true, style: style10);
                continue;
              case 10:
                if (WorldGen.genRand.Next(2) == 0)
                {
                  WorldGen.Place4x2(index7, index6, (ushort) 90, 1, style14);
                  continue;
                }
                WorldGen.Place4x2(index7, index6, (ushort) 90, style: style14);
                continue;
              case 11:
                WorldGen.PlaceTile(index7, index6, 93, true, style: style13);
                continue;
              case 12:
                WorldGen.PlaceTile(index7, index6, 100, true, style: style11);
                continue;
              default:
                continue;
            }
          }
        }
      }
      double num15 = 420000.0 / (double) Main.maxTilesX;
      for (int index10 = 0; (double) index10 < num15; ++index10)
      {
        int num16 = 0;
        int index11 = WorldGen.genRand.Next(num1, Main.maxTilesX - num1);
        int index12 = WorldGen.genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
        while (Main.tile[index11, index12].wall != (ushort) 13 && Main.tile[index11, index12].wall != (ushort) 14 || Main.tile[index11, index12].active())
        {
          index11 = WorldGen.genRand.Next(num1, Main.maxTilesX - num1);
          index12 = WorldGen.genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
          if (WorldGen.drunkWorldGen || WorldGen.remixWorldGen)
            index11 = WorldGen.genRand.Next(2) != 0 ? WorldGen.genRand.Next(Main.maxTilesX - num1, Main.maxTilesX - 50) : WorldGen.genRand.Next(50, num1);
          ++num16;
          if (num16 > 100000)
            break;
        }
        if (num16 <= 100000)
        {
          for (int index13 = 0; index13 < 2; ++index13)
          {
            int index14 = index11;
            int index15 = index11;
            while (!Main.tile[index14, index12].active() && (Main.tile[index14, index12].wall == (ushort) 13 || Main.tile[index14, index12].wall == (ushort) 14))
              --index14;
            int num17 = index14 + 1;
            while (!Main.tile[index15, index12].active() && (Main.tile[index15, index12].wall == (ushort) 13 || Main.tile[index15, index12].wall == (ushort) 14))
              ++index15;
            int num18 = index15 - 1;
            index11 = (num17 + num18) / 2;
            int index16 = index12;
            int index17 = index12;
            while (!Main.tile[index11, index16].active() && (Main.tile[index11, index16].wall == (ushort) 13 || Main.tile[index11, index16].wall == (ushort) 14))
              --index16;
            int num19 = index16 + 1;
            while (!Main.tile[index11, index17].active() && (Main.tile[index11, index17].wall == (ushort) 13 || Main.tile[index11, index17].wall == (ushort) 14))
              ++index17;
            int num20 = index17 - 1;
            index12 = (num19 + num20) / 2;
          }
          int index18 = index11;
          int index19 = index11;
          while (!Main.tile[index18, index12].active() && !Main.tile[index18, index12 - 1].active() && !Main.tile[index18, index12 + 1].active())
            --index18;
          int num21 = index18 + 1;
          while (!Main.tile[index19, index12].active() && !Main.tile[index19, index12 - 1].active() && !Main.tile[index19, index12 + 1].active())
            ++index19;
          int num22 = index19 - 1;
          int index20 = index12;
          int index21 = index12;
          while (!Main.tile[index11, index20].active() && !Main.tile[index11 - 1, index20].active() && !Main.tile[index11 + 1, index20].active())
            --index20;
          int num23 = index20 + 1;
          while (!Main.tile[index11, index21].active() && !Main.tile[index11 - 1, index21].active() && !Main.tile[index11 + 1, index21].active())
            ++index21;
          int num24 = index21 - 1;
          int num25 = (num21 + num22) / 2;
          int num26 = (num23 + num24) / 2;
          int num27 = num22 - num21;
          int num28 = num24 - num23;
          if (num27 > 7 && num28 > 5)
          {
            int num29 = 0;
            if (WorldGen.nearPicture2(num25, num26))
              num29 = -1;
            if (num29 == 0)
            {
              PaintingEntry paintingEntry = WorldGen.RandHellPicture();
              if (!WorldGen.nearPicture(num25, num26))
                WorldGen.PlaceTile(num25, num26, paintingEntry.tileType, true, style: paintingEntry.style);
            }
          }
        }
      }
      int[] numArray = new int[3]
      {
        WorldGen.genRand.Next(16, 22),
        WorldGen.genRand.Next(16, 22),
        WorldGen.genRand.Next(16, 22)
      };
      while (numArray[1] == numArray[0])
        numArray[1] = WorldGen.genRand.Next(16, 22);
      while (numArray[2] == numArray[0] || numArray[2] == numArray[1])
        numArray[2] = WorldGen.genRand.Next(16, 22);
      double num30 = 420000.0 / (double) Main.maxTilesX;
      for (int index22 = 0; (double) index22 < num30; ++index22)
      {
        int num31 = 0;
        int i;
        int j1;
        do
        {
          i = WorldGen.genRand.Next(num1, Main.maxTilesX - num1);
          j1 = WorldGen.genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
          if (WorldGen.drunkWorldGen || WorldGen.remixWorldGen)
            i = WorldGen.genRand.Next(2) != 0 ? WorldGen.genRand.Next(Main.maxTilesX - num1, Main.maxTilesX - 50) : WorldGen.genRand.Next(50, num1);
          ++num31;
        }
        while (num31 <= 100000 && (Main.tile[i, j1].wall != (ushort) 13 && Main.tile[i, j1].wall != (ushort) 14 || Main.tile[i, j1].active()));
        if (num31 <= 100000)
        {
          while (!WorldGen.SolidTile(i, j1) && j1 > 10)
            --j1;
          int j2 = j1 + 1;
          if (Main.tile[i, j2].wall == (ushort) 13 || Main.tile[i, j2].wall == (ushort) 14)
          {
            int num32 = WorldGen.genRand.Next(3);
            int style15 = 32;
            int style16 = 32;
            int num33;
            int num34;
            switch (num32)
            {
              case 1:
                num33 = 3;
                num34 = 3;
                break;
              case 2:
                num33 = 1;
                num34 = 2;
                break;
              default:
                num33 = 1;
                num34 = 3;
                break;
            }
            for (int index23 = i - 1; index23 <= i + num33; ++index23)
            {
              for (int index24 = j2; index24 <= j2 + num34; ++index24)
              {
                Tile tile = Main.tile[i, j2];
                if (index23 < i || index23 == i + num33)
                {
                  if (tile.active())
                  {
                    switch (tile.type)
                    {
                      case 10:
                      case 11:
                      case 34:
                      case 42:
                      case 91:
                        num32 = -1;
                        continue;
                      default:
                        continue;
                    }
                  }
                }
                else if (tile.active())
                  num32 = -1;
              }
            }
            switch (num32)
            {
              case 0:
                WorldGen.PlaceTile(i, j2, 91, true, style: numArray[WorldGen.genRand.Next(3)]);
                continue;
              case 1:
                WorldGen.PlaceTile(i, j2, 34, true, style: style15);
                continue;
              case 2:
                WorldGen.PlaceTile(i, j2, 42, true, style: style16);
                continue;
              default:
                continue;
            }
          }
        }
      }
    }

    public static void HellFort(int i, int j, ushort tileType = 75, byte wallType = 14)
    {
      int[] numArray1 = new int[5];
      int[] numArray2 = new int[5];
      int[] numArray3 = new int[10];
      int[] numArray4 = new int[10];
      int minValue1 = 8;
      int maxValue1 = 20;
      if (WorldGen.drunkWorldGen)
      {
        minValue1 /= 2;
        maxValue1 *= 2;
      }
      numArray1[2] = i - WorldGen.genRand.Next(minValue1 / 2, maxValue1 / 2);
      numArray2[2] = i + WorldGen.genRand.Next(minValue1 / 2, maxValue1 / 2);
      numArray1[3] = numArray2[2];
      numArray2[3] = numArray1[3] + WorldGen.genRand.Next(minValue1, maxValue1);
      numArray1[4] = numArray2[3];
      numArray2[4] = numArray1[4] + WorldGen.genRand.Next(minValue1, maxValue1);
      numArray2[1] = numArray1[2];
      numArray1[1] = numArray2[1] - WorldGen.genRand.Next(minValue1, maxValue1);
      numArray2[0] = numArray1[1];
      numArray1[0] = numArray2[0] - WorldGen.genRand.Next(minValue1, maxValue1);
      int minValue2 = 6;
      int maxValue2 = 12;
      numArray3[3] = j - WorldGen.genRand.Next(minValue2, maxValue2);
      numArray4[3] = j;
      for (int index = 4; index < 10; ++index)
      {
        numArray3[index] = numArray4[index - 1];
        numArray4[index] = numArray3[index] + WorldGen.genRand.Next(minValue2, maxValue2);
      }
      for (int index = 2; index >= 0; --index)
      {
        numArray4[index] = numArray3[index + 1];
        numArray3[index] = numArray4[index] - WorldGen.genRand.Next(minValue2, maxValue2);
      }
      bool flag1 = false;
      bool flag2 = false;
      bool[,] flagArray1 = new bool[5, 10];
      int num1 = 3;
      int num2 = 3;
      for (int index1 = 0; index1 < 2; ++index1)
      {
        if (WorldGen.genRand.Next(3) == 0 || WorldGen.drunkWorldGen)
        {
          flag1 = true;
          int index2 = WorldGen.genRand.Next(10);
          if (index2 < num1)
            num1 = index2;
          if (index2 > num2)
            num2 = index2;
          int index3 = 1;
          if (WorldGen.genRand.Next(2) == 0 || WorldGen.drunkWorldGen)
          {
            flagArray1[0, index2] = true;
            flagArray1[1, index2] = true;
            index3 = 0;
          }
          else
            flagArray1[1, index2] = true;
          int num3 = WorldGen.genRand.Next(2);
          if (num3 == 0)
            num3 = -1;
          for (int index4 = WorldGen.genRand.Next(10); index4 > 0 && index2 >= 0 && index2 < 10; index2 += num3)
            flagArray1[index3, index2] = true;
        }
        if (WorldGen.genRand.Next(3) == 0 || WorldGen.drunkWorldGen)
        {
          flag2 = true;
          int index5 = WorldGen.genRand.Next(10);
          if (index5 < num1)
            num1 = index5;
          if (index5 > num2)
            num2 = index5;
          int index6 = 3;
          if (WorldGen.genRand.Next(2) == 0 || WorldGen.drunkWorldGen)
          {
            flagArray1[3, index5] = true;
            flagArray1[4, index5] = true;
            index6 = 4;
          }
          else
            flagArray1[3, index5] = true;
          int num4 = WorldGen.genRand.Next(2);
          if (num4 == 0)
            num4 = -1;
          for (int index7 = WorldGen.genRand.Next(10); index7 > 0 && index5 >= 0 && index5 < 10; index5 += num4)
            flagArray1[index6, index5] = true;
        }
      }
      for (int index8 = 0; index8 < 5; ++index8)
      {
        int index9 = numArray1[index8];
        bool flag3 = false;
        if (index9 < 10 || index9 > Main.maxTilesX - 10)
        {
          flag3 = true;
        }
        else
        {
          for (int underworldLayer = Main.UnderworldLayer; underworldLayer < Main.maxTilesY; ++underworldLayer)
          {
            if (Main.tile[index9, underworldLayer].wall > (ushort) 0)
              flag3 = true;
          }
        }
        if (flag3)
        {
          for (int index10 = 0; index10 < 10; ++index10)
            flagArray1[index8, index10] = false;
        }
      }
      int num5 = WorldGen.genRand.Next(10);
      if (num5 < num1)
        num1 = num5;
      int num6 = WorldGen.genRand.Next(10);
      if (num6 > num2)
        num2 = num6;
      if (!flag1 && !flag2)
      {
        while (num2 - num1 < 5)
        {
          int num7 = WorldGen.genRand.Next(10);
          if (num7 < num1)
            num1 = num7;
          int num8 = WorldGen.genRand.Next(10);
          if (num8 > num2)
            num2 = num8;
        }
      }
      for (int index = num1; index <= num2; ++index)
        flagArray1[2, index] = true;
      for (int index11 = 0; index11 < 5; ++index11)
      {
        for (int index12 = 0; index12 < 10; ++index12)
        {
          if (flagArray1[index11, index12] && (numArray3[index12] < Main.UnderworldLayer || numArray4[index12] > Main.maxTilesY - 20))
            flagArray1[index11, index12] = false;
        }
      }
      for (int index13 = 0; index13 < 5; ++index13)
      {
        for (int index14 = 0; index14 < 10; ++index14)
        {
          if (flagArray1[index13, index14])
          {
            for (int index15 = numArray1[index13]; index15 <= numArray2[index13]; ++index15)
            {
              for (int index16 = numArray3[index14]; index16 <= numArray4[index14] && index15 >= 10 && index15 <= Main.maxTilesX - 10; ++index16)
              {
                Main.tile[index15, index16].liquid = (byte) 0;
                if (index15 == numArray1[index13] || index15 == numArray2[index13] || index16 == numArray3[index14] || index16 == numArray4[index14])
                {
                  Main.tile[index15, index16].active(true);
                  Main.tile[index15, index16].type = tileType;
                  Main.tile[index15, index16].halfBrick(false);
                  Main.tile[index15, index16].slope((byte) 0);
                }
                else
                {
                  Main.tile[index15, index16].wall = (ushort) wallType;
                  Main.tile[index15, index16].active(false);
                }
              }
            }
          }
        }
      }
      int style1 = 19;
      int style2 = 13;
      for (int index17 = 0; index17 < 4; ++index17)
      {
        bool[] flagArray2 = new bool[10];
        bool flag4 = false;
        for (int index18 = 0; index18 < 10; ++index18)
        {
          if (flagArray1[index17, index18] && flagArray1[index17 + 1, index18])
          {
            flagArray2[index18] = true;
            flag4 = true;
          }
        }
        while (flag4)
        {
          int index19 = WorldGen.genRand.Next(10);
          if (flagArray2[index19])
          {
            flag4 = false;
            Main.tile[numArray2[index17], numArray4[index19] - 1].active(false);
            Main.tile[numArray2[index17], numArray4[index19] - 2].active(false);
            Main.tile[numArray2[index17], numArray4[index19] - 3].active(false);
            Main.tile[numArray2[index17], numArray4[index19] - 1].wall = (ushort) wallType;
            Main.tile[numArray2[index17], numArray4[index19] - 2].wall = (ushort) wallType;
            Main.tile[numArray2[index17], numArray4[index19] - 3].wall = (ushort) wallType;
            WorldGen.PlaceTile(numArray2[index17], numArray4[index19] - 1, 10, true, style: style1);
          }
        }
      }
      for (int index20 = 0; index20 < 5; ++index20)
      {
        for (int index21 = 0; index21 < 10; ++index21)
        {
          if (flagArray1[index20, index21])
          {
            if (index21 > 0 && flagArray1[index20, index21 - 1])
            {
              int num9 = WorldGen.genRand.Next(numArray1[index20] + 2, numArray2[index20] - 1);
              int num10 = WorldGen.genRand.Next(numArray1[index20] + 2, numArray2[index20] - 1);
              int num11 = 0;
              while (num10 - num9 < 2 || num10 - num9 > 5)
              {
                num9 = WorldGen.genRand.Next(numArray1[index20] + 2, numArray2[index20] - 1);
                num10 = WorldGen.genRand.Next(numArray1[index20] + 2, numArray2[index20] - 1);
                ++num11;
                if (num11 > 10000)
                  break;
              }
              if (num11 <= 10000)
              {
                for (int i1 = num9; i1 <= num10 && i1 >= 20 && i1 <= Main.maxTilesX - 20; ++i1)
                {
                  Main.tile[i1, numArray3[index21]].active(false);
                  WorldGen.PlaceTile(i1, numArray3[index21], 19, true, true, style: style2);
                  Main.tile[i1, numArray3[index21]].wall = (ushort) wallType;
                }
              }
              else
                break;
            }
            if (index20 < 4 && flagArray1[index20 + 1, index21] && WorldGen.genRand.Next(3) == 0)
            {
              Main.tile[numArray2[index20], numArray4[index21] - 1].active(false);
              Main.tile[numArray2[index20], numArray4[index21] - 2].active(false);
              Main.tile[numArray2[index20], numArray4[index21] - 3].active(false);
              Main.tile[numArray2[index20], numArray4[index21] - 1].wall = (ushort) wallType;
              Main.tile[numArray2[index20], numArray4[index21] - 2].wall = (ushort) wallType;
              Main.tile[numArray2[index20], numArray4[index21] - 3].wall = (ushort) wallType;
              WorldGen.PlaceTile(numArray2[index20], numArray4[index21] - 1, 10, true, style: style1);
            }
          }
        }
      }
      bool flag5 = false;
      for (int index22 = 0; index22 < 5; ++index22)
      {
        bool[] flagArray3 = new bool[10];
        for (int index23 = 0; index23 < 10; ++index23)
        {
          if (flagArray1[index22, index23])
          {
            flag5 = true;
            flagArray3[index23] = true;
          }
        }
        if (flag5)
        {
          bool flag6 = false;
          for (int index24 = 0; index24 < 10; ++index24)
          {
            if (flagArray3[index24])
            {
              if (!Main.tile[numArray1[index22] - 1, numArray4[index24] - 1].active() && !Main.tile[numArray1[index22] - 1, numArray4[index24] - 2].active() && !Main.tile[numArray1[index22] - 1, numArray4[index24] - 3].active() && Main.tile[numArray1[index22] - 1, numArray4[index24] - 1].liquid == (byte) 0 && Main.tile[numArray1[index22] - 1, numArray4[index24] - 2].liquid == (byte) 0 && Main.tile[numArray1[index22] - 1, numArray4[index24] - 3].liquid == (byte) 0)
                flag6 = true;
              else
                flagArray3[index24] = false;
            }
          }
          while (flag6)
          {
            int index25 = WorldGen.genRand.Next(10);
            if (flagArray3[index25])
            {
              flag6 = false;
              Main.tile[numArray1[index22], numArray4[index25] - 1].active(false);
              Main.tile[numArray1[index22], numArray4[index25] - 2].active(false);
              Main.tile[numArray1[index22], numArray4[index25] - 3].active(false);
              WorldGen.PlaceTile(numArray1[index22], numArray4[index25] - 1, 10, true, style: style1);
            }
          }
          break;
        }
      }
      bool flag7 = false;
      for (int index26 = 4; index26 >= 0; --index26)
      {
        bool[] flagArray4 = new bool[10];
        for (int index27 = 0; index27 < 10; ++index27)
        {
          if (flagArray1[index26, index27])
          {
            flag7 = true;
            flagArray4[index27] = true;
          }
        }
        if (flag7)
        {
          bool flag8 = false;
          for (int index28 = 0; index28 < 10; ++index28)
          {
            if (flagArray4[index28])
            {
              if (index26 >= 20 && index26 <= Main.maxTilesX - 20)
              {
                if (!Main.tile[numArray2[index26] + 1, numArray4[index28] - 1].active() && !Main.tile[numArray2[index26] + 1, numArray4[index28] - 2].active() && !Main.tile[numArray2[index26] + 1, numArray4[index28] - 3].active() && Main.tile[numArray2[index26] + 1, numArray4[index28] - 1].liquid == (byte) 0 && Main.tile[numArray2[index26] + 1, numArray4[index28] - 2].liquid == (byte) 0 && Main.tile[numArray2[index26] + 1, numArray4[index28] - 3].liquid == (byte) 0)
                  flag8 = true;
                else
                  flagArray4[index28] = false;
              }
              else
                break;
            }
          }
          while (flag8)
          {
            int index29 = WorldGen.genRand.Next(10);
            if (flagArray4[index29])
            {
              flag8 = false;
              Main.tile[numArray2[index26], numArray4[index29] - 1].active(false);
              Main.tile[numArray2[index26], numArray4[index29] - 2].active(false);
              Main.tile[numArray2[index26], numArray4[index29] - 3].active(false);
              WorldGen.PlaceTile(numArray2[index26], numArray4[index29] - 1, 10, true, style: style1);
            }
          }
          break;
        }
      }
      bool flag9 = false;
      for (int index30 = 0; index30 < 10; ++index30)
      {
        bool[] flagArray5 = new bool[10];
        for (int index31 = 0; index31 < 5; ++index31)
        {
          if (flagArray1[index31, index30])
          {
            flag9 = true;
            flagArray5[index31] = true;
          }
        }
        if (flag9)
        {
          bool flag10 = true;
          while (flag10)
          {
            int index32 = WorldGen.genRand.Next(5);
            if (flagArray5[index32])
            {
              int num12 = WorldGen.genRand.Next(numArray1[index32] + 2, numArray2[index32] - 1);
              int num13 = WorldGen.genRand.Next(numArray1[index32] + 2, numArray2[index32] - 1);
              int num14 = 0;
              while (num13 - num12 < 2 || num13 - num12 > 5)
              {
                num12 = WorldGen.genRand.Next(numArray1[index32] + 2, numArray2[index32] - 1);
                num13 = WorldGen.genRand.Next(numArray1[index32] + 2, numArray2[index32] - 1);
                ++num14;
                if (num14 > 10000)
                  break;
              }
              if (num14 > 10000)
                break;
              for (int index33 = num12; index33 <= num13 && index33 >= 10 && index33 <= Main.maxTilesX - 10; ++index33)
              {
                if (Main.tile[index33, numArray3[index30] - 1].active() || Main.tile[index33, numArray3[index30] - 1].liquid > (byte) 0)
                  flag10 = false;
              }
              if (flag10)
              {
                for (int i2 = num12; i2 <= num13 && i2 >= 10 && i2 <= Main.maxTilesX - 10; ++i2)
                {
                  Main.tile[i2, numArray3[index30]].active(false);
                  WorldGen.PlaceTile(i2, numArray3[index30], 19, true, true, style: style2);
                }
              }
              flag10 = false;
            }
          }
          break;
        }
      }
    }

    public static void HellHouse(int i, int j, byte type = 76, byte wall = 13)
    {
      int width = WorldGen.genRand.Next(8, 20);
      int num1 = WorldGen.genRand.Next(1, 3);
      int num2 = WorldGen.genRand.Next(4, 13);
      int i1 = i;
      int j1 = j;
      for (int index = 0; index < num1; ++index)
      {
        int height = WorldGen.genRand.Next(5, 9);
        WorldGen.HellRoom(i1, j1, width, height, type, wall);
        j1 -= height;
      }
      int j2 = j;
      for (int index = 0; index < num2; ++index)
      {
        int height = WorldGen.genRand.Next(5, 9);
        j2 += height;
        WorldGen.HellRoom(i1, j2, width, height, type, wall);
      }
      for (int index1 = i - width / 2; index1 <= i + width / 2; ++index1)
      {
        int index2 = j;
        while (index2 < Main.maxTilesY && (Main.tile[index1, index2].active() && (Main.tile[index1, index2].type == (ushort) 76 || Main.tile[index1, index2].type == (ushort) 75) || Main.tile[i, index2].wall == (ushort) 13 || Main.tile[i, index2].wall == (ushort) 14))
          ++index2;
        int num3 = 6 + WorldGen.genRand.Next(3);
        while (index2 < Main.maxTilesY && !Main.tile[index1, index2].active())
        {
          --num3;
          Main.tile[index1, index2].active(true);
          Main.tile[index1, index2].type = (ushort) 57;
          ++index2;
          if (num3 <= 0)
            break;
        }
      }
      int index3 = j;
      while (index3 < Main.maxTilesY && (Main.tile[i, index3].active() && (Main.tile[i, index3].type == (ushort) 76 || Main.tile[i, index3].type == (ushort) 75) || Main.tile[i, index3].wall == (ushort) 13 || Main.tile[i, index3].wall == (ushort) 14))
        ++index3;
      int index4 = index3 - 1;
      int maxValue = index4;
      while (Main.tile[i, index4].active() && (Main.tile[i, index4].type == (ushort) 76 || Main.tile[i, index4].type == (ushort) 75) || Main.tile[i, index4].wall == (ushort) 13 || Main.tile[i, index4].wall == (ushort) 14)
      {
        --index4;
        if (Main.tile[i, index4].active() && (Main.tile[i, index4].type == (ushort) 76 || Main.tile[i, index4].type == (ushort) 75))
        {
          int num4 = WorldGen.genRand.Next(i - width / 2 + 1, i + width / 2 - 1);
          int num5 = WorldGen.genRand.Next(i - width / 2 + 1, i + width / 2 - 1);
          if (num4 > num5)
          {
            int num6 = num4;
            num4 = num5;
            num5 = num6;
          }
          if (num4 == num5)
          {
            if (num4 < i)
              ++num5;
            else
              --num4;
          }
          for (int index5 = num4; index5 <= num5; ++index5)
          {
            if (Main.tile[index5, index4 - 1].wall == (ushort) 13)
              Main.tile[index5, index4].wall = (ushort) 13;
            if (Main.tile[index5, index4 - 1].wall == (ushort) 14)
              Main.tile[index5, index4].wall = (ushort) 14;
            Main.tile[index5, index4].type = (ushort) 19;
            Main.tile[index5, index4].active(true);
          }
          --index4;
        }
      }
      int minValue = index4;
      double num7 = (double) ((maxValue - minValue) * width) * 0.02;
      for (int index6 = 0; (double) index6 < num7; ++index6)
      {
        int num8 = WorldGen.genRand.Next(i - width / 2, i + width / 2 + 1);
        int num9 = WorldGen.genRand.Next(minValue, maxValue);
        int num10 = WorldGen.genRand.Next(3, 8);
        for (int index7 = num8 - num10; index7 <= num8 + num10; ++index7)
        {
          for (int index8 = num9 - num10; index8 <= num9 + num10; ++index8)
          {
            double num11 = (double) Math.Abs(index7 - num8);
            double num12 = (double) Math.Abs(index8 - num9);
            if (Math.Sqrt(num11 * num11 + num12 * num12) < (double) num10 * 0.4)
            {
              try
              {
                if (Main.tile[index7, index8].type == (ushort) 76 || Main.tile[index7, index8].type == (ushort) 19)
                  Main.tile[index7, index8].active(false);
                Main.tile[index7, index8].wall = (ushort) 0;
              }
              catch
              {
              }
            }
          }
        }
      }
    }

    public static void HellRoom(int i, int j, int width, int height, byte type = 76, byte wall = 13)
    {
      if (j > Main.maxTilesY - 40)
        return;
      for (int index1 = i - width / 2; index1 <= i + width / 2; ++index1)
      {
        for (int index2 = j - height; index2 <= j; ++index2)
        {
          try
          {
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].type = (ushort) type;
            Main.tile[index1, index2].liquid = (byte) 0;
            Main.tile[index1, index2].lava(false);
          }
          catch
          {
          }
        }
      }
      for (int index3 = i - width / 2 + 1; index3 <= i + width / 2 - 1; ++index3)
      {
        for (int index4 = j - height + 1; index4 <= j - 1; ++index4)
        {
          try
          {
            Main.tile[index3, index4].active(false);
            Main.tile[index3, index4].wall = (ushort) wall;
            Main.tile[index3, index4].liquid = (byte) 0;
            Main.tile[index3, index4].lava(false);
          }
          catch
          {
          }
        }
      }
    }

    public static void templeCleaner(int x, int y)
    {
      int index1 = x;
      int index2 = y;
      int num = 0;
      if (Main.tile[x + 1, y].active() && Main.tile[x + 1, y].type == (ushort) 226)
        ++num;
      if (Main.tile[x - 1, y].active() && Main.tile[x - 1, y].type == (ushort) 226)
        ++num;
      if (Main.tile[x, y + 1].active() && Main.tile[x, y + 1].type == (ushort) 226)
        ++num;
      if (Main.tile[x, y - 1].active() && Main.tile[x, y - 1].type == (ushort) 226)
        ++num;
      if (Main.tile[x, y].active() && Main.tile[x, y].type == (ushort) 226)
      {
        if (num > 1)
          return;
        Main.tile[index1, index2].active(false);
        Main.tile[index1, index2].wall = (ushort) 87;
      }
      else
      {
        if (Main.tile[x, y].active() || num != 3)
          return;
        Main.tile[index1, index2].active(true);
        Main.tile[index1, index2].type = (ushort) 226;
        Main.tile[index1, index2].liquid = (byte) 0;
        Main.tile[index1, index2].slope((byte) 0);
        Main.tile[index1, index2].halfBrick(false);
      }
    }

    public static Vector2D templePather(Vector2D templePath, int destX, int destY)
    {
      int x = (int) templePath.X;
      int y = (int) templePath.Y;
      int num1 = WorldGen.genRand.Next(5, 20);
      int num2 = WorldGen.genRand.Next(2, 5);
      while (num1 > 0 && (x != destX || y != destY))
      {
        --num1;
        if (x > destX)
          --x;
        if (x < destX)
          ++x;
        if (y > destY)
          --y;
        if (y < destY)
          ++y;
        for (int index1 = x - num2; index1 < x + num2; ++index1)
        {
          for (int index2 = y - num2; index2 < y + num2; ++index2)
          {
            Main.tile[index1, index2].active(false);
            Main.tile[index1, index2].wall = (ushort) 87;
          }
        }
      }
      return new Vector2D((double) x, (double) y);
    }

    public static void outerTempled(int x, int y)
    {
      if (Main.tile[x, y].active() & Main.tile[x, y].type == (ushort) 226 || Main.tile[x, y].wall == (ushort) 87)
        return;
      int num = 6;
      for (int index1 = x - num; index1 <= x + num; ++index1)
      {
        for (int index2 = y - num; index2 <= y + num; ++index2)
        {
          if (!Main.tile[index1, index2].active() && Main.tile[index1, index2].wall == (ushort) 87)
          {
            int index3 = x;
            int index4 = y;
            Main.tile[index3, index4].active(true);
            Main.tile[index3, index4].type = (ushort) 226;
            Main.tile[index3, index4].liquid = (byte) 0;
            Main.tile[index3, index4].slope((byte) 0);
            Main.tile[index3, index4].halfBrick(false);
            return;
          }
        }
      }
    }

    public static void makeTemple(int x, int y)
    {
      Microsoft.Xna.Framework.Rectangle[] rectangleArray = new Microsoft.Xna.Framework.Rectangle[100];
      double num1 = (double) Main.maxTilesX / 4200.0;
      int maxValue = WorldGen.genRand.Next((int) (num1 * 10.0), (int) (num1 * 16.0));
      if (WorldGen.drunkWorldGen)
        maxValue *= 3;
      else if (WorldGen.getGoodWorldGen)
        maxValue *= 3;
      else if (WorldGen.remixWorldGen)
        maxValue *= 2;
      int num2 = 1;
      if (WorldGen.genRand.Next(2) == 0)
        num2 = -1;
      int num3 = num2;
      int num4 = x;
      int num5 = y;
      int num6 = x;
      int num7 = y;
      int num8 = WorldGen.genRand.Next(1, 3);
      int num9 = 0;
      for (int index1 = 0; index1 < maxValue; ++index1)
      {
        ++num9;
        int num10 = num2;
        int num11 = num6;
        int num12 = num7;
        bool flag = true;
        int width1 = 0;
        int height1 = 0;
        int num13 = -10;
        Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(num11 - width1 / 2, num12 - height1 / 2, width1, height1);
        while (flag)
        {
          int num14 = num6;
          int num15 = num7;
          int width2 = WorldGen.genRand.Next(25, 50);
          int height2 = WorldGen.genRand.Next(20, 35);
          if (height2 > width2)
            height2 = width2;
          if (index1 == maxValue - 1)
          {
            int num16 = WorldGen.genRand.Next(55, 65);
            int num17 = WorldGen.genRand.Next(45, 50);
            if (num17 > num16)
              num17 = num16;
            width2 = (int) ((double) num16 * 1.6);
            height2 = (int) ((double) num17 * 1.35);
            num15 += WorldGen.genRand.Next(5, 10);
          }
          if (num9 > num8)
          {
            num12 = num15 + (WorldGen.genRand.Next(height2 + 1, height2 + 3) + num13);
            num11 = num14 + WorldGen.genRand.Next(-5, 6);
            num10 = num2 * -1;
          }
          else
          {
            num11 = num14 + (WorldGen.genRand.Next(width2 + 1, width2 + 3) + num13) * num10;
            num12 = num15 + WorldGen.genRand.Next(-5, 6);
          }
          flag = false;
          rectangle = new Microsoft.Xna.Framework.Rectangle(num11 - width2 / 2, num12 - height2 / 2, width2, height2);
          for (int index2 = 0; index2 < index1; ++index2)
          {
            if (rectangle.Intersects(rectangleArray[index2]))
              flag = true;
            if (WorldGen.genRand.Next(100) == 0)
              ++num13;
          }
        }
        if (num9 > num8)
        {
          ++num8;
          num9 = 1;
        }
        rectangleArray[index1] = rectangle;
        num2 = num10;
        num6 = num11;
        num7 = num12;
      }
      for (int index3 = 0; index3 < maxValue; ++index3)
      {
        for (int index4 = 0; index4 < 2; ++index4)
        {
          for (int index5 = 0; index5 < maxValue; ++index5)
          {
            for (int index6 = 0; index6 < 2; ++index6)
            {
              int x1 = rectangleArray[index3].X;
              if (index4 == 1)
                x1 += rectangleArray[index3].Width - 1;
              int y1 = rectangleArray[index3].Y;
              int num18 = y1 + rectangleArray[index3].Height;
              int x2 = rectangleArray[index5].X;
              if (index6 == 1)
                x2 += rectangleArray[index5].Width - 1;
              int y2 = rectangleArray[index5].Y;
              int num19 = y2 + rectangleArray[index5].Height;
              while (x1 != x2 || y1 != y2 || num18 != num19)
              {
                if (x1 < x2)
                  ++x1;
                if (x1 > x2)
                  --x1;
                if (y1 < y2)
                  ++y1;
                if (y1 > y2)
                  --y1;
                if (num18 < num19)
                  ++num18;
                if (num18 > num19)
                  --num18;
                int index7 = x1;
                for (int index8 = y1; index8 < num18; ++index8)
                {
                  Main.tile[index7, index8].active(true);
                  Main.tile[index7, index8].type = (ushort) 226;
                  Main.tile[index7, index8].liquid = (byte) 0;
                  Main.tile[index7, index8].slope((byte) 0);
                  Main.tile[index7, index8].halfBrick(false);
                }
              }
            }
          }
        }
      }
      for (int index9 = 0; index9 < maxValue; ++index9)
      {
        if (true)
        {
          for (int x3 = rectangleArray[index9].X; x3 < rectangleArray[index9].X + rectangleArray[index9].Width; ++x3)
          {
            for (int y3 = rectangleArray[index9].Y; y3 < rectangleArray[index9].Y + rectangleArray[index9].Height; ++y3)
            {
              Main.tile[x3, y3].active(true);
              Main.tile[x3, y3].type = (ushort) 226;
              Main.tile[x3, y3].liquid = (byte) 0;
              Main.tile[x3, y3].slope((byte) 0);
              Main.tile[x3, y3].halfBrick(false);
            }
          }
          int x4 = rectangleArray[index9].X;
          int num20 = x4 + rectangleArray[index9].Width;
          int y4 = rectangleArray[index9].Y;
          int num21 = y4 + rectangleArray[index9].Height;
          int num22 = x4 + WorldGen.genRand.Next(3, 8);
          int num23 = num20 - WorldGen.genRand.Next(3, 8);
          int num24 = y4 + WorldGen.genRand.Next(3, 8);
          int num25 = num21 - WorldGen.genRand.Next(3, 8);
          int num26 = num22;
          int num27 = num23;
          int num28 = num24;
          int num29 = num25;
          int num30 = (num22 + num23) / 2;
          int num31 = (num24 + num25) / 2;
          for (int index10 = num22; index10 < num23; ++index10)
          {
            for (int index11 = num24; index11 < num25; ++index11)
            {
              if (WorldGen.genRand.Next(20) == 0)
                num28 += WorldGen.genRand.Next(-1, 2);
              if (WorldGen.genRand.Next(20) == 0)
                num29 += WorldGen.genRand.Next(-1, 2);
              if (WorldGen.genRand.Next(20) == 0)
                num26 += WorldGen.genRand.Next(-1, 2);
              if (WorldGen.genRand.Next(20) == 0)
                num27 += WorldGen.genRand.Next(-1, 2);
              if (num26 < num22)
                num26 = num22;
              if (num27 > num23)
                num27 = num23;
              if (num28 < num24)
                num28 = num24;
              if (num29 > num25)
                num29 = num25;
              if (num26 > num30)
                num26 = num30;
              if (num27 < num30)
                num27 = num30;
              if (num28 > num31)
                num28 = num31;
              if (num29 < num31)
                num29 = num31;
              if (index10 >= num26 && index10 < num27 & index11 >= num28 && index11 <= num29)
              {
                Main.tile[index10, index11].active(false);
                Main.tile[index10, index11].wall = (ushort) 87;
              }
            }
          }
          for (int index12 = num25; index12 > num24; --index12)
          {
            for (int index13 = num23; index13 > num22; --index13)
            {
              if (WorldGen.genRand.Next(20) == 0)
                num28 += WorldGen.genRand.Next(-1, 2);
              if (WorldGen.genRand.Next(20) == 0)
                num29 += WorldGen.genRand.Next(-1, 2);
              if (WorldGen.genRand.Next(20) == 0)
                num26 += WorldGen.genRand.Next(-1, 2);
              if (WorldGen.genRand.Next(20) == 0)
                num27 += WorldGen.genRand.Next(-1, 2);
              if (num26 < num22)
                num26 = num22;
              if (num27 > num23)
                num27 = num23;
              if (num28 < num24)
                num28 = num24;
              if (num29 > num25)
                num29 = num25;
              if (num26 > num30)
                num26 = num30;
              if (num27 < num30)
                num27 = num30;
              if (num28 > num31)
                num28 = num31;
              if (num29 < num31)
                num29 = num31;
              if (index13 >= num26 && index13 < num27 & index12 >= num28 && index12 <= num29)
              {
                Main.tile[index13, index12].active(false);
                Main.tile[index13, index12].wall = (ushort) 87;
              }
            }
          }
        }
      }
      Vector2D templePath;
      // ISSUE: explicit constructor call
      ((Vector2D) ref templePath).\u002Ector((double) num4, (double) num5);
      for (int index14 = 0; index14 < maxValue; ++index14)
      {
        Microsoft.Xna.Framework.Rectangle rectangle = rectangleArray[index14];
        rectangle.X += 8;
        rectangle.Y += 8;
        rectangle.Width -= 16;
        rectangle.Height -= 16;
        bool flag1 = true;
        while (flag1)
        {
          int destX = WorldGen.genRand.Next(rectangle.X, rectangle.X + rectangle.Width);
          int destY = WorldGen.genRand.Next(rectangle.Y, rectangle.Y + rectangle.Height);
          if (index14 == maxValue - 1)
          {
            destX = rectangle.X + rectangle.Width / 2 + WorldGen.genRand.Next(-10, 10);
            destY = rectangle.Y + rectangle.Height / 2 + WorldGen.genRand.Next(-10, 10);
          }
          templePath = WorldGen.templePather(templePath, destX, destY);
          if (templePath.X == (double) destX && templePath.Y == (double) destY)
            flag1 = false;
        }
        if (index14 < maxValue - 1)
        {
          if (WorldGen.genRand.Next(3) != 0)
          {
            int index15 = index14 + 1;
            if (rectangleArray[index15].Y >= rectangleArray[index14].Y + rectangleArray[index14].Height)
            {
              rectangle.X = rectangleArray[index15].X;
              if (index14 == 0)
              {
                if (num2 > 0)
                  rectangle.X += (int) ((double) rectangleArray[index15].Width * 0.8);
                else
                  rectangle.X += (int) ((double) rectangleArray[index15].Width * 0.2);
              }
              else if (rectangleArray[index15].X < rectangleArray[index14].X)
                rectangle.X += (int) ((double) rectangleArray[index15].Width * 0.2);
              else
                rectangle.X += (int) ((double) rectangleArray[index15].Width * 0.8);
              rectangle.Y = rectangleArray[index15].Y;
            }
            else
            {
              rectangle.X = (rectangleArray[index14].X + rectangleArray[index14].Width / 2 + rectangleArray[index15].X + rectangleArray[index15].Width / 2) / 2;
              rectangle.Y = (int) ((double) rectangleArray[index15].Y + (double) rectangleArray[index15].Height * 0.8);
            }
            int x5 = rectangle.X;
            int y5 = rectangle.Y;
            bool flag2 = true;
            while (flag2)
            {
              int destX = WorldGen.genRand.Next(x5 - 6, x5 + 7);
              int destY = WorldGen.genRand.Next(y5 - 6, y5 + 7);
              templePath = WorldGen.templePather(templePath, destX, destY);
              if (templePath.X == (double) destX && templePath.Y == (double) destY)
                flag2 = false;
            }
          }
          else
          {
            int index16 = index14 + 1;
            int num32 = (rectangleArray[index14].X + rectangleArray[index14].Width / 2 + rectangleArray[index16].X + rectangleArray[index16].Width / 2) / 2;
            int num33 = (rectangleArray[index14].Y + rectangleArray[index14].Height / 2 + rectangleArray[index16].Y + rectangleArray[index16].Height / 2) / 2;
            bool flag3 = true;
            while (flag3)
            {
              int destX = WorldGen.genRand.Next(num32 - 6, num32 + 7);
              int destY = WorldGen.genRand.Next(num33 - 6, num33 + 7);
              templePath = WorldGen.templePather(templePath, destX, destY);
              if (templePath.X == (double) destX && templePath.Y == (double) destY)
                flag3 = false;
            }
          }
        }
      }
      int num34 = Main.maxTilesX - 20;
      int num35 = 20;
      int num36 = Main.maxTilesY - 20;
      int num37 = 20;
      for (int index = 0; index < maxValue; ++index)
      {
        if (rectangleArray[index].X < num34)
          num34 = rectangleArray[index].X;
        if (rectangleArray[index].X + rectangleArray[index].Width > num35)
          num35 = rectangleArray[index].X + rectangleArray[index].Width;
        if (rectangleArray[index].Y < num36)
          num36 = rectangleArray[index].Y;
        if (rectangleArray[index].Y + rectangleArray[index].Height > num37)
          num37 = rectangleArray[index].Y + rectangleArray[index].Height;
      }
      int num38 = num34 - 10;
      int num39 = num35 + 10;
      int num40 = num36 - 10;
      int num41 = num37 + 10;
      for (int x6 = num38; x6 < num39; ++x6)
      {
        for (int y6 = num40; y6 < num41; ++y6)
          WorldGen.outerTempled(x6, y6);
      }
      for (int x7 = num39; x7 >= num38; --x7)
      {
        for (int y7 = num40; y7 < num41 / 2; ++y7)
          WorldGen.outerTempled(x7, y7);
      }
      for (int y8 = num40; y8 < num41; ++y8)
      {
        for (int x8 = num38; x8 < num39; ++x8)
          WorldGen.outerTempled(x8, y8);
      }
      for (int y9 = num41; y9 >= num40; --y9)
      {
        for (int x9 = num38; x9 < num39; ++x9)
          WorldGen.outerTempled(x9, y9);
      }
      int num42 = num5;
      int num43 = -num3;
      Vector2D vector2D;
      // ISSUE: explicit constructor call
      ((Vector2D) ref vector2D).\u002Ector((double) num4, (double) num5);
      int num44 = WorldGen.genRand.Next(2, 5);
      bool flag4 = true;
      int num45 = 0;
      int num46 = WorldGen.genRand.Next(9, 14);
      while (flag4)
      {
        ++num45;
        if (num45 >= num46)
        {
          num45 = 0;
          --vector2D.Y;
        }
        vector2D.X += (double) num43;
        int x10 = (int) vector2D.X;
        flag4 = false;
        for (int index = (int) vector2D.Y - num44; (double) index < vector2D.Y + (double) num44; ++index)
        {
          if (Main.tile[x10, index].wall == (ushort) 87 || Main.tile[x10, index].active() && Main.tile[x10, index].type == (ushort) 226)
            flag4 = true;
          if (Main.tile[x10, index].active() && Main.tile[x10, index].type == (ushort) 226)
          {
            if (index > num42)
              num42 = index;
            Main.tile[x10, index].active(false);
            Main.tile[x10, index].wall = (ushort) 87;
          }
        }
      }
      int num47 = num42 + 2;
      int i1 = num4;
      int index17 = num5;
      while (!Main.tile[i1, index17].active())
      {
        ++index17;
        if (index17 >= num47)
        {
          index17 = num47;
          Main.tile[i1, index17].ClearEverything();
          Main.tile[i1, index17].active(true);
          Main.tile[i1, index17].type = (ushort) 226;
          break;
        }
      }
      int j1 = index17 - 4;
      int index18 = j1;
      while (Main.tile[i1, index18].active() && Main.tile[i1, index18].type == (ushort) 226 || Main.tile[i1, index18].wall == (ushort) 87)
        --index18;
      int num48 = index18 + 2;
      for (int index19 = i1 - 1; index19 <= i1 + 1; ++index19)
      {
        for (int index20 = num48; index20 <= j1; ++index20)
        {
          Main.tile[index19, index20].active(true);
          Main.tile[index19, index20].type = (ushort) 226;
          Main.tile[index19, index20].liquid = (byte) 0;
          Main.tile[index19, index20].slope((byte) 0);
          Main.tile[index19, index20].halfBrick(false);
        }
      }
      for (int index21 = i1 - 4; index21 <= i1 + 4; ++index21)
      {
        for (int index22 = j1 - 1; index22 < j1 + 3; ++index22)
        {
          Main.tile[index21, index22].active(false);
          Main.tile[index21, index22].wall = (ushort) 87;
        }
      }
      for (int index23 = i1 - 1; index23 <= i1 + 1; ++index23)
      {
        for (int index24 = j1 - 5; index24 <= j1 + 8; ++index24)
        {
          Main.tile[index23, index24].active(true);
          Main.tile[index23, index24].type = (ushort) 226;
          Main.tile[index23, index24].liquid = (byte) 0;
          Main.tile[index23, index24].slope((byte) 0);
          Main.tile[index23, index24].halfBrick(false);
        }
      }
      for (int index25 = i1 - 3; index25 <= i1 + 3; ++index25)
      {
        for (int index26 = j1 - 2; index26 < j1 + 3; ++index26)
        {
          if (index26 >= j1 || index25 < num4 - 1 || index25 > num4 + 1)
          {
            Main.tile[index25, index26].active(false);
            Main.tile[index25, index26].wall = (ushort) 87;
          }
        }
      }
      WorldGen.PlaceTile(i1, j1, 10, true, style: 11);
      for (int x11 = num38; x11 < num39; ++x11)
      {
        for (int y10 = num40; y10 < num41; ++y10)
          WorldGen.templeCleaner(x11, y10);
      }
      for (int y11 = num41; y11 >= num40; --y11)
      {
        for (int x12 = num39; x12 >= num38; --x12)
          WorldGen.templeCleaner(x12, y11);
      }
      for (int index27 = num38; index27 < num39; ++index27)
      {
        for (int index28 = num40; index28 < num41; ++index28)
        {
          bool flag5 = true;
          for (int index29 = index27 - 1; index29 <= index27 + 1; ++index29)
          {
            for (int index30 = index28 - 1; index30 <= index28 + 1; ++index30)
            {
              if ((!Main.tile[index29, index30].active() || Main.tile[index29, index30].type != (ushort) 226) && Main.tile[index29, index30].wall != (ushort) 87)
              {
                flag5 = false;
                break;
              }
            }
          }
          if (flag5)
            Main.tile[index27, index28].wall = (ushort) 87;
        }
      }
      int num49 = 0;
      Microsoft.Xna.Framework.Rectangle rectangle1 = rectangleArray[maxValue - 1];
      int num50 = rectangle1.Width / 2;
      int num51 = rectangle1.Height / 2;
      do
      {
        ++num49;
        int i2 = rectangle1.X + num50 + 15 - WorldGen.genRand.Next(30);
        int j2 = rectangle1.Y + num51 + 15 - WorldGen.genRand.Next(30);
        WorldGen.PlaceTile(i2, j2, 237);
        if (Main.tile[i2, j2].type == (ushort) 237)
        {
          GenVars.lAltarX = i2 - (int) Main.tile[i2, j2].frameX / 18;
          GenVars.lAltarY = j2 - (int) Main.tile[i2, j2].frameY / 18;
          goto label_301;
        }
      }
      while (num49 < 1000);
      int num52 = rectangle1.X + num50;
      int num53 = rectangle1.Y + num51;
      int index31 = num52 + WorldGen.genRand.Next(-10, 11);
      int index32 = num53 + WorldGen.genRand.Next(-10, 11);
      while (!Main.tile[index31, index32].active())
        ++index32;
      Main.tile[index31 - 1, index32].active(true);
      Main.tile[index31 - 1, index32].slope((byte) 0);
      Main.tile[index31 - 1, index32].halfBrick(false);
      Main.tile[index31 - 1, index32].type = (ushort) 226;
      Main.tile[index31, index32].active(true);
      Main.tile[index31, index32].slope((byte) 0);
      Main.tile[index31, index32].halfBrick(false);
      Main.tile[index31, index32].type = (ushort) 226;
      Main.tile[index31 + 1, index32].active(true);
      Main.tile[index31 + 1, index32].slope((byte) 0);
      Main.tile[index31 + 1, index32].halfBrick(false);
      Main.tile[index31 + 1, index32].type = (ushort) 226;
      int num54 = index32 - 2;
      int num55 = index31 - 1;
      for (int index33 = -1; index33 <= 3; ++index33)
      {
        for (int index34 = -1; index34 <= 1; ++index34)
        {
          x = num55 + index33;
          y = num54 + index34;
          Main.tile[x, y].active(false);
        }
      }
      GenVars.lAltarX = num55;
      GenVars.lAltarY = num54;
      for (int index35 = 0; index35 <= 2; ++index35)
      {
        for (int index36 = 0; index36 <= 1; ++index36)
        {
          x = num55 + index35;
          y = num54 + index36;
          Main.tile[x, y].active(true);
          Main.tile[x, y].type = (ushort) 237;
          Main.tile[x, y].frameX = (short) (index35 * 18);
          Main.tile[x, y].frameY = (short) (index36 * 18);
        }
      }
      for (int index37 = 0; index37 <= 2; ++index37)
      {
        for (int index38 = 0; index38 <= 1; ++index38)
        {
          x = num55 + index37;
          y = num54 + index38;
          WorldGen.SquareTileFrame(x, y);
        }
      }
label_301:
      double num56 = (double) maxValue * 1.1 * (1.0 + (double) WorldGen.genRand.Next(-25, 26) * 0.01);
      if (WorldGen.drunkWorldGen)
        num56 *= 1.5;
      int num57 = 0;
      while (num56 > 0.0)
      {
        ++num57;
        int index39 = WorldGen.genRand.Next(maxValue);
        int index40 = WorldGen.genRand.Next(rectangleArray[index39].X, rectangleArray[index39].X + rectangleArray[index39].Width);
        int index41 = WorldGen.genRand.Next(rectangleArray[index39].Y, rectangleArray[index39].Y + rectangleArray[index39].Height);
        if (Main.tile[index40, index41].wall == (ushort) 87 && !Main.tile[index40, index41].active())
        {
          bool flag6 = false;
          if (WorldGen.genRand.Next(2) == 0)
          {
            int num58 = 1;
            if (WorldGen.genRand.Next(2) == 0)
              num58 = -1;
            while (!Main.tile[index40, index41].active())
              index41 += num58;
            int num59 = index41 - num58;
            int num60 = WorldGen.genRand.Next(2);
            int num61 = WorldGen.genRand.Next(3, 10);
            bool flag7 = true;
            for (int index42 = index40 - num61; index42 < index40 + num61; ++index42)
            {
              for (int index43 = num59 - num61; index43 < num59 + num61; ++index43)
              {
                if (Main.tile[index42, index43].active() && (Main.tile[index42, index43].type == (ushort) 10 || Main.tile[index42, index43].type == (ushort) 237))
                {
                  flag7 = false;
                  break;
                }
              }
            }
            if (flag7)
            {
              for (int i3 = index40 - num61; i3 < index40 + num61; ++i3)
              {
                for (int j3 = num59 - num61; j3 < num59 + num61; ++j3)
                {
                  if (WorldGen.SolidTile(i3, j3) && Main.tile[i3, j3].type != (ushort) 232 && !WorldGen.SolidTile(i3, j3 - num58))
                  {
                    Main.tile[i3, j3].type = (ushort) 232;
                    flag6 = true;
                    if (num60 == 0)
                    {
                      Main.tile[i3, j3 - 1].type = (ushort) 232;
                      Main.tile[i3, j3 - 1].active(true);
                      if (WorldGen.drunkWorldGen)
                      {
                        Main.tile[i3, j3 - 2].type = (ushort) 232;
                        Main.tile[i3, j3 - 2].active(true);
                      }
                    }
                    else
                    {
                      Main.tile[i3, j3 + 1].type = (ushort) 232;
                      Main.tile[i3, j3 + 1].active(true);
                      if (WorldGen.drunkWorldGen)
                      {
                        Main.tile[i3, j3 + 2].type = (ushort) 232;
                        Main.tile[i3, j3 + 2].active(true);
                      }
                    }
                    ++num60;
                    if (num60 > 1)
                      num60 = 0;
                  }
                }
              }
            }
            if (flag6)
            {
              num57 = 0;
              --num56;
            }
          }
          else
          {
            int num62 = 1;
            if (WorldGen.genRand.Next(2) == 0)
              num62 = -1;
            while (!Main.tile[index40, index41].active())
              index40 += num62;
            int num63 = index40 - num62;
            int num64 = WorldGen.genRand.Next(2);
            int num65 = WorldGen.genRand.Next(3, 10);
            bool flag8 = true;
            for (int index44 = num63 - num65; index44 < num63 + num65; ++index44)
            {
              for (int index45 = index41 - num65; index45 < index41 + num65; ++index45)
              {
                if (Main.tile[index44, index45].active() && Main.tile[index44, index45].type == (ushort) 10)
                {
                  flag8 = false;
                  break;
                }
              }
            }
            if (flag8)
            {
              for (int i4 = num63 - num65; i4 < num63 + num65; ++i4)
              {
                for (int j4 = index41 - num65; j4 < index41 + num65; ++j4)
                {
                  if (WorldGen.SolidTile(i4, j4) && Main.tile[i4, j4].type != (ushort) 232 && !WorldGen.SolidTile(i4 - num62, j4))
                  {
                    Main.tile[i4, j4].type = (ushort) 232;
                    flag6 = true;
                    if (num64 == 0)
                    {
                      Main.tile[i4 - 1, j4].type = (ushort) 232;
                      Main.tile[i4 - 1, j4].active(true);
                      if (WorldGen.drunkWorldGen)
                      {
                        Main.tile[i4 - 2, j4].type = (ushort) 232;
                        Main.tile[i4 - 2, j4].active(true);
                      }
                    }
                    else
                    {
                      Main.tile[i4 + 1, j4].type = (ushort) 232;
                      Main.tile[i4 + 1, j4].active(true);
                      if (WorldGen.drunkWorldGen)
                      {
                        Main.tile[i4 - 2, j4].type = (ushort) 232;
                        Main.tile[i4 - 2, j4].active(true);
                      }
                    }
                    ++num64;
                    if (num64 > 1)
                      num64 = 0;
                  }
                }
              }
            }
            if (flag6)
            {
              num57 = 0;
              --num56;
            }
          }
        }
        if (num57 > 1000)
        {
          num57 = 0;
          --num56;
        }
      }
      GenVars.tLeft = num38;
      GenVars.tRight = num39;
      GenVars.tTop = num40;
      GenVars.tBottom = num41;
      GenVars.tRooms = maxValue;
    }

    public static void templePart2()
    {
      int tLeft = GenVars.tLeft;
      int tRight = GenVars.tRight;
      int tTop = GenVars.tTop;
      int tBottom = GenVars.tBottom;
      int tRooms = GenVars.tRooms;
      double num1 = (double) tRooms * 1.9 * (1.0 + (double) WorldGen.genRand.Next(-15, 16) * 0.01);
      int num2 = 0;
      while (num1 > 0.0)
      {
        int x2 = WorldGen.genRand.Next(tLeft, tRight);
        int y2 = WorldGen.genRand.Next(tTop, tBottom);
        if (Main.tile[x2, y2].wall == (ushort) 87 && !Main.tile[x2, y2].active())
        {
          if (WorldGen.mayanTrap(x2, y2))
          {
            --num1;
            num2 = 0;
          }
          else
            ++num2;
        }
        else
          ++num2;
        if (num2 > 100)
        {
          num2 = 0;
          --num1;
        }
      }
      Main.tileSolid[232] = false;
      double num3 = (double) tRooms * 0.35 * (1.0 + (double) WorldGen.genRand.Next(-15, 16) * 0.01);
      int contain = 1293;
      int num4 = 0;
      while (num3 > 0.0)
      {
        int i = WorldGen.genRand.Next(tLeft, tRight);
        int j = WorldGen.genRand.Next(tTop, tBottom);
        if (Main.tile[i, j].wall == (ushort) 87 && !Main.tile[i, j].active() && WorldGen.AddBuriedChest(i, j, contain, true, 16))
        {
          --num3;
          num4 = 0;
        }
        ++num4;
        if (num4 > 10000)
          break;
      }
      double num5 = (double) tRooms * 1.25 * (1.0 + (double) WorldGen.genRand.Next(-25, 36) * 0.01);
      int num6 = 0;
      while (num5 > 0.0)
      {
        ++num6;
        int index1 = WorldGen.genRand.Next(tLeft, tRight);
        int index2 = WorldGen.genRand.Next(tTop, tBottom);
        if (Main.tile[index1, index2].wall == (ushort) 87 && !Main.tile[index1, index2].active())
        {
          int i = index1;
          int index3 = index2;
          while (!Main.tile[i, index3].active())
          {
            ++index3;
            if (index3 > tBottom)
              break;
          }
          int j = index3 - 1;
          if (j <= tBottom)
          {
            WorldGen.PlaceTile(i, j, 105, true, style: WorldGen.genRand.Next(43, 46));
            if (Main.tile[i, j].type == (ushort) 105)
              --num5;
          }
        }
      }
      double num7 = (double) tRooms * 1.35 * (1.0 + (double) WorldGen.genRand.Next(-15, 26) * 0.01);
      int num8 = 0;
      while (num7 > 0.0)
      {
        ++num8;
        int index4 = WorldGen.genRand.Next(tLeft, tRight);
        int index5 = WorldGen.genRand.Next(tTop, tBottom);
        if (Main.tile[index4, index5].wall == (ushort) 87 && !Main.tile[index4, index5].active())
        {
          int i = index4;
          int index6 = index5;
          while (!Main.tile[i, index6].active())
          {
            ++index6;
            if (index6 > tBottom)
              break;
          }
          int j = index6 - 1;
          if (j <= tBottom)
          {
            switch (WorldGen.genRand.Next(3))
            {
              case 0:
                WorldGen.PlaceTile(i, j, 18, true, style: 10);
                if (Main.tile[i, j].type == (ushort) 18)
                {
                  --num7;
                  break;
                }
                break;
              case 1:
                WorldGen.PlaceTile(i, j, 14, true, style: 9);
                if (Main.tile[i, j].type == (ushort) 14)
                {
                  --num7;
                  break;
                }
                break;
              case 2:
                WorldGen.PlaceTile(i, j, 15, true, style: 12);
                if (Main.tile[i, j].type == (ushort) 15)
                {
                  --num7;
                  break;
                }
                break;
            }
          }
        }
        if (num8 > 10000)
          break;
      }
      int num9 = 1;
      if (Main.maxTilesX > 4200)
        ++num9;
      if (Main.maxTilesX > 6400)
        num9 += WorldGen.genRand.Next(2);
      int num10 = 0;
      while (num9 > 0)
      {
        ++num10;
        int i = WorldGen.genRand.Next(tLeft, tRight);
        int j = WorldGen.genRand.Next(tTop, tBottom);
        if (Main.tile[i, j].wall == (ushort) 87 && !Main.tile[i, j].active())
        {
          bool flag = false;
          for (int index7 = -70; index7 <= 70; ++index7)
          {
            for (int index8 = -70; index8 <= 70; ++index8)
            {
              int x = index7 + i;
              int y = index8 + j;
              if (WorldGen.InWorld(x, y, 5))
              {
                Tile tile = Main.tile[x, y];
                if (tile.active())
                {
                  if (tile.type == (ushort) 240)
                  {
                    flag = true;
                    break;
                  }
                  if (index7 >= -4 && index7 <= 4 && index8 >= -4 && index8 <= 4 && tile.type == (ushort) 226)
                  {
                    flag = true;
                    break;
                  }
                }
              }
            }
            if (flag)
              break;
          }
          if (!flag)
          {
            if (WorldGen.PlaceTile(i, j, 240, true, style: 88))
              --num9;
          }
          else
            continue;
        }
        if (num10 > 10000)
          break;
      }
      Main.tileSolid[232] = true;
    }

    public static bool nearPicture(int x, int y)
    {
      for (int index1 = x - 4; index1 <= x + 3; ++index1)
      {
        for (int index2 = y - 3; index2 <= y + 2; ++index2)
        {
          if (Main.tile[index1, index2].active())
            return true;
        }
      }
      return false;
    }

    public static bool nearPicture2(int x, int y)
    {
      if (Main.tile[x, y].wall != (ushort) 7 && Main.tile[x, y].wall != (ushort) 8 && Main.tile[x, y].wall != (ushort) 9)
      {
        for (int index1 = x - 8; index1 <= x + 8; ++index1)
        {
          for (int index2 = y - 5; index2 <= y + 5; ++index2)
          {
            if (Main.tile[index1, index2].active() && (Main.tile[index1, index2].type == (ushort) 240 || Main.tile[index1, index2].type == (ushort) 241 || Main.tile[index1, index2].type == (ushort) 242))
              return true;
          }
        }
      }
      else
      {
        for (int index3 = x - 15; index3 <= x + 15; ++index3)
        {
          for (int index4 = y - 10; index4 <= y + 10; ++index4)
          {
            if (Main.tile[index3, index4].active() && (Main.tile[index3, index4].type == (ushort) 240 || Main.tile[index3, index4].type == (ushort) 241 || Main.tile[index3, index4].type == (ushort) 242))
              return true;
          }
        }
      }
      return false;
    }

    private static void ShimmerCleanUp()
    {
      WorldGen.ShimmerRemoveWater();
      int num1 = 120;
      int num2 = 90;
      int num3 = (int) GenVars.shimmerPosition.X - num1;
      int num4 = (int) GenVars.shimmerPosition.X + num1;
      int num5 = (int) GenVars.shimmerPosition.Y - num1;
      int num6 = (int) GenVars.shimmerPosition.Y + num1;
      int num7 = num1 / 4;
      for (int j = num5; j <= num6; ++j)
      {
        for (int i = num3; i <= num4; ++i)
        {
          if ((int) Math.Sqrt(Math.Pow(Math.Abs((double) i - GenVars.shimmerPosition.X), 2.0) + Math.Pow(Math.Abs((double) j - GenVars.shimmerPosition.Y), 2.0)) < num1)
          {
            if (Main.tile[i, j].type == (ushort) 22 || Main.tile[i, j].type == (ushort) 204)
              Main.tile[i, j].type = (ushort) 1;
            if (Main.tile[i, j].type == (ushort) 51 || Main.tile[i, j].type == (ushort) 56 || Main.tile[i, j].type == (ushort) 229 || Main.tile[i, j].type == (ushort) 230 || Main.tile[i, j].type == (ushort) 659)
              Main.tile[i, j].active(false);
            if (TileID.Sets.Conversion.Moss[(int) Main.tile[i, j].type])
              Main.tile[i, j].type = (ushort) 1;
            if (Main.tile[i, j].type == (ushort) 184)
              Main.tile[i, j].active(false);
          }
          if (((double) j <= GenVars.shimmerPosition.Y ? (int) Math.Sqrt(Math.Pow(Math.Abs((double) i - GenVars.shimmerPosition.X) * (1.0 + WorldGen.genRand.NextDouble() * 0.02), 2.0) + Math.Pow(Math.Abs((double) j - GenVars.shimmerPosition.Y) * 1.4 * (1.0 + WorldGen.genRand.NextDouble() * 0.02), 2.0)) : (int) Math.Sqrt(Math.Pow(Math.Abs((double) i - GenVars.shimmerPosition.X) * (1.0 + WorldGen.genRand.NextDouble() * 0.02), 2.0) + Math.Pow(Math.Abs((double) j - GenVars.shimmerPosition.Y) * 1.2 * (1.0 + WorldGen.genRand.NextDouble() * 0.02), 2.0))) < num2)
            WorldGen.Convert(i, j, 0, 3);
        }
      }
      int x1 = (int) GenVars.shimmerPosition.X;
      int y1 = (int) GenVars.shimmerPosition.Y;
      byte num8 = 127;
      Liquid.tilesIgnoreWater(true);
      while ((int) Main.tile[x1, y1].liquid <= (int) num8 || !Main.tile[x1, y1].shimmer())
      {
        for (; !Main.tile[x1, y1].active(); --x1)
        {
          Main.tile[x1, y1].liquid = num8;
          Main.tile[x1, y1].shimmer(true);
        }
        for (int x2 = (int) GenVars.shimmerPosition.X; !Main.tile[x2, y1].active(); ++x2)
        {
          Main.tile[x2, y1].liquid = num8;
          Main.tile[x2, y1].shimmer(true);
        }
        x1 = (int) GenVars.shimmerPosition.X;
        ++y1;
        num8 = byte.MaxValue;
        if (Main.tile[x1, y1].active())
          break;
      }
      if (WorldGen.tenthAnniversaryWorldGen)
      {
        int num9 = 170;
        for (int x3 = (int) GenVars.shimmerPosition.X - num9; (double) x3 <= GenVars.shimmerPosition.X + (double) num9; ++x3)
        {
          for (int y2 = (int) GenVars.shimmerPosition.Y + 40; y2 < Main.maxTilesY - 330 - 100; ++y2)
          {
            if (WorldGen.InWorld(x3, y2))
            {
              if (Main.tile[x3, y2].type == (ushort) 375 || Main.tile[x3, y2].type == (ushort) 374 || Main.tile[x3, y2].type == (ushort) 373)
                Main.tile[x3, y2].active(false);
              if (Main.tile[x3, y2].liquid > (byte) 0 && !Main.tile[x3, y2].shimmer())
                WorldGen.Shimmerator(x3, y2);
            }
          }
        }
      }
      Liquid.tilesIgnoreWater(false);
      for (int i = 10; i < Main.maxTilesX - 10; ++i)
      {
        for (int j = 10; j < Main.maxTilesY - 10; ++j)
        {
          if (Main.tile[i, j].liquid > (byte) 0 && Main.tile[i, j].shimmer() && Main.tile[i, j].type == (ushort) 5)
            WorldGen.KillTile(i, j);
        }
      }
    }

    public static void ShimmerRemoveWater()
    {
      if (!WorldGen.generatingWorld)
        return;
      int num1 = 150;
      int num2 = (int) GenVars.shimmerPosition.X - num1;
      int num3 = (int) GenVars.shimmerPosition.X + num1;
      int num4 = (int) GenVars.shimmerPosition.Y - num1;
      int num5 = (int) GenVars.shimmerPosition.Y + num1 / 2;
      for (int y = num4; y <= num5; ++y)
      {
        for (int x = num2; x <= num3; ++x)
        {
          if (WorldGen.InWorld(x, y) && (int) Math.Sqrt(Math.Pow((double) Math.Abs(x - (int) GenVars.shimmerPosition.X), 2.0) + Math.Pow((double) Math.Abs(y - (int) GenVars.shimmerPosition.Y), 2.0)) < num1 && !Main.tile[x, y].shimmer())
            Main.tile[x, y].liquid = (byte) 0;
        }
      }
    }

    public static bool ShimmerMakeBiome(int X, int Y)
    {
      int num1 = WorldGen.genRand.Next(2);
      double num2 = 0.6;
      double num3 = 1.3;
      double num4 = 0.3;
      if (num1 == 0)
      {
        num2 = 0.55;
        num3 = 2.0;
      }
      double num5 = num2 * (1.05 - WorldGen.genRand.NextDouble() * 0.1);
      double num6 = num3 * (1.05 - WorldGen.genRand.NextDouble() * 0.1);
      double num7 = num4 * (1.0 - WorldGen.genRand.NextDouble() * 0.1);
      int num8 = WorldGen.genRand.Next(105, 125);
      int num9 = (int) ((double) num8 * num7);
      int num10 = (int) ((double) num8 * num5);
      int caveOpenningSize = WorldGen.genRand.Next(9, 13);
      int num11 = X - num8;
      int num12 = X + num8;
      int num13 = Y - num8;
      int num14 = Y + num8;
      for (int y = num13; y <= num14; ++y)
      {
        for (int x = num11; x <= num12; ++x)
        {
          if (!WorldGen.InWorld(x, y, 50) || Main.tile[x, y].type == (ushort) 203 || Main.tile[x, y].type == (ushort) 25)
            return false;
        }
      }
      int num15 = Y;
      if (WorldGen.genRand.Next(4) == 0)
        num15 = Y - WorldGen.genRand.Next(2);
      int num16 = Y - caveOpenningSize;
      if (WorldGen.genRand.Next(4) == 0)
        num16 = Y - caveOpenningSize - WorldGen.genRand.Next(2);
      for (int index1 = num13; index1 <= num14; ++index1)
      {
        for (int index2 = num11; index2 <= num12; ++index2)
        {
          Main.tile[index2, index1].liquid = (byte) 0;
          if (WorldGen.genRand.Next(4) == 0)
            num15 = Y - WorldGen.genRand.Next(2);
          if (WorldGen.genRand.Next(4) == 0)
            num16 = Y - caveOpenningSize + WorldGen.genRand.Next(2);
          int num17 = index1 <= Y ? (int) Math.Sqrt(Math.Pow((double) Math.Abs(index2 - X) * (1.0 + WorldGen.genRand.NextDouble() * 0.02), 2.0) + Math.Pow((double) Math.Abs(index1 - Y) * 1.4 * (1.0 + WorldGen.genRand.NextDouble() * 0.02), 2.0)) : (int) Math.Sqrt(Math.Pow((double) Math.Abs(index2 - X) * (1.0 + WorldGen.genRand.NextDouble() * 0.02), 2.0) + Math.Pow((double) Math.Abs(index1 - Y) * 1.2 * (1.0 + WorldGen.genRand.NextDouble() * 0.02), 2.0));
          if (num17 < num8)
          {
            Main.tile[index2, index1].color((byte) 0);
            Main.tile[index2, index1].wallColor((byte) 0);
            Main.tile[index2, index1].slope((byte) 0);
            Main.tile[index2, index1].halfBrick(false);
            Main.tile[index2, index1].type = (ushort) 1;
            if (index2 > num11 + 5 + WorldGen.genRand.Next(2) && index2 < num12 - 5 - WorldGen.genRand.Next(2))
              Main.tile[index2, index1].active(true);
            if ((double) num17 < (double) num8 * 0.9)
              Main.tile[index2, index1].wall = (ushort) 0;
          }
          int num18 = (int) Math.Sqrt(Math.Pow((double) Math.Abs(index2 - X) * (1.0 + WorldGen.genRand.NextDouble() * 0.02), 2.0) + Math.Pow((double) Math.Abs(index1 - Y) * num6 * (1.0 + WorldGen.genRand.NextDouble() * 0.02), 2.0));
          if (index1 > num16 && index1 < num15)
            Main.tile[index2, index1].active(false);
          if (index1 < num15 && num18 < (int) ((double) num10 * (1.0 + WorldGen.genRand.NextDouble() * 0.02)))
            Main.tile[index2, index1].active(false);
          int num19 = (int) Math.Sqrt(Math.Pow((double) Math.Abs(index2 - X) * (1.0 + WorldGen.genRand.NextDouble() * 0.02), 2.0) + Math.Pow((double) (Math.Abs(index1 - Y) * 2) * (1.0 + WorldGen.genRand.NextDouble() * 0.02), 2.0));
          if (index1 >= Y - 1 && num19 < (int) ((double) num9 * (1.0 + WorldGen.genRand.NextDouble() * 0.025)))
          {
            if (index1 <= Y + 2 || num19 != num9 - 1 || WorldGen.genRand.Next(2) != 0)
              Main.tile[index2, index1].active(false);
            if (index1 >= Y)
            {
              Main.tile[index2, index1].liquid = index1 != Y ? byte.MaxValue : (byte) 127;
              Main.tile[index2, index1].shimmer(true);
            }
          }
        }
      }
      if (num1 == 0)
      {
        int num20 = (int) ((double) X - (double) num8 * num7) - WorldGen.genRand.Next(-15, 1) - 5;
        int num21 = (int) ((double) X + (double) num8 * num7) + WorldGen.genRand.Next(0, 16);
        int index3 = num20;
        int num22 = 0;
        for (; index3 < num21; index3 += WorldGen.genRand.Next(9, 14))
        {
          int index4 = Y - 3;
          while (!Main.tile[index3, index4].active())
            --index4;
          int index5 = index4 - 4;
          int num23 = WorldGen.genRand.Next(5, 10);
          int num24 = WorldGen.genRand.Next(15, 21);
          int index6 = index3 - num23;
          while (num23 > 0)
          {
            for (index6 = index3 - num23; index6 < index3 + num23; ++index6)
            {
              Main.tile[index6, index5].active(true);
              Main.tile[index6, index5].type = (ushort) 1;
            }
            ++num22;
            if (WorldGen.genRand.Next(3) < num22)
            {
              num22 = 0;
              --num23;
              index3 += WorldGen.genRand.Next(-1, 2);
            }
            if (num24 <= 0)
              --num23;
            --num24;
            ++index5;
          }
          int x = index6 - WorldGen.genRand.Next(1, 3);
          Main.tile[x, index5 - 2].active(true);
          Main.tile[x, index5 - 2].type = (ushort) 1;
          Main.tile[x, index5 - 1].active(true);
          Main.tile[x, index5 - 1].type = (ushort) 1;
          Main.tile[x, index5].active(true);
          Main.tile[x, index5].type = (ushort) 1;
          if (WorldGen.genRand.Next(2) == 0)
          {
            Main.tile[x, index5 + 1].active(true);
            Main.tile[x, index5 + 1].type = (ushort) 1;
            WorldGen.PlaceTight(x, index5 + 2);
          }
          else
            WorldGen.PlaceTight(x, index5 + 1);
        }
      }
      WorldGen.ShimmerMakeBiomeOpening(-1, X - num8, Y, caveOpenningSize);
      WorldGen.ShimmerMakeBiomeOpening(1, X + num8, Y, caveOpenningSize);
      int num25 = 70;
      for (int index = 0; index < 500; ++index)
      {
        int checkedX = WorldGen.genRand.Next(X - num25, X + num25);
        int num26 = WorldGen.genRand.Next(Y - 2, Y + 3);
        int num27 = WorldGen.genRand.Next(7);
        int treeTileType = 0;
        switch (num27)
        {
          case 0:
            treeTileType = 583;
            break;
          case 1:
            treeTileType = 584;
            break;
          case 2:
            treeTileType = 585;
            break;
          case 3:
            treeTileType = 586;
            break;
          case 4:
            treeTileType = 587;
            break;
          case 5:
            treeTileType = 588;
            break;
          case 6:
            treeTileType = 589;
            break;
        }
        if (WorldGen.SolidTile(checkedX - 1, num26) && WorldGen.SolidTile(checkedX + 1, num26))
          WorldGen.TryGrowingTreeByType(treeTileType, checkedX, num26);
      }
      return true;
    }

    private static void ShimmerMakeBiomeOpening(int direction, int X, int Y, int caveOpenningSize)
    {
      int i = X;
      --caveOpenningSize;
      bool flag;
      do
      {
        i += direction;
        flag = true;
        for (int j = Y - caveOpenningSize + 1; j < Y - 1; ++j)
        {
          if (WorldGen.SolidTile(i, j))
            flag = false;
          if (WorldGen.SolidTile(i + direction, j))
            flag = false;
          if (WorldGen.SolidTile(i + direction * 2, j))
            flag = false;
          Main.tile[i, j].active(false);
        }
        for (int index = Y - caveOpenningSize; index < Y; ++index)
          Main.tile[i - direction, index].active(false);
        if (WorldGen.SolidTile(i - direction, Y - caveOpenningSize - 1))
          Main.tile[i - direction, Y - caveOpenningSize - 1].wall = (ushort) 0;
        if (WorldGen.SolidTile(i - direction, Y))
          Main.tile[i - direction, Y].wall = (ushort) 0;
        if (WorldGen.genRand.Next(2) == 0)
          Y += WorldGen.genRand.Next(-1, 2);
      }
      while (!flag && i >= 50 && i <= Main.maxTilesX - 50 && Math.Abs(i - X) <= 100);
    }

    private static void Shimminate()
    {
      foreach (KeyValuePair<Point, bool> countedTile in WorldGen.CountedTiles)
      {
        Point key = countedTile.Key;
        Main.tile[key.X, key.Y].shimmer(true);
        Main.tile[key.X, key.Y].liquid = byte.MaxValue;
        if (Main.tile[key.X, key.Y].type == (ushort) 5 || Main.tile[key.X, key.Y].type == (ushort) 56 || Main.tileCut[(int) Main.tile[key.X, key.Y].type] && Main.tile[key.X, key.Y].type != (ushort) 28)
          WorldGen.KillTile(key.X, key.Y);
      }
    }

    public static void Shimmerator(int x, int y, bool jungle = false, bool lavaOk = false)
    {
      WorldGen.numTileCount = 0;
      WorldGen.CountedTiles.Clear();
      WorldGen.ShimmeratorNext(x, y);
      if (WorldGen.numTileCount <= 0 || WorldGen.numTileCount >= WorldGen.maxTileCount)
        return;
      WorldGen.Shimminate();
    }

    private static void ShimmeratorNext(int x, int y)
    {
      if (WorldGen.numTileCount >= WorldGen.maxTileCount)
        return;
      if (x <= 1 || x >= Main.maxTilesX - 1 || y <= 1 || y >= Main.maxTilesY - 1)
      {
        WorldGen.numTileCount = WorldGen.maxTileCount;
      }
      else
      {
        if (WorldGen.CountedTiles.ContainsKey(new Point(x, y)) || (WorldGen.SolidTile(x, y) || Main.tile[x, y].shimmer() || Main.tile[x, y].liquid <= (byte) 0) && (!Main.tile[x, y].active() || Main.tile[x, y].type != (ushort) 56))
          return;
        WorldGen.CountedTiles.Add(new Point(x, y), true);
        ++WorldGen.numTileCount;
        WorldGen.ShimmeratorNext(x - 1, y);
        WorldGen.ShimmeratorNext(x + 1, y);
        WorldGen.ShimmeratorNext(x, y - 1);
        WorldGen.ShimmeratorNext(x, y + 1);
      }
    }

    public static void MakeDungeon(int x, int y)
    {
      GenVars.dEnteranceX = 0;
      GenVars.numDRooms = 0;
      GenVars.numDDoors = 0;
      GenVars.numDungeonPlatforms = 0;
      int num1 = WorldGen.genRand.Next(3);
      WorldGen.genRand.Next(3);
      if (WorldGen.remixWorldGen)
        num1 = !WorldGen.crimson ? 0 : 2;
      ushort tileType1;
      int wallType1;
      switch (num1)
      {
        case 0:
          tileType1 = (ushort) 41;
          wallType1 = 7;
          GenVars.crackedType = (ushort) 481;
          break;
        case 1:
          tileType1 = (ushort) 43;
          wallType1 = 8;
          GenVars.crackedType = (ushort) 482;
          break;
        default:
          tileType1 = (ushort) 44;
          wallType1 = 9;
          GenVars.crackedType = (ushort) 483;
          break;
      }
      Main.tileSolid[(int) GenVars.crackedType] = false;
      GenVars.dungeonLake = true;
      GenVars.numDDoors = 0;
      GenVars.numDungeonPlatforms = 0;
      GenVars.numDRooms = 0;
      GenVars.dungeonX = x;
      GenVars.dungeonY = y;
      GenVars.dMinX = x;
      GenVars.dMaxX = x;
      GenVars.dMinY = y;
      GenVars.dMaxY = y;
      GenVars.dxStrength1 = (double) WorldGen.genRand.Next(25, 30);
      GenVars.dyStrength1 = (double) WorldGen.genRand.Next(20, 25);
      GenVars.dxStrength2 = (double) WorldGen.genRand.Next(35, 50);
      GenVars.dyStrength2 = (double) WorldGen.genRand.Next(10, 15);
      double num2 = (double) (Main.maxTilesX / 60);
      double num3 = num2 + (double) WorldGen.genRand.Next(0, (int) (num2 / 3.0));
      double num4 = num3;
      int num5 = 5;
      WorldGen.DungeonRoom(GenVars.dungeonX, GenVars.dungeonY, tileType1, wallType1);
      while (num3 > 0.0)
      {
        if (GenVars.dungeonX < GenVars.dMinX)
          GenVars.dMinX = GenVars.dungeonX;
        if (GenVars.dungeonX > GenVars.dMaxX)
          GenVars.dMaxX = GenVars.dungeonX;
        if (GenVars.dungeonY > GenVars.dMaxY)
          GenVars.dMaxY = GenVars.dungeonY;
        --num3;
        Main.statusText = Lang.gen[58].Value + " " + (object) (int) ((num4 - num3) / num4 * 60.0) + "%";
        if (num5 > 0)
          --num5;
        if (num5 == 0 & WorldGen.genRand.Next(3) == 0)
        {
          num5 = 5;
          if (WorldGen.genRand.Next(2) == 0)
          {
            int dungeonX = GenVars.dungeonX;
            int dungeonY = GenVars.dungeonY;
            WorldGen.DungeonHalls(GenVars.dungeonX, GenVars.dungeonY, tileType1, wallType1);
            if (WorldGen.genRand.Next(2) == 0)
              WorldGen.DungeonHalls(GenVars.dungeonX, GenVars.dungeonY, tileType1, wallType1);
            WorldGen.DungeonRoom(GenVars.dungeonX, GenVars.dungeonY, tileType1, wallType1);
            GenVars.dungeonX = dungeonX;
            GenVars.dungeonY = dungeonY;
          }
          else
            WorldGen.DungeonRoom(GenVars.dungeonX, GenVars.dungeonY, tileType1, wallType1);
        }
        else
          WorldGen.DungeonHalls(GenVars.dungeonX, GenVars.dungeonY, tileType1, wallType1);
      }
      WorldGen.DungeonRoom(GenVars.dungeonX, GenVars.dungeonY, tileType1, wallType1);
      int num6 = GenVars.dRoomX[0];
      int num7 = GenVars.dRoomY[0];
      for (int index = 0; index < GenVars.numDRooms; ++index)
      {
        if (GenVars.dRoomY[index] < num7)
        {
          num6 = GenVars.dRoomX[index];
          num7 = GenVars.dRoomY[index];
        }
      }
      GenVars.dungeonX = num6;
      GenVars.dungeonY = num7;
      GenVars.dEnteranceX = num6;
      GenVars.dSurface = false;
      int num8 = 5;
      if (WorldGen.drunkWorldGen)
        GenVars.dSurface = true;
      while (!GenVars.dSurface)
      {
        if (num8 > 0)
          --num8;
        if (num8 == 0 && WorldGen.genRand.Next(5) == 0 && (double) GenVars.dungeonY > Main.worldSurface + 100.0)
        {
          num8 = 10;
          int dungeonX = GenVars.dungeonX;
          int dungeonY = GenVars.dungeonY;
          WorldGen.DungeonHalls(GenVars.dungeonX, GenVars.dungeonY, tileType1, wallType1, true);
          WorldGen.DungeonRoom(GenVars.dungeonX, GenVars.dungeonY, tileType1, wallType1);
          GenVars.dungeonX = dungeonX;
          GenVars.dungeonY = dungeonY;
        }
        WorldGen.DungeonStairs(GenVars.dungeonX, GenVars.dungeonY, tileType1, wallType1);
      }
      WorldGen.DungeonEnt(GenVars.dungeonX, GenVars.dungeonY, tileType1, wallType1);
      Main.statusText = Lang.gen[58].Value + " 65%";
      int num9 = Main.maxTilesX * 2;
      int i1;
      int j1;
      int tileType2;
      int wallType2;
      for (int index = 0; index < num9; index = (!WorldGen.DungeonPitTrap(i1, j1, (ushort) tileType2, wallType2) ? index + 1 : index + 1500) + 1)
      {
        i1 = WorldGen.genRand.Next(GenVars.dMinX, GenVars.dMaxX);
        int minValue = GenVars.dMinY;
        if ((double) minValue < Main.worldSurface)
          minValue = (int) Main.worldSurface;
        j1 = WorldGen.genRand.Next(minValue, GenVars.dMaxY);
        tileType2 = (int) tileType1;
        wallType2 = wallType1;
      }
      for (int index1 = 0; index1 < GenVars.numDRooms; ++index1)
      {
        for (int index2 = GenVars.dRoomL[index1]; index2 <= GenVars.dRoomR[index1]; ++index2)
        {
          if (!Main.tile[index2, GenVars.dRoomT[index1] - 1].active())
          {
            GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = index2;
            GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = GenVars.dRoomT[index1] - 1;
            ++GenVars.numDungeonPlatforms;
            break;
          }
        }
        for (int index3 = GenVars.dRoomL[index1]; index3 <= GenVars.dRoomR[index1]; ++index3)
        {
          if (!Main.tile[index3, GenVars.dRoomB[index1] + 1].active())
          {
            GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = index3;
            GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = GenVars.dRoomB[index1] + 1;
            ++GenVars.numDungeonPlatforms;
            break;
          }
        }
        for (int index4 = GenVars.dRoomT[index1]; index4 <= GenVars.dRoomB[index1]; ++index4)
        {
          if (!Main.tile[GenVars.dRoomL[index1] - 1, index4].active())
          {
            GenVars.DDoorX[GenVars.numDDoors] = GenVars.dRoomL[index1] - 1;
            GenVars.DDoorY[GenVars.numDDoors] = index4;
            GenVars.DDoorPos[GenVars.numDDoors] = -1;
            ++GenVars.numDDoors;
            break;
          }
        }
        for (int index5 = GenVars.dRoomT[index1]; index5 <= GenVars.dRoomB[index1]; ++index5)
        {
          if (!Main.tile[GenVars.dRoomR[index1] + 1, index5].active())
          {
            GenVars.DDoorX[GenVars.numDDoors] = GenVars.dRoomR[index1] + 1;
            GenVars.DDoorY[GenVars.numDDoors] = index5;
            GenVars.DDoorPos[GenVars.numDDoors] = 1;
            ++GenVars.numDDoors;
            break;
          }
        }
      }
      Main.statusText = Lang.gen[58].Value + " 70%";
      int num10 = 0;
      int num11 = 1000;
      int num12 = 0;
      int num13 = Main.maxTilesX / 100;
      if (WorldGen.getGoodWorldGen)
        num13 *= 3;
      while (num12 < num13)
      {
        ++num10;
        int index6 = WorldGen.genRand.Next(GenVars.dMinX, GenVars.dMaxX);
        int index7 = WorldGen.genRand.Next((int) Main.worldSurface + 25, GenVars.dMaxY);
        if (WorldGen.drunkWorldGen)
          index7 = WorldGen.genRand.Next(GenVars.dungeonY + 25, GenVars.dMaxY);
        int num14 = index6;
        if ((int) Main.tile[index6, index7].wall == wallType1 && !Main.tile[index6, index7].active())
        {
          int num15 = 1;
          if (WorldGen.genRand.Next(2) == 0)
            num15 = -1;
          while (!Main.tile[index6, index7].active())
            index7 += num15;
          if (Main.tile[index6 - 1, index7].active() && Main.tile[index6 + 1, index7].active() && (int) Main.tile[index6 - 1, index7].type != (int) GenVars.crackedType && !Main.tile[index6 - 1, index7 - num15].active() && !Main.tile[index6 + 1, index7 - num15].active())
          {
            ++num12;
            for (int index8 = WorldGen.genRand.Next(5, 13); Main.tile[index6 - 1, index7].active() && (int) Main.tile[index6 - 1, index7].type != (int) GenVars.crackedType && Main.tile[index6, index7 + num15].active() && Main.tile[index6, index7].active() && !Main.tile[index6, index7 - num15].active() && index8 > 0; --index8)
            {
              Main.tile[index6, index7].type = (ushort) 48;
              if (!Main.tile[index6 - 1, index7 - num15].active() && !Main.tile[index6 + 1, index7 - num15].active())
              {
                Main.tile[index6, index7 - num15].Clear(TileDataType.Slope);
                Main.tile[index6, index7 - num15].type = (ushort) 48;
                Main.tile[index6, index7 - num15].active(true);
                Main.tile[index6, index7 - num15 * 2].Clear(TileDataType.Slope);
                Main.tile[index6, index7 - num15 * 2].type = (ushort) 48;
                Main.tile[index6, index7 - num15 * 2].active(true);
              }
              --index6;
            }
            int num16 = WorldGen.genRand.Next(5, 13);
            for (int index9 = num14 + 1; Main.tile[index9 + 1, index7].active() && (int) Main.tile[index9 + 1, index7].type != (int) GenVars.crackedType && Main.tile[index9, index7 + num15].active() && Main.tile[index9, index7].active() && !Main.tile[index9, index7 - num15].active() && num16 > 0; --num16)
            {
              Main.tile[index9, index7].type = (ushort) 48;
              if (!Main.tile[index9 - 1, index7 - num15].active() && !Main.tile[index9 + 1, index7 - num15].active())
              {
                Main.tile[index9, index7 - num15].Clear(TileDataType.Slope);
                Main.tile[index9, index7 - num15].type = (ushort) 48;
                Main.tile[index9, index7 - num15].active(true);
                Main.tile[index9, index7 - num15 * 2].Clear(TileDataType.Slope);
                Main.tile[index9, index7 - num15 * 2].type = (ushort) 48;
                Main.tile[index9, index7 - num15 * 2].active(true);
              }
              ++index9;
            }
          }
        }
        if (num10 > num11)
        {
          num10 = 0;
          ++num12;
        }
      }
      int num17 = 0;
      int num18 = 1000;
      int num19 = 0;
      Main.statusText = Lang.gen[58].Value + " 75%";
      while (num19 < num13)
      {
        ++num17;
        int index10 = WorldGen.genRand.Next(GenVars.dMinX, GenVars.dMaxX);
        int index11 = WorldGen.genRand.Next((int) Main.worldSurface + 25, GenVars.dMaxY);
        int num20 = index11;
        if ((int) Main.tile[index10, index11].wall == wallType1 && !Main.tile[index10, index11].active())
        {
          int num21 = 1;
          if (WorldGen.genRand.Next(2) == 0)
            num21 = -1;
          while (index10 > 5 && index10 < Main.maxTilesX - 5 && !Main.tile[index10, index11].active())
            index10 += num21;
          if (Main.tile[index10, index11 - 1].active() && Main.tile[index10, index11 + 1].active() && (int) Main.tile[index10, index11 - 1].type != (int) GenVars.crackedType && !Main.tile[index10 - num21, index11 - 1].active() && !Main.tile[index10 - num21, index11 + 1].active())
          {
            ++num19;
            for (int index12 = WorldGen.genRand.Next(5, 13); Main.tile[index10, index11 - 1].active() && (int) Main.tile[index10, index11 - 1].type != (int) GenVars.crackedType && Main.tile[index10 + num21, index11].active() && Main.tile[index10, index11].active() && !Main.tile[index10 - num21, index11].active() && index12 > 0; --index12)
            {
              Main.tile[index10, index11].type = (ushort) 48;
              if (!Main.tile[index10 - num21, index11 - 1].active() && !Main.tile[index10 - num21, index11 + 1].active())
              {
                Main.tile[index10 - num21, index11].type = (ushort) 48;
                Main.tile[index10 - num21, index11].active(true);
                Main.tile[index10 - num21, index11].Clear(TileDataType.Slope);
                Main.tile[index10 - num21 * 2, index11].type = (ushort) 48;
                Main.tile[index10 - num21 * 2, index11].active(true);
                Main.tile[index10 - num21 * 2, index11].Clear(TileDataType.Slope);
              }
              --index11;
            }
            int num22 = WorldGen.genRand.Next(5, 13);
            for (int index13 = num20 + 1; Main.tile[index10, index13 + 1].active() && (int) Main.tile[index10, index13 + 1].type != (int) GenVars.crackedType && Main.tile[index10 + num21, index13].active() && Main.tile[index10, index13].active() && !Main.tile[index10 - num21, index13].active() && num22 > 0; --num22)
            {
              Main.tile[index10, index13].type = (ushort) 48;
              if (!Main.tile[index10 - num21, index13 - 1].active() && !Main.tile[index10 - num21, index13 + 1].active())
              {
                Main.tile[index10 - num21, index13].type = (ushort) 48;
                Main.tile[index10 - num21, index13].active(true);
                Main.tile[index10 - num21, index13].Clear(TileDataType.Slope);
                Main.tile[index10 - num21 * 2, index13].type = (ushort) 48;
                Main.tile[index10 - num21 * 2, index13].active(true);
                Main.tile[index10 - num21 * 2, index13].Clear(TileDataType.Slope);
              }
              ++index13;
            }
          }
        }
        if (num17 > num18)
        {
          num17 = 0;
          ++num19;
        }
      }
      Main.statusText = Lang.gen[58].Value + " 80%";
      for (int index14 = 0; index14 < GenVars.numDDoors; ++index14)
      {
        int num23 = GenVars.DDoorX[index14] - 10;
        int num24 = GenVars.DDoorX[index14] + 10;
        int num25 = 100;
        int num26 = 0;
        for (int index15 = num23; index15 < num24; ++index15)
        {
          bool flag1 = true;
          int index16 = GenVars.DDoorY[index14];
          while (index16 > 10 && !Main.tile[index15, index16].active())
            --index16;
          if (!Main.tileDungeon[(int) Main.tile[index15, index16].type])
            flag1 = false;
          int num27 = index16;
          int index17 = GenVars.DDoorY[index14];
          while (!Main.tile[index15, index17].active())
            ++index17;
          if (!Main.tileDungeon[(int) Main.tile[index15, index17].type])
            flag1 = false;
          int num28 = index17;
          if (num28 - num27 >= 3)
          {
            int num29 = index15 - 20;
            int num30 = index15 + 20;
            int num31 = num28 - 10;
            int num32 = num28 + 10;
            for (int index18 = num29; index18 < num30; ++index18)
            {
              for (int index19 = num31; index19 < num32; ++index19)
              {
                if (Main.tile[index18, index19].active() && Main.tile[index18, index19].type == (ushort) 10)
                {
                  flag1 = false;
                  break;
                }
              }
            }
            if (flag1)
            {
              for (int index20 = num28 - 3; index20 < num28; ++index20)
              {
                for (int index21 = index15 - 3; index21 <= index15 + 3; ++index21)
                {
                  if (Main.tile[index21, index20].active())
                  {
                    flag1 = false;
                    break;
                  }
                }
              }
            }
            if (flag1 && num28 - num27 < 20)
            {
              bool flag2 = false;
              if (GenVars.DDoorPos[index14] == 0 && num28 - num27 < num25)
                flag2 = true;
              if (GenVars.DDoorPos[index14] == -1 && index15 > num26)
                flag2 = true;
              if (GenVars.DDoorPos[index14] == 1 && (index15 < num26 || num26 == 0))
                flag2 = true;
              if (flag2)
              {
                num26 = index15;
                num25 = num28 - num27;
              }
            }
          }
        }
        if (num25 < 20)
        {
          int i2 = num26;
          int index22 = GenVars.DDoorY[index14];
          int index23 = index22;
          for (; !Main.tile[i2, index22].active(); ++index22)
            Main.tile[i2, index22].active(false);
          while (!Main.tile[i2, index23].active())
            --index23;
          int j2 = index22 - 1;
          int num33 = index23 + 1;
          for (int index24 = num33; index24 < j2 - 2; ++index24)
          {
            Main.tile[i2, index24].Clear(TileDataType.Slope);
            Main.tile[i2, index24].active(true);
            Main.tile[i2, index24].type = tileType1;
            if ((int) Main.tile[i2 - 1, index24].type == (int) tileType1)
            {
              Main.tile[i2 - 1, index24].active(false);
              Main.tile[i2 - 1, index24].ClearEverything();
              Main.tile[i2 - 1, index24].wall = (ushort) wallType1;
            }
            if ((int) Main.tile[i2 - 2, index24].type == (int) tileType1)
            {
              Main.tile[i2 - 2, index24].active(false);
              Main.tile[i2 - 2, index24].ClearEverything();
              Main.tile[i2 - 2, index24].wall = (ushort) wallType1;
            }
            if ((int) Main.tile[i2 + 1, index24].type == (int) tileType1)
            {
              Main.tile[i2 + 1, index24].active(false);
              Main.tile[i2 + 1, index24].ClearEverything();
              Main.tile[i2 + 1, index24].wall = (ushort) wallType1;
            }
            if ((int) Main.tile[i2 + 2, index24].type == (int) tileType1)
            {
              Main.tile[i2 + 2, index24].active(false);
              Main.tile[i2 + 2, index24].ClearEverything();
              Main.tile[i2 + 2, index24].wall = (ushort) wallType1;
            }
          }
          int style = 13;
          if (WorldGen.genRand.Next(3) == 0)
          {
            switch (wallType1)
            {
              case 7:
                style = 16;
                break;
              case 8:
                style = 17;
                break;
              case 9:
                style = 18;
                break;
            }
          }
          WorldGen.PlaceTile(i2, j2, 10, true, style: style);
          int index25 = i2 - 1;
          int index26 = j2 - 3;
          while (!Main.tile[index25, index26].active())
            --index26;
          if (j2 - index26 < j2 - num33 + 5 && Main.tileDungeon[(int) Main.tile[index25, index26].type])
          {
            for (int index27 = j2 - 4 - WorldGen.genRand.Next(3); index27 > index26; --index27)
            {
              Main.tile[index25, index27].Clear(TileDataType.Slope);
              Main.tile[index25, index27].active(true);
              Main.tile[index25, index27].type = tileType1;
              if ((int) Main.tile[index25 - 1, index27].type == (int) tileType1)
              {
                Main.tile[index25 - 1, index27].active(false);
                Main.tile[index25 - 1, index27].ClearEverything();
                Main.tile[index25 - 1, index27].wall = (ushort) wallType1;
              }
              if ((int) Main.tile[index25 - 2, index27].type == (int) tileType1)
              {
                Main.tile[index25 - 2, index27].active(false);
                Main.tile[index25 - 2, index27].ClearEverything();
                Main.tile[index25 - 2, index27].wall = (ushort) wallType1;
              }
            }
          }
          int index28 = index25 + 2;
          int index29 = j2 - 3;
          while (!Main.tile[index28, index29].active())
            --index29;
          if (j2 - index29 < j2 - num33 + 5 && Main.tileDungeon[(int) Main.tile[index28, index29].type])
          {
            for (int index30 = j2 - 4 - WorldGen.genRand.Next(3); index30 > index29; --index30)
            {
              Main.tile[index28, index30].active(true);
              Main.tile[index28, index30].Clear(TileDataType.Slope);
              Main.tile[index28, index30].type = tileType1;
              if ((int) Main.tile[index28 + 1, index30].type == (int) tileType1)
              {
                Main.tile[index28 + 1, index30].active(false);
                Main.tile[index28 + 1, index30].ClearEverything();
                Main.tile[index28 + 1, index30].wall = (ushort) wallType1;
              }
              if ((int) Main.tile[index28 + 2, index30].type == (int) tileType1)
              {
                Main.tile[index28 + 2, index30].active(false);
                Main.tile[index28 + 2, index30].ClearEverything();
                Main.tile[index28 + 2, index30].wall = (ushort) wallType1;
              }
            }
          }
          int index31 = j2 + 1;
          int num34 = index28 - 1;
          for (int index32 = index31 - 8; index32 < index31; ++index32)
          {
            if ((int) Main.tile[num34 + 2, index32].type == (int) tileType1)
            {
              Main.tile[num34 + 2, index32].active(false);
              Main.tile[num34 + 2, index32].ClearEverything();
              Main.tile[num34 + 2, index32].wall = (ushort) wallType1;
            }
            if ((int) Main.tile[num34 + 3, index32].type == (int) tileType1)
            {
              Main.tile[num34 + 3, index32].active(false);
              Main.tile[num34 + 3, index32].ClearEverything();
              Main.tile[num34 + 3, index32].wall = (ushort) wallType1;
            }
            if ((int) Main.tile[num34 - 2, index32].type == (int) tileType1)
            {
              Main.tile[num34 - 2, index32].active(false);
              Main.tile[num34 - 2, index32].ClearEverything();
              Main.tile[num34 - 2, index32].wall = (ushort) wallType1;
            }
            if ((int) Main.tile[num34 - 3, index32].type == (int) tileType1)
            {
              Main.tile[num34 - 3, index32].active(false);
              Main.tile[num34 - 3, index32].ClearEverything();
              Main.tile[num34 - 3, index32].wall = (ushort) wallType1;
            }
          }
          Main.tile[num34 - 1, index31].active(true);
          Main.tile[num34 - 1, index31].type = tileType1;
          Main.tile[num34 - 1, index31].Clear(TileDataType.Slope);
          Main.tile[num34 + 1, index31].active(true);
          Main.tile[num34 + 1, index31].type = tileType1;
          Main.tile[num34 + 1, index31].Clear(TileDataType.Slope);
        }
      }
      int[] roomWall = new int[3];
      switch (wallType1)
      {
        case 7:
          roomWall[0] = 7;
          roomWall[1] = 94;
          roomWall[2] = 95;
          break;
        case 9:
          roomWall[0] = 9;
          roomWall[1] = 96;
          roomWall[2] = 97;
          break;
        default:
          roomWall[0] = 8;
          roomWall[1] = 98;
          roomWall[2] = 99;
          break;
      }
      for (int index33 = 0; index33 < 5; ++index33)
      {
        for (int index34 = 0; index34 < 3; ++index34)
        {
          int num35 = WorldGen.genRand.Next(40, 240);
          int num36 = WorldGen.genRand.Next(GenVars.dMinX, GenVars.dMaxX);
          int num37 = WorldGen.genRand.Next(GenVars.dMinY, GenVars.dMaxY);
          for (int x1 = num36 - num35; x1 < num36 + num35; ++x1)
          {
            for (int y1 = num37 - num35; y1 < num37 + num35; ++y1)
            {
              if ((double) y1 > Main.worldSurface)
              {
                double num38 = (double) Math.Abs(num36 - x1);
                double num39 = (double) Math.Abs(num37 - y1);
                if (Math.Sqrt(num38 * num38 + num39 * num39) < (double) num35 * 0.4 && Main.wallDungeon[(int) Main.tile[x1, y1].wall])
                  WorldGen.Spread.WallDungeon(x1, y1, roomWall[index34]);
              }
            }
          }
        }
      }
      Main.statusText = Lang.gen[58].Value + " 85%";
      for (int index35 = 0; index35 < GenVars.numDungeonPlatforms; ++index35)
      {
        int index36 = GenVars.dungeonPlatformX[index35];
        int num40 = GenVars.dungeonPlatformY[index35];
        int num41 = Main.maxTilesX;
        int num42 = 10;
        if ((double) num40 < Main.worldSurface + 50.0)
          num42 = 20;
        for (int index37 = num40 - 5; index37 <= num40 + 5; ++index37)
        {
          int index38 = index36;
          int index39 = index36;
          bool flag3 = false;
          if (Main.tile[index38, index37].active())
          {
            flag3 = true;
          }
          else
          {
            while (!Main.tile[index38, index37].active())
            {
              --index38;
              if (!Main.tileDungeon[(int) Main.tile[index38, index37].type] || index38 == 0)
              {
                flag3 = true;
                break;
              }
            }
            while (!Main.tile[index39, index37].active())
            {
              ++index39;
              if (!Main.tileDungeon[(int) Main.tile[index39, index37].type] || index39 == Main.maxTilesX - 1)
              {
                flag3 = true;
                break;
              }
            }
          }
          if (!flag3 && index39 - index38 <= num42)
          {
            bool flag4 = true;
            int num43 = index36 - num42 / 2 - 2;
            int num44 = index36 + num42 / 2 + 2;
            int num45 = index37 - 5;
            int num46 = index37 + 5;
            for (int index40 = num43; index40 <= num44; ++index40)
            {
              for (int index41 = num45; index41 <= num46; ++index41)
              {
                if (Main.tile[index40, index41].active() && Main.tile[index40, index41].type == (ushort) 19)
                {
                  flag4 = false;
                  break;
                }
              }
            }
            for (int index42 = index37 + 3; index42 >= index37 - 5; --index42)
            {
              if (Main.tile[index36, index42].active())
              {
                flag4 = false;
                break;
              }
            }
            if (flag4)
            {
              num41 = index37;
              break;
            }
          }
        }
        if (num41 > num40 - 10 && num41 < num40 + 10)
        {
          int i3 = index36;
          int j3 = num41;
          int i4 = index36 + 1;
          for (; !Main.tile[i3, j3].active(); --i3)
          {
            Main.tile[i3, j3].active(true);
            Main.tile[i3, j3].type = (ushort) 19;
            Main.tile[i3, j3].Clear(TileDataType.Slope);
            switch (wallType1)
            {
              case 7:
                Main.tile[i3, j3].frameY = (short) 108;
                break;
              case 8:
                Main.tile[i3, j3].frameY = (short) 144;
                break;
              default:
                Main.tile[i3, j3].frameY = (short) 126;
                break;
            }
            WorldGen.TileFrame(i3, j3);
          }
          for (; !Main.tile[i4, j3].active(); ++i4)
          {
            Main.tile[i4, j3].active(true);
            Main.tile[i4, j3].type = (ushort) 19;
            Main.tile[i4, j3].Clear(TileDataType.Slope);
            switch (wallType1)
            {
              case 7:
                Main.tile[i4, j3].frameY = (short) 108;
                break;
              case 8:
                Main.tile[i4, j3].frameY = (short) 144;
                break;
              default:
                Main.tile[i4, j3].frameY = (short) 126;
                break;
            }
            WorldGen.TileFrame(i4, j3);
          }
        }
      }
      int num47 = 5;
      if (WorldGen.drunkWorldGen)
        num47 = 6;
      for (int index = 0; index < num47; ++index)
      {
        bool flag = false;
        while (!flag)
        {
          int i5 = WorldGen.genRand.Next(GenVars.dMinX, GenVars.dMaxX);
          int j4 = WorldGen.genRand.Next((int) Main.worldSurface, GenVars.dMaxY);
          if (Main.wallDungeon[(int) Main.tile[i5, j4].wall] && !Main.tile[i5, j4].active())
          {
            ushort chestTileType = 21;
            int contain = 0;
            int Style = 0;
            switch (index)
            {
              case 0:
                Style = 23;
                contain = 1156;
                break;
              case 1:
                if (!WorldGen.crimson)
                {
                  Style = 24;
                  contain = 1571;
                  break;
                }
                Style = 25;
                contain = 1569;
                break;
              case 2:
                Style = 26;
                contain = 1260;
                break;
              case 3:
                Style = 27;
                contain = 1572;
                break;
              case 4:
                chestTileType = (ushort) 467;
                Style = 13;
                contain = 4607;
                break;
              case 5:
                if (WorldGen.crimson)
                {
                  Style = 24;
                  contain = 1571;
                  break;
                }
                Style = 25;
                contain = 1569;
                break;
            }
            flag = WorldGen.AddBuriedChest(i5, j4, contain, Style: Style, chestTileType: chestTileType);
          }
        }
      }
      int[] numArray = new int[3]
      {
        WorldGen.genRand.Next(9, 13),
        WorldGen.genRand.Next(9, 13),
        0
      };
      while (numArray[1] == numArray[0])
        numArray[1] = WorldGen.genRand.Next(9, 13);
      numArray[2] = WorldGen.genRand.Next(9, 13);
      while (numArray[2] == numArray[0] || numArray[2] == numArray[1])
        numArray[2] = WorldGen.genRand.Next(9, 13);
      Main.statusText = Lang.gen[58].Value + " 90%";
      int num48 = 0;
      int num49 = 1000;
      int num50 = 0;
      while (num50 < Main.maxTilesX / 20)
      {
        ++num48;
        int index43 = WorldGen.genRand.Next(GenVars.dMinX, GenVars.dMaxX);
        int j5 = WorldGen.genRand.Next(GenVars.dMinY, GenVars.dMaxY);
        bool flag5 = true;
        if (Main.wallDungeon[(int) Main.tile[index43, j5].wall] && !Main.tile[index43, j5].active())
        {
          int num51 = 1;
          if (WorldGen.genRand.Next(2) == 0)
            num51 = -1;
          while (flag5 && !Main.tile[index43, j5].active())
          {
            index43 -= num51;
            if (index43 < 5 || index43 > Main.maxTilesX - 5)
              flag5 = false;
            else if (Main.tile[index43, j5].active() && !Main.tileDungeon[(int) Main.tile[index43, j5].type])
              flag5 = false;
          }
          if (flag5 && Main.tile[index43, j5].active() && Main.tileDungeon[(int) Main.tile[index43, j5].type] && Main.tile[index43, j5 - 1].active() && Main.tileDungeon[(int) Main.tile[index43, j5 - 1].type] && Main.tile[index43, j5 + 1].active() && Main.tileDungeon[(int) Main.tile[index43, j5 + 1].type])
          {
            int i6 = index43 + num51;
            for (int index44 = i6 - 3; index44 <= i6 + 3; ++index44)
            {
              for (int index45 = j5 - 3; index45 <= j5 + 3; ++index45)
              {
                if (Main.tile[index44, index45].active() && Main.tile[index44, index45].type == (ushort) 19)
                {
                  flag5 = false;
                  break;
                }
              }
            }
            if (flag5 && !Main.tile[i6, j5 - 1].active() & !Main.tile[i6, j5 - 2].active() & !Main.tile[i6, j5 - 3].active())
            {
              int index46 = i6;
              int num52 = i6;
              while (index46 > GenVars.dMinX && index46 < GenVars.dMaxX && !Main.tile[index46, j5].active() && !Main.tile[index46, j5 - 1].active() && !Main.tile[index46, j5 + 1].active())
                index46 += num51;
              int num53 = Math.Abs(i6 - index46);
              bool flag6 = false;
              if (WorldGen.genRand.Next(2) == 0)
                flag6 = true;
              if (num53 > 5)
              {
                for (int index47 = WorldGen.genRand.Next(1, 4); index47 > 0; --index47)
                {
                  Main.tile[i6, j5].active(true);
                  Main.tile[i6, j5].Clear(TileDataType.Slope);
                  Main.tile[i6, j5].type = (ushort) 19;
                  Main.tile[i6, j5].frameY = (int) Main.tile[i6, j5].wall != roomWall[0] ? ((int) Main.tile[i6, j5].wall != roomWall[1] ? (short) (18 * numArray[2]) : (short) (18 * numArray[1])) : (short) (18 * numArray[0]);
                  WorldGen.TileFrame(i6, j5);
                  if (flag6)
                  {
                    WorldGen.PlaceTile(i6, j5 - 1, 50, true);
                    if (WorldGen.genRand.Next(50) == 0 && (double) j5 > (Main.worldSurface + Main.rockLayer) / 2.0 && Main.tile[i6, j5 - 1].type == (ushort) 50)
                      Main.tile[i6, j5 - 1].frameX = (short) 90;
                  }
                  i6 += num51;
                }
                num48 = 0;
                ++num50;
                if (!flag6 && WorldGen.genRand.Next(2) == 0)
                {
                  int i7 = num52;
                  int j6 = j5 - 1;
                  int Type = 0;
                  if (WorldGen.genRand.Next(4) == 0)
                    Type = 1;
                  switch (Type)
                  {
                    case 0:
                      Type = 13;
                      break;
                    case 1:
                      Type = 49;
                      break;
                  }
                  WorldGen.PlaceTile(i7, j6, Type, true);
                  if (Main.tile[i7, j6].type == (ushort) 13)
                    Main.tile[i7, j6].frameX = WorldGen.genRand.Next(2) != 0 ? (short) 36 : (short) 18;
                }
              }
            }
          }
        }
        if (num48 > num49)
        {
          num48 = 0;
          ++num50;
        }
      }
      Main.statusText = Lang.gen[58].Value + " 95%";
      int num54 = 1;
      for (int index = 0; index < GenVars.numDRooms; ++index)
      {
        int num55 = 0;
        while (num55 < 1000)
        {
          int num56 = (int) ((double) GenVars.dRoomSize[index] * 0.4);
          int i8 = GenVars.dRoomX[index] + WorldGen.genRand.Next(-num56, num56 + 1);
          int j7 = GenVars.dRoomY[index] + WorldGen.genRand.Next(-num56, num56 + 1);
          int Style = 2;
          if (num54 == 1)
            ++num54;
          int contain;
          if (num54 == 2)
            contain = 155;
          else if (num54 == 3)
            contain = 156;
          else if (num54 == 4)
            contain = !WorldGen.remixWorldGen ? 157 : 2623;
          else if (num54 == 5)
            contain = 163;
          else if (num54 == 6)
            contain = 113;
          else if (num54 == 7)
            contain = 3317;
          else if (num54 == 8)
          {
            contain = 327;
            Style = 0;
          }
          else
          {
            contain = 164;
            num54 = 0;
          }
          if ((double) j7 < Main.worldSurface + 50.0)
          {
            contain = 327;
            Style = 0;
          }
          if (contain == 0 && WorldGen.genRand.Next(2) == 0)
          {
            num55 = 1000;
          }
          else
          {
            if (WorldGen.AddBuriedChest(i8, j7, contain, Style: Style))
            {
              num55 += 1000;
              ++num54;
            }
            ++num55;
          }
        }
      }
      GenVars.dMinX -= 25;
      GenVars.dMaxX += 25;
      GenVars.dMinY -= 25;
      GenVars.dMaxY += 25;
      if (GenVars.dMinX < 0)
        GenVars.dMinX = 0;
      if (GenVars.dMaxX > Main.maxTilesX)
        GenVars.dMaxX = Main.maxTilesX;
      if (GenVars.dMinY < 0)
        GenVars.dMinY = 0;
      if (GenVars.dMaxY > Main.maxTilesY)
        GenVars.dMaxY = Main.maxTilesY;
      int failCount = 0;
      int failMax1 = 1000;
      int numAdd1 = 0;
      WorldGen.MakeDungeon_Lights(tileType1, ref failCount, failMax1, ref numAdd1, roomWall);
      failCount = 0;
      int failMax2 = 1000;
      int numAdd2 = 0;
      WorldGen.MakeDungeon_Traps(ref failCount, failMax2, ref numAdd2);
      double count1 = WorldGen.MakeDungeon_GroundFurniture(wallType1);
      double count2 = WorldGen.MakeDungeon_Pictures(roomWall, count1);
      WorldGen.MakeDungeon_Banners(roomWall, count2);
    }

    private static void MakeDungeon_Traps(ref int failCount, int failMax, ref int numAdd)
    {
      while (numAdd < Main.maxTilesX / 500)
      {
        ++failCount;
        int x2 = WorldGen.genRand.Next(GenVars.dMinX, GenVars.dMaxX);
        int y2 = WorldGen.genRand.Next(GenVars.dMinY, GenVars.dMaxY);
        while ((double) y2 < Main.worldSurface)
          y2 = WorldGen.genRand.Next(GenVars.dMinY, GenVars.dMaxY);
        if (Main.wallDungeon[(int) Main.tile[x2, y2].wall] && WorldGen.placeTrap(x2, y2, 0))
          failCount = failMax;
        if (failCount > failMax)
        {
          ++numAdd;
          failCount = 0;
        }
      }
    }

    private static void MakeDungeon_Lights(
      ushort tileType,
      ref int failCount,
      int failMax,
      ref int numAdd,
      int[] roomWall)
    {
      int[] numArray = new int[3]
      {
        WorldGen.genRand.Next(7),
        WorldGen.genRand.Next(7),
        0
      };
      while (numArray[1] == numArray[0])
        numArray[1] = WorldGen.genRand.Next(7);
      numArray[2] = WorldGen.genRand.Next(7);
      while (numArray[2] == numArray[0] || numArray[2] == numArray[1])
        numArray[2] = WorldGen.genRand.Next(7);
      while (numAdd < Main.maxTilesX / 150)
      {
        ++failCount;
        int index1 = WorldGen.genRand.Next(GenVars.dMinX, GenVars.dMaxX);
        int index2 = WorldGen.genRand.Next(GenVars.dMinY, GenVars.dMaxY);
        if (Main.wallDungeon[(int) Main.tile[index1, index2].wall])
        {
          for (int y = index2; y > GenVars.dMinY; --y)
          {
            if (Main.tile[index1, y - 1].active() && (int) Main.tile[index1, y - 1].type == (int) tileType)
            {
              bool flag1 = false;
              for (int index3 = index1 - 15; index3 < index1 + 15; ++index3)
              {
                for (int index4 = y - 15; index4 < y + 15; ++index4)
                {
                  if (index3 > 0 && index3 < Main.maxTilesX && index4 > 0 && index4 < Main.maxTilesY && (Main.tile[index3, index4].type == (ushort) 42 || Main.tile[index3, index4].type == (ushort) 34))
                  {
                    flag1 = true;
                    break;
                  }
                }
              }
              if (Main.tile[index1 - 1, y].active() || Main.tile[index1 + 1, y].active() || Main.tile[index1 - 1, y + 1].active() || Main.tile[index1 + 1, y + 1].active() || Main.tile[index1, y + 2].active())
                flag1 = true;
              if (!flag1)
              {
                bool flag2 = false;
                if (!flag2 && WorldGen.genRand.Next(7) == 0)
                {
                  int style = 27;
                  switch (roomWall[0])
                  {
                    case 7:
                      style = 27;
                      break;
                    case 8:
                      style = 28;
                      break;
                    case 9:
                      style = 29;
                      break;
                  }
                  bool flag3 = false;
                  for (int index5 = 0; index5 < 15; ++index5)
                  {
                    if (WorldGen.SolidTile(index1, y + index5))
                    {
                      flag3 = true;
                      break;
                    }
                  }
                  if (!flag3)
                    WorldGen.PlaceChand(index1, y, (ushort) 34, style);
                  if (Main.tile[index1, y].type == (ushort) 34)
                  {
                    flag2 = true;
                    failCount = 0;
                    ++numAdd;
                    for (int index6 = 0; index6 < 1000; ++index6)
                    {
                      int i = index1 + WorldGen.genRand.Next(-12, 13);
                      int j = y + WorldGen.genRand.Next(3, 21);
                      if (!Main.tile[i, j].active() && !Main.tile[i, j + 1].active() && Main.tileDungeon[(int) Main.tile[i - 1, j].type] && Main.tileDungeon[(int) Main.tile[i + 1, j].type] && Collision.CanHit(new Point(i * 16, j * 16), 16, 16, new Point(index1 * 16, y * 16 + 1), 16, 16))
                      {
                        if ((WorldGen.SolidTile(i - 1, j) && Main.tile[i - 1, j].type != (ushort) 10 || WorldGen.SolidTile(i + 1, j) && Main.tile[i + 1, j].type != (ushort) 10 || WorldGen.SolidTile(i, j + 1)) && Main.wallDungeon[(int) Main.tile[i, j].wall] && (Main.tileDungeon[(int) Main.tile[i - 1, j].type] || Main.tileDungeon[(int) Main.tile[i + 1, j].type]))
                          WorldGen.PlaceTile(i, j, 136, true);
                        if (Main.tile[i, j].active())
                        {
                          while (i != index1 || j != y)
                          {
                            Main.tile[i, j].wire(true);
                            if (i > index1)
                              --i;
                            if (i < index1)
                              ++i;
                            Main.tile[i, j].wire(true);
                            if (j > y)
                              --j;
                            if (j < y)
                              ++j;
                            Main.tile[i, j].wire(true);
                          }
                          if (WorldGen.genRand.Next(3) > 0)
                          {
                            Main.tile[index1, y].frameX = (short) 18;
                            Main.tile[index1, y + 1].frameX = (short) 18;
                            break;
                          }
                          break;
                        }
                      }
                    }
                  }
                }
                if (!flag2)
                {
                  int style = numArray[0];
                  if ((int) Main.tile[index1, y].wall == roomWall[1])
                    style = numArray[1];
                  if ((int) Main.tile[index1, y].wall == roomWall[2])
                    style = numArray[2];
                  WorldGen.Place1x2Top(index1, y, (ushort) 42, style);
                  if (Main.tile[index1, y].type == (ushort) 42)
                  {
                    failCount = 0;
                    ++numAdd;
                    for (int index7 = 0; index7 < 1000; ++index7)
                    {
                      int i = index1 + WorldGen.genRand.Next(-12, 13);
                      int j = y + WorldGen.genRand.Next(3, 21);
                      if (!Main.tile[i, j].active() && !Main.tile[i, j + 1].active() && Main.tile[i - 1, j].type != (ushort) 48 && Main.tile[i + 1, j].type != (ushort) 48 && Collision.CanHit(new Point(i * 16, j * 16), 16, 16, new Point(index1 * 16, y * 16 + 1), 16, 16))
                      {
                        if (WorldGen.SolidTile(i - 1, j) && Main.tile[i - 1, j].type != (ushort) 10 || WorldGen.SolidTile(i + 1, j) && Main.tile[i + 1, j].type != (ushort) 10 || WorldGen.SolidTile(i, j + 1))
                          WorldGen.PlaceTile(i, j, 136, true);
                        if (Main.tile[i, j].active())
                        {
                          while (i != index1 || j != y)
                          {
                            Main.tile[i, j].wire(true);
                            if (i > index1)
                              --i;
                            if (i < index1)
                              ++i;
                            Main.tile[i, j].wire(true);
                            if (j > y)
                              --j;
                            if (j < y)
                              ++j;
                            Main.tile[i, j].wire(true);
                          }
                          if (WorldGen.genRand.Next(3) > 0)
                          {
                            Main.tile[index1, y].frameX = (short) 18;
                            Main.tile[index1, y + 1].frameX = (short) 18;
                            break;
                          }
                          break;
                        }
                      }
                    }
                    break;
                  }
                  break;
                }
                break;
              }
              break;
            }
          }
        }
        if (failCount > failMax)
        {
          ++numAdd;
          failCount = 0;
        }
      }
    }

    private static double MakeDungeon_Banners(int[] roomWall, double count)
    {
      count = 840000.0 / (double) Main.maxTilesX;
      for (int index1 = 0; (double) index1 < count; ++index1)
      {
        int i = WorldGen.genRand.Next(GenVars.dMinX, GenVars.dMaxX);
        int j1;
        for (j1 = WorldGen.genRand.Next(GenVars.dMinY, GenVars.dMaxY); !Main.wallDungeon[(int) Main.tile[i, j1].wall] || Main.tile[i, j1].active(); j1 = WorldGen.genRand.Next(GenVars.dMinY, GenVars.dMaxY))
          i = WorldGen.genRand.Next(GenVars.dMinX, GenVars.dMaxX);
        while (!WorldGen.SolidTile(i, j1) && j1 > 10)
          --j1;
        int j2 = j1 + 1;
        if (Main.wallDungeon[(int) Main.tile[i, j2].wall] && Main.tile[i, j2 - 1].type != (ushort) 48 && !Main.tile[i, j2].active() && !Main.tile[i, j2 + 1].active() && !Main.tile[i, j2 + 2].active() && !Main.tile[i, j2 + 3].active())
        {
          bool flag = true;
          for (int index2 = i - 1; index2 <= i + 1; ++index2)
          {
            for (int index3 = j2; index3 <= j2 + 3; ++index3)
            {
              if (Main.tile[index2, index3].active() && (Main.tile[index2, index3].type == (ushort) 10 || Main.tile[index2, index3].type == (ushort) 11 || Main.tile[index2, index3].type == (ushort) 91))
                flag = false;
            }
          }
          if (flag)
          {
            int num = 10;
            if ((int) Main.tile[i, j2].wall == roomWall[1])
              num = 12;
            if ((int) Main.tile[i, j2].wall == roomWall[2])
              num = 14;
            int style = num + WorldGen.genRand.Next(2);
            WorldGen.PlaceTile(i, j2, 91, true, style: style);
          }
        }
      }
      return count;
    }

    private static double MakeDungeon_Pictures(int[] roomWall, double count)
    {
      count = 420000.0 / (double) Main.maxTilesX;
      for (int index1 = 0; (double) index1 < count; ++index1)
      {
        int index2 = WorldGen.genRand.Next(GenVars.dMinX, GenVars.dMaxX);
        int index3;
        for (index3 = WorldGen.genRand.Next((int) Main.worldSurface, GenVars.dMaxY); !Main.wallDungeon[(int) Main.tile[index2, index3].wall] || Main.tile[index2, index3].active(); index3 = WorldGen.genRand.Next((int) Main.worldSurface, GenVars.dMaxY))
          index2 = WorldGen.genRand.Next(GenVars.dMinX, GenVars.dMaxX);
        for (int index4 = 0; index4 < 2; ++index4)
        {
          int index5 = index2;
          int index6 = index2;
          while (!Main.tile[index5, index3].active() && Main.wallDungeon[(int) Main.tile[index5, index3].wall])
            --index5;
          int num1 = index5 + 1;
          while (!Main.tile[index6, index3].active() && Main.wallDungeon[(int) Main.tile[index6, index3].wall])
            ++index6;
          int num2 = index6 - 1;
          index2 = (num1 + num2) / 2;
          int index7 = index3;
          int index8 = index3;
          while (!Main.tile[index2, index7].active() && Main.wallDungeon[(int) Main.tile[index2, index7].wall])
            --index7;
          int num3 = index7 + 1;
          while (!Main.tile[index2, index8].active() && Main.wallDungeon[(int) Main.tile[index2, index8].wall])
            ++index8;
          int num4 = index8 - 1;
          index3 = (num3 + num4) / 2;
        }
        int index9 = index2;
        int index10 = index2;
        while (!Main.tile[index9, index3].active() && !Main.tile[index9, index3 - 1].active() && !Main.tile[index9, index3 + 1].active())
          --index9;
        int num5 = index9 + 1;
        while (!Main.tile[index10, index3].active() && !Main.tile[index10, index3 - 1].active() && !Main.tile[index10, index3 + 1].active())
          ++index10;
        int num6 = index10 - 1;
        int index11 = index3;
        int index12 = index3;
        while (!Main.tile[index2, index11].active() && !Main.tile[index2 - 1, index11].active() && !Main.tile[index2 + 1, index11].active())
          --index11;
        int num7 = index11 + 1;
        while (!Main.tile[index2, index12].active() && !Main.tile[index2 - 1, index12].active() && !Main.tile[index2 + 1, index12].active())
          ++index12;
        int num8 = index12 - 1;
        int index13 = (num5 + num6) / 2;
        int index14 = (num7 + num8) / 2;
        int num9 = num6 - num5;
        int num10 = num8 - num7;
        if (num9 > 7 && num10 > 5)
        {
          bool[] flagArray = new bool[3]
          {
            true,
            false,
            false
          };
          if (num9 > num10 * 3 && num9 > 21)
            flagArray[1] = true;
          if (num10 > num9 * 3 && num10 > 21)
            flagArray[2] = true;
          int index15 = WorldGen.genRand.Next(3);
          if ((int) Main.tile[index13, index14].wall == roomWall[0])
            index15 = 0;
          while (!flagArray[index15])
            index15 = WorldGen.genRand.Next(3);
          if (WorldGen.nearPicture2(index13, index14))
            index15 = -1;
          switch (index15)
          {
            case 0:
              PaintingEntry paintingEntry1 = WorldGen.RandPictureTile();
              if ((int) Main.tile[index13, index14].wall != roomWall[0])
                paintingEntry1 = WorldGen.RandBonePicture();
              if (!WorldGen.nearPicture(index13, index14))
              {
                WorldGen.PlaceTile(index13, index14, paintingEntry1.tileType, true, style: paintingEntry1.style);
                continue;
              }
              continue;
            case 1:
              PaintingEntry paintingEntry2 = WorldGen.RandPictureTile();
              if ((int) Main.tile[index13, index14].wall != roomWall[0])
                paintingEntry2 = WorldGen.RandBonePicture();
              if (!Main.tile[index13, index14].active())
                WorldGen.PlaceTile(index13, index14, paintingEntry2.tileType, true, style: paintingEntry2.style);
              int num11 = index13;
              int num12 = index14;
              int index16 = index14;
              for (int index17 = 0; index17 < 2; ++index17)
              {
                index13 += 7;
                int index18 = index16;
                int index19 = index16;
                while (!Main.tile[index13, index18].active() && !Main.tile[index13 - 1, index18].active() && !Main.tile[index13 + 1, index18].active())
                  --index18;
                int num13 = index18 + 1;
                while (!Main.tile[index13, index19].active() && !Main.tile[index13 - 1, index19].active() && !Main.tile[index13 + 1, index19].active())
                  ++index19;
                int num14 = index19 - 1;
                index16 = (num13 + num14) / 2;
                PaintingEntry paintingEntry3 = WorldGen.RandPictureTile();
                if ((int) Main.tile[index13, index16].wall != roomWall[0])
                  paintingEntry3 = WorldGen.RandBonePicture();
                if (Math.Abs(num12 - index16) < 4 && !WorldGen.nearPicture(index13, index16))
                  WorldGen.PlaceTile(index13, index16, paintingEntry3.tileType, true, style: paintingEntry3.style);
                else
                  break;
              }
              int index20 = index14;
              int index21 = num11;
              for (int index22 = 0; index22 < 2; ++index22)
              {
                index21 -= 7;
                int index23 = index20;
                int index24 = index20;
                while (!Main.tile[index21, index23].active() && !Main.tile[index21 - 1, index23].active() && !Main.tile[index21 + 1, index23].active())
                  --index23;
                int num15 = index23 + 1;
                while (!Main.tile[index21, index24].active() && !Main.tile[index21 - 1, index24].active() && !Main.tile[index21 + 1, index24].active())
                  ++index24;
                int num16 = index24 - 1;
                index20 = (num15 + num16) / 2;
                PaintingEntry paintingEntry4 = WorldGen.RandPictureTile();
                if ((int) Main.tile[index21, index20].wall != roomWall[0])
                  paintingEntry4 = WorldGen.RandBonePicture();
                if (Math.Abs(num12 - index20) < 4 && !WorldGen.nearPicture(index21, index20))
                  WorldGen.PlaceTile(index21, index20, paintingEntry4.tileType, true, style: paintingEntry4.style);
                else
                  break;
              }
              continue;
            case 2:
              PaintingEntry paintingEntry5 = WorldGen.RandPictureTile();
              if ((int) Main.tile[index13, index14].wall != roomWall[0])
                paintingEntry5 = WorldGen.RandBonePicture();
              if (!Main.tile[index13, index14].active())
                WorldGen.PlaceTile(index13, index14, paintingEntry5.tileType, true, style: paintingEntry5.style);
              int num17 = index14;
              int num18 = index13;
              int index25 = index13;
              for (int index26 = 0; index26 < 3; ++index26)
              {
                index14 += 7;
                int index27 = index25;
                int index28 = index25;
                while (!Main.tile[index27, index14].active() && !Main.tile[index27, index14 - 1].active() && !Main.tile[index27, index14 + 1].active())
                  --index27;
                int num19 = index27 + 1;
                while (!Main.tile[index28, index14].active() && !Main.tile[index28, index14 - 1].active() && !Main.tile[index28, index14 + 1].active())
                  ++index28;
                int num20 = index28 - 1;
                index25 = (num19 + num20) / 2;
                PaintingEntry paintingEntry6 = WorldGen.RandPictureTile();
                if ((int) Main.tile[index25, index14].wall != roomWall[0])
                  paintingEntry6 = WorldGen.RandBonePicture();
                if (Math.Abs(num18 - index25) < 4 && !WorldGen.nearPicture(index25, index14))
                  WorldGen.PlaceTile(index25, index14, paintingEntry6.tileType, true, style: paintingEntry6.style);
                else
                  break;
              }
              int index29 = index13;
              int index30 = num17;
              for (int index31 = 0; index31 < 3; ++index31)
              {
                index30 -= 7;
                int index32 = index29;
                int index33 = index29;
                while (!Main.tile[index32, index30].active() && !Main.tile[index32, index30 - 1].active() && !Main.tile[index32, index30 + 1].active())
                  --index32;
                int num21 = index32 + 1;
                while (!Main.tile[index33, index30].active() && !Main.tile[index33, index30 - 1].active() && !Main.tile[index33, index30 + 1].active())
                  ++index33;
                int num22 = index33 - 1;
                index29 = (num21 + num22) / 2;
                PaintingEntry paintingEntry7 = WorldGen.RandPictureTile();
                if ((int) Main.tile[index29, index30].wall != roomWall[0])
                  paintingEntry7 = WorldGen.RandBonePicture();
                if (Math.Abs(num18 - index29) < 4 && !WorldGen.nearPicture(index29, index30))
                  WorldGen.PlaceTile(index29, index30, paintingEntry7.tileType, true, style: paintingEntry7.style);
                else
                  break;
              }
              continue;
            default:
              continue;
          }
        }
      }
      return count;
    }

    private static double MakeDungeon_GroundFurniture(int wallType)
    {
      double num1 = (double) (2000 * Main.maxTilesX) / 4200.0;
      int num2 = 1 + (int) ((double) Main.maxTilesX / 4200.0);
      int num3 = 1 + (int) ((double) Main.maxTilesX / 4200.0);
      for (int index1 = 0; (double) index1 < num1; ++index1)
      {
        if (num2 > 0 || num3 > 0)
          --index1;
        int i1 = WorldGen.genRand.Next(GenVars.dMinX, GenVars.dMaxX);
        int j;
        for (j = WorldGen.genRand.Next((int) Main.worldSurface + 10, GenVars.dMaxY); !Main.wallDungeon[(int) Main.tile[i1, j].wall] || Main.tile[i1, j].active(); j = WorldGen.genRand.Next((int) Main.worldSurface + 10, GenVars.dMaxY))
          i1 = WorldGen.genRand.Next(GenVars.dMinX, GenVars.dMaxX);
        if (Main.wallDungeon[(int) Main.tile[i1, j].wall] && !Main.tile[i1, j].active())
        {
          while (!WorldGen.SolidTile(i1, j) && j < Main.UnderworldLayer)
            ++j;
          int index2 = j - 1;
          int i2 = i1;
          int i3 = i1;
          while (!Main.tile[i2, index2].active() && WorldGen.SolidTile(i2, index2 + 1))
            --i2;
          int num4 = i2 + 1;
          while (!Main.tile[i3, index2].active() && WorldGen.SolidTile(i3, index2 + 1))
            ++i3;
          int num5 = i3 - 1;
          int num6 = num5 - num4;
          int index3 = (num5 + num4) / 2;
          if (!Main.tile[index3, index2].active() && Main.wallDungeon[(int) Main.tile[index3, index2].wall] && WorldGen.SolidTile(index3, index2 + 1) && Main.tile[index3, index2 + 1].type != (ushort) 48)
          {
            int style1 = 13;
            int style2 = 10;
            int style3 = 11;
            int style4 = 1;
            int style5 = 46;
            int style6 = 1;
            int style7 = 5;
            int style8 = 11;
            int style9 = 5;
            int style10 = 6;
            int style11 = 21;
            int style12 = 22;
            int style13 = 24;
            int style14 = 30;
            switch (wallType)
            {
              case 8:
                style1 = 14;
                style2 = 11;
                style3 = 12;
                style4 = 2;
                style5 = 47;
                style6 = 2;
                style7 = 6;
                style8 = 12;
                style9 = 6;
                style10 = 7;
                style11 = 22;
                style12 = 23;
                style13 = 25;
                style14 = 31;
                break;
              case 9:
                style1 = 15;
                style2 = 12;
                style3 = 13;
                style4 = 3;
                style5 = 48;
                style6 = 3;
                style7 = 7;
                style8 = 13;
                style9 = 7;
                style10 = 8;
                style11 = 23;
                style12 = 24;
                style13 = 26;
                style14 = 32;
                break;
            }
            if (Main.tile[index3, index2].wall >= (ushort) 94 && Main.tile[index3, index2].wall <= (ushort) 105)
            {
              style1 = 17;
              style2 = 14;
              style3 = 15;
              style4 = -1;
              style5 = -1;
              style6 = 5;
              style7 = -1;
              style8 = -1;
              style9 = -1;
              style10 = -1;
              style11 = -1;
              style12 = -1;
              style13 = -1;
              style14 = -1;
            }
            int num7 = WorldGen.genRand.Next(13);
            if ((num7 == 10 || num7 == 11 || num7 == 12) && WorldGen.genRand.Next(4) != 0)
              num7 = WorldGen.genRand.Next(13);
            while (num7 == 2 && style5 == -1 || num7 == 5 && style7 == -1 || num7 == 6 && style8 == -1 || num7 == 7 && style9 == -1 || num7 == 8 && style10 == -1 || num7 == 9 && style11 == -1 || num7 == 10 && style12 == -1 || num7 == 11 && style13 == -1 || num7 == 12 && style14 == -1)
              num7 = WorldGen.genRand.Next(13);
            int num8 = 0;
            int num9 = 0;
            if (num7 == 0)
            {
              num8 = 5;
              num9 = 4;
            }
            if (num7 == 1)
            {
              num8 = 4;
              num9 = 3;
            }
            if (num7 == 2)
            {
              num8 = 3;
              num9 = 5;
            }
            if (num7 == 3)
            {
              num8 = 4;
              num9 = 6;
            }
            if (num7 == 4)
            {
              num8 = 3;
              num9 = 3;
            }
            if (num7 == 5)
            {
              num8 = 5;
              num9 = 3;
            }
            if (num7 == 6)
            {
              num8 = 5;
              num9 = 4;
            }
            if (num7 == 7)
            {
              num8 = 5;
              num9 = 4;
            }
            if (num7 == 8)
            {
              num8 = 5;
              num9 = 4;
            }
            if (num7 == 9)
            {
              num8 = 5;
              num9 = 3;
            }
            if (num7 == 10)
            {
              num8 = 2;
              num9 = 4;
            }
            if (num7 == 11)
            {
              num8 = 3;
              num9 = 3;
            }
            if (num7 == 12)
            {
              num8 = 2;
              num9 = 5;
            }
            for (int index4 = index3 - num8; index4 <= index3 + num8; ++index4)
            {
              for (int index5 = index2 - num9; index5 <= index2; ++index5)
              {
                if (Main.tile[index4, index5].active())
                {
                  num7 = -1;
                  break;
                }
              }
            }
            if ((double) num6 < (double) num8 * 1.75)
              num7 = -1;
            if (num2 > 0 || num3 > 0)
            {
              if (num2 > 0)
              {
                WorldGen.PlaceTile(index3, index2, 355, true);
                if (Main.tile[index3, index2].type == (ushort) 355)
                  --num2;
              }
              else if (num3 > 0)
              {
                WorldGen.PlaceTile(index3, index2, 354, true);
                if (Main.tile[index3, index2].type == (ushort) 354)
                  --num3;
              }
            }
            else
            {
              switch (num7)
              {
                case 0:
                  WorldGen.PlaceTile(index3, index2, 14, true, style: style2);
                  if (Main.tile[index3, index2].active())
                  {
                    if (!Main.tile[index3 - 2, index2].active())
                    {
                      WorldGen.PlaceTile(index3 - 2, index2, 15, true, style: style1);
                      if (Main.tile[index3 - 2, index2].active())
                      {
                        Main.tile[index3 - 2, index2].frameX += (short) 18;
                        Main.tile[index3 - 2, index2 - 1].frameX += (short) 18;
                      }
                    }
                    if (!Main.tile[index3 + 2, index2].active())
                      WorldGen.PlaceTile(index3 + 2, index2, 15, true, style: style1);
                  }
                  for (int i4 = index3 - 1; i4 <= index3 + 1; ++i4)
                  {
                    if (WorldGen.genRand.Next(2) == 0 && !Main.tile[i4, index2 - 2].active())
                    {
                      int num10 = WorldGen.genRand.Next(5);
                      if (style4 != -1 && num10 <= 1 && !Main.tileLighted[(int) Main.tile[i4 - 1, index2 - 2].type])
                        WorldGen.PlaceTile(i4, index2 - 2, 33, true, style: style4);
                      if (num10 == 2 && !Main.tileLighted[(int) Main.tile[i4 - 1, index2 - 2].type])
                        WorldGen.PlaceTile(i4, index2 - 2, 49, true);
                      if (num10 == 3)
                        WorldGen.PlaceTile(i4, index2 - 2, 50, true);
                      if (num10 == 4)
                        WorldGen.PlaceTile(i4, index2 - 2, 103, true);
                    }
                  }
                  continue;
                case 1:
                  WorldGen.PlaceTile(index3, index2, 18, true, style: style3);
                  if (Main.tile[index3, index2].active())
                  {
                    if (WorldGen.genRand.Next(2) == 0)
                    {
                      if (!Main.tile[index3 - 1, index2].active())
                      {
                        WorldGen.PlaceTile(index3 - 1, index2, 15, true, style: style1);
                        if (Main.tile[index3 - 1, index2].active())
                        {
                          Main.tile[index3 - 1, index2].frameX += (short) 18;
                          Main.tile[index3 - 1, index2 - 1].frameX += (short) 18;
                        }
                      }
                    }
                    else if (!Main.tile[index3 + 2, index2].active())
                      WorldGen.PlaceTile(index3 + 2, index2, 15, true, style: style1);
                    for (int i5 = index3; i5 <= index3 + 1; ++i5)
                    {
                      if (WorldGen.genRand.Next(2) == 0 && !Main.tile[i5, index2 - 1].active())
                      {
                        int num11 = WorldGen.genRand.Next(5);
                        if (style4 != -1 && num11 <= 1 && !Main.tileLighted[(int) Main.tile[i5 - 1, index2 - 1].type])
                          WorldGen.PlaceTile(i5, index2 - 1, 33, true, style: style4);
                        if (num11 == 2 && !Main.tileLighted[(int) Main.tile[i5 - 1, index2 - 1].type])
                          WorldGen.PlaceTile(i5, index2 - 1, 49, true);
                        if (num11 == 3)
                          WorldGen.PlaceTile(i5, index2 - 1, 50, true);
                        if (num11 == 4)
                          WorldGen.PlaceTile(i5, index2 - 1, 103, true);
                      }
                    }
                    continue;
                  }
                  continue;
                case 2:
                  WorldGen.PlaceTile(index3, index2, 105, true, style: style5);
                  continue;
                case 3:
                  WorldGen.PlaceTile(index3, index2, 101, true, style: style6);
                  continue;
                case 4:
                  if (WorldGen.genRand.Next(2) == 0)
                  {
                    WorldGen.PlaceTile(index3, index2, 15, true, style: style1);
                    Main.tile[index3, index2].frameX += (short) 18;
                    Main.tile[index3, index2 - 1].frameX += (short) 18;
                    continue;
                  }
                  WorldGen.PlaceTile(index3, index2, 15, true, style: style1);
                  continue;
                case 5:
                  if (WorldGen.genRand.Next(2) == 0)
                  {
                    WorldGen.Place4x2(index3, index2, (ushort) 79, 1, style7);
                    continue;
                  }
                  WorldGen.Place4x2(index3, index2, (ushort) 79, style: style7);
                  continue;
                case 6:
                  WorldGen.PlaceTile(index3, index2, 87, true, style: style8);
                  continue;
                case 7:
                  WorldGen.PlaceTile(index3, index2, 88, true, style: style9);
                  continue;
                case 8:
                  WorldGen.PlaceTile(index3, index2, 89, true, style: style10);
                  continue;
                case 9:
                  if (WorldGen.genRand.Next(2) == 0)
                  {
                    WorldGen.Place4x2(index3, index2, (ushort) 90, 1, style11);
                    continue;
                  }
                  WorldGen.Place4x2(index3, index2, (ushort) 90, style: style11);
                  continue;
                case 10:
                  WorldGen.PlaceTile(index3, index2, 93, true, style: style13);
                  continue;
                case 11:
                  WorldGen.PlaceTile(index3, index2, 100, true, style: style12);
                  continue;
                case 12:
                  WorldGen.PlaceTile(index3, index2, 104, true, style: style14);
                  continue;
                default:
                  continue;
              }
            }
          }
        }
      }
      return num1;
    }

    public static PaintingEntry RandBonePicture()
    {
      int num1 = WorldGen.genRand.Next(2);
      int num2 = 0;
      switch (num1)
      {
        case 0:
          num1 = 240;
          num2 = WorldGen.genRand.Next(2);
          switch (num2)
          {
            case 0:
              num2 = 16;
              break;
            case 1:
              num2 = 17;
              break;
          }
          break;
        case 1:
          num1 = 241;
          num2 = WorldGen.genRand.Next(9);
          break;
      }
      return new PaintingEntry()
      {
        tileType = num1,
        style = num2
      };
    }

    public static PaintingEntry RandHellPicture()
    {
      int num1 = WorldGen.genRand.Next(4);
      if (num1 == 1)
        num1 = WorldGen.genRand.Next(4);
      int num2;
      int num3;
      if (num1 == 0)
      {
        num2 = 240;
        num3 = WorldGen.genRand.Next(5);
        switch (num3)
        {
          case 0:
            num3 = 27;
            break;
          case 1:
            num3 = 29;
            break;
          case 2:
            num3 = 30;
            break;
          case 3:
            num3 = 31;
            break;
          case 4:
            num3 = 32;
            break;
        }
      }
      else if (num1 == 1)
      {
        num2 = 242;
        num3 = 14;
      }
      else if (num1 == 2)
      {
        num2 = 245;
        num3 = WorldGen.genRand.Next(3);
        switch (num3)
        {
          case 0:
            num3 = 1;
            break;
          case 1:
            num3 = 2;
            break;
          case 2:
            num3 = 4;
            break;
        }
      }
      else
      {
        num2 = 246;
        num3 = WorldGen.genRand.Next(3);
        switch (num3)
        {
          case 0:
            num3 = 0;
            break;
          case 1:
            num3 = 16;
            break;
          case 2:
            num3 = 17;
            break;
        }
      }
      return new PaintingEntry()
      {
        tileType = num2,
        style = num3
      };
    }

    public static PaintingEntry RandHousePictureDesert()
    {
      int num1 = WorldGen.genRand.Next(4);
      int num2;
      int num3;
      if (num1 <= 1)
      {
        num2 = 240;
        num3 = 63 + WorldGen.genRand.Next(6);
      }
      else if (num1 == 2)
      {
        num2 = 245;
        num3 = 7 + WorldGen.genRand.Next(2);
      }
      else
      {
        num2 = 242;
        num3 = 37 + WorldGen.genRand.Next(6);
      }
      return new PaintingEntry()
      {
        tileType = num2,
        style = num3
      };
    }

    public static PaintingEntry RandHousePicture()
    {
      int num1 = WorldGen.genRand.Next(4);
      if (num1 >= 3 && WorldGen.genRand.Next(2) != 0)
        num1 = WorldGen.genRand.Next(3);
      int num2;
      int num3;
      if (num1 <= 1)
      {
        num2 = 240;
        num3 = WorldGen.genRand.Next(15);
        switch (num3)
        {
          case 0:
            num3 = 26;
            break;
          case 1:
            num3 = 28;
            break;
          case 2:
            num3 = 20;
            break;
          case 3:
            num3 = 21;
            break;
          case 4:
            num3 = 22;
            break;
          case 5:
            num3 = 24;
            break;
          case 6:
            num3 = 25;
            break;
          case 7:
            num3 = 33;
            break;
          case 8:
            num3 = 34;
            break;
          case 9:
            num3 = 35;
            break;
          case 10:
            num3 = 76;
            break;
          case 11:
            num3 = 77;
            break;
          case 12:
            num3 = 78;
            break;
          case 13:
            num3 = 79;
            break;
          case 14:
            num3 = 82;
            break;
        }
      }
      else if (num1 == 2)
      {
        int maxValue = 9;
        num2 = 245;
        num3 = WorldGen.genRand.Next(maxValue);
        if (num3 == 0 && WorldGen.genRand.Next(3) != 0)
          num3 = WorldGen.genRand.Next(maxValue);
        switch (num3)
        {
          case 0:
            num3 = 0;
            break;
          case 1:
            num3 = 3;
            break;
          case 2:
            num3 = 5;
            break;
          case 3:
            num3 = 6;
            break;
          case 4:
            num3 = 14;
            break;
          case 5:
            int num4 = WorldGen.genRand.Next(4);
            if (num4 == 0)
              num3 = 15;
            if (num4 == 1)
              num3 = 16;
            if (num4 == 2)
              num3 = 17;
            if (num4 == 3)
            {
              num3 = 18;
              break;
            }
            break;
          case 6:
            num3 = 19;
            break;
          case 7:
            num3 = 20;
            break;
          case 8:
            num3 = 21;
            break;
        }
      }
      else
      {
        num2 = 246;
        num3 = WorldGen.genRand.Next(8);
        switch (num3)
        {
          case 0:
            num3 = 1;
            break;
          case 1:
            num3 = 30;
            break;
          case 2:
            num3 = 31;
            break;
          case 3:
            num3 = 32;
            break;
          case 4:
            num3 = 33;
            break;
          case 5:
            num3 = 34;
            break;
          case 6:
            num3 = 35;
            break;
          case 7:
            num3 = 36;
            break;
        }
      }
      return new PaintingEntry()
      {
        tileType = num2,
        style = num3
      };
    }

    public static PaintingEntry RandPictureTile()
    {
      int num1 = WorldGen.genRand.Next(3);
      int num2 = 0;
      if (num1 <= 1)
      {
        int maxValue = 7;
        num1 = 240;
        num2 = WorldGen.genRand.Next(maxValue);
        if (num2 == 6)
          num2 = WorldGen.genRand.Next(maxValue);
        if (num2 == 0)
          num2 = 12;
        else if (num2 == 1)
          num2 = 13;
        else if (num2 == 2)
          num2 = 14;
        else if (num2 == 3)
          num2 = 15;
        else if (num2 == 4)
          num2 = 18;
        else if (num2 == 5)
          num2 = 19;
        else if (num2 == 6)
          num2 = 23;
      }
      else if (num1 == 2)
      {
        num1 = 242;
        num2 = WorldGen.genRand.Next(17);
        if (num2 > 13)
        {
          switch (num2)
          {
            case 14:
              num2 = 15;
              break;
            case 15:
              num2 = 16;
              break;
            case 16:
              num2 = 30;
              break;
          }
        }
      }
      return new PaintingEntry()
      {
        tileType = num1,
        style = num2
      };
    }

    public static void DungeonStairs(int i, int j, ushort tileType, int wallType)
    {
      Vector2D zero = Vector2D.Zero;
      double maxValue = (double) WorldGen.genRand.Next(5, 9);
      int num1 = 1;
      Vector2D vector2D;
      vector2D.X = (double) i;
      vector2D.Y = (double) j;
      int num2 = WorldGen.genRand.Next(10, 30);
      int num3 = i <= GenVars.dEnteranceX ? 1 : -1;
      if (i > Main.maxTilesX - 400)
        num3 = -1;
      else if (i < 400)
        num3 = 1;
      zero.Y = -1.0;
      zero.X = (double) num3;
      if (WorldGen.genRand.Next(3) != 0)
        zero.X *= 1.0 + (double) WorldGen.genRand.Next(0, 200) * 0.01;
      else if (WorldGen.genRand.Next(3) == 0)
        zero.X *= (double) WorldGen.genRand.Next(50, 76) * 0.01;
      else if (WorldGen.genRand.Next(6) == 0)
        zero.Y *= 2.0;
      if (GenVars.dungeonX < Main.maxTilesX / 2 && zero.X < 0.0 && zero.X < 0.5)
        zero.X = -0.5;
      if (GenVars.dungeonX > Main.maxTilesX / 2 && zero.X > 0.0 && zero.X > 0.5)
        zero.X = -0.5;
      if (WorldGen.drunkWorldGen)
      {
        num1 = num3 * -1;
        zero.X *= -1.0;
      }
      while (num2 > 0)
      {
        --num2;
        int num4 = (int) (vector2D.X - maxValue - 4.0 - (double) WorldGen.genRand.Next(6));
        int num5 = (int) (vector2D.X + maxValue + 4.0 + (double) WorldGen.genRand.Next(6));
        int num6 = (int) (vector2D.Y - maxValue - 4.0);
        int num7 = (int) (vector2D.Y + maxValue + 4.0 + (double) WorldGen.genRand.Next(6));
        if (num4 < 0)
          num4 = 0;
        if (num5 > Main.maxTilesX)
          num5 = Main.maxTilesX;
        if (num6 < 0)
          num6 = 0;
        if (num7 > Main.maxTilesY)
          num7 = Main.maxTilesY;
        int num8 = 1;
        if (vector2D.X > (double) (Main.maxTilesX / 2))
          num8 = -1;
        int i1 = (int) (vector2D.X + GenVars.dxStrength1 * 0.6 * (double) num8 + GenVars.dxStrength2 * (double) num8);
        int num9 = (int) (GenVars.dyStrength2 * 0.5);
        if (vector2D.Y < Main.worldSurface - 5.0 && Main.tile[i1, (int) (vector2D.Y - maxValue - 6.0 + (double) num9)].wall == (ushort) 0 && Main.tile[i1, (int) (vector2D.Y - maxValue - 7.0 + (double) num9)].wall == (ushort) 0 && Main.tile[i1, (int) (vector2D.Y - maxValue - 8.0 + (double) num9)].wall == (ushort) 0)
        {
          GenVars.dSurface = true;
          WorldGen.TileRunner(i1, (int) (vector2D.Y - maxValue - 6.0 + (double) num9), (double) WorldGen.genRand.Next(25, 35), WorldGen.genRand.Next(10, 20), -1, speedY: -1.0);
        }
        for (int index1 = num4; index1 < num5; ++index1)
        {
          for (int index2 = num6; index2 < num7; ++index2)
          {
            Main.tile[index1, index2].liquid = (byte) 0;
            if (!Main.wallDungeon[(int) Main.tile[index1, index2].wall])
            {
              Main.tile[index1, index2].wall = (ushort) 0;
              Main.tile[index1, index2].active(true);
              Main.tile[index1, index2].type = tileType;
            }
          }
        }
        for (int index3 = num4 + 1; index3 < num5 - 1; ++index3)
        {
          for (int index4 = num6 + 1; index4 < num7 - 1; ++index4)
            Main.tile[index3, index4].wall = (ushort) wallType;
        }
        int num10 = 0;
        if (WorldGen.genRand.Next((int) maxValue) == 0)
          num10 = WorldGen.genRand.Next(1, 3);
        int num11 = (int) (vector2D.X - maxValue * 0.5 - (double) num10);
        int num12 = (int) (vector2D.X + maxValue * 0.5 + (double) num10);
        int num13 = (int) (vector2D.Y - maxValue * 0.5 - (double) num10);
        int num14 = (int) (vector2D.Y + maxValue * 0.5 + (double) num10);
        if (num11 < 0)
          num11 = 0;
        if (num12 > Main.maxTilesX)
          num12 = Main.maxTilesX;
        if (num13 < 0)
          num13 = 0;
        if (num14 > Main.maxTilesY)
          num14 = Main.maxTilesY;
        for (int i2 = num11; i2 < num12; ++i2)
        {
          for (int j1 = num13; j1 < num14; ++j1)
          {
            Main.tile[i2, j1].active(false);
            WorldGen.PlaceWall(i2, j1, wallType, true);
          }
        }
        if (GenVars.dSurface)
          num2 = 0;
        vector2D = Vector2D.op_Addition(vector2D, zero);
        if (vector2D.Y < Main.worldSurface)
          zero.Y *= 0.98;
      }
      GenVars.dungeonX = (int) vector2D.X;
      GenVars.dungeonY = (int) vector2D.Y;
    }

    public static bool PlaceSandTrap(int i, int j)
    {
      int num1 = 6;
      int num2 = 4;
      int num3 = 25;
      int i1 = i;
      int index1 = j;
      while (!Main.tile[i1, index1].active() && index1 < Main.UnderworldLayer)
        ++index1;
      if (!Main.tileSolid[(int) Main.tile[i1, index1].type] || Main.tile[i1, index1].halfBrick() || Main.tile[i1, index1].topSlope() || Main.tile[i1, index1].type != (ushort) 53 && Main.tile[i1, index1].type != (ushort) 397 && Main.tile[i1, index1].type != (ushort) 396 || Main.tile[i1, index1].wall != (ushort) 216 && Main.tile[i1, index1].wall != (ushort) 187)
        return false;
      int j1 = index1 - 1;
      int num4 = -1;
      int num5 = WorldGen.genRand.Next(6, 12);
      int num6 = WorldGen.genRand.Next(6, 14);
      for (int index2 = i1 - num3; index2 <= i1 + num3; ++index2)
      {
        for (int index3 = j1 - num3; index3 < j1 + num3; ++index3)
        {
          if (Main.tile[index2, index3].wire() || TileID.Sets.BasicChest[(int) Main.tile[index2, index3].type] || TileID.Sets.Paintings[(int) Main.tile[index2, index3].type] || Main.tile[index2, index3].type == (ushort) 10 || Main.tile[index2, index3].type == (ushort) 19 || Main.tile[index2, index3].type == (ushort) 15 || Main.tile[index2, index3].type == (ushort) 219)
            return false;
        }
      }
      for (int index4 = i1 - 2; index4 <= i1 + 2; ++index4)
      {
        for (int index5 = j1 + 1; index5 <= j1 + 3; ++index5)
        {
          if (!Main.tile[index4, index5].active() || !Main.tileSolid[(int) Main.tile[index4, index5].type])
            return false;
        }
      }
      if (Main.tile[i1, j1 + 1].type == (ushort) 162)
        return false;
      for (int index6 = j1; index6 > j1 - 30; --index6)
      {
        if (Main.tile[i1, index6].active())
        {
          if (Main.tile[i1, index6].type != (ushort) 396)
            return false;
          num4 = index6;
          break;
        }
      }
      if (num4 <= -1 || j1 - num4 < num6 + num2)
        return false;
      int num7 = 0;
      int index7 = (j1 + num4) / 2;
      for (int index8 = i1 - num5; index8 <= i1 + num5; ++index8)
      {
        if (Main.tile[index8, index7].active() && Main.tileSolid[(int) Main.tile[index8, index7].type])
          return false;
        for (int index9 = num4 - num6; index9 <= num4; ++index9)
        {
          if (Main.tile[index8, index9].active())
          {
            if (TileID.Sets.Ore[(int) Main.tile[index8, index9].type] || Main.tile[index8, index9].type == (ushort) 404)
              return false;
            if (Main.tileSolid[(int) Main.tile[index8, index9].type])
              ++num7;
          }
        }
      }
      double num8 = (double) ((num5 * 2 + 1) * (num6 + 1)) * 0.75;
      if ((double) num7 < num8)
        return false;
      for (int index10 = i1 - num5 - 1; index10 <= i1 + num5 + 1; ++index10)
      {
        for (int index11 = num4 - num6; index11 <= num4; ++index11)
        {
          bool flag = false;
          if (Main.tile[index10, index11].active() && Main.tileSolid[(int) Main.tile[index10, index11].type])
            flag = true;
          if (index11 == num4)
          {
            Main.tile[index10, index11].slope((byte) 0);
            Main.tile[index10, index11].halfBrick(false);
            if (!flag)
            {
              Main.tile[index10, index11].active(true);
              Main.tile[index10, index11].type = (ushort) 396;
            }
          }
          else if (index11 == num4 - num6)
          {
            Main.tile[index10, index11].ClearTile();
            Main.tile[index10, index11].active(true);
            Main.tile[index10, index11].type = !flag || !Main.tile[index10, index11 - 1].active() || !Main.tileSolid[(int) Main.tile[index10, index11 - 1].type] ? (ushort) 396 : (ushort) 397;
          }
          else if (index10 == i1 - num5 - 1 || index10 == i1 + num5 + 1)
          {
            if (!flag)
            {
              Main.tile[index10, index11].ClearTile();
              Main.tile[index10, index11].active(true);
              Main.tile[index10, index11].type = (ushort) 396;
            }
            else
            {
              Main.tile[index10, index11].slope((byte) 0);
              Main.tile[index10, index11].halfBrick(false);
            }
          }
          else
          {
            Main.tile[index10, index11].ClearTile();
            Main.tile[index10, index11].active(true);
            Main.tile[index10, index11].type = (ushort) 53;
          }
        }
      }
      for (int index12 = (int) ((double) num4 - (double) num6 * 0.666); (double) index12 <= (double) num4 - (double) num6 * 0.333; ++index12)
      {
        if ((double) index12 < (double) num4 - (double) num6 * 0.4)
        {
          if (Main.tile[i1 - num5 - 2, index12].bottomSlope())
            Main.tile[i1 - num5 - 2, index12].slope((byte) 0);
        }
        else if ((double) index12 > (double) num4 - (double) num6 * 0.6)
        {
          if (Main.tile[i1 - num5 - 2, index12].topSlope())
            Main.tile[i1 - num5 - 2, index12].slope((byte) 0);
          Main.tile[i1 - num5 - 2, index12].halfBrick(false);
        }
        else
        {
          Main.tile[i1 - num5 - 2, index12].halfBrick(false);
          Main.tile[i1 - num5 - 2, index12].slope((byte) 0);
        }
        if (!Main.tile[i1 - num5 - 2, index12].active() || !Main.tileSolid[(int) Main.tile[i1 - num5 - 2, index12].type])
        {
          Main.tile[i1 - num5 - 2, index12].active(true);
          Main.tile[i1 - num5 - 2, index12].type = (ushort) 396;
        }
        if (!Main.tile[i1 + num5 + 2, index12].active() || !Main.tileSolid[(int) Main.tile[i1 + num5 + 2, index12].type])
        {
          Main.tile[i1 + num5 + 2, index12].active(true);
          Main.tile[i1 + num5 + 2, index12].type = (ushort) 396;
        }
      }
      for (int index13 = num4 - num6; index13 <= num4; ++index13)
      {
        Main.tile[i1 - num5 - 2, index13].slope((byte) 0);
        Main.tile[i1 - num5 - 2, index13].halfBrick(false);
        Main.tile[i1 - num5 - 1, index13].slope((byte) 0);
        Main.tile[i1 - num5 - 1, index13].halfBrick(false);
        Main.tile[i1 - num5 + 1, index13].slope((byte) 0);
        Main.tile[i1 - num5 + 1, index13].halfBrick(false);
        Main.tile[i1 - num5 + 2, index13].slope((byte) 0);
        Main.tile[i1 - num5 + 2, index13].halfBrick(false);
      }
      for (int index14 = i1 - num5 - 1; index14 < i1 + num5 + 1; ++index14)
      {
        int index15 = j1 - num6 - 1;
        if (Main.tile[index14, index15].bottomSlope())
          Main.tile[index14, index15].slope((byte) 0);
        Main.tile[index14, index15].halfBrick(false);
      }
      WorldGen.KillTile(i1 - 2, j1);
      WorldGen.KillTile(i1 - 1, j1);
      WorldGen.KillTile(i1 + 1, j1);
      WorldGen.KillTile(i1 + 2, j1);
      WorldGen.PlaceTile(i1, j1, 135, true, style: 7);
      for (int i2 = i1 - num5; i2 <= i1 + num5; ++i2)
      {
        int num9 = j1;
        if ((double) i2 < (double) i1 - (double) num5 * 0.8 || (double) i2 > (double) i1 + (double) num5 * 0.8)
          num9 = j1 - 3;
        else if ((double) i2 < (double) i1 - (double) num5 * 0.6 || (double) i2 > (double) i1 + (double) num5 * 0.6)
          num9 = j1 - 2;
        else if ((double) i2 < (double) i1 - (double) num5 * 0.4 || (double) i2 > (double) i1 + (double) num5 * 0.4)
          num9 = j1 - 1;
        for (int j2 = num4; j2 <= j1; ++j2)
        {
          if (i2 == i1 && j2 <= j1)
            Main.tile[i1, j2].wire(true);
          if (Main.tile[i2, j2].active() && Main.tileSolid[(int) Main.tile[i2, j2].type])
          {
            if (j2 < num4 + num1 - 4)
            {
              Main.tile[i2, j2].actuator(true);
              Main.tile[i2, j2].wire(true);
            }
            else if (j2 < num9)
              WorldGen.KillTile(i2, j2);
          }
        }
      }
      return true;
    }

    public static bool DungeonPitTrap(int i, int j, ushort tileType, int wallType)
    {
      int num1 = 30;
      int i1 = i;
      int index1 = j;
      int num2 = index1;
      int num3 = WorldGen.genRand.Next(8, 19);
      int num4 = WorldGen.genRand.Next(19, 46);
      int num5 = num3 + WorldGen.genRand.Next(6, 10);
      int num6 = num4 + WorldGen.genRand.Next(6, 10);
      if (!Main.wallDungeon[(int) Main.tile[i1, index1].wall] || Main.tile[i1, index1].active())
        return false;
      for (int j1 = index1; j1 < Main.maxTilesY; ++j1)
      {
        if (j1 > Main.maxTilesY - 300)
          return false;
        if (Main.tile[i1, j1].active() && WorldGen.SolidTile(i1, j1))
        {
          if (Main.tile[i1, j1].type == (ushort) 48)
            return false;
          index1 = j1;
          break;
        }
      }
      if (!Main.wallDungeon[(int) Main.tile[i1 - num3, index1].wall] || !Main.wallDungeon[(int) Main.tile[i1 + num3, index1].wall])
        return false;
      for (int index2 = index1; index2 < index1 + num1; ++index2)
      {
        bool flag = true;
        for (int index3 = i1 - num3; index3 <= i1 + num3; ++index3)
        {
          Tile tile = Main.tile[index3, index2];
          if (tile.active() && Main.tileDungeon[(int) tile.type])
            flag = false;
        }
        if (flag)
        {
          index1 = index2;
          break;
        }
      }
      for (int index4 = i1 - num3; index4 <= i1 + num3; ++index4)
      {
        for (int index5 = index1; index5 <= index1 + num4; ++index5)
        {
          Tile tile = Main.tile[index4, index5];
          if (tile.active() && (Main.tileDungeon[(int) tile.type] || (int) tile.type == (int) GenVars.crackedType))
            return false;
        }
      }
      bool flag1 = false;
      if (GenVars.dungeonLake)
      {
        flag1 = true;
        GenVars.dungeonLake = false;
      }
      else if (WorldGen.genRand.Next(8) == 0)
        flag1 = true;
      for (int index6 = i1 - num3; index6 <= i1 + num3; ++index6)
      {
        for (int index7 = num2; index7 <= index1 + num4; ++index7)
        {
          if (Main.tileDungeon[(int) Main.tile[index6, index7].type])
          {
            Main.tile[index6, index7].type = GenVars.crackedType;
            Main.tile[index6, index7].wall = (ushort) wallType;
          }
        }
      }
      for (int index8 = i1 - num5; index8 <= i1 + num5; ++index8)
      {
        for (int index9 = num2; index9 <= index1 + num6; ++index9)
        {
          Main.tile[index8, index9].lava(false);
          Main.tile[index8, index9].liquid = (byte) 0;
          if (!Main.wallDungeon[(int) Main.tile[index8, index9].wall] && (int) Main.tile[index8, index9].type != (int) GenVars.crackedType)
          {
            Main.tile[index8, index9].Clear(TileDataType.Slope);
            Main.tile[index8, index9].type = tileType;
            Main.tile[index8, index9].active(true);
            if (index8 > i1 - num5 && index8 < i1 + num5 && index9 < index1 + num6)
              Main.tile[index8, index9].wall = (ushort) wallType;
          }
        }
      }
      for (int index10 = i1 - num3; index10 <= i1 + num3; ++index10)
      {
        for (int index11 = num2; index11 <= index1 + num4; ++index11)
        {
          if ((int) Main.tile[index10, index11].type != (int) GenVars.crackedType)
          {
            if (flag1)
              Main.tile[index10, index11].liquid = byte.MaxValue;
            if (index10 == i1 - num3 || index10 == i1 + num3 || index11 == index1 + num4)
              Main.tile[index10, index11].type = (ushort) 48;
            else if (index10 == i1 - num3 + 1 && index11 % 2 == 0 || index10 == i1 + num3 - 1 && index11 % 2 == 0 || index11 == index1 + num4 - 1 && index10 % 2 == 0)
              Main.tile[index10, index11].type = (ushort) 48;
            else
              Main.tile[index10, index11].active(false);
          }
        }
      }
      return true;
    }

    public static void DungeonHalls(int i, int j, ushort tileType, int wallType, bool forceX = false)
    {
      Vector2D zero1 = Vector2D.Zero;
      double num1 = (double) WorldGen.genRand.Next(4, 6);
      double num2 = num1;
      Vector2D zero2 = Vector2D.Zero;
      Vector2D zero3 = Vector2D.Zero;
      Vector2D vector2D;
      vector2D.X = (double) i;
      vector2D.Y = (double) j;
      int num3 = WorldGen.genRand.Next(35, 80);
      bool flag1 = false;
      if (WorldGen.genRand.Next(6) == 0)
        flag1 = true;
      if (forceX)
      {
        num3 += 20;
        GenVars.lastDungeonHall = Vector2D.Zero;
      }
      else if (WorldGen.genRand.Next(5) == 0)
      {
        num1 *= 2.0;
        num3 /= 2;
      }
      bool flag2 = false;
      bool flag3 = false;
      bool flag4 = true;
      while (!flag2)
      {
        bool flag5 = false;
        int num4;
        if (flag4 && !forceX)
        {
          bool flag6 = true;
          bool flag7 = true;
          bool flag8 = true;
          bool flag9 = true;
          int num5 = num3;
          bool flag10 = false;
          for (int index1 = j; index1 > j - num5; --index1)
          {
            int index2 = i;
            if ((int) Main.tile[index2, index1].wall == wallType)
            {
              if (flag10)
              {
                flag6 = false;
                break;
              }
            }
            else
              flag10 = true;
          }
          bool flag11 = false;
          for (int index3 = j; index3 < j + num5; ++index3)
          {
            int index4 = i;
            if ((int) Main.tile[index4, index3].wall == wallType)
            {
              if (flag11)
              {
                flag7 = false;
                break;
              }
            }
            else
              flag11 = true;
          }
          bool flag12 = false;
          for (int index5 = i; index5 > i - num5; --index5)
          {
            int index6 = j;
            if ((int) Main.tile[index5, index6].wall == wallType)
            {
              if (flag12)
              {
                flag8 = false;
                break;
              }
            }
            else
              flag12 = true;
          }
          bool flag13 = false;
          for (int index7 = i; index7 < i + num5; ++index7)
          {
            int index8 = j;
            if ((int) Main.tile[index7, index8].wall == wallType)
            {
              if (flag13)
              {
                flag9 = false;
                break;
              }
            }
            else
              flag13 = true;
          }
          if (!flag8 && !flag9 && !flag6 && !flag7)
          {
            num4 = WorldGen.genRand.Next(2) != 0 ? 1 : -1;
            if (WorldGen.genRand.Next(2) == 0)
              flag5 = true;
          }
          else
          {
            WorldGen.genRand.Next(4);
            int num6;
            do
            {
              num6 = WorldGen.genRand.Next(4);
            }
            while (!(num6 == 0 & flag6) && !(num6 == 1 & flag7) && !(num6 == 2 & flag8) && !(num6 == 3 & flag9));
            switch (num6)
            {
              case 0:
                num4 = -1;
                break;
              case 1:
                num4 = 1;
                break;
              default:
                flag5 = true;
                num4 = num6 != 2 ? 1 : -1;
                break;
            }
          }
        }
        else
        {
          num4 = WorldGen.genRand.Next(2) != 0 ? 1 : -1;
          if (WorldGen.genRand.Next(2) == 0)
            flag5 = true;
        }
        flag4 = false;
        if (forceX)
          flag5 = true;
        if (flag5)
        {
          zero2.Y = 0.0;
          zero2.X = (double) num4;
          zero3.Y = 0.0;
          zero3.X = (double) -num4;
          zero1.Y = 0.0;
          zero1.X = (double) num4;
          if (WorldGen.genRand.Next(3) == 0)
            zero1.Y = WorldGen.genRand.Next(2) != 0 ? 0.2 : -0.2;
        }
        else
        {
          ++num1;
          zero1.Y = (double) num4;
          zero1.X = 0.0;
          zero2.X = 0.0;
          zero2.Y = (double) num4;
          zero3.X = 0.0;
          zero3.Y = (double) -num4;
          if (WorldGen.genRand.Next(3) != 0)
          {
            flag3 = true;
            zero1.X = WorldGen.genRand.Next(2) != 0 ? (double) -WorldGen.genRand.Next(10, 20) * 0.1 : (double) WorldGen.genRand.Next(10, 20) * 0.1;
          }
          else if (WorldGen.genRand.Next(2) == 0)
            zero1.X = WorldGen.genRand.Next(2) != 0 ? (double) -WorldGen.genRand.Next(20, 40) * 0.01 : (double) WorldGen.genRand.Next(20, 40) * 0.01;
          else
            num3 /= 2;
        }
        if (Vector2D.op_Inequality(GenVars.lastDungeonHall, zero3))
          flag2 = true;
      }
      int num7 = 0;
      bool flag14 = vector2D.Y < Main.rockLayer + 100.0;
      if (WorldGen.remixWorldGen)
        flag14 = vector2D.Y < Main.worldSurface + 100.0;
      if (!forceX)
      {
        if (vector2D.X > (double) (WorldGen.lastMaxTilesX - 200))
        {
          int num8 = -1;
          zero2.Y = 0.0;
          zero2.X = (double) num8;
          zero1.Y = 0.0;
          zero1.X = (double) num8;
          if (WorldGen.genRand.Next(3) == 0)
            zero1.Y = WorldGen.genRand.Next(2) != 0 ? 0.2 : -0.2;
        }
        else if (vector2D.X < 200.0)
        {
          int num9 = 1;
          zero2.Y = 0.0;
          zero2.X = (double) num9;
          zero1.Y = 0.0;
          zero1.X = (double) num9;
          if (WorldGen.genRand.Next(3) == 0)
            zero1.Y = WorldGen.genRand.Next(2) != 0 ? 0.2 : -0.2;
        }
        else if (vector2D.Y > (double) (WorldGen.lastMaxTilesY - 300))
        {
          int num10 = -1;
          ++num1;
          zero1.Y = (double) num10;
          zero1.X = 0.0;
          zero2.X = 0.0;
          zero2.Y = (double) num10;
          if (WorldGen.genRand.Next(2) == 0)
            zero1.X = WorldGen.genRand.Next(2) != 0 ? (double) -WorldGen.genRand.Next(20, 50) * 0.01 : (double) WorldGen.genRand.Next(20, 50) * 0.01;
        }
        else if (flag14)
        {
          int num11 = 1;
          ++num1;
          zero1.Y = (double) num11;
          zero1.X = 0.0;
          zero2.X = 0.0;
          zero2.Y = (double) num11;
          if (WorldGen.genRand.Next(3) != 0)
          {
            flag3 = true;
            zero1.X = WorldGen.genRand.Next(2) != 0 ? (double) -WorldGen.genRand.Next(10, 20) * 0.1 : (double) WorldGen.genRand.Next(10, 20) * 0.1;
          }
          else if (WorldGen.genRand.Next(2) == 0)
            zero1.X = WorldGen.genRand.Next(2) != 0 ? (double) WorldGen.genRand.Next(20, 50) * 0.01 : (double) WorldGen.genRand.Next(20, 50) * 0.01;
        }
        else if (vector2D.X < (double) (Main.maxTilesX / 2) && vector2D.X > (double) Main.maxTilesX * 0.25)
        {
          int num12 = -1;
          zero2.Y = 0.0;
          zero2.X = (double) num12;
          zero1.Y = 0.0;
          zero1.X = (double) num12;
          if (WorldGen.genRand.Next(3) == 0)
            zero1.Y = WorldGen.genRand.Next(2) != 0 ? 0.2 : -0.2;
        }
        else if (vector2D.X > (double) (Main.maxTilesX / 2) && vector2D.X < (double) Main.maxTilesX * 0.75)
        {
          int num13 = 1;
          zero2.Y = 0.0;
          zero2.X = (double) num13;
          zero1.Y = 0.0;
          zero1.X = (double) num13;
          if (WorldGen.genRand.Next(3) == 0)
            zero1.Y = WorldGen.genRand.Next(2) != 0 ? 0.2 : -0.2;
        }
      }
      if (zero2.Y == 0.0)
      {
        GenVars.DDoorX[GenVars.numDDoors] = (int) vector2D.X;
        GenVars.DDoorY[GenVars.numDDoors] = (int) vector2D.Y;
        GenVars.DDoorPos[GenVars.numDDoors] = 0;
        ++GenVars.numDDoors;
      }
      else
      {
        GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = (int) vector2D.X;
        GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = (int) vector2D.Y;
        ++GenVars.numDungeonPlatforms;
      }
      GenVars.lastDungeonHall = zero2;
      if (Math.Abs(zero1.X) > Math.Abs(zero1.Y) && WorldGen.genRand.Next(3) != 0)
        num1 = (double) (int) (num2 * ((double) WorldGen.genRand.Next(110, 150) * 0.01));
      while (num3 > 0)
      {
        ++num7;
        if (zero2.X > 0.0 && vector2D.X > (double) (Main.maxTilesX - 100))
          num3 = 0;
        else if (zero2.X < 0.0 && vector2D.X < 100.0)
          num3 = 0;
        else if (zero2.Y > 0.0 && vector2D.Y > (double) (Main.maxTilesY - 100))
          num3 = 0;
        else if (WorldGen.remixWorldGen && zero2.Y < 0.0 && vector2D.Y < (Main.rockLayer + Main.worldSurface) / 2.0)
          num3 = 0;
        else if (!WorldGen.remixWorldGen && zero2.Y < 0.0 && vector2D.Y < Main.rockLayer + 50.0)
          num3 = 0;
        --num3;
        int num14 = (int) (vector2D.X - num1 - 4.0 - (double) WorldGen.genRand.Next(6));
        int num15 = (int) (vector2D.X + num1 + 4.0 + (double) WorldGen.genRand.Next(6));
        int num16 = (int) (vector2D.Y - num1 - 4.0 - (double) WorldGen.genRand.Next(6));
        int num17 = (int) (vector2D.Y + num1 + 4.0 + (double) WorldGen.genRand.Next(6));
        if (num14 < 0)
          num14 = 0;
        if (num15 > Main.maxTilesX)
          num15 = Main.maxTilesX;
        if (num16 < 0)
          num16 = 0;
        if (num17 > Main.maxTilesY)
          num17 = Main.maxTilesY;
        for (int index9 = num14; index9 < num15; ++index9)
        {
          for (int index10 = num16; index10 < num17; ++index10)
          {
            if (index9 < GenVars.dMinX)
              GenVars.dMinX = index9;
            if (index9 > GenVars.dMaxX)
              GenVars.dMaxX = index9;
            if (index10 > GenVars.dMaxY)
              GenVars.dMaxY = index10;
            Main.tile[index9, index10].liquid = (byte) 0;
            if (!Main.wallDungeon[(int) Main.tile[index9, index10].wall])
            {
              Main.tile[index9, index10].active(true);
              Main.tile[index9, index10].type = tileType;
              Main.tile[index9, index10].Clear(TileDataType.Slope);
            }
          }
        }
        for (int index11 = num14 + 1; index11 < num15 - 1; ++index11)
        {
          for (int index12 = num16 + 1; index12 < num17 - 1; ++index12)
            Main.tile[index11, index12].wall = (ushort) wallType;
        }
        int num18 = 0;
        if (zero1.Y == 0.0 && WorldGen.genRand.Next((int) num1 + 1) == 0)
          num18 = WorldGen.genRand.Next(1, 3);
        else if (zero1.X == 0.0 && WorldGen.genRand.Next((int) num1 - 1) == 0)
          num18 = WorldGen.genRand.Next(1, 3);
        else if (WorldGen.genRand.Next((int) num1 * 3) == 0)
          num18 = WorldGen.genRand.Next(1, 3);
        int num19 = (int) (vector2D.X - num1 * 0.5 - (double) num18);
        int num20 = (int) (vector2D.X + num1 * 0.5 + (double) num18);
        int num21 = (int) (vector2D.Y - num1 * 0.5 - (double) num18);
        int num22 = (int) (vector2D.Y + num1 * 0.5 + (double) num18);
        if (num19 < 0)
          num19 = 0;
        if (num20 > Main.maxTilesX)
          num20 = Main.maxTilesX;
        if (num21 < 0)
          num21 = 0;
        if (num22 > Main.maxTilesY)
          num22 = Main.maxTilesY;
        for (int index13 = num19; index13 < num20; ++index13)
        {
          for (int index14 = num21; index14 < num22; ++index14)
          {
            Main.tile[index13, index14].Clear(TileDataType.Slope);
            if (flag1)
            {
              if (Main.tile[index13, index14].active() || (int) Main.tile[index13, index14].wall != wallType)
              {
                Main.tile[index13, index14].active(true);
                Main.tile[index13, index14].type = GenVars.crackedType;
              }
            }
            else
              Main.tile[index13, index14].active(false);
            Main.tile[index13, index14].Clear(TileDataType.Slope);
            Main.tile[index13, index14].wall = (ushort) wallType;
          }
        }
        vector2D = Vector2D.op_Addition(vector2D, zero1);
        if (flag3 && num7 > WorldGen.genRand.Next(10, 20))
        {
          num7 = 0;
          zero1.X *= -1.0;
        }
      }
      GenVars.dungeonX = (int) vector2D.X;
      GenVars.dungeonY = (int) vector2D.Y;
      if (zero2.Y == 0.0)
      {
        GenVars.DDoorX[GenVars.numDDoors] = (int) vector2D.X;
        GenVars.DDoorY[GenVars.numDDoors] = (int) vector2D.Y;
        GenVars.DDoorPos[GenVars.numDDoors] = 0;
        ++GenVars.numDDoors;
      }
      else
      {
        GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = (int) vector2D.X;
        GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = (int) vector2D.Y;
        ++GenVars.numDungeonPlatforms;
      }
    }

    public static void DungeonRoom(int i, int j, ushort tileType, int wallType)
    {
      double num1 = (double) WorldGen.genRand.Next(15, 30);
      Vector2D vector2D1;
      vector2D1.X = (double) WorldGen.genRand.Next(-10, 11) * 0.1;
      vector2D1.Y = (double) WorldGen.genRand.Next(-10, 11) * 0.1;
      Vector2D vector2D2;
      vector2D2.X = (double) i;
      vector2D2.Y = (double) j - num1 / 2.0;
      int num2 = WorldGen.genRand.Next(10, 20);
      double num3 = vector2D2.X;
      double num4 = vector2D2.X;
      double num5 = vector2D2.Y;
      double num6 = vector2D2.Y;
      while (num2 > 0)
      {
        --num2;
        int num7 = (int) (vector2D2.X - num1 * 0.8 - 5.0);
        int num8 = (int) (vector2D2.X + num1 * 0.8 + 5.0);
        int num9 = (int) (vector2D2.Y - num1 * 0.8 - 5.0);
        int num10 = (int) (vector2D2.Y + num1 * 0.8 + 5.0);
        if (num7 < 0)
          num7 = 0;
        if (num8 > Main.maxTilesX)
          num8 = Main.maxTilesX;
        if (num9 < 0)
          num9 = 0;
        if (num10 > Main.maxTilesY)
          num10 = Main.maxTilesY;
        for (int index1 = num7; index1 < num8; ++index1)
        {
          for (int index2 = num9; index2 < num10; ++index2)
          {
            if (index1 < GenVars.dMinX)
              GenVars.dMinX = index1;
            if (index1 > GenVars.dMaxX)
              GenVars.dMaxX = index1;
            if (index2 > GenVars.dMaxY)
              GenVars.dMaxY = index2;
            Main.tile[index1, index2].liquid = (byte) 0;
            if (!Main.wallDungeon[(int) Main.tile[index1, index2].wall])
            {
              Main.tile[index1, index2].Clear(TileDataType.Slope);
              Main.tile[index1, index2].active(true);
              Main.tile[index1, index2].type = tileType;
            }
          }
        }
        for (int index3 = num7 + 1; index3 < num8 - 1; ++index3)
        {
          for (int index4 = num9 + 1; index4 < num10 - 1; ++index4)
            Main.tile[index3, index4].wall = (ushort) wallType;
        }
        int num11 = (int) (vector2D2.X - num1 * 0.5);
        int num12 = (int) (vector2D2.X + num1 * 0.5);
        int num13 = (int) (vector2D2.Y - num1 * 0.5);
        int num14 = (int) (vector2D2.Y + num1 * 0.5);
        if (num11 < 0)
          num11 = 0;
        if (num12 > Main.maxTilesX)
          num12 = Main.maxTilesX;
        if (num13 < 0)
          num13 = 0;
        if (num14 > Main.maxTilesY)
          num14 = Main.maxTilesY;
        if ((double) num11 < num3)
          num3 = (double) num11;
        if ((double) num12 > num4)
          num4 = (double) num12;
        if ((double) num13 < num5)
          num5 = (double) num13;
        if ((double) num14 > num6)
          num6 = (double) num14;
        for (int index5 = num11; index5 < num12; ++index5)
        {
          for (int index6 = num13; index6 < num14; ++index6)
          {
            Main.tile[index5, index6].active(false);
            Main.tile[index5, index6].wall = (ushort) wallType;
          }
        }
        vector2D2 = Vector2D.op_Addition(vector2D2, vector2D1);
        vector2D1.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        vector2D1.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        if (vector2D1.X > 1.0)
          vector2D1.X = 1.0;
        if (vector2D1.X < -1.0)
          vector2D1.X = -1.0;
        if (vector2D1.Y > 1.0)
          vector2D1.Y = 1.0;
        if (vector2D1.Y < -1.0)
          vector2D1.Y = -1.0;
      }
      GenVars.dRoomX[GenVars.numDRooms] = (int) vector2D2.X;
      GenVars.dRoomY[GenVars.numDRooms] = (int) vector2D2.Y;
      GenVars.dRoomSize[GenVars.numDRooms] = (int) num1;
      GenVars.dRoomL[GenVars.numDRooms] = (int) num3;
      GenVars.dRoomR[GenVars.numDRooms] = (int) num4;
      GenVars.dRoomT[GenVars.numDRooms] = (int) num5;
      GenVars.dRoomB[GenVars.numDRooms] = (int) num6;
      GenVars.dRoomTreasure[GenVars.numDRooms] = false;
      ++GenVars.numDRooms;
    }

    public static void DungeonEnt(int i, int j, ushort tileType, int wallType)
    {
      int num1 = 60;
      for (int x = i - num1; x < i + num1; ++x)
      {
        for (int y = j - num1; y < j + num1; ++y)
        {
          if (WorldGen.InWorld(x, y))
          {
            Main.tile[x, y].liquid = (byte) 0;
            Main.tile[x, y].lava(false);
            Main.tile[x, y].Clear(TileDataType.Slope);
          }
        }
      }
      double dxStrength1 = GenVars.dxStrength1;
      double dyStrength1 = GenVars.dyStrength1;
      Vector2D vector2D;
      vector2D.X = (double) i;
      vector2D.Y = (double) j - dyStrength1 / 2.0;
      GenVars.dMinY = (int) vector2D.Y;
      int num2 = 1;
      if (i > Main.maxTilesX / 2)
        num2 = -1;
      if (WorldGen.drunkWorldGen || WorldGen.getGoodWorldGen)
        num2 *= -1;
      int num3 = (int) (vector2D.X - dxStrength1 * 0.6 - (double) WorldGen.genRand.Next(2, 5));
      int num4 = (int) (vector2D.X + dxStrength1 * 0.6 + (double) WorldGen.genRand.Next(2, 5));
      int num5 = (int) (vector2D.Y - dyStrength1 * 0.6 - (double) WorldGen.genRand.Next(2, 5));
      int num6 = (int) (vector2D.Y + dyStrength1 * 0.6 + (double) WorldGen.genRand.Next(8, 16));
      if (num3 < 0)
        num3 = 0;
      if (num4 > Main.maxTilesX)
        num4 = Main.maxTilesX;
      if (num5 < 0)
        num5 = 0;
      if (num6 > Main.maxTilesY)
        num6 = Main.maxTilesY;
      for (int index1 = num3; index1 < num4; ++index1)
      {
        for (int index2 = num5; index2 < num6; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          if ((int) Main.tile[index1, index2].wall != wallType)
          {
            Main.tile[index1, index2].wall = (ushort) 0;
            if (index1 > num3 + 1 && index1 < num4 - 2 && index2 > num5 + 1 && index2 < num6 - 2)
              Main.tile[index1, index2].wall = (ushort) wallType;
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].type = tileType;
            Main.tile[index1, index2].Clear(TileDataType.Slope);
          }
        }
      }
      int num7 = num3;
      int num8 = num3 + 5 + WorldGen.genRand.Next(4);
      int num9 = num5 - 3 - WorldGen.genRand.Next(3);
      int num10 = num5;
      for (int index3 = num7; index3 < num8; ++index3)
      {
        for (int index4 = num9; index4 < num10; ++index4)
        {
          Main.tile[index3, index4].liquid = (byte) 0;
          if ((int) Main.tile[index3, index4].wall != wallType)
          {
            Main.tile[index3, index4].active(true);
            Main.tile[index3, index4].type = tileType;
            Main.tile[index3, index4].Clear(TileDataType.Slope);
          }
        }
      }
      int num11 = num4 - 5 - WorldGen.genRand.Next(4);
      int num12 = num4;
      int num13 = num5 - 3 - WorldGen.genRand.Next(3);
      int num14 = num5;
      for (int index5 = num11; index5 < num12; ++index5)
      {
        for (int index6 = num13; index6 < num14; ++index6)
        {
          Main.tile[index5, index6].liquid = (byte) 0;
          if ((int) Main.tile[index5, index6].wall != wallType)
          {
            Main.tile[index5, index6].active(true);
            Main.tile[index5, index6].type = tileType;
            Main.tile[index5, index6].Clear(TileDataType.Slope);
          }
        }
      }
      int num15 = 1 + WorldGen.genRand.Next(2);
      int num16 = 2 + WorldGen.genRand.Next(4);
      int num17 = 0;
      for (int index7 = num3; index7 < num4; ++index7)
      {
        for (int index8 = num5 - num15; index8 < num5; ++index8)
        {
          Main.tile[index7, index8].liquid = (byte) 0;
          if ((int) Main.tile[index7, index8].wall != wallType)
          {
            Main.tile[index7, index8].active(true);
            Main.tile[index7, index8].type = tileType;
            Main.tile[index7, index8].Clear(TileDataType.Slope);
          }
        }
        ++num17;
        if (num17 >= num16)
        {
          index7 += num16;
          num17 = 0;
        }
      }
      for (int index9 = num3; index9 < num4; ++index9)
      {
        for (int index10 = num6; (double) index10 < Main.worldSurface; ++index10)
        {
          Main.tile[index9, index10].liquid = (byte) 0;
          if (!Main.wallDungeon[(int) Main.tile[index9, index10].wall])
          {
            Main.tile[index9, index10].active(true);
            Main.tile[index9, index10].type = tileType;
          }
          if (index9 > num3 && index9 < num4 - 1)
            Main.tile[index9, index10].wall = (ushort) wallType;
          Main.tile[index9, index10].Clear(TileDataType.Slope);
        }
      }
      int num18 = (int) (vector2D.X - dxStrength1 * 0.6);
      int num19 = (int) (vector2D.X + dxStrength1 * 0.6);
      int num20 = (int) (vector2D.Y - dyStrength1 * 0.6);
      int num21 = (int) (vector2D.Y + dyStrength1 * 0.6);
      if (num18 < 0)
        num18 = 0;
      if (num19 > Main.maxTilesX)
        num19 = Main.maxTilesX;
      if (num20 < 0)
        num20 = 0;
      if (num21 > Main.maxTilesY)
        num21 = Main.maxTilesY;
      for (int index11 = num18; index11 < num19; ++index11)
      {
        for (int index12 = num20; index12 < num21; ++index12)
        {
          Main.tile[index11, index12].liquid = (byte) 0;
          Main.tile[index11, index12].wall = (ushort) wallType;
          Main.tile[index11, index12].Clear(TileDataType.Slope);
        }
      }
      int num22 = (int) (vector2D.X - dxStrength1 * 0.6 - 1.0);
      int num23 = (int) (vector2D.X + dxStrength1 * 0.6 + 1.0);
      int num24 = (int) (vector2D.Y - dyStrength1 * 0.6 - 1.0);
      int num25 = (int) (vector2D.Y + dyStrength1 * 0.6 + 1.0);
      if (num22 < 0)
        num22 = 0;
      if (num23 > Main.maxTilesX)
        num23 = Main.maxTilesX;
      if (num24 < 0)
        num24 = 0;
      if (num25 > Main.maxTilesY)
        num25 = Main.maxTilesY;
      if (WorldGen.drunkWorldGen)
        num22 -= 4;
      for (int index13 = num22; index13 < num23; ++index13)
      {
        for (int index14 = num24; index14 < num25; ++index14)
        {
          Main.tile[index13, index14].liquid = (byte) 0;
          Main.tile[index13, index14].wall = (ushort) wallType;
          Main.tile[index13, index14].Clear(TileDataType.Slope);
        }
      }
      int num26 = (int) (vector2D.X - dxStrength1 * 0.5);
      int num27 = (int) (vector2D.X + dxStrength1 * 0.5);
      int num28 = (int) (vector2D.Y - dyStrength1 * 0.5);
      int num29 = (int) (vector2D.Y + dyStrength1 * 0.5);
      if (num26 < 0)
        num26 = 0;
      if (num27 > Main.maxTilesX)
        num27 = Main.maxTilesX;
      if (num28 < 0)
        num28 = 0;
      if (num29 > Main.maxTilesY)
        num29 = Main.maxTilesY;
      for (int index15 = num26; index15 < num27; ++index15)
      {
        for (int index16 = num28; index16 < num29; ++index16)
        {
          Main.tile[index15, index16].liquid = (byte) 0;
          Main.tile[index15, index16].active(false);
          Main.tile[index15, index16].wall = (ushort) wallType;
        }
      }
      int x1 = (int) vector2D.X;
      int index17 = num29;
      for (int index18 = 0; index18 < 20; ++index18)
      {
        int index19 = (int) vector2D.X - index18;
        if (!Main.tile[index19, index17].active() && Main.wallDungeon[(int) Main.tile[index19, index17].wall])
        {
          GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = index19;
          GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = index17;
          ++GenVars.numDungeonPlatforms;
          break;
        }
        int index20 = (int) vector2D.X + index18;
        if (!Main.tile[index20, index17].active() && Main.wallDungeon[(int) Main.tile[index20, index17].wall])
        {
          GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = index20;
          GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = index17;
          ++GenVars.numDungeonPlatforms;
          break;
        }
      }
      vector2D.X += dxStrength1 * 0.6 * (double) num2;
      vector2D.Y += dyStrength1 * 0.5;
      double dxStrength2 = GenVars.dxStrength2;
      double dyStrength2 = GenVars.dyStrength2;
      vector2D.X += dxStrength2 * 0.55 * (double) num2;
      vector2D.Y -= dyStrength2 * 0.5;
      int num30 = (int) (vector2D.X - dxStrength2 * 0.6 - (double) WorldGen.genRand.Next(1, 3));
      int num31 = (int) (vector2D.X + dxStrength2 * 0.6 + (double) WorldGen.genRand.Next(1, 3));
      int num32 = (int) (vector2D.Y - dyStrength2 * 0.6 - (double) WorldGen.genRand.Next(1, 3));
      int num33 = (int) (vector2D.Y + dyStrength2 * 0.6 + (double) WorldGen.genRand.Next(6, 16));
      if (num30 < 0)
        num30 = 0;
      if (num31 > Main.maxTilesX)
        num31 = Main.maxTilesX;
      if (num32 < 0)
        num32 = 0;
      if (num33 > Main.maxTilesY)
        num33 = Main.maxTilesY;
      for (int index21 = num30; index21 < num31; ++index21)
      {
        for (int index22 = num32; index22 < num33; ++index22)
        {
          Main.tile[index21, index22].liquid = (byte) 0;
          if ((int) Main.tile[index21, index22].wall != wallType)
          {
            bool flag = true;
            if (num2 < 0)
            {
              if ((double) index21 < vector2D.X - dxStrength2 * 0.5)
                flag = false;
            }
            else if ((double) index21 > vector2D.X + dxStrength2 * 0.5 - 1.0)
              flag = false;
            if (flag)
            {
              Main.tile[index21, index22].wall = (ushort) 0;
              Main.tile[index21, index22].active(true);
              Main.tile[index21, index22].type = tileType;
              Main.tile[index21, index22].Clear(TileDataType.Slope);
            }
          }
        }
      }
      for (int index23 = num30; index23 < num31; ++index23)
      {
        for (int index24 = num33; (double) index24 < Main.worldSurface; ++index24)
        {
          Main.tile[index23, index24].liquid = (byte) 0;
          if (!Main.wallDungeon[(int) Main.tile[index23, index24].wall])
          {
            Main.tile[index23, index24].active(true);
            Main.tile[index23, index24].type = tileType;
          }
          Main.tile[index23, index24].wall = (ushort) wallType;
          Main.tile[index23, index24].Clear(TileDataType.Slope);
        }
      }
      int num34 = (int) (vector2D.X - dxStrength2 * 0.5);
      int num35 = (int) (vector2D.X + dxStrength2 * 0.5);
      int num36 = num34;
      if (num2 < 0)
        ++num36;
      int num37 = num36 + 5 + WorldGen.genRand.Next(4);
      int num38 = num32 - 3 - WorldGen.genRand.Next(3);
      int num39 = num32;
      for (int index25 = num36; index25 < num37; ++index25)
      {
        for (int index26 = num38; index26 < num39; ++index26)
        {
          Main.tile[index25, index26].liquid = (byte) 0;
          if ((int) Main.tile[index25, index26].wall != wallType)
          {
            Main.tile[index25, index26].active(true);
            Main.tile[index25, index26].type = tileType;
            Main.tile[index25, index26].Clear(TileDataType.Slope);
          }
        }
      }
      int num40 = num35 - 5 - WorldGen.genRand.Next(4);
      int num41 = num35;
      int num42 = num32 - 3 - WorldGen.genRand.Next(3);
      int num43 = num32;
      for (int index27 = num40; index27 < num41; ++index27)
      {
        for (int index28 = num42; index28 < num43; ++index28)
        {
          Main.tile[index27, index28].liquid = (byte) 0;
          if ((int) Main.tile[index27, index28].wall != wallType)
          {
            Main.tile[index27, index28].active(true);
            Main.tile[index27, index28].type = tileType;
            Main.tile[index27, index28].Clear(TileDataType.Slope);
          }
        }
      }
      int num44 = 1 + WorldGen.genRand.Next(2);
      int num45 = 2 + WorldGen.genRand.Next(4);
      int num46 = 0;
      if (num2 < 0)
        ++num35;
      for (int index29 = num34 + 1; index29 < num35 - 1; ++index29)
      {
        for (int index30 = num32 - num44; index30 < num32; ++index30)
        {
          Main.tile[index29, index30].liquid = (byte) 0;
          if ((int) Main.tile[index29, index30].wall != wallType)
          {
            Main.tile[index29, index30].active(true);
            Main.tile[index29, index30].type = tileType;
            Main.tile[index29, index30].Clear(TileDataType.Slope);
          }
        }
        ++num46;
        if (num46 >= num45)
        {
          index29 += num45;
          num46 = 0;
        }
      }
      if (!WorldGen.drunkWorldGen)
      {
        int num47 = (int) (vector2D.X - dxStrength2 * 0.6);
        int num48 = (int) (vector2D.X + dxStrength2 * 0.6);
        int num49 = (int) (vector2D.Y - dyStrength2 * 0.6);
        int num50 = (int) (vector2D.Y + dyStrength2 * 0.6);
        if (num47 < 0)
          num47 = 0;
        if (num48 > Main.maxTilesX)
          num48 = Main.maxTilesX;
        if (num49 < 0)
          num49 = 0;
        if (num50 > Main.maxTilesY)
          num50 = Main.maxTilesY;
        for (int index31 = num47; index31 < num48; ++index31)
        {
          for (int index32 = num49; index32 < num50; ++index32)
          {
            Main.tile[index31, index32].liquid = (byte) 0;
            Main.tile[index31, index32].wall = (ushort) 0;
          }
        }
      }
      int num51 = (int) (vector2D.X - dxStrength2 * 0.5);
      int num52 = (int) (vector2D.X + dxStrength2 * 0.5);
      int num53 = (int) (vector2D.Y - dyStrength2 * 0.5);
      int num54 = (int) (vector2D.Y + dyStrength2 * 0.5);
      if (num51 < 0)
        num51 = 0;
      if (num52 > Main.maxTilesX)
        num52 = Main.maxTilesX;
      if (num53 < 0)
        num53 = 0;
      if (num54 > Main.maxTilesY)
        num54 = Main.maxTilesY;
      for (int index33 = num51; index33 < num52; ++index33)
      {
        for (int index34 = num53; index34 < num54; ++index34)
        {
          Main.tile[index33, index34].liquid = (byte) 0;
          Main.tile[index33, index34].active(false);
          Main.tile[index33, index34].wall = (ushort) 0;
        }
      }
      Main.dungeonX = (int) vector2D.X;
      Main.dungeonY = num54;
      int index35 = NPC.NewNPC((IEntitySource) new EntitySource_WorldGen(), Main.dungeonX * 16 + 8, Main.dungeonY * 16, 37);
      Main.npc[index35].homeless = false;
      Main.npc[index35].homeTileX = Main.dungeonX;
      Main.npc[index35].homeTileY = Main.dungeonY;
      if (WorldGen.drunkWorldGen)
      {
        int worldSurface = (int) Main.worldSurface;
        while (Main.tile[GenVars.dungeonX, worldSurface].active() || Main.tile[GenVars.dungeonX, worldSurface].wall > (ushort) 0 || Main.tile[GenVars.dungeonX, worldSurface - 1].active() || Main.tile[GenVars.dungeonX, worldSurface - 1].wall > (ushort) 0 || Main.tile[GenVars.dungeonX, worldSurface - 2].active() || Main.tile[GenVars.dungeonX, worldSurface - 2].wall > (ushort) 0 || Main.tile[GenVars.dungeonX, worldSurface - 3].active() || Main.tile[GenVars.dungeonX, worldSurface - 3].wall > (ushort) 0 || Main.tile[GenVars.dungeonX, worldSurface - 4].active() || Main.tile[GenVars.dungeonX, worldSurface - 4].wall > (ushort) 0)
        {
          --worldSurface;
          if (worldSurface < 50)
            break;
        }
        if (worldSurface > 50)
          WorldGen.GrowDungeonTree(GenVars.dungeonX, worldSurface);
      }
      if (!WorldGen.drunkWorldGen)
      {
        int num55 = 100;
        if (num2 == 1)
        {
          int num56 = 0;
          for (int index36 = num52; index36 < num52 + num55; ++index36)
          {
            ++num56;
            for (int index37 = num54 + num56; index37 < num54 + num55; ++index37)
            {
              Main.tile[index36, index37].liquid = (byte) 0;
              Main.tile[index36, index37 - 1].liquid = (byte) 0;
              Main.tile[index36, index37 - 2].liquid = (byte) 0;
              Main.tile[index36, index37 - 3].liquid = (byte) 0;
              if (!Main.wallDungeon[(int) Main.tile[index36, index37].wall] && Main.tile[index36, index37].wall != (ushort) 3 && Main.tile[index36, index37].wall != (ushort) 83)
              {
                Main.tile[index36, index37].active(true);
                Main.tile[index36, index37].type = tileType;
                Main.tile[index36, index37].Clear(TileDataType.Slope);
              }
            }
          }
        }
        else
        {
          int num57 = 0;
          for (int index38 = num51; index38 > num51 - num55; --index38)
          {
            ++num57;
            for (int index39 = num54 + num57; index39 < num54 + num55; ++index39)
            {
              Main.tile[index38, index39].liquid = (byte) 0;
              Main.tile[index38, index39 - 1].liquid = (byte) 0;
              Main.tile[index38, index39 - 2].liquid = (byte) 0;
              Main.tile[index38, index39 - 3].liquid = (byte) 0;
              if (!Main.wallDungeon[(int) Main.tile[index38, index39].wall] && Main.tile[index38, index39].wall != (ushort) 3 && Main.tile[index38, index39].wall != (ushort) 83)
              {
                Main.tile[index38, index39].active(true);
                Main.tile[index38, index39].type = tileType;
                Main.tile[index38, index39].Clear(TileDataType.Slope);
              }
            }
          }
        }
      }
      int num58 = 1 + WorldGen.genRand.Next(2);
      int num59 = 2 + WorldGen.genRand.Next(4);
      int num60 = 0;
      int num61 = (int) (vector2D.X - dxStrength2 * 0.5);
      int num62 = (int) (vector2D.X + dxStrength2 * 0.5);
      int num63;
      int num64;
      if (WorldGen.drunkWorldGen)
      {
        if (num2 == 1)
        {
          num63 = num62 - 1;
          num64 = num61 - 1;
        }
        else
        {
          num64 = num61 + 1;
          num63 = num62 + 1;
        }
      }
      else
      {
        num64 = num61 + 2;
        num63 = num62 - 2;
      }
      for (int i1 = num64; i1 < num63; ++i1)
      {
        for (int j1 = num53; j1 < num54 + 1; ++j1)
          WorldGen.PlaceWall(i1, j1, wallType, true);
        if (!WorldGen.drunkWorldGen)
        {
          ++num60;
          if (num60 >= num59)
          {
            i1 += num59 * 2;
            num60 = 0;
          }
        }
      }
      if (WorldGen.drunkWorldGen)
      {
        int num65 = (int) (vector2D.X - dxStrength2 * 0.5);
        int num66 = (int) (vector2D.X + dxStrength2 * 0.5);
        if (num2 == 1)
          num65 = num66 - 3;
        else
          num66 = num65 + 3;
        for (int index40 = num65; index40 < num66; ++index40)
        {
          for (int index41 = num53; index41 < num54 + 1; ++index41)
          {
            Main.tile[index40, index41].active(true);
            Main.tile[index40, index41].type = tileType;
            Main.tile[index40, index41].Clear(TileDataType.Slope);
          }
        }
      }
      vector2D.X -= dxStrength2 * 0.6 * (double) num2;
      vector2D.Y += dyStrength2 * 0.5;
      double num67 = 15.0;
      double num68 = 3.0;
      vector2D.Y -= num68 * 0.5;
      int num69 = (int) (vector2D.X - num67 * 0.5);
      int num70 = (int) (vector2D.X + num67 * 0.5);
      int num71 = (int) (vector2D.Y - num68 * 0.5);
      int num72 = (int) (vector2D.Y + num68 * 0.5);
      if (num69 < 0)
        num69 = 0;
      if (num70 > Main.maxTilesX)
        num70 = Main.maxTilesX;
      if (num71 < 0)
        num71 = 0;
      if (num72 > Main.maxTilesY)
        num72 = Main.maxTilesY;
      for (int index42 = num69; index42 < num70; ++index42)
      {
        for (int index43 = num71; index43 < num72; ++index43)
          Main.tile[index42, index43].active(false);
      }
      if (num2 < 0)
        --vector2D.X;
      WorldGen.PlaceTile((int) vector2D.X, (int) vector2D.Y + 1, 10, true, style: 13);
    }

    public static bool AddBuriedChest(
      Point point,
      int contain = 0,
      bool notNearOtherChests = false,
      int Style = -1)
    {
      return WorldGen.AddBuriedChest(point.X, point.Y, contain, notNearOtherChests, Style);
    }

    public static bool IsChestRigged(int x, int y) => Main.tile[x, y].type == (ushort) 467 && (int) Main.tile[x, y].frameX / 36 == 4;

    private static bool IsUndergroundDesert(int x, int y)
    {
      if ((double) y < Main.worldSurface || (double) x < (double) Main.maxTilesX * 0.15 || (double) x > (double) Main.maxTilesX * 0.85 || WorldGen.remixWorldGen && (double) y > Main.rockLayer)
        return false;
      int num = 15;
      for (int index1 = x - num; index1 <= x + num; ++index1)
      {
        for (int index2 = y - num; index2 <= y + num; ++index2)
        {
          if (Main.tile[index1, index2].wall == (ushort) 187 || Main.tile[index1, index2].wall == (ushort) 216)
            return true;
        }
      }
      return false;
    }

    private static bool IsDungeon(int x, int y) => (double) y >= Main.worldSurface && x >= 0 && x <= Main.maxTilesX && Main.wallDungeon[(int) Main.tile[x, y].wall];

    public static bool AddBuriedChest(
      int i,
      int j,
      int contain = 0,
      bool notNearOtherChests = false,
      int Style = -1,
      bool trySlope = false,
      ushort chestTileType = 0)
    {
      if (chestTileType == (ushort) 0)
        chestTileType = (ushort) 21;
      bool flag1 = false;
      bool flag2 = false;
      bool flag3 = false;
      bool flag4 = false;
      bool flag5 = false;
      bool flag6 = false;
      bool flag7 = false;
      bool flag8 = false;
      bool flag9 = false;
      bool flag10 = false;
      int maxValue1 = 15;
      if (WorldGen.tenthAnniversaryWorldGen)
        maxValue1 *= 3;
      for (int index1 = j; index1 < Main.maxTilesY - 10; ++index1)
      {
        int slope1 = -1;
        int slope2 = -1;
        if (Main.tile[i, index1].shimmer())
          return false;
        if (trySlope && Main.tile[i, index1].active() && Main.tileSolid[(int) Main.tile[i, index1].type] && !Main.tileSolidTop[(int) Main.tile[i, index1].type])
        {
          if (Style == 17)
          {
            int num = 30;
            for (int x = i - num; x <= i + num; ++x)
            {
              for (int y = index1 - num; y <= index1 + num; ++y)
              {
                if (!WorldGen.InWorld(x, y, 5) || Main.tile[x, y].active() && (Main.tile[x, y].type == (ushort) 21 || Main.tile[x, y].type == (ushort) 467))
                  return false;
              }
            }
          }
          if (Main.tile[i - 1, index1].topSlope())
          {
            slope1 = (int) Main.tile[i - 1, index1].slope();
            Main.tile[i - 1, index1].slope((byte) 0);
          }
          if (Main.tile[i, index1].topSlope())
          {
            slope2 = (int) Main.tile[i, index1].slope();
            Main.tile[i, index1].slope((byte) 0);
          }
        }
        if (WorldGen.remixWorldGen && (double) i > (double) Main.maxTilesX * 0.37 && (double) i < (double) Main.maxTilesX * 0.63 && index1 > Main.maxTilesY - 250)
          return false;
        int num1 = 2;
        for (int index2 = i - num1; index2 <= i + num1; ++index2)
        {
          for (int index3 = index1 - num1; index3 <= index1 + num1; ++index3)
          {
            if (Main.tile[index2, index3].active() && (TileID.Sets.Boulders[(int) Main.tile[index2, index3].type] || Main.tile[index2, index3].type == (ushort) 26 || Main.tile[index2, index3].type == (ushort) 237))
              return false;
          }
        }
        if (WorldGen.SolidTile(i, index1))
        {
          bool flag11 = false;
          int num2 = i;
          int num3 = index1;
          int style = 0;
          bool flag12 = (double) num3 >= Main.worldSurface + 25.0;
          if (WorldGen.remixWorldGen)
            flag12 = num3 < Main.maxTilesY - 400;
          if (flag12 || contain > 0)
            style = 1;
          if (Style >= 0)
            style = Style;
          if (chestTileType == (ushort) 467 && style == 10 || contain == 0 && num3 <= Main.maxTilesY - 205 && WorldGen.IsUndergroundDesert(i, index1))
          {
            flag2 = true;
            style = 10;
            chestTileType = (ushort) 467;
            if (num3 > (GenVars.desertHiveHigh * 3 + GenVars.desertHiveLow * 4) / 7)
              contain = (int) Utils.SelectRandom<short>(WorldGen.genRand, (short) 4061, (short) 4062, (short) 4276);
            else
              contain = (int) Utils.SelectRandom<short>(WorldGen.genRand, (short) 4056, (short) 4055, (short) 4262, (short) 4263);
            if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(maxValue1) == 0)
              contain = 52;
          }
          if (chestTileType == (ushort) 21 && (style == 11 || contain == 0 && (double) num3 >= Main.worldSurface + 25.0 && num3 <= Main.maxTilesY - 205 && (Main.tile[i, index1].type == (ushort) 147 || Main.tile[i, index1].type == (ushort) 161 || Main.tile[i, index1].type == (ushort) 162)))
          {
            flag1 = true;
            style = 11;
            switch (WorldGen.genRand.Next(6))
            {
              case 0:
                contain = 670;
                break;
              case 1:
                contain = 724;
                break;
              case 2:
                contain = 950;
                break;
              case 3:
                contain = !WorldGen.remixWorldGen ? 1319 : 725;
                break;
              case 4:
                contain = 987;
                break;
              default:
                contain = 1579;
                break;
            }
            if (WorldGen.genRand.Next(20) == 0)
              contain = 997;
            if (WorldGen.genRand.Next(50) == 0)
              contain = 669;
            if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(maxValue1) == 0)
              contain = 52;
          }
          if (chestTileType == (ushort) 21 && (Style == 10 || contain == 211 || contain == 212 || contain == 213 || contain == 753))
          {
            flag3 = true;
            style = 10;
            if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(maxValue1) == 0)
              contain = 52;
          }
          if (chestTileType == (ushort) 21 && num3 > Main.maxTilesY - 205 && contain == 0)
          {
            flag7 = true;
            contain = GenVars.hellChestItem[GenVars.hellChest];
            style = 4;
            flag11 = true;
            if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(maxValue1) == 0)
              contain = 52;
          }
          if (chestTileType == (ushort) 21 && style == 17)
          {
            flag4 = true;
            if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(maxValue1) == 0)
              contain = 52;
          }
          if (chestTileType == (ushort) 21 && style == 12)
          {
            flag5 = true;
            if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(maxValue1) == 0)
              contain = 52;
          }
          if (chestTileType == (ushort) 21 && style == 32)
          {
            flag6 = true;
            if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(maxValue1) == 0)
              contain = 52;
          }
          if (chestTileType == (ushort) 21 && style != 0 && WorldGen.IsDungeon(i, index1))
            flag8 = true;
          if (chestTileType == (ushort) 21 && style != 0 && (contain == 848 || contain == 857 || contain == 934))
            flag9 = true;
          if (chestTileType == (ushort) 21 && (style == 13 || contain == 159 || contain == 65 || contain == 158 || contain == 2219))
          {
            flag10 = true;
            if (WorldGen.remixWorldGen && !WorldGen.getGoodWorldGen)
            {
              if (WorldGen.crimson)
              {
                style = 43;
              }
              else
              {
                chestTileType = (ushort) 467;
                style = 3;
              }
            }
          }
          if (WorldGen.noTrapsWorldGen && style == 1 && chestTileType == (ushort) 21 && (!WorldGen.remixWorldGen || WorldGen.genRand.Next(3) == 0))
          {
            style = 4;
            chestTileType = (ushort) 467;
          }
          int index4 = chestTileType != (ushort) 467 ? WorldGen.PlaceChest(num2 - 1, num3 - 1, chestTileType, notNearOtherChests, style) : WorldGen.PlaceChest(num2 - 1, num3 - 1, chestTileType, notNearOtherChests, style);
          if (index4 >= 0)
          {
            if (flag11)
            {
              ++GenVars.hellChest;
              if (GenVars.hellChest >= GenVars.hellChestItem.Length)
                GenVars.hellChest = 0;
            }
            Chest chest = Main.chest[index4];
            int index5 = 0;
            while (index5 == 0)
            {
              bool flag13 = (double) num3 < Main.worldSurface + 25.0;
              if (WorldGen.remixWorldGen)
                flag13 = (double) num3 >= (Main.rockLayer + (double) ((Main.maxTilesY - 350) * 2)) / 3.0;
              if (style == 0 & flag13 | flag9)
              {
                if (contain > 0)
                {
                  chest.item[index5].SetDefaults(contain);
                  chest.item[index5].Prefix(-1);
                  ++index5;
                  switch (contain)
                  {
                    case 832:
                      chest.item[index5].SetDefaults(933);
                      ++index5;
                      if (WorldGen.genRand.Next(6) == 0)
                      {
                        int Type = WorldGen.genRand.Next(2);
                        switch (Type)
                        {
                          case 0:
                            Type = 4429;
                            break;
                          case 1:
                            Type = 4427;
                            break;
                        }
                        chest.item[index5].SetDefaults(Type);
                        ++index5;
                        break;
                      }
                      break;
                    case 848:
                      chest.item[index5].SetDefaults(866);
                      ++index5;
                      break;
                  }
                  if (Main.tenthAnniversaryWorld & flag9)
                  {
                    Item[] objArray1 = chest.item;
                    int index6 = index5;
                    int num4 = index6 + 1;
                    objArray1[index6].SetDefaults(848);
                    Item[] objArray2 = chest.item;
                    int index7 = num4;
                    index5 = index7 + 1;
                    objArray2[index7].SetDefaults(866);
                  }
                }
                else
                {
                  int num5 = WorldGen.genRand.Next(10);
                  if (num5 == 0)
                  {
                    chest.item[index5].SetDefaults(280);
                    chest.item[index5].Prefix(-1);
                  }
                  if (num5 == 1)
                  {
                    chest.item[index5].SetDefaults(281);
                    chest.item[index5].Prefix(-1);
                  }
                  if (num5 == 2)
                  {
                    chest.item[index5].SetDefaults(284);
                    chest.item[index5].Prefix(-1);
                  }
                  if (num5 == 3)
                  {
                    chest.item[index5].SetDefaults(285);
                    chest.item[index5].Prefix(-1);
                  }
                  if (num5 == 4)
                  {
                    chest.item[index5].SetDefaults(953);
                    chest.item[index5].Prefix(-1);
                  }
                  if (num5 == 5)
                  {
                    chest.item[index5].SetDefaults(946);
                    chest.item[index5].Prefix(-1);
                  }
                  if (num5 == 6)
                  {
                    chest.item[index5].SetDefaults(3068);
                    chest.item[index5].Prefix(-1);
                  }
                  if (num5 == 7)
                  {
                    if (WorldGen.remixWorldGen)
                    {
                      chest.item[index5].SetDefaults(517);
                      chest.item[index5].Prefix(-1);
                    }
                    else
                    {
                      chest.item[index5].SetDefaults(3069);
                      chest.item[index5].Prefix(-1);
                    }
                  }
                  if (num5 == 8)
                  {
                    chest.item[index5].SetDefaults(3084);
                    chest.item[index5].Prefix(-1);
                  }
                  if (num5 == 9)
                  {
                    chest.item[index5].SetDefaults(4341);
                    chest.item[index5].Prefix(-1);
                  }
                  ++index5;
                }
                if (WorldGen.genRand.Next(6) == 0)
                {
                  int num6 = WorldGen.genRand.Next(40, 76);
                  chest.item[index5].SetDefaults(282);
                  chest.item[index5].stack = num6;
                  ++index5;
                }
                if (WorldGen.genRand.Next(6) == 0)
                {
                  int num7 = WorldGen.genRand.Next(150, 301);
                  chest.item[index5].SetDefaults(279);
                  chest.item[index5].stack = num7;
                  ++index5;
                }
                if (WorldGen.genRand.Next(6) == 0)
                {
                  chest.item[index5].SetDefaults(3093);
                  chest.item[index5].stack = 1;
                  if (WorldGen.genRand.Next(5) == 0)
                    chest.item[index5].stack += WorldGen.genRand.Next(2);
                  if (WorldGen.genRand.Next(10) == 0)
                    chest.item[index5].stack += WorldGen.genRand.Next(3);
                  ++index5;
                }
                if (WorldGen.genRand.Next(6) == 0)
                {
                  chest.item[index5].SetDefaults(4345);
                  chest.item[index5].stack = 1;
                  if (WorldGen.genRand.Next(5) == 0)
                    chest.item[index5].stack += WorldGen.genRand.Next(2);
                  if (WorldGen.genRand.Next(10) == 0)
                    chest.item[index5].stack += WorldGen.genRand.Next(3);
                  ++index5;
                }
                if (WorldGen.genRand.Next(3) == 0)
                {
                  chest.item[index5].SetDefaults(168);
                  chest.item[index5].stack = WorldGen.genRand.Next(3, 6);
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num8 = WorldGen.genRand.Next(2);
                  int num9 = WorldGen.genRand.Next(8) + 3;
                  if (num8 == 0)
                    chest.item[index5].SetDefaults(GenVars.copperBar);
                  if (num8 == 1)
                    chest.item[index5].SetDefaults(GenVars.ironBar);
                  chest.item[index5].stack = num9;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num10 = WorldGen.genRand.Next(50, 101);
                  chest.item[index5].SetDefaults(965);
                  chest.item[index5].stack = num10;
                  ++index5;
                }
                if (WorldGen.genRand.Next(3) != 0)
                {
                  int num11 = WorldGen.genRand.Next(2);
                  int num12 = WorldGen.genRand.Next(26) + 25;
                  if (num11 == 0)
                    chest.item[index5].SetDefaults(40);
                  if (num11 == 1)
                    chest.item[index5].SetDefaults(42);
                  chest.item[index5].stack = num12;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num13 = WorldGen.genRand.Next(3) + 3;
                  chest.item[index5].SetDefaults(28);
                  chest.item[index5].stack = num13;
                  ++index5;
                }
                if (WorldGen.genRand.Next(3) != 0)
                {
                  chest.item[index5].SetDefaults(2350);
                  chest.item[index5].stack = WorldGen.genRand.Next(3, 6);
                  ++index5;
                }
                if (WorldGen.genRand.Next(3) > 0)
                {
                  int num14 = WorldGen.genRand.Next(6);
                  int num15 = WorldGen.genRand.Next(1, 3);
                  if (num14 == 0)
                    chest.item[index5].SetDefaults(292);
                  if (num14 == 1)
                    chest.item[index5].SetDefaults(298);
                  if (num14 == 2)
                    chest.item[index5].SetDefaults(299);
                  if (num14 == 3)
                    chest.item[index5].SetDefaults(290);
                  if (num14 == 4)
                    chest.item[index5].SetDefaults(2322);
                  if (num14 == 5)
                    chest.item[index5].SetDefaults(2325);
                  chest.item[index5].stack = num15;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num16 = WorldGen.genRand.Next(2);
                  int num17 = WorldGen.genRand.Next(11) + 10;
                  if (num16 == 0)
                    chest.item[index5].SetDefaults(8);
                  if (num16 == 1)
                    chest.item[index5].SetDefaults(31);
                  chest.item[index5].stack = num17;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  chest.item[index5].SetDefaults(72);
                  chest.item[index5].stack = WorldGen.genRand.Next(10, 30);
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  chest.item[index5].SetDefaults(9);
                  chest.item[index5].stack = WorldGen.genRand.Next(50, 100);
                  ++index5;
                }
              }
              else if (!WorldGen.remixWorldGen && (double) num3 < Main.rockLayer || WorldGen.remixWorldGen && (double) num3 > Main.rockLayer && num3 < Main.maxTilesY - 250)
              {
                if (contain > 0)
                {
                  if (contain == 832)
                  {
                    chest.item[index5].SetDefaults(933);
                    ++index5;
                  }
                  chest.item[index5].SetDefaults(contain);
                  chest.item[index5].Prefix(-1);
                  ++index5;
                  if (flag4)
                  {
                    if (WorldGen.genRand.Next(2) == 0)
                      chest.item[index5++].SetDefaults(4425);
                    if (WorldGen.genRand.Next(2) == 0)
                      chest.item[index5++].SetDefaults(4460);
                  }
                  if (flag10 && WorldGen.genRand.Next(40) == 0)
                    chest.item[index5++].SetDefaults(4978);
                  if (flag5 && WorldGen.genRand.Next(10) == 0)
                  {
                    int Type = WorldGen.genRand.Next(2);
                    switch (Type)
                    {
                      case 0:
                        Type = 4429;
                        break;
                      case 1:
                        Type = 4427;
                        break;
                    }
                    chest.item[index5].SetDefaults(Type);
                    ++index5;
                  }
                  if (flag8 && (!GenVars.generatedShadowKey || WorldGen.genRand.Next(3) == 0))
                  {
                    GenVars.generatedShadowKey = true;
                    chest.item[index5].SetDefaults(329);
                    ++index5;
                  }
                }
                else
                {
                  switch (WorldGen.genRand.Next(6))
                  {
                    case 0:
                      chest.item[index5].SetDefaults(49);
                      chest.item[index5].Prefix(-1);
                      break;
                    case 1:
                      chest.item[index5].SetDefaults(50);
                      chest.item[index5].Prefix(-1);
                      break;
                    case 2:
                      chest.item[index5].SetDefaults(53);
                      chest.item[index5].Prefix(-1);
                      break;
                    case 3:
                      chest.item[index5].SetDefaults(54);
                      chest.item[index5].Prefix(-1);
                      break;
                    case 4:
                      chest.item[index5].SetDefaults(5011);
                      chest.item[index5].Prefix(-1);
                      break;
                    default:
                      chest.item[index5].SetDefaults(975);
                      chest.item[index5].Prefix(-1);
                      break;
                  }
                  ++index5;
                  if (WorldGen.genRand.Next(20) == 0)
                  {
                    chest.item[index5].SetDefaults(997);
                    chest.item[index5].Prefix(-1);
                    ++index5;
                  }
                  else if (WorldGen.genRand.Next(20) == 0)
                  {
                    chest.item[index5].SetDefaults(930);
                    chest.item[index5].Prefix(-1);
                    int index8 = index5 + 1;
                    chest.item[index8].SetDefaults(931);
                    chest.item[index8].stack = WorldGen.genRand.Next(26) + 25;
                    index5 = index8 + 1;
                  }
                  if (flag6 && WorldGen.genRand.Next(2) == 0)
                  {
                    chest.item[index5].SetDefaults(4450);
                    ++index5;
                  }
                  if (flag6 && WorldGen.genRand.Next(3) == 0)
                  {
                    chest.item[index5].SetDefaults(4779);
                    int index9 = index5 + 1;
                    chest.item[index9].SetDefaults(4780);
                    int index10 = index9 + 1;
                    chest.item[index10].SetDefaults(4781);
                    index5 = index10 + 1;
                  }
                }
                if (flag2)
                {
                  if (WorldGen.genRand.Next(3) == 0)
                  {
                    chest.item[index5].SetDefaults(4423);
                    chest.item[index5].stack = WorldGen.genRand.Next(10, 20);
                    ++index5;
                  }
                }
                else if (WorldGen.genRand.Next(3) == 0)
                {
                  chest.item[index5].SetDefaults(166);
                  chest.item[index5].stack = WorldGen.genRand.Next(10, 20);
                  ++index5;
                }
                if (WorldGen.genRand.Next(5) == 0)
                {
                  chest.item[index5].SetDefaults(52);
                  ++index5;
                }
                if (WorldGen.genRand.Next(3) == 0)
                {
                  int num18 = WorldGen.genRand.Next(50, 101);
                  chest.item[index5].SetDefaults(965);
                  chest.item[index5].stack = num18;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num19 = WorldGen.genRand.Next(2);
                  int num20 = WorldGen.genRand.Next(10) + 5;
                  if (num19 == 0)
                    chest.item[index5].SetDefaults(GenVars.ironBar);
                  if (num19 == 1)
                    chest.item[index5].SetDefaults(GenVars.silverBar);
                  chest.item[index5].stack = num20;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num21 = WorldGen.genRand.Next(2);
                  int num22 = WorldGen.genRand.Next(25) + 25;
                  if (num21 == 0)
                    chest.item[index5].SetDefaults(40);
                  if (num21 == 1)
                    chest.item[index5].SetDefaults(42);
                  chest.item[index5].stack = num22;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num23 = WorldGen.genRand.Next(3) + 3;
                  chest.item[index5].SetDefaults(28);
                  chest.item[index5].stack = num23;
                  ++index5;
                }
                if (WorldGen.genRand.Next(3) > 0)
                {
                  int num24 = WorldGen.genRand.Next(9);
                  int num25 = WorldGen.genRand.Next(1, 3);
                  if (num24 == 0)
                    chest.item[index5].SetDefaults(289);
                  if (num24 == 1)
                    chest.item[index5].SetDefaults(298);
                  if (num24 == 2)
                    chest.item[index5].SetDefaults(299);
                  if (num24 == 3)
                    chest.item[index5].SetDefaults(290);
                  if (num24 == 4)
                    chest.item[index5].SetDefaults(303);
                  if (num24 == 5)
                    chest.item[index5].SetDefaults(291);
                  if (num24 == 6)
                    chest.item[index5].SetDefaults(304);
                  if (num24 == 7)
                    chest.item[index5].SetDefaults(2322);
                  if (num24 == 8)
                    chest.item[index5].SetDefaults(2329);
                  chest.item[index5].stack = num25;
                  ++index5;
                }
                if (WorldGen.genRand.Next(3) != 0)
                {
                  int num26 = WorldGen.genRand.Next(2, 5);
                  chest.item[index5].SetDefaults(2350);
                  chest.item[index5].stack = num26;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num27 = WorldGen.genRand.Next(11) + 10;
                  if (style == 11)
                    chest.item[index5].SetDefaults(974);
                  else
                    chest.item[index5].SetDefaults(8);
                  chest.item[index5].stack = num27;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  chest.item[index5].SetDefaults(72);
                  chest.item[index5].stack = WorldGen.genRand.Next(50, 90);
                  ++index5;
                }
              }
              else if (num3 < Main.maxTilesY - 250 || WorldGen.remixWorldGen && (Style == 7 || Style == 14))
              {
                if (contain > 0)
                {
                  chest.item[index5].SetDefaults(contain);
                  chest.item[index5].Prefix(-1);
                  ++index5;
                  if (flag1 && WorldGen.genRand.Next(5) == 0)
                  {
                    chest.item[index5].SetDefaults(3199);
                    ++index5;
                  }
                  if (flag2)
                  {
                    if (WorldGen.genRand.Next(7) == 0)
                    {
                      chest.item[index5].SetDefaults(4346);
                      ++index5;
                    }
                    if (WorldGen.genRand.Next(15) == 0)
                    {
                      chest.item[index5].SetDefaults(4066);
                      ++index5;
                    }
                  }
                  if (flag3 && WorldGen.genRand.Next(6) == 0)
                  {
                    Item[] objArray3 = chest.item;
                    int index11 = index5;
                    int num28 = index11 + 1;
                    objArray3[index11].SetDefaults(3360);
                    Item[] objArray4 = chest.item;
                    int index12 = num28;
                    index5 = index12 + 1;
                    objArray4[index12].SetDefaults(3361);
                  }
                  if (flag3 && WorldGen.genRand.Next(10) == 0)
                    chest.item[index5++].SetDefaults(4426);
                  if (flag4)
                  {
                    if (WorldGen.genRand.Next(2) == 0)
                      chest.item[index5++].SetDefaults(4425);
                    if (WorldGen.genRand.Next(2) == 0)
                      chest.item[index5++].SetDefaults(4460);
                  }
                  if (flag8 && (!GenVars.generatedShadowKey || WorldGen.genRand.Next(3) == 0))
                  {
                    GenVars.generatedShadowKey = true;
                    chest.item[index5].SetDefaults(329);
                    ++index5;
                  }
                }
                else
                {
                  int num29 = WorldGen.genRand.Next(7);
                  bool flag14 = num3 > GenVars.lavaLine;
                  if (WorldGen.remixWorldGen)
                    flag14 = (double) num3 > Main.worldSurface && (double) num3 < Main.rockLayer;
                  int maxValue2 = 20;
                  if (WorldGen.tenthAnniversaryWorldGen)
                    maxValue2 = 15;
                  if (WorldGen.genRand.Next(maxValue2) == 0 & flag14)
                  {
                    chest.item[index5].SetDefaults(906);
                    chest.item[index5].Prefix(-1);
                  }
                  else if (WorldGen.genRand.Next(15) == 0)
                  {
                    chest.item[index5].SetDefaults(997);
                    chest.item[index5].Prefix(-1);
                  }
                  else
                  {
                    if (num29 == 0)
                    {
                      chest.item[index5].SetDefaults(49);
                      chest.item[index5].Prefix(-1);
                    }
                    if (num29 == 1)
                    {
                      chest.item[index5].SetDefaults(50);
                      chest.item[index5].Prefix(-1);
                    }
                    if (num29 == 2)
                    {
                      chest.item[index5].SetDefaults(53);
                      chest.item[index5].Prefix(-1);
                    }
                    if (num29 == 3)
                    {
                      chest.item[index5].SetDefaults(54);
                      chest.item[index5].Prefix(-1);
                    }
                    if (num29 == 4)
                    {
                      chest.item[index5].SetDefaults(5011);
                      chest.item[index5].Prefix(-1);
                    }
                    if (num29 == 5)
                    {
                      chest.item[index5].SetDefaults(975);
                      chest.item[index5].Prefix(-1);
                    }
                    if (num29 == 6)
                    {
                      chest.item[index5].SetDefaults(930);
                      chest.item[index5].Prefix(-1);
                      ++index5;
                      chest.item[index5].SetDefaults(931);
                      chest.item[index5].stack = WorldGen.genRand.Next(26) + 25;
                    }
                  }
                  ++index5;
                  if (flag6)
                  {
                    if (WorldGen.genRand.Next(2) == 0)
                    {
                      chest.item[index5].SetDefaults(4450);
                      ++index5;
                    }
                    else
                    {
                      chest.item[index5].SetDefaults(4779);
                      int index13 = index5 + 1;
                      chest.item[index13].SetDefaults(4780);
                      int index14 = index13 + 1;
                      chest.item[index14].SetDefaults(4781);
                      index5 = index14 + 1;
                    }
                  }
                }
                if (WorldGen.genRand.Next(5) == 0)
                {
                  chest.item[index5].SetDefaults(43);
                  ++index5;
                }
                if (WorldGen.genRand.Next(3) == 0)
                {
                  chest.item[index5].SetDefaults(167);
                  ++index5;
                }
                if (WorldGen.genRand.Next(4) == 0)
                {
                  chest.item[index5].SetDefaults(51);
                  chest.item[index5].stack = WorldGen.genRand.Next(26) + 25;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num30 = WorldGen.genRand.Next(2);
                  int num31 = WorldGen.genRand.Next(8) + 3;
                  if (num30 == 0)
                    chest.item[index5].SetDefaults(GenVars.goldBar);
                  if (num30 == 1)
                    chest.item[index5].SetDefaults(GenVars.silverBar);
                  chest.item[index5].stack = num31;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num32 = WorldGen.genRand.Next(2);
                  int num33 = WorldGen.genRand.Next(26) + 25;
                  if (num32 == 0)
                    chest.item[index5].SetDefaults(41);
                  if (num32 == 1)
                    chest.item[index5].SetDefaults(279);
                  chest.item[index5].stack = num33;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num34 = WorldGen.genRand.Next(3) + 3;
                  chest.item[index5].SetDefaults(188);
                  chest.item[index5].stack = num34;
                  ++index5;
                }
                if (WorldGen.genRand.Next(3) > 0)
                {
                  int num35 = WorldGen.genRand.Next(6);
                  int num36 = WorldGen.genRand.Next(1, 3);
                  if (num35 == 0)
                    chest.item[index5].SetDefaults(296);
                  if (num35 == 1)
                    chest.item[index5].SetDefaults(295);
                  if (num35 == 2)
                    chest.item[index5].SetDefaults(299);
                  if (num35 == 3)
                    chest.item[index5].SetDefaults(302);
                  if (num35 == 4)
                    chest.item[index5].SetDefaults(303);
                  if (num35 == 5)
                    chest.item[index5].SetDefaults(305);
                  chest.item[index5].stack = num36;
                  ++index5;
                }
                if (WorldGen.genRand.Next(3) > 1)
                {
                  int num37 = WorldGen.genRand.Next(6);
                  int num38 = WorldGen.genRand.Next(1, 3);
                  if (num37 == 0)
                    chest.item[index5].SetDefaults(301);
                  if (num37 == 1)
                    chest.item[index5].SetDefaults(297);
                  if (num37 == 2)
                    chest.item[index5].SetDefaults(304);
                  if (num37 == 3)
                    chest.item[index5].SetDefaults(2329);
                  if (num37 == 4)
                    chest.item[index5].SetDefaults(2351);
                  if (num37 == 5)
                    chest.item[index5].SetDefaults(2326);
                  chest.item[index5].stack = num38;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num39 = WorldGen.genRand.Next(2, 5);
                  chest.item[index5].SetDefaults(2350);
                  chest.item[index5].stack = num39;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num40 = WorldGen.genRand.Next(2);
                  int num41 = WorldGen.genRand.Next(15) + 15;
                  if (num40 == 0)
                  {
                    if (style == 11)
                      chest.item[index5].SetDefaults(974);
                    else
                      chest.item[index5].SetDefaults(8);
                  }
                  if (num40 == 1)
                    chest.item[index5].SetDefaults(282);
                  chest.item[index5].stack = num41;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  chest.item[index5].SetDefaults(73);
                  chest.item[index5].stack = WorldGen.genRand.Next(1, 3);
                  ++index5;
                }
              }
              else
              {
                if (contain > 0)
                {
                  chest.item[index5].SetDefaults(contain);
                  chest.item[index5].Prefix(-1);
                  ++index5;
                  if (flag7 && WorldGen.genRand.Next(5) == 0)
                  {
                    chest.item[index5].SetDefaults(5010);
                    ++index5;
                  }
                  if (flag7 && WorldGen.genRand.Next(10) == 0)
                  {
                    chest.item[index5].SetDefaults(4443);
                    ++index5;
                  }
                  if (flag7 && WorldGen.genRand.Next(10) == 0)
                  {
                    chest.item[index5].SetDefaults(4737);
                    ++index5;
                  }
                  if (flag7 && WorldGen.genRand.Next(10) == 0)
                  {
                    chest.item[index5].SetDefaults(4551);
                    ++index5;
                  }
                }
                else
                {
                  int num42 = WorldGen.genRand.Next(4);
                  if (num42 == 0)
                  {
                    chest.item[index5].SetDefaults(49);
                    chest.item[index5].Prefix(-1);
                  }
                  if (num42 == 1)
                  {
                    chest.item[index5].SetDefaults(50);
                    chest.item[index5].Prefix(-1);
                  }
                  if (num42 == 2)
                  {
                    chest.item[index5].SetDefaults(53);
                    chest.item[index5].Prefix(-1);
                  }
                  if (num42 == 3)
                  {
                    chest.item[index5].SetDefaults(54);
                    chest.item[index5].Prefix(-1);
                  }
                  ++index5;
                }
                if (WorldGen.genRand.Next(3) == 0)
                {
                  chest.item[index5].SetDefaults(167);
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num43 = WorldGen.genRand.Next(2);
                  int num44 = WorldGen.genRand.Next(15) + 15;
                  if (num43 == 0)
                    chest.item[index5].SetDefaults(117);
                  if (num43 == 1)
                    chest.item[index5].SetDefaults(GenVars.goldBar);
                  chest.item[index5].stack = num44;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num45 = WorldGen.genRand.Next(2);
                  int num46 = WorldGen.genRand.Next(25) + 50;
                  if (num45 == 0)
                    chest.item[index5].SetDefaults(265);
                  if (num45 == 1)
                  {
                    if (WorldGen.SavedOreTiers.Silver == 168)
                      chest.item[index5].SetDefaults(4915);
                    else
                      chest.item[index5].SetDefaults(278);
                  }
                  chest.item[index5].stack = num46;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num47 = WorldGen.genRand.Next(6) + 15;
                  chest.item[index5].SetDefaults(227);
                  chest.item[index5].stack = num47;
                  ++index5;
                }
                if (WorldGen.genRand.Next(4) > 0)
                {
                  int num48 = WorldGen.genRand.Next(8);
                  int num49 = WorldGen.genRand.Next(1, 3);
                  if (num48 == 0)
                    chest.item[index5].SetDefaults(296);
                  if (num48 == 1)
                    chest.item[index5].SetDefaults(295);
                  if (num48 == 2)
                    chest.item[index5].SetDefaults(293);
                  if (num48 == 3)
                    chest.item[index5].SetDefaults(288);
                  if (num48 == 4)
                    chest.item[index5].SetDefaults(294);
                  if (num48 == 5)
                    chest.item[index5].SetDefaults(297);
                  if (num48 == 6)
                    chest.item[index5].SetDefaults(304);
                  if (num48 == 7)
                    chest.item[index5].SetDefaults(2323);
                  chest.item[index5].stack = num49;
                  ++index5;
                }
                if (WorldGen.genRand.Next(3) > 0)
                {
                  int num50 = WorldGen.genRand.Next(8);
                  int num51 = WorldGen.genRand.Next(1, 3);
                  if (num50 == 0)
                    chest.item[index5].SetDefaults(305);
                  if (num50 == 1)
                    chest.item[index5].SetDefaults(301);
                  if (num50 == 2)
                    chest.item[index5].SetDefaults(302);
                  if (num50 == 3)
                    chest.item[index5].SetDefaults(288);
                  if (num50 == 4)
                    chest.item[index5].SetDefaults(300);
                  if (num50 == 5)
                    chest.item[index5].SetDefaults(2351);
                  if (num50 == 6)
                    chest.item[index5].SetDefaults(2348);
                  if (num50 == 7)
                    chest.item[index5].SetDefaults(2345);
                  chest.item[index5].stack = num51;
                  ++index5;
                }
                if (WorldGen.genRand.Next(3) == 0)
                {
                  int num52 = WorldGen.genRand.Next(1, 3);
                  if (WorldGen.genRand.Next(2) == 0)
                    chest.item[index5].SetDefaults(2350);
                  else
                    chest.item[index5].SetDefaults(4870);
                  chest.item[index5].stack = num52;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num53 = WorldGen.genRand.Next(2);
                  int num54 = WorldGen.genRand.Next(15) + 15;
                  if (num53 == 0)
                    chest.item[index5].SetDefaults(8);
                  if (num53 == 1)
                    chest.item[index5].SetDefaults(282);
                  chest.item[index5].stack = num54;
                  ++index5;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  chest.item[index5].SetDefaults(73);
                  chest.item[index5].stack = WorldGen.genRand.Next(2, 5);
                  ++index5;
                }
              }
              if (index5 > 0 && chestTileType == (ushort) 21)
              {
                if (style == 10 && WorldGen.genRand.Next(4) == 0)
                {
                  chest.item[index5].SetDefaults(2204);
                  ++index5;
                }
                if (style == 11 && WorldGen.genRand.Next(7) == 0)
                {
                  chest.item[index5].SetDefaults(2198);
                  ++index5;
                }
                if (flag10 && WorldGen.genRand.Next(3) == 0)
                {
                  chest.item[index5].SetDefaults(2197);
                  ++index5;
                }
                if (flag10)
                {
                  int num55 = WorldGen.genRand.Next(6);
                  if (num55 == 0)
                    chest.item[index5].SetDefaults(5258);
                  if (num55 == 1)
                    chest.item[index5].SetDefaults(5226);
                  if (num55 == 2)
                    chest.item[index5].SetDefaults(5254);
                  if (num55 == 3)
                    chest.item[index5].SetDefaults(5238);
                  if (num55 == 4)
                    chest.item[index5].SetDefaults(5255);
                  if (num55 == 5)
                    chest.item[index5].SetDefaults(5388);
                  ++index5;
                }
                if (flag10)
                {
                  chest.item[index5].SetDefaults(751);
                  chest.item[index5].stack = WorldGen.genRand.Next(50, 101);
                  ++index5;
                }
                if (style == 16)
                {
                  chest.item[index5].SetDefaults(2195);
                  ++index5;
                }
                if (Main.wallDungeon[(int) Main.tile[i, index1].wall] && WorldGen.genRand.Next(8) == 0)
                {
                  chest.item[index5].SetDefaults(2192);
                  ++index5;
                }
                if ((style == 23 || style == 24 || style == 25 || style == 26 || style == 27) && WorldGen.genRand.Next(2) == 0)
                {
                  chest.item[index5].SetDefaults(5234);
                  ++index5;
                }
                if (style == 16)
                {
                  if (WorldGen.genRand.Next(5) == 0)
                  {
                    chest.item[index5].SetDefaults(2767);
                    ++index5;
                  }
                  else
                  {
                    chest.item[index5].SetDefaults(2766);
                    chest.item[index5].stack = WorldGen.genRand.Next(3, 8);
                    ++index5;
                  }
                }
              }
              if (index5 > 0 && chestTileType == (ushort) 467)
              {
                if (flag10 && WorldGen.genRand.Next(3) == 0)
                {
                  chest.item[index5].SetDefaults(2197);
                  ++index5;
                }
                if (flag10)
                {
                  int num56 = WorldGen.genRand.Next(5);
                  if (num56 == 0)
                    chest.item[index5].SetDefaults(5258);
                  if (num56 == 1)
                    chest.item[index5].SetDefaults(5226);
                  if (num56 == 2)
                    chest.item[index5].SetDefaults(5254);
                  if (num56 == 3)
                    chest.item[index5].SetDefaults(5238);
                  if (num56 == 4)
                    chest.item[index5].SetDefaults(5255);
                  ++index5;
                }
                if (flag10)
                {
                  chest.item[index5].SetDefaults(751);
                  chest.item[index5].stack = WorldGen.genRand.Next(50, 101);
                  ++index5;
                }
                if (style == 13 && WorldGen.genRand.Next(2) == 0)
                {
                  chest.item[index5].SetDefaults(5234);
                  ++index5;
                }
              }
            }
            return true;
          }
          if (trySlope)
          {
            if (slope1 > -1)
              Main.tile[i - 1, index1].slope((byte) slope1);
            if (slope2 > -1)
              Main.tile[i, index1].slope((byte) slope2);
          }
          return false;
        }
      }
      return false;
    }

    public static void UnlockDoor(int i, int j)
    {
      int index1 = i;
      int index2 = j;
      if (Main.tile[index1, index2] == null)
        return;
      while (Main.tile[index1, index2].frameY != (short) 594)
      {
        --index2;
        if (Main.tile[index1, index2].frameY < (short) 594 || index2 <= 0)
          return;
      }
      SoundEngine.PlaySound(22, index1 * 16, index2 * 16 + 16);
      for (int index3 = index2; index3 <= index2 + 2; ++index3)
      {
        if (Main.tile[index1, index3] == null)
          Main.tile[index1, index3] = new Tile();
        Main.tile[index1, index3].frameY += (short) 54;
        for (int index4 = 0; index4 < 4; ++index4)
          Dust.NewDust(new Vector2((float) (index1 * 16), (float) (index3 * 16)), 16, 16, 11);
      }
      AchievementsHelper.NotifyProgressionEvent(22);
    }

    public static bool OpenDoor(int i, int j, int direction)
    {
      if (Main.tile[i, j - 1] == null)
        Main.tile[i, j - 1] = new Tile();
      if (Main.tile[i, j - 2] == null)
        Main.tile[i, j - 2] = new Tile();
      if (Main.tile[i, j + 1] == null)
        Main.tile[i, j + 1] = new Tile();
      if (Main.tile[i, j] == null)
        Main.tile[i, j] = new Tile();
      Tile t = Main.tile[i, j];
      if (t.type != (ushort) 10 || WorldGen.IsLockedDoor(t))
        return false;
      short num1 = 0;
      int frameY = (int) t.frameY;
      int num2 = 0;
      while (frameY >= 54)
      {
        frameY -= 54;
        ++num2;
      }
      if (t.frameX >= (short) 54)
      {
        int num3 = (int) t.frameX / 54;
        num2 += 36 * num3;
        num1 += (short) (72 * num3);
      }
      int y = j - frameY / 18;
      int index = i;
      TileColorCache cache1 = Main.tile[index, y].BlockColorAndCoating();
      if (Main.tile[index, y + 1] == null)
        Main.tile[index, y + 1] = new Tile();
      TileColorCache cache2 = Main.tile[index, y + 1].BlockColorAndCoating();
      if (Main.tile[index, y + 2] == null)
        Main.tile[index, y + 2] = new Tile();
      TileColorCache cache3 = Main.tile[index, y + 2].BlockColorAndCoating();
      int x;
      int i1;
      if (direction == -1)
      {
        x = i - 1;
        num1 += (short) 36;
        i1 = i - 1;
      }
      else
      {
        x = i;
        i1 = i + 1;
      }
      for (int j1 = y; j1 < y + 3; ++j1)
      {
        if (Main.tile[i1, j1] == null)
          Main.tile[i1, j1] = new Tile();
        if (Main.tile[i1, j1].active())
        {
          if (!Main.tileCut[(int) Main.tile[i1, j1].type] && Main.tile[i1, j1].type != (ushort) 3 && Main.tile[i1, j1].type != (ushort) 24 && Main.tile[i1, j1].type != (ushort) 52 && Main.tile[i1, j1].type != (ushort) 61 && Main.tile[i1, j1].type != (ushort) 62 && Main.tile[i1, j1].type != (ushort) 69 && Main.tile[i1, j1].type != (ushort) 655 && Main.tile[i1, j1].type != (ushort) 71 && Main.tile[i1, j1].type != (ushort) 73 && Main.tile[i1, j1].type != (ushort) 74 && Main.tile[i1, j1].type != (ushort) 110 && Main.tile[i1, j1].type != (ushort) 113 && Main.tile[i1, j1].type != (ushort) 115 && Main.tile[i1, j1].type != (ushort) 165)
            return false;
          WorldGen.KillTile(i1, j1);
        }
      }
      if (Main.netMode != 1 && Wiring.running)
      {
        Wiring.SkipWire(x, y);
        Wiring.SkipWire(x, y + 1);
        Wiring.SkipWire(x, y + 2);
        Wiring.SkipWire(x + 1, y);
        Wiring.SkipWire(x + 1, y + 1);
        Wiring.SkipWire(x + 1, y + 2);
      }
      int num4 = num2 % 36 * 54;
      SoundEngine.PlaySound(8, i * 16, j * 16);
      Main.tile[x, y].active(true);
      Main.tile[x, y].type = (ushort) 11;
      Main.tile[x, y].frameY = (short) num4;
      Main.tile[x, y].frameX = num1;
      Main.tile[x, y].UseBlockColors(cache1);
      if (Main.tile[x + 1, y] == null)
        Main.tile[x + 1, y] = new Tile();
      Main.tile[x + 1, y].active(true);
      Main.tile[x + 1, y].type = (ushort) 11;
      Main.tile[x + 1, y].frameY = (short) num4;
      Main.tile[x + 1, y].frameX = (short) ((int) num1 + 18);
      Main.tile[x + 1, y].UseBlockColors(cache1);
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      Main.tile[x, y + 1].active(true);
      Main.tile[x, y + 1].type = (ushort) 11;
      Main.tile[x, y + 1].frameY = (short) (num4 + 18);
      Main.tile[x, y + 1].frameX = num1;
      Main.tile[x, y + 1].UseBlockColors(cache2);
      if (Main.tile[x + 1, y + 1] == null)
        Main.tile[x + 1, y + 1] = new Tile();
      Main.tile[x + 1, y + 1].active(true);
      Main.tile[x + 1, y + 1].type = (ushort) 11;
      Main.tile[x + 1, y + 1].frameY = (short) (num4 + 18);
      Main.tile[x + 1, y + 1].frameX = (short) ((int) num1 + 18);
      Main.tile[x + 1, y + 1].UseBlockColors(cache2);
      if (Main.tile[x, y + 2] == null)
        Main.tile[x, y + 2] = new Tile();
      Main.tile[x, y + 2].active(true);
      Main.tile[x, y + 2].type = (ushort) 11;
      Main.tile[x, y + 2].frameY = (short) (num4 + 36);
      Main.tile[x, y + 2].frameX = num1;
      Main.tile[x, y + 2].UseBlockColors(cache3);
      if (Main.tile[x + 1, y + 2] == null)
        Main.tile[x + 1, y + 2] = new Tile();
      Main.tile[x + 1, y + 2].active(true);
      Main.tile[x + 1, y + 2].type = (ushort) 11;
      Main.tile[x + 1, y + 2].frameY = (short) (num4 + 36);
      Main.tile[x + 1, y + 2].frameX = (short) ((int) num1 + 18);
      Main.tile[x + 1, y + 2].UseBlockColors(cache3);
      for (int i2 = x - 1; i2 <= x + 2; ++i2)
      {
        for (int j2 = y - 1; j2 <= y + 2; ++j2)
          WorldGen.TileFrame(i2, j2);
      }
      return true;
    }

    public static void Check1xX(int x, int j, short type)
    {
      if (WorldGen.destroyObject)
        return;
      int frameX = (int) Main.tile[x, j].frameX;
      int num1 = 3;
      if (type == (short) 92)
        num1 = 6;
      int frameY = (int) Main.tile[x, j].frameY;
      int num2 = 0;
      while (frameY >= 18 * num1)
      {
        frameY -= 18 * num1;
        ++num2;
      }
      int num3 = (int) Main.tile[x, j].frameX / 18;
      int num4 = j - frameY / 18;
      bool flag = false;
      for (int index = 0; index < num1; ++index)
      {
        if (Main.tile[x, num4 + index] == null)
          Main.tile[x, num4 + index] = new Tile();
        if (!Main.tile[x, num4 + index].active())
          flag = true;
        else if ((int) Main.tile[x, num4 + index].type != (int) type)
          flag = true;
        else if ((int) Main.tile[x, num4 + index].frameY != index * 18 + num2 * num1 * 18)
          flag = true;
        else if ((int) Main.tile[x, num4 + index].frameX != frameX)
          flag = true;
      }
      if (Main.tile[x, num4 + num1] == null)
        Main.tile[x, num4 + num1] = new Tile();
      if (!WorldGen.SolidTileAllowBottomSlope(x, num4 + num1))
        flag = true;
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int index = 0; index < num1; ++index)
      {
        if ((int) Main.tile[x, num4 + index].type == (int) type)
          WorldGen.KillTile(x, num4 + index);
      }
      if (type == (short) 92)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, j), x * 16, j * 16, 32, 32, 341);
      if (type == (short) 453)
      {
        int Type = num3 >= 2 ? (num3 >= 4 ? 3743 : 3745) : 3744;
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, j), x * 16, j * 16, 16, 32, Type);
      }
      if (type == (short) 93)
      {
        int Type = 0;
        if (num2 == 0)
          Type = 342;
        else if (num2 >= 1 && num2 <= 10)
          Type = 2082 + num2 - 1;
        else if (num2 >= 11 && num2 <= 16)
        {
          Type = 2129 + num2 - 11;
        }
        else
        {
          switch (num2)
          {
            case 17:
              Type = 2225;
              break;
            case 18:
              Type = 2533;
              break;
            case 19:
              Type = 2547;
              break;
            case 20:
              Type = 2563;
              break;
            case 21:
              Type = 2578;
              break;
            case 22:
              Type = 2643;
              break;
            case 23:
              Type = 2644;
              break;
            case 24:
              Type = 2645;
              break;
            case 25:
              Type = 2646;
              break;
            case 26:
              Type = 2647;
              break;
            case 27:
              Type = 2819;
              break;
            case 28:
              Type = 3135;
              break;
            case 29:
              Type = 3137;
              break;
            case 30:
              Type = 3136;
              break;
            case 31:
              Type = 3892;
              break;
            case 32:
              Type = 3942;
              break;
            case 33:
              Type = 3969;
              break;
            case 34:
              Type = 4156;
              break;
            case 35:
              Type = 4177;
              break;
            case 36:
              Type = 4198;
              break;
            case 37:
              Type = 4219;
              break;
            case 38:
              Type = 4308;
              break;
            case 39:
              Type = 4577;
              break;
            case 40:
              Type = 5159;
              break;
            case 41:
              Type = 5180;
              break;
            case 42:
              Type = 5201;
              break;
          }
        }
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, j), x * 16, j * 16, 32, 32, Type);
      }
      WorldGen.destroyObject = false;
    }

    public static void Check2xX(int i, int j, ushort type)
    {
      if (WorldGen.destroyObject)
        return;
      int index1 = i;
      int frameX1 = (int) Main.tile[i, j].frameX;
      while (frameX1 >= 36)
        frameX1 -= 36;
      if (frameX1 == 18)
        --index1;
      if (Main.tile[index1, j] == null)
        Main.tile[index1, j] = new Tile();
      int num1 = (int) Main.tile[index1, j].frameY / 18;
      int num2 = 3;
      if (type == (ushort) 104)
        num2 = 5;
      if (type == (ushort) 207)
        num2 = 4;
      int num3 = 0;
      while (num1 >= num2)
      {
        num1 -= num2;
        num3 += num2 * 18;
      }
      int y = j - num1;
      if (type == (ushort) 410 && num3 != 0)
        num3 += 2;
      if (Main.tile[index1, y] == null)
        Main.tile[index1, y] = new Tile();
      int frameX2 = (int) Main.tile[index1, j].frameX;
      int frameY = (int) Main.tile[index1, j].frameY;
      bool flag1 = false;
      for (int index2 = 0; index2 < num2; ++index2)
      {
        if (Main.tile[index1, y + index2] == null)
          Main.tile[index1, y + index2] = new Tile();
        if (!Main.tile[index1, y + index2].active())
          flag1 = true;
        else if ((int) Main.tile[index1, y + index2].type != (int) type)
          flag1 = true;
        else if ((int) Main.tile[index1, y + index2].frameY != index2 * 18 + num3)
          flag1 = true;
        else if ((int) Main.tile[index1, y + index2].frameX != frameX2)
          flag1 = true;
        if (Main.tile[index1 + 1, y + index2] == null)
          Main.tile[index1 + 1, y + index2] = new Tile();
        if (!Main.tile[index1 + 1, y + index2].active())
          flag1 = true;
        else if ((int) Main.tile[index1 + 1, y + index2].type != (int) type)
          flag1 = true;
        else if ((int) Main.tile[index1 + 1, y + index2].frameY != index2 * 18 + num3)
          flag1 = true;
        else if ((int) Main.tile[index1 + 1, y + index2].frameX != frameX2 + 18)
          flag1 = true;
      }
      if (type == (ushort) 465 || type == (ushort) 531 || type == (ushort) 591 || type == (ushort) 592)
      {
        bool flag2 = false;
        for (int index3 = 0; index3 < 2; ++index3)
        {
          bool flag3 = false;
          Tile tileSafely = Framing.GetTileSafely(index1 + index3, y - 1);
          if (type != (ushort) 531 && tileSafely.type == (ushort) 380)
            flag3 = true;
          else if (type != (ushort) 531 && TileID.Sets.Platforms[(int) tileSafely.type])
          {
            if (index3 == 0)
            {
              flag2 = WorldGen.IsBelowANonHammeredPlatform(index1 + index3, y);
              flag3 = true;
            }
            else if (flag2 == WorldGen.IsBelowANonHammeredPlatform(index1 + index3, y))
              flag3 = true;
          }
          else
            flag3 = WorldGen.SolidTileAllowTopSlope(index1 + index3, y - 1);
          if (!flag3)
          {
            flag1 = true;
            break;
          }
        }
      }
      else
      {
        if (!WorldGen.SolidTileAllowBottomSlope(index1, y + num2))
          flag1 = true;
        if (!WorldGen.SolidTileAllowBottomSlope(index1 + 1, y + num2))
          flag1 = true;
      }
      if (!flag1)
        return;
      WorldGen.destroyObject = true;
      for (int index4 = 0; index4 < num2; ++index4)
      {
        if ((int) Main.tile[index1, y + index4].type == (int) type)
          WorldGen.KillTile(index1, y + index4);
        if ((int) Main.tile[index1 + 1, y + index4].type == (int) type)
          WorldGen.KillTile(index1 + 1, y + index4);
      }
      if (type == (ushort) 104)
      {
        int num4 = frameX2 / 36;
        int Type = num4 < 1 || num4 > 5 ? (num4 != 6 ? (num4 != 7 ? (num4 < 8 || num4 > 23 ? (num4 != 24 ? (num4 != 25 ? (num4 != 26 ? (num4 != 27 ? (num4 != 28 ? (num4 != 29 ? (num4 != 30 ? (num4 != 31 ? (num4 != 32 ? (num4 != 33 ? (num4 != 34 ? (num4 != 35 ? (num4 != 36 ? (num4 != 37 ? (num4 != 38 ? (num4 != 39 ? (num4 != 40 ? (num4 != 41 ? (num4 != 42 ? (num4 != 43 ? 359 : 5199) : 5178) : 5157) : 4575) : 4306) : 4217) : 4196) : 4175) : 4154) : 3966) : 3940) : 3902) : 3901) : 3900) : 3899) : 3898) : 3127) : 3128) : 3126) : 2809) : 2591 + num4 - 8) : 2575) : 2560) : 2237 + num4 - 1;
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, Type);
      }
      if (type == (ushort) 105)
      {
        int num5 = frameX2 / 36 + frameY / 54 % 3 * 55;
        int Type = num5 != 0 ? (num5 != 1 ? (num5 != 43 ? (num5 != 44 ? (num5 != 45 ? (num5 != 46 ? (num5 != 47 ? (num5 != 48 ? (num5 != 49 ? (num5 != 50 ? (num5 < 51 || num5 > 62 ? (num5 < 63 || num5 > 75 ? (num5 != 76 ? (num5 != 77 ? (num5 != 78 ? (num5 != 79 ? (num5 != 80 ? (num5 != 81 ? (num5 != 82 ? 438 + num5 - 2 : 5319) : 5318) : 5317) : 4466) : 4342) : 4360) : 4397) : 3708 + num5 - 63) : 3651 + num5 - 51) : 2672) : 1462) : 1410) : 1409) : 1408) : 1154) : 1153) : 1152) : 52) : 360;
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, Type);
      }
      if (type == (ushort) 356)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, 3064);
      if (type == (ushort) 663)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, 5381);
      if (type == (ushort) 456)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, 3748);
      if (type == (ushort) 337)
      {
        int num6 = frameX2 / 36;
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, 2702 + num6);
      }
      if (type == (ushort) 207)
      {
        int Type = frameX2 / 36;
        switch (Type)
        {
          case 0:
            Type = 909;
            break;
          case 1:
            Type = 910;
            break;
          default:
            if (Type >= 2 && Type <= 7)
            {
              Type = 938 + Type;
              break;
            }
            switch (Type)
            {
              case 8:
                Type = 4922;
                break;
              case 9:
                Type = 4417;
                break;
            }
            break;
        }
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, Type);
      }
      if (type == (ushort) 410)
      {
        int num7 = frameX2 / 36;
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, num7 + 3536);
      }
      if (type == (ushort) 480)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, 4054);
      if (type == (ushort) 509)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, 4318);
      if (type == (ushort) 657)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, 5345);
      if (type == (ushort) 658)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, 5347);
      if (type == (ushort) 489)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, 4074);
      if (type == (ushort) 320)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, 2496);
      if (type == (ushort) 349)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, 470);
      if (type == (ushort) 506)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, 4276);
      if (type == (ushort) 545)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, 4420);
      if (type == (ushort) 465)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, 3815);
      if (type == (ushort) 531)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, 4355);
      if (type == (ushort) 378)
      {
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 48, 3202);
        TETrainingDummy.Kill(index1, y);
      }
      if (type == (ushort) 560)
      {
        int num8 = frameX2 / 36;
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, num8 + 4599);
      }
      if (type == (ushort) 591)
      {
        int num9 = frameX2 / 36;
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, num9 + 4858);
      }
      if (type == (ushort) 592)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index1, j), index1 * 16, j * 16, 32, 32, 4867);
      WorldGen.destroyObject = false;
    }

    public static bool IsBelowANonHammeredPlatform(int x, int y)
    {
      if (y < 1)
        return false;
      Tile tile = Main.tile[x, y - 1];
      return tile != null && tile.active() && TileID.Sets.Platforms[(int) tile.type] && !tile.halfBrick() && tile.slope() == (byte) 0;
    }

    public static void PlaceTight(int x, int y, bool spiders = false)
    {
      if (Main.tile[x, y - 1] == null)
        Main.tile[x, y - 1] = new Tile();
      if (Main.tile[x, y] == null)
        Main.tile[x, y] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (Main.tile[x, y].shimmer())
        return;
      WorldGen.PlaceUncheckedStalactite(x, y, WorldGen.genRand.Next(2) == 0, WorldGen.genRand.Next(3), spiders);
      if (Main.tile[x, y].type != (ushort) 165)
        return;
      WorldGen.CheckTight(x, y);
    }

    public static void PlaceUncheckedStalactite(
      int x,
      int y,
      bool preferSmall,
      int variation,
      bool spiders)
    {
      ushort num1 = 165;
      variation = Utils.Clamp<int>(variation, 0, 2);
      if (WorldGen.SolidTile(x, y - 1) && !Main.tile[x, y].active() && !Main.tile[x, y + 1].active())
      {
        if (spiders)
        {
          int num2 = 108 + variation * 18;
          Main.tile[x, y].type = num1;
          Main.tile[x, y].active(true);
          Main.tile[x, y].frameX = (short) num2;
          Main.tile[x, y].frameY = (short) 0;
          Main.tile[x, y + 1].type = num1;
          Main.tile[x, y + 1].active(true);
          Main.tile[x, y + 1].frameX = (short) num2;
          Main.tile[x, y + 1].frameY = (short) 18;
        }
        else
        {
          if (Main.tile[x, y - 1].type == (ushort) 147 || Main.tile[x, y - 1].type == (ushort) 161 || Main.tile[x, y - 1].type == (ushort) 163 || Main.tile[x, y - 1].type == (ushort) 164 || Main.tile[x, y - 1].type == (ushort) 200)
          {
            if (preferSmall)
            {
              int num3 = variation * 18;
              Main.tile[x, y].type = num1;
              Main.tile[x, y].active(true);
              Main.tile[x, y].frameX = (short) num3;
              Main.tile[x, y].frameY = (short) 72;
            }
            else
            {
              int num4 = variation * 18;
              Main.tile[x, y].type = num1;
              Main.tile[x, y].active(true);
              Main.tile[x, y].frameX = (short) num4;
              Main.tile[x, y].frameY = (short) 0;
              Main.tile[x, y + 1].type = num1;
              Main.tile[x, y + 1].active(true);
              Main.tile[x, y + 1].frameX = (short) num4;
              Main.tile[x, y + 1].frameY = (short) 18;
            }
          }
          if (Main.tile[x, y - 1].type == (ushort) 1 || Main.tileMoss[(int) Main.tile[x, y - 1].type] || Main.tile[x, y - 1].type == (ushort) 117 || Main.tile[x, y - 1].type == (ushort) 25 || Main.tile[x, y - 1].type == (ushort) 203)
          {
            if (preferSmall)
            {
              int num5 = 54 + variation * 18;
              Main.tile[x, y].type = num1;
              Main.tile[x, y].active(true);
              Main.tile[x, y].frameX = (short) num5;
              Main.tile[x, y].frameY = (short) 72;
            }
            else
            {
              int num6 = 54 + variation * 18;
              Main.tile[x, y].type = num1;
              Main.tile[x, y].active(true);
              Main.tile[x, y].frameX = (short) num6;
              Main.tile[x, y].frameY = (short) 0;
              Main.tile[x, y + 1].type = num1;
              Main.tile[x, y + 1].active(true);
              Main.tile[x, y + 1].frameX = (short) num6;
              Main.tile[x, y + 1].frameY = (short) 18;
            }
          }
          if (Main.tile[x, y - 1].type == (ushort) 225)
          {
            int num7 = 162 + variation * 18;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num7;
            Main.tile[x, y].frameY = (short) 72;
          }
          if (Main.tile[x, y - 1].type == (ushort) 396 || Main.tile[x, y - 1].type == (ushort) 397)
          {
            if (preferSmall)
            {
              int num8 = 378 + variation * 18;
              Main.tile[x, y].type = num1;
              Main.tile[x, y].active(true);
              Main.tile[x, y].frameX = (short) num8;
              Main.tile[x, y].frameY = (short) 72;
            }
            else
            {
              int num9 = 378 + variation * 18;
              Main.tile[x, y].type = num1;
              Main.tile[x, y].active(true);
              Main.tile[x, y].frameX = (short) num9;
              Main.tile[x, y].frameY = (short) 0;
              Main.tile[x, y + 1].type = num1;
              Main.tile[x, y + 1].active(true);
              Main.tile[x, y + 1].frameX = (short) num9;
              Main.tile[x, y + 1].frameY = (short) 18;
            }
          }
          if (Main.tile[x, y - 1].type == (ushort) 368)
          {
            if (preferSmall)
            {
              int num10 = 432 + variation * 18;
              Main.tile[x, y].type = num1;
              Main.tile[x, y].active(true);
              Main.tile[x, y].frameX = (short) num10;
              Main.tile[x, y].frameY = (short) 72;
            }
            else
            {
              int num11 = 432 + variation * 18;
              Main.tile[x, y].type = num1;
              Main.tile[x, y].active(true);
              Main.tile[x, y].frameX = (short) num11;
              Main.tile[x, y].frameY = (short) 0;
              Main.tile[x, y + 1].type = num1;
              Main.tile[x, y + 1].active(true);
              Main.tile[x, y + 1].frameX = (short) num11;
              Main.tile[x, y + 1].frameY = (short) 18;
            }
          }
          if (Main.tile[x, y - 1].type != (ushort) 367)
            return;
          if (preferSmall)
          {
            int num12 = 486 + variation * 18;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num12;
            Main.tile[x, y].frameY = (short) 72;
          }
          else
          {
            int num13 = 486 + variation * 18;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num13;
            Main.tile[x, y].frameY = (short) 0;
            Main.tile[x, y + 1].type = num1;
            Main.tile[x, y + 1].active(true);
            Main.tile[x, y + 1].frameX = (short) num13;
            Main.tile[x, y + 1].frameY = (short) 18;
          }
        }
      }
      else
      {
        if (spiders || !WorldGen.SolidTile(x, y + 1) || Main.tile[x, y].active() || Main.tile[x, y - 1].active())
          return;
        if (Main.tile[x, y + 1].type == (ushort) 1 || Main.tileMoss[(int) Main.tile[x, y + 1].type] || Main.tile[x, y - 1].type == (ushort) 117 || Main.tile[x, y - 1].type == (ushort) 25 || Main.tile[x, y - 1].type == (ushort) 203)
        {
          if (preferSmall)
          {
            int num14 = 54 + variation * 18;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num14;
            Main.tile[x, y].frameY = (short) 90;
          }
          else
          {
            int num15 = 54 + variation * 18;
            Main.tile[x, y - 1].type = num1;
            Main.tile[x, y - 1].active(true);
            Main.tile[x, y - 1].frameX = (short) num15;
            Main.tile[x, y - 1].frameY = (short) 36;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num15;
            Main.tile[x, y].frameY = (short) 54;
          }
        }
        if (Main.tile[x, y + 1].type == (ushort) 225)
        {
          int num16 = 162 + variation * 18;
          Main.tile[x, y].type = num1;
          Main.tile[x, y].active(true);
          Main.tile[x, y].frameX = (short) num16;
          Main.tile[x, y].frameY = (short) 90;
        }
        if (Main.tile[x, y + 1].type == (ushort) 396 || Main.tile[x, y + 1].type == (ushort) 397)
        {
          if (preferSmall)
          {
            int num17 = 378 + variation * 18;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num17;
            Main.tile[x, y].frameY = (short) 90;
          }
          else
          {
            int num18 = 378 + variation * 18;
            Main.tile[x, y - 1].type = num1;
            Main.tile[x, y - 1].active(true);
            Main.tile[x, y - 1].frameX = (short) num18;
            Main.tile[x, y - 1].frameY = (short) 36;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num18;
            Main.tile[x, y].frameY = (short) 54;
          }
        }
        if (Main.tile[x, y + 1].type == (ushort) 368)
        {
          if (preferSmall)
          {
            int num19 = 432 + variation * 18;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num19;
            Main.tile[x, y].frameY = (short) 90;
          }
          else
          {
            int num20 = 432 + variation * 18;
            Main.tile[x, y - 1].type = num1;
            Main.tile[x, y - 1].active(true);
            Main.tile[x, y - 1].frameX = (short) num20;
            Main.tile[x, y - 1].frameY = (short) 36;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num20;
            Main.tile[x, y].frameY = (short) 54;
          }
        }
        if (Main.tile[x, y + 1].type != (ushort) 367)
          return;
        if (preferSmall)
        {
          int num21 = 486 + variation * 18;
          Main.tile[x, y].type = num1;
          Main.tile[x, y].active(true);
          Main.tile[x, y].frameX = (short) num21;
          Main.tile[x, y].frameY = (short) 90;
        }
        else
        {
          int num22 = 486 + variation * 18;
          Main.tile[x, y - 1].type = num1;
          Main.tile[x, y - 1].active(true);
          Main.tile[x, y - 1].frameX = (short) num22;
          Main.tile[x, y - 1].frameY = (short) 36;
          Main.tile[x, y].type = num1;
          Main.tile[x, y].active(true);
          Main.tile[x, y].frameX = (short) num22;
          Main.tile[x, y].frameY = (short) 54;
        }
      }
    }

    public static bool UpdateStalagtiteStyle(int x, int j)
    {
      if (Main.netMode == 1 || Main.tile[x, j] == null)
        return true;
      int style;
      bool fail1;
      WorldGen.GetStalagtiteStyle(x, j, out style, out fail1);
      if (fail1)
        return false;
      bool fail2;
      int desiredStyle;
      int height;
      int y;
      WorldGen.GetDesiredStalagtiteStyle(x, j, out fail2, out desiredStyle, out height, out y);
      if (fail2)
        return false;
      if (style != desiredStyle)
      {
        int num = WorldGen.genRand.Next(3) * 18;
        switch (desiredStyle)
        {
          case 0:
            num += 54;
            break;
          case 1:
            num += 216;
            break;
          case 2:
            num += 270;
            break;
          case 3:
            num += 324;
            break;
          case 4:
            num += 378;
            break;
          case 5:
            num += 432;
            break;
          case 6:
            num += 486;
            break;
          case 7:
            num = num;
            break;
          case 8:
            num += 540;
            break;
          case 9:
            num += 594;
            break;
          case 10:
            num += 648;
            break;
        }
        for (int index = y; index < y + height; ++index)
          Main.tile[x, index].frameX = (short) num;
        if (Main.netMode == 2)
          NetMessage.SendTileSquare(-1, x, y, 1, 2);
      }
      return true;
    }

    private static void GetDesiredStalagtiteStyle(
      int x,
      int j,
      out bool fail,
      out int desiredStyle,
      out int height,
      out int y)
    {
      fail = false;
      desiredStyle = 0;
      height = 1;
      y = j;
      if (Main.tile[x, y].frameY == (short) 72)
        desiredStyle = (int) Main.tile[x, y - 1].type;
      else if (Main.tile[x, y].frameY == (short) 90)
        desiredStyle = (int) Main.tile[x, y + 1].type;
      else if (Main.tile[x, y].frameY >= (short) 36)
      {
        if (Main.tile[x, y].frameY == (short) 54)
          --y;
        height = 2;
        desiredStyle = (int) Main.tile[x, y + 2].type;
      }
      else
      {
        if (Main.tile[x, y].frameY == (short) 18)
          --y;
        height = 2;
        desiredStyle = (int) Main.tile[x, y - 1].type;
      }
      if (desiredStyle == 1 || Main.tileMoss[desiredStyle])
        desiredStyle = 0;
      else if (desiredStyle == 200)
        desiredStyle = 10;
      else if (desiredStyle == 164)
        desiredStyle = 8;
      else if (desiredStyle == 163)
        desiredStyle = 9;
      else if (desiredStyle == 117 || desiredStyle == 402 || desiredStyle == 403)
        desiredStyle = 1;
      else if (desiredStyle == 25 || desiredStyle == 398 || desiredStyle == 400)
        desiredStyle = 2;
      else if (desiredStyle == 203 || desiredStyle == 399 || desiredStyle == 401)
        desiredStyle = 3;
      else if (desiredStyle == 396 || desiredStyle == 397)
        desiredStyle = 4;
      else if (desiredStyle == 367)
        desiredStyle = 6;
      else if (desiredStyle == 368)
        desiredStyle = 5;
      else if (desiredStyle == 161 || desiredStyle == 147)
        desiredStyle = 7;
      else
        fail = true;
    }

    private static void GetStalagtiteStyle(int x, int y, out int style, out bool fail)
    {
      style = 0;
      fail = false;
      switch ((int) Main.tile[x, y].frameX / 54)
      {
        case 0:
          style = 7;
          break;
        case 1:
          style = 0;
          break;
        case 4:
          style = 1;
          break;
        case 5:
          style = 2;
          break;
        case 6:
          style = 3;
          break;
        case 7:
          style = 4;
          break;
        case 8:
          style = 5;
          break;
        case 9:
          style = 6;
          break;
        case 10:
          style = 8;
          break;
        case 11:
          style = 9;
          break;
        case 12:
          style = 10;
          break;
        default:
          fail = true;
          break;
      }
    }

    public static void CheckTight(int x, int j)
    {
      if (Main.tile[x, j] == null)
        return;
      int j1 = j;
      if (Main.tile[x, j1].frameY == (short) 72)
      {
        if (Main.tile[x, j1 - 1] == null)
          Main.tile[x, j1 - 1] = new Tile();
        if (Main.tile[x, j1] == null)
          Main.tile[x, j1] = new Tile();
        if (Main.tile[x, j1 + 1] == null)
          Main.tile[x, j1 + 1] = new Tile();
        bool flag = false;
        if (!WorldGen.SolidTile(x, j1 - 1))
          flag = true;
        if (!flag && !WorldGen.UpdateStalagtiteStyle(x, j1))
          flag = true;
        if (!flag)
          return;
        WorldGen.destroyObject = true;
        if ((int) Main.tile[x, j1].type == (int) Main.tile[x, j].type)
          WorldGen.KillTile(x, j1);
        WorldGen.destroyObject = false;
      }
      else if (Main.tile[x, j1].frameY == (short) 90)
      {
        if (Main.tile[x, j1 - 1] == null)
          Main.tile[x, j1 - 1] = new Tile();
        if (Main.tile[x, j1] == null)
          Main.tile[x, j1] = new Tile();
        if (Main.tile[x, j1 + 1] == null)
          Main.tile[x, j1 + 1] = new Tile();
        bool flag = false;
        if (!WorldGen.SolidTile(x, j1 + 1))
          flag = true;
        if (!flag && !WorldGen.UpdateStalagtiteStyle(x, j1))
          flag = true;
        if (!flag)
          return;
        WorldGen.destroyObject = true;
        if ((int) Main.tile[x, j1].type == (int) Main.tile[x, j].type)
          WorldGen.KillTile(x, j1);
        WorldGen.destroyObject = false;
      }
      else if (Main.tile[x, j1].frameY >= (short) 36)
      {
        if (Main.tile[x, j1].frameY == (short) 54)
          --j1;
        if (Main.tile[x, j1] == null)
          Main.tile[x, j1] = new Tile();
        if (Main.tile[x, j1 + 1] == null)
          Main.tile[x, j1 + 1] = new Tile();
        if (Main.tile[x, j1 + 2] == null)
          Main.tile[x, j1 + 2] = new Tile();
        bool flag = false;
        if (!WorldGen.SolidTile(x, j1 + 2))
          flag = true;
        if ((int) Main.tile[x, j1 + 1].type != (int) Main.tile[x, j1].type)
          flag = true;
        if ((int) Main.tile[x, j1 + 1].frameX != (int) Main.tile[x, j1].frameX)
          flag = true;
        if (!flag && !WorldGen.UpdateStalagtiteStyle(x, j1))
          flag = true;
        if (!flag)
          return;
        WorldGen.destroyObject = true;
        if ((int) Main.tile[x, j1].type == (int) Main.tile[x, j].type)
          WorldGen.KillTile(x, j1);
        if ((int) Main.tile[x, j1 + 1].type == (int) Main.tile[x, j].type)
          WorldGen.KillTile(x, j1 + 1);
        WorldGen.destroyObject = false;
      }
      else
      {
        if (Main.tile[x, j1].frameY == (short) 18)
          --j1;
        if (Main.tile[x, j1 - 1] == null)
          Main.tile[x, j1 - 1] = new Tile();
        if (Main.tile[x, j1] == null)
          Main.tile[x, j1] = new Tile();
        if (Main.tile[x, j1 + 1] == null)
          Main.tile[x, j1 + 1] = new Tile();
        bool flag = false;
        if (!WorldGen.SolidTile(x, j1 - 1))
          flag = true;
        if ((int) Main.tile[x, j1 + 1].type != (int) Main.tile[x, j1].type)
          flag = true;
        if ((int) Main.tile[x, j1 + 1].frameX != (int) Main.tile[x, j1].frameX)
          flag = true;
        if (!flag && !WorldGen.UpdateStalagtiteStyle(x, j1))
          flag = true;
        if (!flag)
          return;
        WorldGen.destroyObject = true;
        if ((int) Main.tile[x, j1].type == (int) Main.tile[x, j].type)
          WorldGen.KillTile(x, j1);
        if ((int) Main.tile[x, j1 + 1].type == (int) Main.tile[x, j].type)
          WorldGen.KillTile(x, j1 + 1);
        WorldGen.destroyObject = false;
      }
    }

    public static void Place1xX(int x, int y, ushort type, int style = 0)
    {
      int num1 = style * 18;
      int num2 = 3;
      if (type == (ushort) 92)
        num2 = 6;
      bool flag = true;
      for (int index = y - num2 + 1; index < y + 1; ++index)
      {
        if (Main.tile[x, index] == null)
          Main.tile[x, index] = new Tile();
        if (Main.tile[x, index].active())
          flag = false;
        if (type == (ushort) 93 && Main.tile[x, index].liquid > (byte) 0)
          flag = false;
      }
      if (!flag || !WorldGen.SolidTile2(x, y + 1))
        return;
      for (int index = 0; index < num2; ++index)
      {
        Main.tile[x, y - num2 + 1 + index].active(true);
        Main.tile[x, y - num2 + 1 + index].frameY = (short) (index * 18 + num2 * num1);
        Main.tile[x, y - num2 + 1 + index].frameX = (short) 0;
        Main.tile[x, y - num2 + 1 + index].type = type;
      }
    }

    public static int checkXmasTreeDrop(int x, int y, int obj)
    {
      int index1 = x;
      int index2 = y;
      if (Main.tile[x, y].frameX < (short) 10)
      {
        index1 -= (int) Main.tile[x, y].frameX;
        index2 -= (int) Main.tile[x, y].frameY;
      }
      int num1 = 0;
      if (((int) Main.tile[index1, index2].frameY & 1) == 1)
        ++num1;
      if (((int) Main.tile[index1, index2].frameY & 2) == 2)
        num1 += 2;
      if (((int) Main.tile[index1, index2].frameY & 4) == 4)
        num1 += 4;
      int num2 = 0;
      if (((int) Main.tile[index1, index2].frameY & 8) == 8)
        ++num2;
      if (((int) Main.tile[index1, index2].frameY & 16) == 16)
        num2 += 2;
      if (((int) Main.tile[index1, index2].frameY & 32) == 32)
        num2 += 4;
      int num3 = 0;
      if (((int) Main.tile[index1, index2].frameY & 64) == 64)
        ++num3;
      if (((int) Main.tile[index1, index2].frameY & 128) == 128)
        num3 += 2;
      if (((int) Main.tile[index1, index2].frameY & 256) == 256)
        num3 += 4;
      if (((int) Main.tile[index1, index2].frameY & 512) == 512)
        num3 += 8;
      int num4 = 0;
      if (((int) Main.tile[index1, index2].frameY & 1024) == 1024)
        ++num4;
      if (((int) Main.tile[index1, index2].frameY & 2048) == 2048)
        num4 += 2;
      if (((int) Main.tile[index1, index2].frameY & 4096) == 4096)
        num4 += 4;
      if (((int) Main.tile[index1, index2].frameY & 8192) == 8192)
        num4 += 8;
      if (obj == 0 && num1 > 0)
        return num1;
      if (obj == 1 && num2 > 0)
        return num2;
      if (obj == 2 && num3 > 0)
        return num3;
      return obj == 3 && num4 > 0 ? num4 : -1;
    }

    public static void dropXmasTree(int x, int y, int obj)
    {
      int index1 = x;
      int index2 = y;
      if (Main.tile[x, y].frameX < (short) 10)
      {
        index1 -= (int) Main.tile[x, y].frameX;
        index2 -= (int) Main.tile[x, y].frameY;
      }
      int num1 = 0;
      if (((int) Main.tile[index1, index2].frameY & 1) == 1)
        ++num1;
      if (((int) Main.tile[index1, index2].frameY & 2) == 2)
        num1 += 2;
      if (((int) Main.tile[index1, index2].frameY & 4) == 4)
        num1 += 4;
      int num2 = 0;
      if (((int) Main.tile[index1, index2].frameY & 8) == 8)
        ++num2;
      if (((int) Main.tile[index1, index2].frameY & 16) == 16)
        num2 += 2;
      if (((int) Main.tile[index1, index2].frameY & 32) == 32)
        num2 += 4;
      int num3 = 0;
      if (((int) Main.tile[index1, index2].frameY & 64) == 64)
        ++num3;
      if (((int) Main.tile[index1, index2].frameY & 128) == 128)
        num3 += 2;
      if (((int) Main.tile[index1, index2].frameY & 256) == 256)
        num3 += 4;
      if (((int) Main.tile[index1, index2].frameY & 512) == 512)
        num3 += 8;
      int num4 = 0;
      if (((int) Main.tile[index1, index2].frameY & 1024) == 1024)
        ++num4;
      if (((int) Main.tile[index1, index2].frameY & 2048) == 2048)
        num4 += 2;
      if (((int) Main.tile[index1, index2].frameY & 4096) == 4096)
        num4 += 4;
      if (((int) Main.tile[index1, index2].frameY & 8192) == 8192)
        num4 += 8;
      if (obj == 0 && num1 > 0)
      {
        int number = Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, 1874 + num1 - 1);
        if (Main.netMode != 1)
          return;
        NetMessage.SendData(21, number: number, number2: 1f);
      }
      else if (obj == 1 && num2 > 0)
      {
        int number = Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, 1878 + num2 - 1);
        if (Main.netMode != 1)
          return;
        NetMessage.SendData(21, number: number, number2: 1f);
      }
      else if (obj == 2 && num3 > 0)
      {
        int number = Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, 1884 + num3 - 1);
        if (Main.netMode != 1)
          return;
        NetMessage.SendData(21, number: number, number2: 1f);
      }
      else
      {
        if (obj != 3 || num4 <= 0)
          return;
        int number = Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, 1895 + num4 - 1);
        if (Main.netMode != 1)
          return;
        NetMessage.SendData(21, number: number, number2: 1f);
      }
    }

    public static void setXmasTree(int x, int y, int obj, int style)
    {
      int index1 = x;
      int index2 = y;
      if (Main.tile[x, y].frameX < (short) 10)
      {
        index1 -= (int) Main.tile[x, y].frameX;
        index2 -= (int) Main.tile[x, y].frameY;
      }
      if (obj == 0)
      {
        if ((style & 1) == 1)
          Main.tile[index1, index2].frameY |= (short) 1;
        else
          Main.tile[index1, index2].frameY &= (short) -2;
        if ((style & 2) == 2)
          Main.tile[index1, index2].frameY |= (short) 2;
        else
          Main.tile[index1, index2].frameY &= (short) -3;
        if ((style & 4) == 4)
          Main.tile[index1, index2].frameY |= (short) 4;
        else
          Main.tile[index1, index2].frameY &= (short) -5;
      }
      if (obj == 1)
      {
        if ((style & 1) == 1)
          Main.tile[index1, index2].frameY |= (short) 8;
        else
          Main.tile[index1, index2].frameY &= (short) -9;
        if ((style & 2) == 2)
          Main.tile[index1, index2].frameY |= (short) 16;
        else
          Main.tile[index1, index2].frameY &= (short) -17;
        if ((style & 4) == 4)
          Main.tile[index1, index2].frameY |= (short) 32;
        else
          Main.tile[index1, index2].frameY &= (short) -33;
      }
      if (obj == 2)
      {
        if ((style & 1) == 1)
          Main.tile[index1, index2].frameY |= (short) 64;
        else
          Main.tile[index1, index2].frameY &= (short) -65;
        if ((style & 2) == 2)
          Main.tile[index1, index2].frameY |= (short) 128;
        else
          Main.tile[index1, index2].frameY &= (short) -129;
        if ((style & 4) == 4)
          Main.tile[index1, index2].frameY |= (short) 256;
        else
          Main.tile[index1, index2].frameY &= (short) -257;
        if ((style & 8) == 8)
          Main.tile[index1, index2].frameY |= (short) 512;
        else
          Main.tile[index1, index2].frameY &= (short) -513;
      }
      if (obj != 3)
        return;
      if ((style & 1) == 1)
        Main.tile[index1, index2].frameY |= (short) 1024;
      else
        Main.tile[index1, index2].frameY &= (short) -1025;
      if ((style & 2) == 2)
        Main.tile[index1, index2].frameY |= (short) 2048;
      else
        Main.tile[index1, index2].frameY &= (short) -2049;
      if ((style & 4) == 4)
        Main.tile[index1, index2].frameY |= (short) 4096;
      else
        Main.tile[index1, index2].frameY &= (short) -4097;
      if ((style & 8) == 8)
        Main.tile[index1, index2].frameY |= (short) 8192;
      else
        Main.tile[index1, index2].frameY &= (short) -8193;
    }

    public static int PlaceXmasTree_Direct(
      int x,
      int y,
      int type,
      int style,
      int dir,
      int alternate)
    {
      for (short index1 = 0; index1 < (short) 4; ++index1)
      {
        for (short index2 = 0; index2 < (short) 8; ++index2)
        {
          Tile tile = Main.tile[x + (int) index1, y + (int) index2];
          tile.active(true);
          tile.type = (ushort) type;
          if (index1 == (short) 0 && index2 == (short) 0)
          {
            tile.frameX = (short) 10;
            tile.frameY = (short) 0;
          }
          else
          {
            tile.frameX = index1;
            tile.frameY = index2;
          }
        }
      }
      return 0;
    }

    public static void PlaceXmasTree(int x, int y, ushort type = 171)
    {
      bool flag = true;
      int num1 = x - 1;
      int num2 = y - 7;
      for (int i = num1; i < num1 + 4; ++i)
      {
        for (int index = num2; index < num2 + 8; ++index)
        {
          if (Main.tile[i, index].active())
            flag = false;
        }
        if (i > num1 && i < num1 + 3 && !WorldGen.SolidTile(i, num2 + 8))
          flag = false;
      }
      if (!flag)
        return;
      int num3 = 0;
      for (int index1 = num1; index1 < num1 + 4; ++index1)
      {
        int num4 = 0;
        for (int index2 = num2; index2 < num2 + 8; ++index2)
        {
          Main.tile[index1, index2].active(true);
          if (num3 == 0 && num4 == 0)
          {
            Main.tile[index1, index2].frameX = (short) 10;
            Main.tile[index1, index2].frameY = (short) 0;
          }
          else
          {
            Main.tile[index1, index2].frameX = (short) num3;
            Main.tile[index1, index2].frameY = (short) num4;
          }
          Main.tile[index1, index2].type = type;
          Main.tile[index1, index2].active(true);
          ++num4;
        }
        ++num3;
      }
    }

    public static void CheckXmasTree(int x, int y)
    {
      if (WorldGen.destroyObject)
        return;
      int num1 = x;
      int num2 = y;
      if (Main.tile[x, y].frameX < (short) 10)
      {
        num1 -= (int) Main.tile[x, y].frameX;
        num2 -= (int) Main.tile[x, y].frameY;
      }
      bool flag = false;
      int num3 = 0;
      for (int i = num1; i < num1 + 4; ++i)
      {
        int num4 = 0;
        for (int index = num2; index < num2 + 8; ++index)
        {
          if (Main.tile[i, index].active() && Main.tile[i, index].type == (ushort) 171)
          {
            if (num3 != 0 && num4 != 0 && (int) Main.tile[i, index].frameX != num3 && (int) Main.tile[i, index].frameY != num4)
              flag = true;
          }
          else
            flag = true;
          ++num4;
        }
        ++num3;
        if (i > num1 && i < num1 + 3 && !WorldGen.SolidTile2(i, num2 + 8))
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i = num1; i < num1 + 4; ++i)
      {
        for (int j = num2; j < num2 + 8; ++j)
        {
          if (Main.tile[i, j].type == (ushort) 171)
            WorldGen.KillTile(i, j);
        }
      }
      Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1873);
      WorldGen.destroyObject = false;
    }

    public static void Place2xX(int x, int y, ushort type, int style = 0)
    {
      int num1 = style * 36;
      int num2 = 0;
      int num3 = 3;
      if (type == (ushort) 105 && style == 34)
      {
        type = (ushort) 349;
        style = 0;
        num1 = 0;
      }
      if (type == (ushort) 105)
      {
        int num4 = style / 55;
        num1 -= 1980 * num4;
        num2 += 54 * num4;
      }
      if (type == (ushort) 104)
        num3 = 5;
      if (type == (ushort) 207)
        num3 = 4;
      bool flag = true;
      for (int index = y - num3 + 1; index < y + 1; ++index)
      {
        if (Main.tile[x, index] == null)
          Main.tile[x, index] = new Tile();
        if (Main.tile[x, index].active())
          flag = false;
        if (Main.tile[x + 1, index] == null)
          Main.tile[x + 1, index] = new Tile();
        if (Main.tile[x + 1, index].active())
          flag = false;
      }
      if (!flag || !WorldGen.SolidTile2(x, y + 1) || !WorldGen.SolidTile2(x + 1, y + 1))
        return;
      for (int index = 0; index < num3; ++index)
      {
        Main.tile[x, y - num3 + 1 + index].active(true);
        Main.tile[x, y - num3 + 1 + index].frameY = (short) (num2 + index * 18);
        Main.tile[x, y - num3 + 1 + index].frameX = (short) num1;
        Main.tile[x, y - num3 + 1 + index].type = type;
        Main.tile[x + 1, y - num3 + 1 + index].active(true);
        Main.tile[x + 1, y - num3 + 1 + index].frameY = (short) (num2 + index * 18);
        Main.tile[x + 1, y - num3 + 1 + index].frameX = (short) (num1 + 18);
        Main.tile[x + 1, y - num3 + 1 + index].type = type;
      }
    }

    public static int GetItemDrop_Benches(int style)
    {
      switch (style)
      {
        case 1:
          return 2397;
        case 2:
          return 2398;
        case 3:
          return 2399;
        case 4:
          return 2400;
        case 5:
          return 2401;
        case 6:
          return 2402;
        case 7:
          return 2403;
        case 8:
          return 2404;
        case 9:
          return 2405;
        case 10:
          return 2406;
        case 11:
          return 2407;
        case 12:
          return 2408;
        case 13:
          return 2409;
        case 14:
          return 2410;
        case 15:
          return 2411;
        case 16:
          return 2412;
        case 17:
          return 2413;
        case 18:
          return 2414;
        case 19:
          return 2415;
        case 20:
          return 2416;
        case 21:
          return 2521;
        case 22:
          return 2527;
        case 23:
          return 2539;
        case 24:
          return 858;
        case 25:
          return 2582;
        case 26:
          return 2634;
        case 27:
          return 2635;
        case 28:
          return 2636;
        case 29:
          return 2823;
        case 30:
          return 3150;
        case 31:
          return 3152;
        case 32:
          return 3151;
        case 33:
          return 3918;
        case 34:
          return 3919;
        case 35:
          return 3947;
        case 36:
          return 3973;
        case 37:
          return 4161;
        case 38:
          return 4182;
        case 39:
          return 4203;
        case 40:
          return 4224;
        case 41:
          return 4313;
        case 42:
          return 4582;
        case 43:
          return 4993;
        case 44:
          return 5164;
        case 45:
          return 5185;
        case 46:
          return 5206;
        default:
          return 335;
      }
    }

    public static int GetItemDrop_PicnicTables(int style) => style == 0 || style != 1 ? 4064 : 4065;

    public static int GetItemDrop_Chair(int style)
    {
      switch (style)
      {
        case 1:
          return 358;
        case 2:
          return 628;
        case 3:
          return 629;
        case 4:
          return 630;
        case 5:
          return 806;
        case 6:
          return 807;
        case 7:
          return 808;
        case 8:
          return 809;
        case 9:
          return 810;
        case 10:
          return 826;
        case 11:
          return 915;
        case 12:
          return 1143;
        case 13:
          return 1396;
        case 14:
          return 1399;
        case 15:
          return 1402;
        case 16:
          return 1459;
        case 17:
          return 1509;
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
          return 1703 + style - 18;
        case 24:
          return 1792;
        case 25:
          return 1814;
        case 26:
          return 1925;
        case 27:
          return 2228;
        case 28:
          return 2288;
        case 29:
          return 2524;
        case 30:
          return 2557;
        case 31:
          return 2572;
        case 32:
          return 2812;
        case 33:
          return 3174;
        case 34:
          return 3176;
        case 35:
          return 3175;
        case 36:
          return 3889;
        case 37:
          return 3937;
        case 38:
          return 3963;
        case 39:
          return 4151;
        case 40:
          return 4172;
        case 41:
          return 4193;
        case 42:
          return 4214;
        case 43:
          return 4304;
        case 44:
          return 4572;
        case 45:
          return 5154;
        case 46:
          return 5175;
        case 47:
          return 5196;
        default:
          return 34;
      }
    }

    public static int GetItemDrop_Toilet(int style)
    {
      int itemDropToilet = 4096 + style;
      switch (style)
      {
        case 32:
          itemDropToilet = 4141;
          break;
        case 33:
          itemDropToilet = 4165;
          break;
        case 34:
          itemDropToilet = 4186;
          break;
        case 35:
          itemDropToilet = 4207;
          break;
        case 36:
          itemDropToilet = 4228;
          break;
        case 37:
          itemDropToilet = 4316;
          break;
        case 38:
          itemDropToilet = 4586;
          break;
        case 39:
          itemDropToilet = 4731;
          break;
        case 40:
          itemDropToilet = 5168;
          break;
        case 41:
          itemDropToilet = 5189;
          break;
        case 42:
          itemDropToilet = 5210;
          break;
      }
      if (itemDropToilet > 5210)
        itemDropToilet = 5210;
      return itemDropToilet;
    }

    public static void Check1x2(int x, int j, ushort type)
    {
      if (WorldGen.destroyObject)
        return;
      int index = j;
      bool flag = true;
      if (Main.tile[x, index] == null)
        Main.tile[x, index] = new Tile();
      if (Main.tile[x, index + 1] == null)
        Main.tile[x, index + 1] = new Tile();
      int frameY = (int) Main.tile[x, index].frameY;
      int style = 0;
      while (frameY >= 40)
      {
        frameY -= 40;
        ++style;
      }
      if (frameY == 18)
        --index;
      int num1 = (int) Main.tile[x, index].frameX / 18;
      if (Main.tile[x, index].frameX == (short) -1)
        num1 = (int) Main.tile[x, index + 1].frameX / 18;
      if (Main.tile[x, index] == null)
        Main.tile[x, index] = new Tile();
      if ((int) Main.tile[x, index].frameY == 40 * style && (int) Main.tile[x, index + 1].frameY == 40 * style + 18 && (int) Main.tile[x, index].type == (int) type && (int) Main.tile[x, index + 1].type == (int) type)
        flag = false;
      if (Main.tile[x, index + 2] == null)
        Main.tile[x, index + 2] = new Tile();
      if (!WorldGen.SolidTileAllowBottomSlope(x, index + 2) && !TileID.Sets.Platforms[(int) Main.tile[x, index + 2].type])
        flag = true;
      if (Main.tile[x, index].type == (ushort) 20)
      {
        int num2 = (int) Main.tile[x, index].frameX / 54;
        int type1 = (int) Main.tile[x, index + 2].type;
        int num3 = -1;
        switch (type1)
        {
          case 2:
          case 477:
            num3 = 0;
            break;
          case 23:
          case 661:
            num3 = 3;
            break;
          case 53:
            num3 = 6;
            break;
          case 60:
            num3 = 2;
            break;
          case 109:
          case 492:
            num3 = 5;
            break;
          case 112:
            num3 = 9;
            break;
          case 116:
            num3 = 7;
            break;
          case 147:
            num3 = 1;
            break;
          case 199:
          case 662:
            num3 = 4;
            break;
          case 234:
            num3 = 8;
            break;
          case 633:
            num3 = 10;
            break;
          default:
            flag = true;
            break;
        }
        if (!flag && num2 != num3)
        {
          int num4 = 54 * num3 + WorldGen.genRand.Next(3) * 18;
          Main.tile[x, index].frameX = (short) num4;
          Main.tile[x, index + 1].frameX = (short) num4;
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      if ((int) Main.tile[x, index].type == (int) type)
        WorldGen.KillTile(x, index);
      if ((int) Main.tile[x, index + 1].type == (int) type)
        WorldGen.KillTile(x, index + 1);
      if (type == (ushort) 216)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, index), x * 16, index * 16, 32, 32, 970 + style);
      if (type == (ushort) 338)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, index), x * 16, index * 16, 32, 32, 2738);
      if (type == (ushort) 390)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, index), x * 16, index * 16, 16, 32, 3253);
      if (type == (ushort) 493)
      {
        int Type = 0;
        switch (num1)
        {
          case 0:
            Type = 4083;
            break;
          case 1:
            Type = 4084;
            break;
          case 2:
            Type = 4085;
            break;
          case 3:
            Type = 4086;
            break;
          case 4:
            Type = 4087;
            break;
          case 5:
            Type = 4088;
            break;
        }
        if (Type > 0)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, index), x * 16, index * 16, 32, 32, Type);
      }
      if (type == (ushort) 15)
      {
        int itemDropChair = WorldGen.GetItemDrop_Chair(style);
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, index), x * 16, index * 16, 32, 32, itemDropChair);
      }
      if (type == (ushort) 497)
      {
        int itemDropToilet = WorldGen.GetItemDrop_Toilet(style);
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, index), x * 16, index * 16, 32, 32, itemDropToilet);
      }
      else if (type == (ushort) 134)
      {
        if (style == 1)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, index), x * 16, index * 16, 32, 32, 1220);
        else
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, index), x * 16, index * 16, 32, 32, 525);
      }
      WorldGen.destroyObject = false;
    }

    public static void CheckOnTable1x1(int x, int y, int type)
    {
      if (Main.tile[x, y + 1] == null)
        return;
      if (Main.tile[x, y + 1].topSlope())
      {
        if (TileID.Sets.Platforms[(int) Main.tile[x, y + 1].type])
        {
          if (Main.tile[x, y + 1].blockType() == 3 && Main.tile[x - 1, y + 1].active() && Main.tile[x - 1, y + 1].blockType() == 0 && TileID.Sets.Platforms[(int) Main.tile[x - 1, y + 1].type] || Main.tile[x, y + 1].blockType() == 2 && Main.tile[x + 1, y + 1].active() && Main.tile[x + 1, y + 1].blockType() == 0 && TileID.Sets.Platforms[(int) Main.tile[x + 1, y + 1].type])
            return;
          WorldGen.KillTile(x, y);
        }
        else
          WorldGen.KillTile(x, y);
      }
      else
      {
        if (Main.tile[x, y + 1].active() && Main.tileTable[(int) Main.tile[x, y + 1].type] && !Main.tile[x, y + 1].halfBrick())
          return;
        if (type == 78)
        {
          if (WorldGen.SolidTileAllowBottomSlope(x, y + 1))
            return;
          WorldGen.KillTile(x, y);
        }
        else
          WorldGen.KillTile(x, y);
      }
    }

    public static void CheckSign(int x, int y, ushort type)
    {
      if (WorldGen.destroyObject)
        return;
      int num1 = x - 2;
      int num2 = x + 3;
      int num3 = y - 2;
      int num4 = y + 3;
      if (num1 < 0 || num2 > Main.maxTilesX || num3 < 0 || num4 > Main.maxTilesY)
        return;
      bool flag = false;
      for (int index1 = num1; index1 < num2; ++index1)
      {
        for (int index2 = num3; index2 < num4; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
        }
      }
      int num5 = (int) Main.tile[x, y].frameX / 18;
      int num6 = (int) Main.tile[x, y].frameY / 18;
      int num7 = num5 % 2;
      int num8 = num6 % 2;
      int index3 = x - num7;
      int index4 = y - num8;
      int num9 = (int) Main.tile[index3, index4].frameX / 18 / 2;
      int num10 = (int) Main.tile[index3, index4].frameY / 18 / 2;
      int num11 = (int) Main.tile[x, y].frameX / 18;
      int num12 = 0;
      while (num11 > 1)
      {
        num11 -= 2;
        ++num12;
      }
      int num13 = index3;
      int num14 = index3 + 2;
      int num15 = index4;
      int num16 = index4 + 2;
      int num17 = 0;
      for (int index5 = num13; index5 < num14; ++index5)
      {
        int num18 = 0;
        for (int index6 = num15; index6 < num16; ++index6)
        {
          if (!Main.tile[index5, index6].active() || (int) Main.tile[index5, index6].type != (int) type)
          {
            flag = true;
            break;
          }
          if ((int) Main.tile[index5, index6].frameX / 18 != num17 + num9 * 2 || (int) Main.tile[index5, index6].frameY / 18 != num18 + num10 * 2)
          {
            flag = true;
            break;
          }
          ++num18;
        }
        ++num17;
      }
      if (!flag)
      {
        if (type == (ushort) 85)
        {
          if (WorldGen.SolidTileAllowBottomSlope(index3, index4 + 2) && WorldGen.SolidTileAllowBottomSlope(index3 + 1, index4 + 2))
            num9 = num12;
          else
            flag = true;
        }
        else if (WorldGen.TopEdgeCanBeAttachedTo(index3, index4 + 2) && WorldGen.TopEdgeCanBeAttachedTo(index3 + 1, index4 + 2))
          num9 = 0;
        else if (WorldGen.BottomEdgeCanBeAttachedTo(index3, index4 - 1) && WorldGen.BottomEdgeCanBeAttachedTo(index3 + 1, index4 - 1))
          num9 = 1;
        else if (WorldGen.RightEdgeCanBeAttachedTo(index3 - 1, index4) && WorldGen.RightEdgeCanBeAttachedTo(index3 - 1, index4 + 1))
          num9 = 2;
        else if (WorldGen.LeftEdgeCanBeAttachedTo(index3 + 2, index4) && WorldGen.LeftEdgeCanBeAttachedTo(index3 + 2, index4 + 1))
          num9 = 3;
        else if (Main.tile[index3, index4].wall > (ushort) 0 && Main.tile[index3 + 1, index4].wall > (ushort) 0 && Main.tile[index3, index4 + 1].wall > (ushort) 0 && Main.tile[index3 + 1, index4 + 1].wall > (ushort) 0)
          num9 = 4;
        else
          flag = true;
      }
      if (flag)
      {
        if (type == (ushort) 395)
        {
          int key = TEItemFrame.Find(index3, index4);
          if (key != -1 && ((TEItemFrame) TileEntity.ByID[key]).item.stack > 0)
          {
            ((TEItemFrame) TileEntity.ByID[key]).DropItem();
            if (Main.netMode != 2)
              Main.LocalPlayer.InterruptItemUsageIfOverTile(395);
          }
        }
        WorldGen.destroyObject = true;
        for (int i = num13; i < num14; ++i)
        {
          for (int j = num15; j < num16; ++j)
          {
            if ((int) Main.tile[i, j].type == (int) type)
              WorldGen.KillTile(i, j);
          }
        }
        if (type != (ushort) 395)
          Sign.KillSign(index3, index4);
        if (type == (ushort) 85)
        {
          int Type = 321;
          if (num12 >= 6 && num12 <= 10)
            Type = 3229 + num12 - 6;
          else if (num12 >= 1 && num12 <= 5)
            Type = 1173 + num12 - 1;
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, Type);
          if (Main.netMode != 1 && WorldGen.genRand.Next(2) == 0 && NPC.CountNPCS(316) < 2)
          {
            int closest = (int) Player.FindClosest(new Vector2((float) (x * 16), (float) (y * 16)), 16, 16);
            if (Main.player[closest].ZoneGraveyard || !Main.dayTime || (double) y > Main.worldSurface)
              NPC.SpawnOnPlayer(closest, 316);
          }
        }
        else if (type == (ushort) 395)
        {
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index3, index4), index3 * 16, index4 * 16, 32, 32, 3270);
          TEItemFrame.Kill(index3, index4);
        }
        else if (type == (ushort) 425)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index3, index4), index3 * 16, index4 * 16, 32, 32, 3617);
        else if (type == (ushort) 573)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index3, index4), index3 * 16, index4 * 16, 32, 32, 4710);
        else if (type == (ushort) 511)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index3, index4), index3 * 16, index4 * 16, 32, 32, 4320);
        else if (type == (ushort) 510)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index3, index4), index3 * 16, index4 * 16, 32, 32, 4319);
        else
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 171);
        WorldGen.destroyObject = false;
      }
      else
      {
        int num19 = 36 * num9;
        for (int index7 = 0; index7 < 2; ++index7)
        {
          for (int index8 = 0; index8 < 2; ++index8)
          {
            Main.tile[index3 + index7, index4 + index8].active(true);
            Main.tile[index3 + index7, index4 + index8].type = type;
            Main.tile[index3 + index7, index4 + index8].frameX = (short) (num19 + 18 * index7);
            Main.tile[index3 + index7, index4 + index8].frameY = (short) (18 * index8 + num10 * 36);
          }
        }
      }
    }

    public static bool PlaceSign(int x, int y, ushort type, int Style = 0)
    {
      int num1 = x - 2;
      int num2 = x + 3;
      int num3 = y - 2;
      int num4 = y + 3;
      if (num1 < 0 || num2 > Main.maxTilesX || num3 < 0 || num4 > Main.maxTilesY)
        return false;
      for (int index1 = num1; index1 < num2; ++index1)
      {
        for (int index2 = num3; index2 < num4; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
        }
      }
      int index3 = x;
      int index4 = y;
      int num5 = 0;
      if (type == (ushort) 55 || type == (ushort) 425 || type == (ushort) 510 || type == (ushort) 511)
      {
        if (WorldGen.SolidTile2(x, y + 1) && WorldGen.SolidTile2(x + 1, y + 1))
        {
          --index4;
          num5 = 0;
        }
        else if (Main.tile[x, y - 1].nactive() && Main.tileSolid[(int) Main.tile[x, y - 1].type] && !Main.tileSolidTop[(int) Main.tile[x, y - 1].type] && Main.tile[x + 1, y - 1].nactive() && Main.tileSolid[(int) Main.tile[x + 1, y - 1].type] && !Main.tileSolidTop[(int) Main.tile[x + 1, y - 1].type])
          num5 = 1;
        else if (Main.tile[x - 1, y].nactive() && Main.tileSolid[(int) Main.tile[x - 1, y].type] && !Main.tileSolidTop[(int) Main.tile[x - 1, y].type] && !Main.tileNoAttach[(int) Main.tile[x - 1, y].type] && Main.tile[x - 1, y + 1].nactive() && Main.tileSolid[(int) Main.tile[x - 1, y + 1].type] && !Main.tileSolidTop[(int) Main.tile[x - 1, y + 1].type] && !Main.tileNoAttach[(int) Main.tile[x - 1, y + 1].type])
          num5 = 2;
        else if (Main.tile[x + 1, y].nactive() && Main.tileSolid[(int) Main.tile[x + 1, y].type] && !Main.tileSolidTop[(int) Main.tile[x + 1, y].type] && !Main.tileNoAttach[(int) Main.tile[x + 1, y].type] && Main.tile[x + 1, y + 1].nactive() && Main.tileSolid[(int) Main.tile[x + 1, y + 1].type] && !Main.tileSolidTop[(int) Main.tile[x + 1, y + 1].type] && !Main.tileNoAttach[(int) Main.tile[x + 1, y + 1].type])
        {
          --index3;
          num5 = 3;
        }
        else
        {
          if (Main.tile[index3, index4].wall <= (ushort) 0 || Main.tile[index3 + 1, index4].wall <= (ushort) 0 || Main.tile[index3, index4 + 1].wall <= (ushort) 0 || Main.tile[index3 + 1, index4 + 1].wall <= (ushort) 0)
            return false;
          num5 = 4;
        }
      }
      if (Main.tile[index3, index4].active() || Main.tile[index3 + 1, index4].active() || Main.tile[index3, index4 + 1].active() || Main.tile[index3 + 1, index4 + 1].active())
        return false;
      int num6 = 36 * num5;
      for (int index5 = 0; index5 < 2; ++index5)
      {
        for (int index6 = 0; index6 < 2; ++index6)
        {
          Main.tile[index3 + index5, index4 + index6].active(true);
          Main.tile[index3 + index5, index4 + index6].type = type;
          Main.tile[index3 + index5, index4 + index6].frameX = (short) (num6 + 18 * index5);
          Main.tile[index3 + index5, index4 + index6].frameY = (short) (18 * index6);
        }
      }
      return true;
    }

    public static bool Place2x2Horizontal(int x, int y, ushort type, int Style = 0)
    {
      int num1 = x - 2;
      int num2 = x + 3;
      int num3 = y - 2;
      int num4 = y + 3;
      if (num1 < 0 || num2 > Main.maxTilesX || num3 < 0 || num4 > Main.maxTilesY)
        return false;
      for (int index1 = num1; index1 < num2; ++index1)
      {
        for (int index2 = num3; index2 < num4; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
        }
      }
      int index3 = x;
      int num5 = y;
      if (!WorldGen.SolidTile2(x, y + 1) || !WorldGen.SolidTile2(x + 1, y + 1))
        return false;
      int index4 = num5 - 1;
      int num6 = Style;
      if (Main.tile[index3, index4].active() || Main.tile[index3 + 1, index4].active() || Main.tile[index3, index4 + 1].active() || Main.tile[index3 + 1, index4 + 1].active())
        return false;
      int num7 = 36 * num6;
      for (int index5 = 0; index5 < 2; ++index5)
      {
        for (int index6 = 0; index6 < 2; ++index6)
        {
          Main.tile[index3 + index5, index4 + index6].active(true);
          Main.tile[index3 + index5, index4 + index6].type = type;
          Main.tile[index3 + index5, index4 + index6].frameX = (short) (num7 + 18 * index5);
          Main.tile[index3 + index5, index4 + index6].frameY = (short) (18 * index6);
        }
      }
      return true;
    }

    public static Color paintColor(int color)
    {
      Color white = Color.White;
      int num = color;
      if (num == 1 || num == 13)
      {
        white.R = byte.MaxValue;
        white.G = (byte) 0;
        white.B = (byte) 0;
      }
      if (num == 2 || num == 14)
      {
        white.R = byte.MaxValue;
        white.G = (byte) 127;
        white.B = (byte) 0;
      }
      if (num == 3 || num == 15)
      {
        white.R = byte.MaxValue;
        white.G = byte.MaxValue;
        white.B = (byte) 0;
      }
      if (num == 4 || num == 16)
      {
        white.R = (byte) 127;
        white.G = byte.MaxValue;
        white.B = (byte) 0;
      }
      if (num == 5 || num == 17)
      {
        white.R = (byte) 0;
        white.G = byte.MaxValue;
        white.B = (byte) 0;
      }
      if (num == 6 || num == 18)
      {
        white.R = (byte) 0;
        white.G = byte.MaxValue;
        white.B = (byte) 127;
      }
      if (num == 7 || num == 19)
      {
        white.R = (byte) 0;
        white.G = byte.MaxValue;
        white.B = byte.MaxValue;
      }
      if (num == 8 || num == 20)
      {
        white.R = (byte) 0;
        white.G = (byte) 127;
        white.B = byte.MaxValue;
      }
      if (num == 9 || num == 21)
      {
        white.R = (byte) 0;
        white.G = (byte) 0;
        white.B = byte.MaxValue;
      }
      if (num == 10 || num == 22)
      {
        white.R = (byte) 127;
        white.G = (byte) 0;
        white.B = byte.MaxValue;
      }
      if (num == 11 || num == 23)
      {
        white.R = byte.MaxValue;
        white.G = (byte) 0;
        white.B = byte.MaxValue;
      }
      if (num == 12 || num == 24)
      {
        white.R = byte.MaxValue;
        white.G = (byte) 0;
        white.B = (byte) 127;
      }
      if (num == 25)
      {
        white.R = (byte) 75;
        white.G = (byte) 75;
        white.B = (byte) 75;
      }
      if (num == 26)
      {
        white.R = byte.MaxValue;
        white.G = byte.MaxValue;
        white.B = byte.MaxValue;
      }
      if (num == 27)
      {
        white.R = (byte) 175;
        white.G = (byte) 175;
        white.B = (byte) 175;
      }
      if (num == 28)
      {
        white.R = byte.MaxValue;
        white.G = (byte) 178;
        white.B = (byte) 125;
      }
      if (num == 29)
      {
        white.R = (byte) 25;
        white.G = (byte) 25;
        white.B = (byte) 25;
      }
      if (num == 30)
      {
        white.R = (byte) 200;
        white.G = (byte) 200;
        white.B = (byte) 200;
        white.A = (byte) 150;
      }
      return white;
    }

    public static Color coatingColor(int coating)
    {
      switch (coating)
      {
        case 1:
          return new Color(235, 170, (int) byte.MaxValue, (int) byte.MaxValue);
        case 2:
          return new Color(180, 245, (int) byte.MaxValue, (int) byte.MaxValue);
        default:
          return Color.Transparent;
      }
    }

    public static List<Color> coatingColors(Tile tile, bool block)
    {
      WorldGen._coatingColors.Clear();
      if (tile == null)
        return WorldGen._coatingColors;
      if (block && tile.fullbrightBlock() || !block && tile.fullbrightWall())
        WorldGen._coatingColors.Add(WorldGen.coatingColor(1));
      if (block && tile.invisibleBlock() || !block && tile.invisibleWall())
        WorldGen._coatingColors.Add(WorldGen.coatingColor(2));
      return WorldGen._coatingColors;
    }

    public static void paintEffect(int x, int y, byte color, byte oldColor)
    {
      int color1 = (int) color;
      if (color == (byte) 0)
        color1 = (int) oldColor;
      Color newColor = WorldGen.paintColor(color1);
      for (int index1 = 0; index1 < 10; ++index1)
      {
        int index2 = Dust.NewDust(new Vector2((float) (x * 16), (float) (y * 16)), 16, 16, 143, Alpha: 50, newColor: newColor);
        if (WorldGen.genRand.Next(2) == 0)
        {
          Main.dust[index2].noGravity = true;
          Main.dust[index2].scale *= 1.2f;
        }
        else
          Main.dust[index2].scale *= 0.5f;
      }
    }

    public static void paintCoatEffect(int x, int y, byte paintCoatId, List<Color> oldColors)
    {
      Color color = WorldGen.coatingColor((int) paintCoatId);
      for (int index1 = 0; index1 < 10; ++index1)
      {
        Color newColor = color;
        if (paintCoatId == (byte) 0 && oldColors.Count > 0)
          newColor = oldColors[Main.rand.Next(oldColors.Count)];
        int index2 = Dust.NewDust(new Vector2((float) (x * 16), (float) (y * 16)), 16, 16, 143, Alpha: 50, newColor: newColor);
        if (WorldGen.genRand.Next(2) == 0)
        {
          Main.dust[index2].noGravity = true;
          Main.dust[index2].scale *= 1.2f;
        }
        else
          Main.dust[index2].scale *= 0.5f;
      }
    }

    public static bool paintTile(int x, int y, byte color, bool broadCast = false)
    {
      Tile tile = Main.tile[x, y];
      if (tile == null || !tile.active())
        return false;
      byte oldColor = tile.color();
      if ((int) oldColor == (int) color)
        return false;
      WorldGen.paintEffect(x, y, color, oldColor);
      tile.color(color);
      if (broadCast)
        NetMessage.SendData(63, number: x, number2: ((float) y), number3: ((float) color));
      return true;
    }

    public static bool paintCoatTile(int x, int y, byte paintCoatId, bool broadcast = false)
    {
      Tile tile = Main.tile[x, y];
      if (tile == null || !tile.active())
        return false;
      List<Color> oldColors = WorldGen.coatingColors(tile, true);
      switch (paintCoatId)
      {
        case 0:
          if (!tile.fullbrightBlock() && !tile.invisibleBlock())
            return false;
          tile.fullbrightBlock(false);
          tile.invisibleBlock(false);
          WorldGen.SquareTileFrame(x, y, false);
          break;
        case 1:
          if (tile.fullbrightBlock())
            return false;
          tile.fullbrightBlock(true);
          break;
        case 2:
          if (tile.invisibleBlock())
            return false;
          tile.invisibleBlock(true);
          WorldGen.SquareTileFrame(x, y, false);
          break;
        default:
          return false;
      }
      if (broadcast)
        NetMessage.SendData(63, number: x, number2: ((float) y), number3: ((float) paintCoatId), number4: 1f);
      WorldGen.paintCoatEffect(x, y, paintCoatId, oldColors);
      return true;
    }

    public static bool paintCoatWall(int x, int y, byte paintCoatId, bool broadcast = false)
    {
      Tile tile = Main.tile[x, y];
      if (tile == null || tile.wall == (ushort) 0)
        return false;
      List<Color> oldColors = WorldGen.coatingColors(tile, false);
      switch (paintCoatId)
      {
        case 0:
          if (!tile.fullbrightWall() && !tile.invisibleWall())
            return false;
          tile.fullbrightWall(false);
          tile.invisibleWall(false);
          WorldGen.SquareWallFrame(x, y, false);
          break;
        case 1:
          if (tile.fullbrightWall())
            return false;
          tile.fullbrightWall(true);
          break;
        case 2:
          if (tile.invisibleWall())
            return false;
          tile.invisibleWall(true);
          WorldGen.SquareWallFrame(x, y, false);
          break;
        default:
          return false;
      }
      if (broadcast)
        NetMessage.SendData(64, number: x, number2: ((float) y), number3: ((float) paintCoatId), number4: 1f);
      WorldGen.paintCoatEffect(x, y, paintCoatId, oldColors);
      return true;
    }

    public static bool paintWall(int x, int y, byte color, bool broadCast = false)
    {
      Tile tile = Main.tile[x, y];
      if (tile == null || tile.wall == (ushort) 0)
        return false;
      byte oldColor = tile.wallColor();
      if ((int) oldColor == (int) color)
        return false;
      tile.wallColor(color);
      if (broadCast)
        NetMessage.SendData(64, number: x, number2: ((float) y), number3: ((float) color));
      WorldGen.paintEffect(x, y, color, oldColor);
      return true;
    }

    public static void Place3x3Wall(int x, int y, ushort type, int style)
    {
      int num1 = x - 1;
      int num2 = y - 1;
      bool flag = true;
      for (int index1 = num1; index1 < num1 + 3; ++index1)
      {
        for (int index2 = num2; index2 < num2 + 3; ++index2)
        {
          if (Main.tile[index1, index2].active() || Main.tile[index1, index2].wall == (ushort) 0)
          {
            flag = false;
            break;
          }
        }
      }
      if (!flag)
        return;
      int num3 = 0;
      for (; style > 35; style -= 36)
        ++num3;
      int num4 = style * 54;
      int num5 = num3 * 54;
      for (int index3 = num1; index3 < num1 + 3; ++index3)
      {
        for (int index4 = num2; index4 < num2 + 3; ++index4)
        {
          Main.tile[index3, index4].active(true);
          Main.tile[index3, index4].type = type;
          Main.tile[index3, index4].frameX = (short) (num4 + 18 * (index3 - num1));
          Main.tile[index3, index4].frameY = (short) (num5 + 18 * (index4 - num2));
        }
      }
    }

    public static void Check3x3Wall(int x, int y)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      Tile tile1 = Main.tile[x, y];
      if (tile1 == null)
        return;
      int type = (int) tile1.type;
      int num1 = 0;
      int num2 = 0;
      int num3 = (int) tile1.frameX / 18;
      while (num3 >= 3)
      {
        num3 -= 3;
        ++num1;
      }
      int num4 = x - num3;
      int num5 = (int) tile1.frameY / 18;
      while (num5 >= 3)
      {
        num5 -= 3;
        ++num2;
      }
      int num6 = y - num5;
      int num7 = num2 * 54;
      int num8 = num1 * 54;
      for (int index1 = num4; index1 < num4 + 3; ++index1)
      {
        for (int index2 = num6; index2 < num6 + 3; ++index2)
        {
          Tile tile2 = Main.tile[index1, index2];
          if (tile2 != null && ((int) tile2.type != type || !tile2.active() || tile2.wall <= (ushort) 0 || (int) tile2.frameX != num8 + (index1 - num4) * 18 || (int) tile2.frameY != num7 + (index2 - num6) * 18))
          {
            flag = true;
            break;
          }
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i = num4; i < num4 + 3; ++i)
      {
        for (int j = num6; j < num6 + 3; ++j)
        {
          if (Main.tile[i, j] != null && (int) Main.tile[i, j].type == type && Main.tile[i, j].active())
            WorldGen.KillTile(i, j);
        }
      }
      switch (type)
      {
        case 240:
          int num9 = num1 + num2 * 36;
          switch (num9)
          {
            case 18:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1419);
              break;
            case 19:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1420);
              break;
            case 20:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1427);
              break;
            case 21:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1428);
              break;
            case 33:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1574);
              break;
            case 34:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1575);
              break;
            case 35:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1576);
              break;
            case 36:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1855);
              break;
            case 37:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1856);
              break;
            case 38:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1960);
              break;
            case 39:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1961);
              break;
            case 40:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1962);
              break;
            case 54:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2489);
              break;
            case 55:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2589);
              break;
            case 56:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3357);
              break;
            case 57:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3358);
              break;
            case 58:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3359);
              break;
            case 59:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3595);
              break;
            case 60:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3867);
              break;
            case 61:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3866);
              break;
            case 62:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3868);
              break;
            case 69:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4660);
              break;
            case 70:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4723);
              break;
            case 71:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4724);
              break;
            case 72:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4783);
              break;
            case 73:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4958);
              break;
            case 74:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5087);
              break;
            case 75:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5108);
              break;
            case 92:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5388);
              break;
            default:
              if (num9 >= 76 && num9 <= 91)
              {
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5218 + num9 - 76);
                break;
              }
              if (num9 >= 63 && num9 <= 68)
              {
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4626 + num9 - 63);
                break;
              }
              if (num9 >= 41 && num9 <= 45)
              {
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2114 + num9 - 41);
                break;
              }
              if (num9 >= 46 && num9 <= 53)
              {
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2442 + num9 - 46);
                break;
              }
              if (num9 >= 22 && num9 <= 25)
              {
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1440 + num9 - 22);
                break;
              }
              if (num9 >= 26 && num9 <= 29)
              {
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1496 + num9 - 26);
                break;
              }
              if (num9 >= 30 && num9 <= 32)
              {
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1538 + num9 - 30);
                break;
              }
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1360 + num9);
              break;
          }
          break;
        case 440:
          int Type1 = -1;
          int Type2 = -1;
          switch (num1)
          {
            case 0:
              Type1 = 3644;
              Type2 = 1526;
              break;
            case 1:
              Type1 = 3645;
              Type2 = 1524;
              break;
            case 2:
              Type1 = 3646;
              Type2 = 1525;
              break;
            case 3:
              Type1 = 3647;
              Type2 = 1523;
              break;
            case 4:
              Type1 = 3648;
              Type2 = 1522;
              break;
            case 5:
              Type1 = 3649;
              Type2 = 1527;
              break;
            case 6:
              Type1 = 3650;
              Type2 = 3643;
              break;
          }
          if (Type1 != -1)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, Type1);
          if (Type2 != -1 && num2 == 1)
          {
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, Type2);
            break;
          }
          break;
      }
      WorldGen.destroyObject = false;
    }

    public static void Place2x3Wall(int x, int y, ushort type, int style)
    {
      int num1 = x;
      int num2 = y - 1;
      bool flag = true;
      for (int index1 = num1; index1 < num1 + 2; ++index1)
      {
        for (int index2 = num2; index2 < num2 + 3; ++index2)
        {
          if (Main.tile[index1, index2].active() || Main.tile[index1, index2].wall == (ushort) 0)
          {
            flag = false;
            break;
          }
        }
      }
      if (!flag)
        return;
      int num3 = style * 36;
      int num4 = 0;
      for (int index3 = num1; index3 < num1 + 2; ++index3)
      {
        for (int index4 = num2; index4 < num2 + 3; ++index4)
        {
          Main.tile[index3, index4].active(true);
          Main.tile[index3, index4].type = type;
          Main.tile[index3, index4].frameX = (short) (num3 + 18 * (index3 - num1));
          Main.tile[index3, index4].frameY = (short) (num4 + 18 * (index4 - num2));
        }
      }
    }

    public static void Check2x3Wall(int x, int y)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int type = (int) Main.tile[x, y].type;
      int num1 = 0;
      int num2 = (int) Main.tile[x, y].frameX / 18;
      while (num2 >= 2)
      {
        num2 -= 2;
        ++num1;
      }
      int num3 = x - num2;
      int num4 = y - (int) Main.tile[x, y].frameY / 18;
      int num5 = num1 * 36;
      for (int index1 = num3; index1 < num3 + 2; ++index1)
      {
        for (int index2 = num4; index2 < num4 + 3; ++index2)
        {
          if ((int) Main.tile[index1, index2].type != type || !Main.tile[index1, index2].active() || Main.tile[index1, index2].wall <= (ushort) 0 || (int) Main.tile[index1, index2].frameX != num5 + (index1 - num3) * 18 || (int) Main.tile[index1, index2].frameY != (index2 - num4) * 18)
          {
            flag = true;
            break;
          }
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i = num3; i < num3 + 2; ++i)
      {
        for (int j = num4; j < num4 + 3; ++j)
        {
          if ((int) Main.tile[i, j].type == type && Main.tile[i, j].active())
            WorldGen.KillTile(i, j);
        }
      }
      if (type == 245)
      {
        if (num1 >= 19 && num1 <= 28)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5248 + num1 - 19);
        else if (num1 >= 15 && num1 <= 18)
        {
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5247);
        }
        else
        {
          switch (num1)
          {
            case 5:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1495);
              break;
            case 6:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1577);
              break;
            case 7:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4638);
              break;
            case 8:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4639);
              break;
            case 9:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4659);
              break;
            case 10:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4726);
              break;
            case 11:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4727);
              break;
            case 12:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4728);
              break;
            case 13:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5086);
              break;
            case 14:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5246);
              break;
            default:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1474 + num1);
              break;
          }
        }
      }
      WorldGen.destroyObject = false;
    }

    public static void Place3x2Wall(int x, int y, ushort type, int style)
    {
      int num1 = x - 1;
      int num2 = y;
      bool flag = true;
      for (int index1 = num1; index1 < num1 + 3; ++index1)
      {
        for (int index2 = num2; index2 < num2 + 2; ++index2)
        {
          if (Main.tile[index1, index2].active() || Main.tile[index1, index2].wall == (ushort) 0)
          {
            flag = false;
            break;
          }
        }
      }
      if (!flag)
        return;
      int num3 = 0;
      int num4 = style * 36;
      for (int index3 = num1; index3 < num1 + 3; ++index3)
      {
        for (int index4 = num2; index4 < num2 + 2; ++index4)
        {
          Main.tile[index3, index4].active(true);
          Main.tile[index3, index4].type = type;
          Main.tile[index3, index4].frameX = (short) (num3 + 18 * (index3 - num1));
          Main.tile[index3, index4].frameY = (short) (num4 + 18 * (index4 - num2));
        }
      }
    }

    public static void Check3x2Wall(int x, int y)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int type = (int) Main.tile[x, y].type;
      int num1 = 0;
      int num2 = (int) Main.tile[x, y].frameY / 18;
      while (num2 >= 2)
      {
        num2 -= 2;
        ++num1;
      }
      int num3 = y - num2;
      int num4 = x - (int) Main.tile[x, y].frameX / 18;
      int num5 = num1 * 36;
      for (int index1 = num4; index1 < num4 + 3; ++index1)
      {
        for (int index2 = num3; index2 < num3 + 2; ++index2)
        {
          if ((int) Main.tile[index1, index2].type != type || !Main.tile[index1, index2].active() || Main.tile[index1, index2].wall <= (ushort) 0 || (int) Main.tile[index1, index2].frameY != num5 + (index2 - num3) * 18 || (int) Main.tile[index1, index2].frameX != (index1 - num4) * 18)
          {
            flag = true;
            break;
          }
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i = num4; i < num4 + 3; ++i)
      {
        for (int j = num3; j < num3 + 2; ++j)
        {
          if ((int) Main.tile[i, j].type == type && Main.tile[i, j].active())
            WorldGen.KillTile(i, j);
        }
      }
      if (type == 246)
      {
        switch (num1)
        {
          case 16:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1541);
            break;
          case 17:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1542);
            break;
          case 18:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1908);
            break;
          case 19:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4661);
            break;
          case 20:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4729);
            break;
          default:
            if (num1 >= 21 && num1 <= 36)
            {
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5258 + num1 - 21);
              break;
            }
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1479 + num1);
            break;
        }
      }
      WorldGen.destroyObject = false;
    }

    public static void Place4x3Wall(int x, int y, ushort type, int style)
    {
      int num1 = x - 1;
      int num2 = y - 1;
      bool flag = true;
      for (int index1 = num1; index1 < num1 + 4; ++index1)
      {
        for (int index2 = num2; index2 < num2 + 3; ++index2)
        {
          if (Main.tile[index1, index2].active() || Main.tile[index1, index2].wall == (ushort) 0)
          {
            flag = false;
            break;
          }
        }
      }
      if (!flag)
        return;
      int num3 = 0;
      int num4 = style * 54;
      for (int index3 = num1; index3 < num1 + 4; ++index3)
      {
        for (int index4 = num2; index4 < num2 + 3; ++index4)
        {
          Main.tile[index3, index4].active(true);
          Main.tile[index3, index4].type = type;
          Main.tile[index3, index4].frameX = (short) (num3 + 18 * (index3 - num1));
          Main.tile[index3, index4].frameY = (short) (num4 + 18 * (index4 - num2));
        }
      }
    }

    public static void Check4x3Wall(int x, int y)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int type = (int) Main.tile[x, y].type;
      int num1 = 0;
      int num2 = (int) Main.tile[x, y].frameY / 18;
      while (num2 >= 3)
      {
        num2 -= 3;
        ++num1;
      }
      int num3 = y - num2;
      int num4 = x - (int) Main.tile[x, y].frameX / 18;
      int num5 = num1 * 54;
      for (int index1 = num4; index1 < num4 + 4; ++index1)
      {
        for (int index2 = num3; index2 < num3 + 3; ++index2)
        {
          if ((int) Main.tile[index1, index2].type != type || !Main.tile[index1, index2].active() || Main.tile[index1, index2].wall <= (ushort) 0 || (int) Main.tile[index1, index2].frameY != num5 + (index2 - num3) * 18 || (int) Main.tile[index1, index2].frameX != (index1 - num4) * 18)
          {
            flag = true;
            break;
          }
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i = num4; i < num4 + 4; ++i)
      {
        for (int j = num3; j < num3 + 3; ++j)
        {
          if ((int) Main.tile[i, j].type == type && Main.tile[i, j].active())
            WorldGen.KillTile(i, j);
        }
      }
      if (type == 241)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1417);
      WorldGen.destroyObject = false;
    }

    public static void Place6x4Wall(int x, int y, ushort type, int style)
    {
      int num1 = x - 2;
      int num2 = y - 2;
      bool flag = true;
      for (int index1 = num1; index1 < num1 + 6; ++index1)
      {
        for (int index2 = num2; index2 < num2 + 4; ++index2)
        {
          if (Main.tile[index1, index2].active() || Main.tile[index1, index2].wall == (ushort) 0)
          {
            flag = false;
            break;
          }
        }
      }
      if (!flag)
        return;
      int num3 = 27;
      int num4 = style / num3 * 108;
      int num5 = style % num3 * 72;
      for (int index3 = num1; index3 < num1 + 6; ++index3)
      {
        for (int index4 = num2; index4 < num2 + 4; ++index4)
        {
          Main.tile[index3, index4].active(true);
          Main.tile[index3, index4].type = type;
          Main.tile[index3, index4].frameX = (short) (num4 + 18 * (index3 - num1));
          Main.tile[index3, index4].frameY = (short) (num5 + 18 * (index4 - num2));
        }
      }
    }

    public static void Check6x4Wall(int x, int y)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int type = (int) Main.tile[x, y].type;
      int num1 = (int) Main.tile[x, y].frameY / 18;
      int num2 = (int) Main.tile[x, y].frameX / 18;
      int num3 = 27 * (num2 / 6) + (num1 >> 2);
      int num4 = num1 % 4;
      int num5 = num2 % 6;
      int num6 = y - num4;
      int num7 = x - (int) Main.tile[x, y].frameX / 18 % 6;
      int num8 = num3 % 27 * 72;
      int num9 = num3 / 27 * 108;
      for (int index1 = num7; index1 < num7 + 6; ++index1)
      {
        for (int index2 = num6; index2 < num6 + 4; ++index2)
        {
          if ((int) Main.tile[index1, index2].type != type || !Main.tile[index1, index2].active() || Main.tile[index1, index2].wall <= (ushort) 0 || (int) Main.tile[index1, index2].frameY != num8 + (index2 - num6) * 18 || (int) Main.tile[index1, index2].frameX != num9 + (index1 - num7) * 18)
          {
            flag = true;
            break;
          }
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i = num7; i < num7 + 6; ++i)
      {
        for (int j = num6; j < num6 + 4; ++j)
        {
          if ((int) Main.tile[i, j].type == type && Main.tile[i, j].active())
            WorldGen.KillTile(i, j);
        }
      }
      if (type == 242)
      {
        switch (num3)
        {
          case 30:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2995);
            break;
          case 62:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5274);
            break;
          case 63:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5308);
            break;
          case 64:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5310);
            break;
          case 65:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5389);
            break;
          default:
            if (num3 >= 50 && num3 <= 61)
            {
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5234 + num3 - 50);
              break;
            }
            if (num3 >= 46 && num3 <= 49)
            {
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5121 + num3 - 46);
              break;
            }
            switch (num3)
            {
              case 43:
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4658);
                break;
              case 44:
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4725);
                break;
              case 45:
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5085);
                break;
              default:
                if (num3 >= 37 && num3 <= 42)
                {
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4632 + num3 - 37);
                  break;
                }
                if (num3 >= 31 && num3 <= 35)
                {
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3055 + num3 - 31);
                  break;
                }
                if (num3 >= 27 && num3 <= 29)
                {
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2865 + num3 - 27);
                  break;
                }
                if (num3 == 36)
                {
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3596);
                  break;
                }
                if (num3 == 26)
                {
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2497);
                  break;
                }
                if (num3 == 25)
                {
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2495);
                  break;
                }
                if (num3 >= 22)
                {
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2281 + num3 - 22);
                  break;
                }
                if (num3 >= 17)
                {
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1846 + num3 - 17);
                  break;
                }
                if (num3 == 16)
                {
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1573);
                  break;
                }
                if (num3 >= 13)
                {
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1500 + num3 - 13);
                  break;
                }
                if (num3 >= 6)
                {
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1433 + num3 - 6);
                  break;
                }
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1421 + num3);
                break;
            }
            break;
        }
      }
      WorldGen.destroyObject = false;
    }

    private static int RollRandomSeaShellStyle()
    {
      int num = WorldGen.genRand.Next(2);
      if (WorldGen.genRand.Next(10) == 0)
        num = 2;
      if (WorldGen.genRand.Next(10) == 0)
        num = 3;
      if (WorldGen.genRand.Next(50) == 0)
        num = 4;
      return num;
    }

    public static void Place1x1(int x, int y, int type, int style = 0)
    {
      Tile tile = Main.tile[x, y];
      if (Main.tile[x, y] == null)
      {
        tile = new Tile();
        Main.tile[x, y] = tile;
      }
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (type == 324)
      {
        if (!WorldGen.SolidTile2(x, y + 1) && (!Main.tile[x, y + 1].nactive() || !Main.tileTable[(int) Main.tile[x, y + 1].type]))
          return;
        tile.active(true);
        tile.type = (ushort) type;
        tile.frameX = (short) (22 * WorldGen.genRand.Next(3));
        tile.frameY = (short) (22 * style);
      }
      else
      {
        if (!WorldGen.SolidTile2(x, y + 1) || tile.active())
          return;
        tile.active(true);
        tile.type = (ushort) type;
        switch (type)
        {
          case 36:
          case 144:
          case 239:
            tile.frameX = (short) (style * 18);
            tile.frameY = (short) 0;
            break;
          case 324:
            tile.frameX = (short) (22 * WorldGen.RollRandomSeaShellStyle());
            tile.frameY = (short) (22 * style);
            break;
          default:
            tile.frameY = (short) (style * 18);
            break;
        }
      }
    }

    public static void Check1x1(int x, int y, int type)
    {
      if (Main.tile[x, y + 1] == null)
        return;
      if (!WorldGen.SolidTileAllowBottomSlope(x, y + 1))
        WorldGen.KillTile(x, y);
      if (type != 624 || WorldGen.HasValidGroundForAbigailsFlowerBelowSpot(x, y))
        return;
      WorldGen.KillTile(x, y);
    }

    public static void CheckGolf1x1(int x, int y, int type)
    {
      Tile tile = Main.tile[x, y];
      bool flag = false;
      if ((int) tile.frameX % 18 != 0)
        flag = true;
      if ((int) tile.frameY % 18 != 0)
        flag = true;
      if (!WorldGen.SolidTileAllowBottomSlope(x, y + 1))
        flag = true;
      if (!flag)
        return;
      WorldGen.KillTile(x, y);
    }

    public static void CheckLogicTiles(int x, int y, int type)
    {
      if (type == 419)
      {
        Tile tile = Main.tile[x, y + 1];
        if (tile != null && (!tile.active() || tile.type != (ushort) 420 && tile.type != (ushort) 419))
        {
          WorldGen.KillTile(x, y);
          return;
        }
      }
      Tile tile1 = Main.tile[x, y];
      bool flag = false;
      if ((int) tile1.frameX % 18 != 0)
        flag = true;
      if ((int) tile1.frameY % 18 != 0)
        flag = true;
      if (!flag)
        return;
      WorldGen.KillTile(x, y);
    }

    public static void PlaceLogicTiles(int x, int y, int type, int style = 0)
    {
      Tile tile = Main.tile[x, y];
      if (Main.tile[x, y] == null)
      {
        tile = new Tile();
        Main.tile[x, y] = tile;
      }
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (type == 419)
      {
        if (!Main.tile[x, y + 1].active() || Main.tile[x, y + 1].type != (ushort) 419 && Main.tile[x, y + 1].type != (ushort) 420)
          return;
        tile.active(true);
        tile.type = (ushort) type;
        tile.frameX = (short) (style * 18);
        tile.frameY = (short) 0;
      }
      else
      {
        if (tile.active())
          return;
        tile.active(true);
        tile.type = (ushort) type;
        tile.frameX = (short) 0;
        tile.frameY = (short) (18 * style);
      }
    }

    public static void PlaceOnTable1x1(int x, int y, int type, int style = 0)
    {
      bool flag = false;
      if (Main.tile[x, y] == null)
        Main.tile[x, y] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (!Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && Main.tileTable[(int) Main.tile[x, y + 1].type])
        flag = true;
      if (type == 78 && !Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && Main.tileSolid[(int) Main.tile[x, y + 1].type] && !Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == (byte) 0)
        flag = true;
      if (!flag)
        return;
      Main.tile[x, y].active(true);
      Main.tile[x, y].type = (ushort) type;
      if (type == 33)
      {
        Main.tile[x, y].frameX = (short) 0;
        Main.tile[x, y].frameY = (short) (style * 22);
      }
      else
      {
        Main.tile[x, y].frameX = (short) (style * 18);
        Main.tile[x, y].frameY = (short) 0;
      }
      if (type != 50)
        return;
      Main.tile[x, y].frameX = (short) (18 * WorldGen.genRand.Next(5));
    }

    public static bool PlaceAlch(int x, int y, int style)
    {
      if (Main.tile[x, y] == null)
        Main.tile[x, y] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (!Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && !Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == (byte) 0)
      {
        bool flag = false;
        switch (style)
        {
          case 0:
            if (Main.tile[x, y + 1].type != (ushort) 2 && Main.tile[x, y + 1].type != (ushort) 477 && Main.tile[x, y + 1].type != (ushort) 492 && Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380 && Main.tile[x, y + 1].type != (ushort) 109)
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0)
            {
              flag = true;
              break;
            }
            break;
          case 1:
            if (Main.tile[x, y + 1].type != (ushort) 60 && Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380)
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0)
            {
              flag = true;
              break;
            }
            break;
          case 2:
            if (Main.tile[x, y + 1].type != (ushort) 0 && Main.tile[x, y + 1].type != (ushort) 59 && Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380)
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0)
            {
              flag = true;
              break;
            }
            break;
          case 3:
            if (Main.tile[x, y + 1].type != (ushort) 661 && Main.tile[x, y + 1].type != (ushort) 662 && Main.tile[x, y + 1].type != (ushort) 203 && Main.tile[x, y + 1].type != (ushort) 199 && Main.tile[x, y + 1].type != (ushort) 23 && Main.tile[x, y + 1].type != (ushort) 25 && Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380)
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0)
            {
              flag = true;
              break;
            }
            break;
          case 4:
            if (Main.tile[x, y + 1].type != (ushort) 53 && Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380 && Main.tile[x, y + 1].type != (ushort) 116)
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
          case 5:
            if (Main.tile[x, y + 1].type != (ushort) 57 && Main.tile[x, y + 1].type != (ushort) 633 && Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380)
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && !Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
          case 6:
            if (Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380 && Main.tile[x, y + 1].type != (ushort) 147 && Main.tile[x, y + 1].type != (ushort) 161 && Main.tile[x, y + 1].type != (ushort) 163 && Main.tile[x, y + 1].type != (ushort) 164 && Main.tile[x, y + 1].type != (ushort) 200)
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
        }
        if (!flag)
        {
          Main.tile[x, y].active(true);
          Main.tile[x, y].type = (ushort) 82;
          Main.tile[x, y].frameX = (short) (18 * style);
          Main.tile[x, y].frameY = (short) 0;
          return true;
        }
      }
      return false;
    }

    public static void GrowSpike(int i, int j, ushort spikeType, ushort landType)
    {
      int num1 = -1;
      switch (landType)
      {
        case 23:
          num1 = 661;
          break;
        case 199:
          num1 = 662;
          break;
      }
      int index1 = i;
      int index2 = j;
      int num2 = 0;
      if (Main.tile[index1 + 1, index2].active() && (int) Main.tile[index1 + 1, index2].type == (int) spikeType)
        ++num2;
      if (Main.tile[index1 - 1, index2].active() && (int) Main.tile[index1 - 1, index2].type == (int) spikeType)
        ++num2;
      if (Main.tile[index1, index2 + 1].active() && (int) Main.tile[index1, index2 + 1].type == (int) spikeType)
        ++num2;
      if (Main.tile[index1, index2 - 1].active() && (int) Main.tile[index1, index2 - 1].type == (int) spikeType)
        ++num2;
      if (num2 >= 3 && (int) Main.tile[i, j].type != (int) landType && (int) Main.tile[i, j].type != num1)
        return;
      switch (WorldGen.genRand.Next(4))
      {
        case 0:
          --index2;
          break;
        case 1:
          ++index2;
          break;
        case 2:
          --index1;
          break;
        case 3:
          ++index1;
          break;
      }
      if (Main.tile[index1, index2].active())
        return;
      int num3 = 0;
      if (Main.tile[index1 + 1, index2].active() && (int) Main.tile[index1 + 1, index2].type == (int) spikeType)
        ++num3;
      if (Main.tile[index1 - 1, index2].active() && (int) Main.tile[index1 - 1, index2].type == (int) spikeType)
        ++num3;
      if (Main.tile[index1, index2 + 1].active() && (int) Main.tile[index1, index2 + 1].type == (int) spikeType)
        ++num3;
      if (Main.tile[index1, index2 - 1].active() && (int) Main.tile[index1, index2 - 1].type == (int) spikeType)
        ++num3;
      if (num3 >= 2)
        return;
      int num4 = 7;
      int num5 = index1 - num4;
      int num6 = index1 + num4;
      int num7 = index2 - num4;
      int num8 = index2 + num4;
      bool flag = false;
      for (int index3 = num5; index3 < num6; ++index3)
      {
        for (int index4 = num7; index4 < num8; ++index4)
        {
          if (Math.Abs(index3 - index1) * 2 + Math.Abs(index4 - index2) < 9 && Main.tile[index3, index4].active() && ((int) Main.tile[index3, index4].type == (int) landType || (int) Main.tile[index3, index4].type == num1) && Main.tile[index3, index4 - 1].active() && (int) Main.tile[index3, index4 - 1].type == (int) spikeType && Main.tile[index3, index4 - 1].liquid == (byte) 0)
          {
            flag = true;
            break;
          }
        }
      }
      if (!flag)
        return;
      Main.tile[index1, index2].type = spikeType;
      Main.tile[index1, index2].active(true);
      Main.tile[index1, index2].CopyPaintAndCoating(Main.tile[i, j]);
      WorldGen.SquareTileFrame(index1, index2);
      if (Main.netMode != 2)
        return;
      NetMessage.SendTileSquare(-1, index1, index2, 1);
    }

    private static bool GrowMoreVines(int x, int y)
    {
      if (!WorldGen.InWorld(x, y, 30))
        return false;
      int num1 = 4;
      int num2 = 6;
      int num3 = 10;
      int num4 = 60;
      int num5 = 0;
      int num6 = y;
      if (Main.tile[x, y].type == (ushort) 528)
        num4 /= 5;
      for (int index1 = x - num1; index1 <= x + num1; ++index1)
      {
        for (int index2 = num6 - num2; index2 <= num6 + num3; ++index2)
        {
          if (TileID.Sets.IsVine[(int) Main.tile[index1, index2].type])
          {
            ++num5;
            if (index2 > y && Collision.CanHitLine(new Vector2((float) (x * 16), (float) (y * 16)), 1, 1, new Vector2((float) (index1 * 16), (float) (index2 * 16)), 1, 1))
            {
              if (Main.tile[index1, index2].type == (ushort) 528)
                num5 += (index2 - y) * 20;
              else
                num5 += (index2 - y) * 2;
            }
            if (num5 > num4)
              return false;
          }
        }
      }
      return true;
    }

    private static void GrowGlowTulips()
    {
      int num1 = Main.maxTilesX <= 4200 ? 0 : (Main.maxTilesX <= 6400 ? 1 : 2);
      int minValue = 100;
      int maxValue = 300;
      int num2;
      switch (num1)
      {
        case 1:
          num2 = 4;
          break;
        case 2:
          num2 = 6;
          break;
        default:
          num2 = 2;
          break;
      }
      int num3 = 0;
      int num4 = 10000;
      int num5 = (int) ((double) num4 * 0.75);
      while (num3 < num2)
      {
        --num4;
        if (num4 <= 0)
          break;
        if (WorldGen.TryGrowingGlowTulip(num3 < num2 / 2 || num4 > num5 && WorldGen.genRand.Next(2) == 0 ? WorldGen.genRand.Next(minValue, maxValue) : WorldGen.genRand.Next(Main.maxTilesX - maxValue, Main.maxTilesX - minValue), !WorldGen.remixWorldGen ? WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 200) : WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 350)))
          ++num3;
      }
    }

    private static void MatureTheHerbPlants()
    {
      for (int i = 10; i < Main.maxTilesX - 10; ++i)
      {
        for (int index = 10; index < Main.maxTilesY - 10; ++index)
        {
          if ((double) index > Main.rockLayer && (Main.tile[i, index + 1].type == (ushort) 59 || Main.tile[i, index + 1].type == (ushort) 0) && WorldGen.SolidTile(i, index + 1) && !Main.tile[i, index].active() && Main.tile[i, index].liquid == (byte) 0 && WorldGen.genRand.Next(25) == 0)
          {
            Main.tile[i, index].active(true);
            Main.tile[i, index].type = (ushort) 82;
            Main.tile[i, index].frameX = (short) 36;
            Main.tile[i, index].frameY = (short) 0;
          }
          if (Main.tile[i, index].type == (ushort) 82 && WorldGen.genRand.Next(3) == 0)
          {
            Main.tile[i, index].type = (ushort) 83;
            if (Main.tile[i, index].frameX == (short) 36 && WorldGen.genRand.Next(2) == 0)
              Main.tile[i, index].type = (ushort) 84;
            if (Main.tile[i, index].frameX == (short) 108 && WorldGen.genRand.Next(3) == 0)
              Main.tile[i, index].type = (ushort) 84;
          }
        }
      }
    }

    public static void GrowAlch(int x, int y)
    {
      if (!Main.tile[x, y].active())
        return;
      if (Main.tile[x, y].liquid > (byte) 0)
      {
        int num = (int) Main.tile[x, y].frameX / 18;
        if ((!Main.tile[x, y].lava() || num != 5) && (Main.tile[x, y].liquidType() != (byte) 0 || num != 1 && num != 4))
        {
          WorldGen.KillTile(x, y);
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, x, y);
          WorldGen.SquareTileFrame(x, y);
        }
      }
      if (Main.tile[x, y].type == (ushort) 82)
      {
        if (WorldGen.genRand.Next(50) == 0)
        {
          bool flag = false;
          if (Main.tile[x, y].frameX == (short) 108)
          {
            if (WorldGen.genRand.Next(2) == 0)
              flag = true;
          }
          else
            flag = true;
          if (!flag)
            return;
          Main.tile[x, y].type = (ushort) 83;
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, x, y);
          WorldGen.SquareTileFrame(x, y);
        }
        else if (Main.dayTime && Main.tile[x, y].type == (ushort) 82 && Main.tile[x, y].frameX == (short) 0 && WorldGen.genRand.Next(50) == 0)
        {
          Main.tile[x, y].type = (ushort) 83;
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, x, y);
          WorldGen.SquareTileFrame(x, y);
        }
        else if (!Main.dayTime && Main.tile[x, y].type == (ushort) 82 && Main.tile[x, y].frameX == (short) 18 && WorldGen.genRand.Next(50) == 0)
        {
          Main.tile[x, y].type = (ushort) 83;
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, x, y);
          WorldGen.SquareTileFrame(x, y);
        }
        else if (Main.raining && Main.tile[x, y].type == (ushort) 82 && Main.tile[x, y].frameX == (short) 72 && WorldGen.genRand.Next(50) == 0)
        {
          Main.tile[x, y].type = (ushort) 83;
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, x, y);
          WorldGen.SquareTileFrame(x, y);
        }
        else if ((double) y > Main.worldSurface && Main.tile[x, y].type == (ushort) 82 && Main.tile[x, y].frameX == (short) 36 && WorldGen.genRand.Next(50) == 0)
        {
          Main.tile[x, y].type = (ushort) 83;
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, x, y);
          WorldGen.SquareTileFrame(x, y);
        }
        else
        {
          if (y <= Main.maxTilesY - 200 || Main.tile[x, y].type != (ushort) 82 || Main.tile[x, y].frameX != (short) 90 || WorldGen.genRand.Next(50) != 0)
            return;
          Main.tile[x, y].type = (ushort) 83;
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, x, y);
          WorldGen.SquareTileFrame(x, y);
        }
      }
      else if (Main.tile[x, y].frameX == (short) 36 && WorldGen.genRand.Next(3) != 0)
      {
        if (Main.tile[x, y].type == (ushort) 83)
        {
          if (WorldGen.genRand.Next(2) != 0)
            return;
          Main.tile[x, y].type = (ushort) 84;
          if (Main.netMode != 2)
            return;
          NetMessage.SendTileSquare(-1, x, y);
        }
        else
        {
          if (Main.tile[x, y].type != (ushort) 84 && WorldGen.genRand.Next(5) != 0)
            return;
          Main.tile[x, y].type = (ushort) 83;
          if (Main.netMode != 2)
            return;
          NetMessage.SendTileSquare(-1, x, y);
        }
      }
      else
      {
        if (Main.tile[x, y].frameX != (short) 108 || Main.tile[x, y].type != (ushort) 83 || WorldGen.genRand.Next(30) != 0)
          return;
        Main.tile[x, y].type = (ushort) 84;
        if (Main.netMode == 2)
          NetMessage.SendTileSquare(-1, x, y);
        WorldGen.SquareTileFrame(x, y);
      }
    }

    public static void PlantAlch()
    {
      int index1 = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
      int index2 = !Main.remixWorld ? (WorldGen.genRand.Next(40) != 0 ? (WorldGen.genRand.Next(10) != 0 ? WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 20) : WorldGen.genRand.Next(20, Main.maxTilesY - 20)) : WorldGen.genRand.Next((int) (Main.rockLayer + (double) Main.maxTilesY) / 2, Main.maxTilesY - 20)) : WorldGen.genRand.Next(20, Main.maxTilesY - 20);
      while (index2 < Main.maxTilesY - 20 && !Main.tile[index1, index2].active())
        ++index2;
      if (!Main.tile[index1, index2].nactive() || Main.tile[index1, index2 - 1].active() || Main.tile[index1, index2 - 1].liquid != (byte) 0)
        return;
      int num1 = 15;
      int num2 = 5;
      int num3 = 0;
      int num4 = (int) ((double) num1 * ((double) Main.maxTilesX / 4200.0));
      int num5 = Utils.Clamp<int>(index1 - num4, 4, Main.maxTilesX - 4);
      int num6 = Utils.Clamp<int>(index1 + num4, 4, Main.maxTilesX - 4);
      int num7 = Utils.Clamp<int>(index2 - num4, 4, Main.maxTilesY - 4);
      int num8 = Utils.Clamp<int>(index2 + num4, 4, Main.maxTilesY - 4);
      for (int index3 = num5; index3 <= num6; ++index3)
      {
        for (int index4 = num7; index4 <= num8; ++index4)
        {
          if (Main.tileAlch[(int) Main.tile[index3, index4].type])
            ++num3;
        }
      }
      if (num3 >= num2)
        return;
      if (Main.tile[index1, index2].type == (ushort) 2 || Main.tile[index1, index2].type == (ushort) 109)
        WorldGen.PlaceAlch(index1, index2 - 1, 0);
      if (Main.tile[index1, index2].type == (ushort) 60)
        WorldGen.PlaceAlch(index1, index2 - 1, 1);
      if (Main.tile[index1, index2].type == (ushort) 0 || Main.tile[index1, index2].type == (ushort) 59)
        WorldGen.PlaceAlch(index1, index2 - 1, 2);
      if (Main.tile[index1, index2].type == (ushort) 23 || Main.tile[index1, index2].type == (ushort) 661 || Main.tile[index1, index2].type == (ushort) 25 || Main.tile[index1, index2].type == (ushort) 203 || Main.tile[index1, index2].type == (ushort) 199 || Main.tile[index1, index2].type == (ushort) 662)
        WorldGen.PlaceAlch(index1, index2 - 1, 3);
      if ((Main.tile[index1, index2].type == (ushort) 53 || Main.tile[index1, index2].type == (ushort) 116) && index1 >= WorldGen.beachDistance && index1 <= Main.maxTilesX - WorldGen.beachDistance)
        WorldGen.PlaceAlch(index1, index2 - 1, 4);
      if (Main.tile[index1, index2].type == (ushort) 57 || Main.tile[index1, index2].type == (ushort) 633)
        WorldGen.PlaceAlch(index1, index2 - 1, 5);
      if (Main.tile[index1, index2].type == (ushort) 147 || Main.tile[index1, index2].type == (ushort) 163 || Main.tile[index1, index2].type == (ushort) 164 || Main.tile[index1, index2].type == (ushort) 161 || Main.tile[index1, index2].type == (ushort) 200)
        WorldGen.PlaceAlch(index1, index2 - 1, 6);
      if (!Main.tile[index1, index2 - 1].active() || Main.netMode != 2)
        return;
      NetMessage.SendTileSquare(-1, index1, index2 - 1);
    }

    public static void CheckAlch(int x, int y)
    {
      if (Main.tile[x, y] == null)
        Main.tile[x, y] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      bool flag = false;
      if (!Main.tile[x, y + 1].nactive())
        flag = true;
      if (Main.tile[x, y + 1].halfBrick())
        flag = true;
      int num = (int) Main.tile[x, y].frameX / 18;
      Main.tile[x, y].frameY = (short) 0;
      if (!flag)
      {
        switch (num)
        {
          case 0:
            if (Main.tile[x, y + 1].type != (ushort) 109 && Main.tile[x, y + 1].type != (ushort) 2 && Main.tile[x, y + 1].type != (ushort) 477 && Main.tile[x, y + 1].type != (ushort) 492 && Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380)
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
          case 1:
            if (Main.tile[x, y + 1].type != (ushort) 60 && Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380)
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
          case 2:
            if (Main.tile[x, y + 1].type != (ushort) 0 && Main.tile[x, y + 1].type != (ushort) 59 && Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380)
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
          case 3:
            if (Main.tile[x, y + 1].type != (ushort) 661 && Main.tile[x, y + 1].type != (ushort) 662 && Main.tile[x, y + 1].type != (ushort) 199 && Main.tile[x, y + 1].type != (ushort) 203 && Main.tile[x, y + 1].type != (ushort) 23 && Main.tile[x, y + 1].type != (ushort) 25 && Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380)
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
          case 4:
            if (Main.tile[x, y + 1].type != (ushort) 53 && Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380 && Main.tile[x, y + 1].type != (ushort) 116)
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
          case 5:
            if (Main.tile[x, y + 1].type != (ushort) 57 && Main.tile[x, y + 1].type != (ushort) 633 && Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380)
              flag = true;
            if (Main.tile[x, y].type != (ushort) 82 && Main.tile[x, y].lava() && Main.netMode != 1)
            {
              if (Main.tile[x, y].liquid > (byte) 16)
              {
                if (Main.tile[x, y].type == (ushort) 83)
                {
                  Main.tile[x, y].type = (ushort) 84;
                  if (Main.netMode == 2)
                  {
                    NetMessage.SendTileSquare(-1, x, y);
                    break;
                  }
                  break;
                }
                break;
              }
              if (Main.tile[x, y].type == (ushort) 84)
              {
                Main.tile[x, y].type = (ushort) 83;
                if (Main.netMode == 2)
                {
                  NetMessage.SendTileSquare(-1, x, y);
                  break;
                }
                break;
              }
              break;
            }
            break;
          case 6:
            if (Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380 && Main.tile[x, y + 1].type != (ushort) 147 && Main.tile[x, y + 1].type != (ushort) 161 && Main.tile[x, y + 1].type != (ushort) 163 && Main.tile[x, y + 1].type != (ushort) 164 && Main.tile[x, y + 1].type != (ushort) 200)
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
        }
      }
      if (!flag)
        return;
      WorldGen.KillTile(x, y);
    }

    public static void CheckBanner(int x, int j, byte type)
    {
      if (WorldGen.destroyObject)
        return;
      int num1 = (int) Main.tile[x, j].frameY / 18;
      int num2 = 0;
      while (num1 >= 3)
      {
        num1 -= 3;
        ++num2;
      }
      int num3 = j - num1;
      int frameX = (int) Main.tile[x, j].frameX;
      bool flag1 = false;
      for (int index = 0; index < 3; ++index)
      {
        if (Main.tile[x, num3 + index] == null)
          Main.tile[x, num3 + index] = new Tile();
        if (!Main.tile[x, num3 + index].active())
          flag1 = true;
        else if ((int) Main.tile[x, num3 + index].type != (int) type)
          flag1 = true;
        else if ((int) Main.tile[x, num3 + index].frameY != index * 18 + num2 * 18 * 3)
          flag1 = true;
        else if ((int) Main.tile[x, num3 + index].frameX != frameX)
          flag1 = true;
      }
      if (Main.tile[x, num3 - 1] == null)
        Main.tile[x, num3 - 1] = new Tile();
      Tile tile = Main.tile[x, num3 - 1];
      if (!tile.nactive())
        flag1 = true;
      bool flag2 = ((tile.topSlope() || tile.halfBrick() ? 1 : (Main.tileSolid[(int) tile.type] ? 1 : 0)) & (!Main.tileSolidTop[(int) tile.type] ? (true ? 1 : 0) : (!TileID.Sets.Platforms[(int) tile.type] ? (false ? 1 : 0) : (tile.halfBrick() ? (true ? 1 : 0) : (tile.topSlope() ? 1 : 0))))) != 0 && !TileID.Sets.NotReallySolid[(int) tile.type] && !tile.bottomSlope();
      if (TileID.Sets.Platforms[(int) tile.type] || tile.type == (ushort) 380)
        flag2 = true;
      if (!flag2)
        flag1 = true;
      if (!flag1)
        return;
      WorldGen.destroyObject = true;
      for (int index = 0; index < 3; ++index)
      {
        if ((int) Main.tile[x, num3 + index].type == (int) type)
          WorldGen.KillTile(x, num3 + index);
      }
      if (type == (byte) 91)
      {
        int num4 = frameX / 18 + num2 * 111;
        if (num4 == 310)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 5352);
        else if (num4 >= 297)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 4668 + num4);
        else if (num4 >= 295)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 4392 + num4);
        else if (num4 >= 294)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 4602);
        else if (num4 >= 288)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 4253 + num4);
        else if (num4 >= 278)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 3559 + num4);
        else if (num4 >= 273)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 3516 + num4);
        else if (num4 >= 272)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 3780);
        else if (num4 >= 270)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 3323 + num4);
        else if (num4 >= 207)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 3183 + num4);
        else if (num4 >= 109)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 2788 + num4);
        else if (num4 >= 22)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 1593 + num4);
        else if (num4 >= 10 && num4 <= 15)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 1441 + num4);
        else if (num4 >= 16 && num4 <= 21)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 1448 + num4);
        else if (num4 >= 7 && num4 <= 9)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 838 + num4);
        else if (num4 >= 4 && num4 <= 6)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 785 + num4);
        else
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num3 + 1), x * 16, (num3 + 1) * 16, 32, 32, 337 + num4);
      }
      WorldGen.destroyObject = false;
    }

    public static void PlaceBanner(int x, int y, ushort type, int style = 0)
    {
      int num1 = style * 18;
      int num2 = 0;
      if (style >= 90)
      {
        num1 -= 1620;
        num2 += 54;
      }
      if (Main.tile[x, y - 1] == null)
        Main.tile[x, y - 1] = new Tile();
      if (Main.tile[x, y] == null)
        Main.tile[x, y] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (Main.tile[x, y + 2] == null)
        Main.tile[x, y + 2] = new Tile();
      if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[(int) Main.tile[x, y - 1].type] || Main.tileSolidTop[(int) Main.tile[x, y - 1].type] || Main.tile[x, y].active() || Main.tile[x, y + 1].active() || Main.tile[x, y + 2].active())
        return;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) num2;
      Main.tile[x, y].frameX = (short) num1;
      Main.tile[x, y].type = type;
      Main.tile[x, y + 1].active(true);
      Main.tile[x, y + 1].frameY = (short) (num2 + 18);
      Main.tile[x, y + 1].frameX = (short) num1;
      Main.tile[x, y + 1].type = type;
      Main.tile[x, y + 2].active(true);
      Main.tile[x, y + 2].frameY = (short) (num2 + 36);
      Main.tile[x, y + 2].frameX = (short) num1;
      Main.tile[x, y + 2].type = type;
    }

    public static void PlaceMan(int i, int j, int dir)
    {
      for (int index1 = i; index1 <= i + 1; ++index1)
      {
        for (int index2 = j - 2; index2 <= j; ++index2)
        {
          if (Main.tile[index1, index2].active())
            return;
        }
      }
      if (!WorldGen.SolidTile2(i, j + 1) || !WorldGen.SolidTile2(i + 1, j + 1))
        return;
      byte num = 0;
      if (dir == 1)
        num = (byte) 36;
      Main.tile[i, j - 2].active(true);
      Main.tile[i, j - 2].frameY = (short) 0;
      Main.tile[i, j - 2].frameX = (short) num;
      Main.tile[i, j - 2].type = (ushort) 128;
      Main.tile[i, j - 1].active(true);
      Main.tile[i, j - 1].frameY = (short) 18;
      Main.tile[i, j - 1].frameX = (short) num;
      Main.tile[i, j - 1].type = (ushort) 128;
      Main.tile[i, j].active(true);
      Main.tile[i, j].frameY = (short) 36;
      Main.tile[i, j].frameX = (short) num;
      Main.tile[i, j].type = (ushort) 128;
      Main.tile[i + 1, j - 2].active(true);
      Main.tile[i + 1, j - 2].frameY = (short) 0;
      Main.tile[i + 1, j - 2].frameX = (short) (byte) (18U + (uint) num);
      Main.tile[i + 1, j - 2].type = (ushort) 128;
      Main.tile[i + 1, j - 1].active(true);
      Main.tile[i + 1, j - 1].frameY = (short) 18;
      Main.tile[i + 1, j - 1].frameX = (short) (byte) (18U + (uint) num);
      Main.tile[i + 1, j - 1].type = (ushort) 128;
      Main.tile[i + 1, j].active(true);
      Main.tile[i + 1, j].frameY = (short) 36;
      Main.tile[i + 1, j].frameX = (short) (byte) (18U + (uint) num);
      Main.tile[i + 1, j].type = (ushort) 128;
    }

    public static void PlaceWoman(int i, int j, int dir)
    {
      for (int index1 = i; index1 <= i + 1; ++index1)
      {
        for (int index2 = j - 2; index2 <= j; ++index2)
        {
          if (Main.tile[index1, index2].active())
            return;
        }
      }
      if (!WorldGen.SolidTile2(i, j + 1) || !WorldGen.SolidTile2(i + 1, j + 1))
        return;
      byte num = 0;
      if (dir == 1)
        num = (byte) 36;
      Main.tile[i, j - 2].active(true);
      Main.tile[i, j - 2].frameY = (short) 0;
      Main.tile[i, j - 2].frameX = (short) num;
      Main.tile[i, j - 2].type = (ushort) 269;
      Main.tile[i, j - 1].active(true);
      Main.tile[i, j - 1].frameY = (short) 18;
      Main.tile[i, j - 1].frameX = (short) num;
      Main.tile[i, j - 1].type = (ushort) 269;
      Main.tile[i, j].active(true);
      Main.tile[i, j].frameY = (short) 36;
      Main.tile[i, j].frameX = (short) num;
      Main.tile[i, j].type = (ushort) 269;
      Main.tile[i + 1, j - 2].active(true);
      Main.tile[i + 1, j - 2].frameY = (short) 0;
      Main.tile[i + 1, j - 2].frameX = (short) (byte) (18U + (uint) num);
      Main.tile[i + 1, j - 2].type = (ushort) 269;
      Main.tile[i + 1, j - 1].active(true);
      Main.tile[i + 1, j - 1].frameY = (short) 18;
      Main.tile[i + 1, j - 1].frameX = (short) (byte) (18U + (uint) num);
      Main.tile[i + 1, j - 1].type = (ushort) 269;
      Main.tile[i + 1, j].active(true);
      Main.tile[i + 1, j].frameY = (short) 36;
      Main.tile[i + 1, j].frameX = (short) (byte) (18U + (uint) num);
      Main.tile[i + 1, j].type = (ushort) 269;
    }

    public static void CheckWeaponsRack(int i, int j)
    {
      if (WorldGen.destroyObject)
        return;
      int num1 = i;
      int y = j - (int) Main.tile[i, j].frameY / 18;
      int num2 = (int) Main.tile[i, j].frameX;
      int num3 = 0;
      while (num2 >= 5000)
      {
        num2 -= 5000;
        ++num3;
      }
      if (num3 != 0)
        num2 = (num3 - 1) * 18;
      int num4 = num2 % 54;
      int x = num1 - num4 / 18;
      bool flag = false;
      for (int index1 = 0; index1 < 3; ++index1)
      {
        for (int index2 = 0; index2 < 3; ++index2)
        {
          int index3 = x + index1;
          int index4 = y + index2;
          int num5 = (int) Main.tile[index3, index4].frameX;
          int num6 = 0;
          while (num5 >= 5000)
          {
            num5 -= 5000;
            ++num6;
          }
          if (num6 != 0)
            num5 = (num6 - 1) * 18;
          int num7 = num5 % 54;
          if (!Main.tile[index3, index4].active() || Main.tile[index3, index4].type != (ushort) 334 || Main.tile[index3, index4].wall <= (ushort) 0 || (int) Main.tile[index3, index4].frameY != index2 * 18 || num7 != index1 * 18)
            flag = true;
        }
      }
      if (!flag)
        return;
      int key = TEWeaponsRack.Find(x, y);
      if (key != -1 && ((TEWeaponsRack) TileEntity.ByID[key]).item.stack > 0)
      {
        ((TEWeaponsRack) TileEntity.ByID[key]).DropItem();
        if (Main.netMode != 2)
          Main.LocalPlayer.InterruptItemUsageIfOverTile(471);
      }
      WorldGen.destroyObject = true;
      Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 48, 48, 2699);
      TEWeaponsRack.Kill(x, y);
      for (int index5 = 0; index5 < 3; ++index5)
      {
        for (int index6 = 0; index6 < 3; ++index6)
        {
          int i1 = x + index5;
          int j1 = y + index6;
          if (Main.tile[i1, j1].active() && Main.tile[i1, j1].type == (ushort) 334)
            WorldGen.KillTile(i1, j1);
        }
      }
      WorldGen.destroyObject = false;
    }

    public static void ToggleGemLock(int i, int j, bool on)
    {
      Tile tileSafely = Framing.GetTileSafely(i, j);
      if (!tileSafely.active() || tileSafely.type != (ushort) 440 || tileSafely.frameY < (short) 54 && !on)
        return;
      bool flag = false;
      int Type = -1;
      if (tileSafely.frameY >= (short) 54)
        flag = true;
      int num1 = (int) Main.tile[i, j].frameX / 54;
      int num2 = (int) Main.tile[i, j].frameX % 54 / 18;
      int num3 = (int) Main.tile[i, j].frameY % 54 / 18;
      switch (num1)
      {
        case 0:
          Type = 1526;
          break;
        case 1:
          Type = 1524;
          break;
        case 2:
          Type = 1525;
          break;
        case 3:
          Type = 1523;
          break;
        case 4:
          Type = 1522;
          break;
        case 5:
          Type = 1527;
          break;
        case 6:
          Type = 3643;
          break;
      }
      for (int index1 = i - num2; index1 < i - num2 + 3; ++index1)
      {
        for (int index2 = j - num3; index2 < j - num3 + 3; ++index2)
          Main.tile[index1, index2].frameY = (short) ((on ? 54 : 0) + (index2 - j + num3) * 18);
      }
      if (Type != -1 & flag)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, Type);
      WorldGen.SquareTileFrame(i, j);
      NetMessage.SendTileSquare(-1, i - num2, j - num3, 3, 3);
      Wiring.HitSwitch(i - num2, j - num3);
      NetMessage.SendData(59, number: (i - num2), number2: ((float) (j - num3)));
    }

    public static void CheckMan(int i, int j)
    {
      if (WorldGen.destroyObject)
        return;
      int num1 = i;
      int num2 = j - (int) Main.tile[i, j].frameY / 18;
      int frameX1 = (int) Main.tile[i, j].frameX;
      while (frameX1 >= 100)
        frameX1 -= 100;
      while (frameX1 >= 36)
        frameX1 -= 36;
      int i1 = num1 - frameX1 / 18;
      bool flag = false;
      for (int index1 = 0; index1 <= 1; ++index1)
      {
        for (int index2 = 0; index2 <= 2; ++index2)
        {
          int index3 = i1 + index1;
          int index4 = num2 + index2;
          int frameX2 = (int) Main.tile[index3, index4].frameX;
          while (frameX2 >= 100)
            frameX2 -= 100;
          if (frameX2 >= 36)
            frameX2 -= 36;
          if (!Main.tile[index3, index4].active() || Main.tile[index3, index4].type != (ushort) 128 || (int) Main.tile[index3, index4].frameY != index2 * 18 || frameX2 != index1 * 18)
            flag = true;
        }
      }
      if (!WorldGen.SolidTileAllowBottomSlope(i1, num2 + 3) || !WorldGen.SolidTileAllowBottomSlope(i1 + 1, num2 + 3))
        flag = true;
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 498);
      for (int index5 = 0; index5 <= 1; ++index5)
      {
        for (int index6 = 0; index6 <= 2; ++index6)
        {
          int i2 = i1 + index5;
          int j1 = num2 + index6;
          if (Main.tile[i2, j1].active() && Main.tile[i2, j1].type == (ushort) 128)
            WorldGen.KillTile(i2, j1);
        }
      }
      WorldGen.destroyObject = false;
    }

    public static void CheckWoman(int i, int j)
    {
      if (WorldGen.destroyObject)
        return;
      int num1 = i;
      int num2 = j - (int) Main.tile[i, j].frameY / 18;
      int frameX1 = (int) Main.tile[i, j].frameX;
      while (frameX1 >= 100)
        frameX1 -= 100;
      while (frameX1 >= 36)
        frameX1 -= 36;
      int i1 = num1 - frameX1 / 18;
      bool flag = false;
      for (int index1 = 0; index1 <= 1; ++index1)
      {
        for (int index2 = 0; index2 <= 2; ++index2)
        {
          int index3 = i1 + index1;
          int index4 = num2 + index2;
          int frameX2 = (int) Main.tile[index3, index4].frameX;
          while (frameX2 >= 100)
            frameX2 -= 100;
          if (frameX2 >= 36)
            frameX2 -= 36;
          if (!Main.tile[index3, index4].active() || Main.tile[index3, index4].type != (ushort) 269 || (int) Main.tile[index3, index4].frameY != index2 * 18 || frameX2 != index1 * 18)
            flag = true;
        }
      }
      if (!WorldGen.SolidTileAllowBottomSlope(i1, num2 + 3) || !WorldGen.SolidTileAllowBottomSlope(i1 + 1, num2 + 3))
        flag = true;
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1989);
      for (int index5 = 0; index5 <= 1; ++index5)
      {
        for (int index6 = 0; index6 <= 2; ++index6)
        {
          int i2 = i1 + index5;
          int j1 = num2 + index6;
          if (Main.tile[i2, j1].active() && Main.tile[i2, j1].type == (ushort) 269)
            WorldGen.KillTile(i2, j1);
        }
      }
      WorldGen.destroyObject = false;
    }

    public static void Place1x2(int x, int y, ushort type, int style)
    {
      short num1 = 0;
      if (type == (ushort) 20)
        num1 = (short) (WorldGen.genRand.Next(3) * 18);
      if (Main.tile[x, y - 1] == null)
        Main.tile[x, y - 1] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (!(WorldGen.SolidTile2(x, y + 1) & !Main.tile[x, y - 1].active()))
        return;
      short num2 = (short) (style * 40);
      Main.tile[x, y - 1].active(true);
      Main.tile[x, y - 1].frameY = num2;
      Main.tile[x, y - 1].frameX = num1;
      Main.tile[x, y - 1].type = type;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) ((int) num2 + 18);
      Main.tile[x, y].frameX = num1;
      Main.tile[x, y].type = type;
    }

    public static void Place1x2Top(int x, int y, ushort type, int style)
    {
      short num1 = 0;
      if (Main.tile[x, y - 1] == null)
        Main.tile[x, y - 1] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[(int) Main.tile[x, y - 1].type] || Main.tileSolidTop[(int) Main.tile[x, y - 1].type] || Main.tile[x, y + 1].active())
        return;
      short num2 = (short) (style * 36);
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = num2;
      Main.tile[x, y].frameX = num1;
      Main.tile[x, y].type = type;
      Main.tile[x, y + 1].active(true);
      Main.tile[x, y + 1].frameY = (short) ((int) num2 + 18);
      Main.tile[x, y + 1].frameX = num1;
      Main.tile[x, y + 1].type = type;
    }

    public static void Check1x2Top(int x, int j, ushort type)
    {
      if (WorldGen.destroyObject)
        return;
      int index1 = j;
      bool flag1 = true;
      int num1 = (int) Main.tile[x, index1].frameY / 18;
      int num2 = 0;
      while (num1 >= 2)
      {
        num1 -= 2;
        ++num2;
      }
      int index2 = index1 - num1;
      int num3 = num2 * 36;
      if (Main.tile[x, index2] == null)
        Main.tile[x, index2] = new Tile();
      if (Main.tile[x, index2 + 1] == null)
        Main.tile[x, index2 + 1] = new Tile();
      if (Main.tile[x, index2] == null)
        Main.tile[x, index2] = new Tile();
      if ((int) Main.tile[x, index2].frameY == num3 && (int) Main.tile[x, index2 + 1].frameY == num3 + 18 && (int) Main.tile[x, index2].type == (int) type && (int) Main.tile[x, index2 + 1].type == (int) type)
        flag1 = false;
      if (Main.tile[x, index2 - 1] == null)
        Main.tile[x, index2 - 1] = new Tile();
      bool flag2 = false;
      switch (type)
      {
        case 42:
        case 270:
        case 271:
        case 572:
        case 581:
        case 660:
          flag2 = true;
          break;
      }
      bool flag3 = Main.tile[x, index2 - 1].active() && (TileID.Sets.Platforms[(int) Main.tile[x, index2 - 1].type] || Main.tile[x, index2 - 1].type == (ushort) 380);
      if ((!flag2 || !flag3) && (!Main.tile[x, index2 - 1].nactive() || !Main.tileSolid[(int) Main.tile[x, index2 - 1].type] || Main.tileSolidTop[(int) Main.tile[x, index2 - 1].type]))
        flag1 = true;
      if (!flag1)
        return;
      WorldGen.destroyObject = true;
      if ((int) Main.tile[x, index2].type == (int) type)
        WorldGen.KillTile(x, index2);
      if ((int) Main.tile[x, index2 + 1].type == (int) type)
        WorldGen.KillTile(x, index2 + 1);
      switch (type)
      {
        case 42:
          int Type = 0;
          switch (num2)
          {
            case 0:
              Type = 136;
              break;
            case 7:
              Type = 1431;
              break;
            case 8:
              Type = 1808;
              break;
            case 9:
              Type = 1859;
              break;
            default:
              if (num2 < 10)
              {
                Type = 1389 + num2;
                break;
              }
              switch (num2)
              {
                case 10:
                  Type = 2032;
                  break;
                case 11:
                  Type = 2033;
                  break;
                case 12:
                  Type = 2034;
                  break;
                case 13:
                  Type = 2035;
                  break;
                case 14:
                  Type = 2036;
                  break;
                case 15:
                  Type = 2037;
                  break;
                case 16:
                  Type = 2038;
                  break;
                case 17:
                  Type = 2039;
                  break;
                case 18:
                  Type = 2040;
                  break;
                case 19:
                  Type = 2041;
                  break;
                case 20:
                  Type = 2042;
                  break;
                case 21:
                  Type = 2043;
                  break;
                default:
                  if (num2 >= 22 && num2 <= 25)
                  {
                    Type = 2145 + num2 - 22;
                    break;
                  }
                  switch (num2)
                  {
                    case 26:
                      Type = 2226;
                      break;
                    case 27:
                      Type = 2530;
                      break;
                    case 28:
                      Type = 2546;
                      break;
                    case 29:
                      Type = 2564;
                      break;
                    case 30:
                      Type = 2579;
                      break;
                    case 31:
                      Type = 2641;
                      break;
                    case 32:
                      Type = 2642;
                      break;
                    case 33:
                      Type = 2820;
                      break;
                    case 34:
                      Type = 3138;
                      break;
                    case 35:
                      Type = 3140;
                      break;
                    case 36:
                      Type = 3139;
                      break;
                    case 37:
                      Type = 3891;
                      break;
                    case 38:
                      Type = 3943;
                      break;
                    case 39:
                      Type = 3970;
                      break;
                    case 40:
                      Type = 4157;
                      break;
                    case 41:
                      Type = 4178;
                      break;
                    case 42:
                      Type = 4199;
                      break;
                    case 43:
                      Type = 4220;
                      break;
                    case 44:
                      Type = 4309;
                      break;
                    case 45:
                      Type = 4578;
                      break;
                    case 46:
                      Type = 5160;
                      break;
                    case 47:
                      Type = 5181;
                      break;
                    case 48:
                      Type = 5202;
                      break;
                  }
                  break;
              }
              break;
          }
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, index2), x * 16, index2 * 16, 32, 32, Type);
          break;
        case 270:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, index2), x * 16, index2 * 16, 32, 32, 1993);
          break;
        case 271:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, index2), x * 16, index2 * 16, 32, 32, 2005);
          break;
        case 572:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, index2), x * 16, index2 * 16, 32, 32, 4695 + num2);
          break;
        case 581:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, index2), x * 16, index2 * 16, 32, 32, 4848);
          break;
        case 660:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, index2), x * 16, index2 * 16, 32, 32, 5351);
          break;
      }
      WorldGen.destroyObject = false;
    }

    public static bool PlaceSmallPile(int i, int j, int X, int Y, ushort type = 185)
    {
      int i1 = i;
      int index = j;
      short num1 = (short) (Y * 18);
      short num2 = (short) (X * 18);
      if (Main.tile[i1, index] == null)
        Main.tile[i1, index] = new Tile();
      if (Main.tile[i1 + 1, index] == null)
        Main.tile[i1 + 1, index] = new Tile();
      if (Main.tile[i1, index + 1] == null)
        Main.tile[i1, index + 1] = new Tile();
      if (Main.tile[i1 + 1, index + 1] == null)
        Main.tile[i1 + 1, index + 1] = new Tile();
      if (Main.tile[i1, index].lava())
        return false;
      if (Y == 1)
      {
        short num3 = (short) (X * 36);
        bool flag = false;
        if (WorldGen.SolidTile2(i1, index + 1) && WorldGen.SolidTile2(i1 + 1, index + 1) && !Main.tile[i1, index].active() && !Main.tile[i1 + 1, index].active())
          flag = true;
        if (flag)
        {
          Main.tile[i1, index].active(true);
          Main.tile[i1, index].frameY = num1;
          Main.tile[i1, index].frameX = num3;
          Main.tile[i1, index].type = type;
          Main.tile[i1 + 1, index].active(true);
          Main.tile[i1 + 1, index].frameY = num1;
          Main.tile[i1 + 1, index].frameX = (short) ((int) num3 + 18);
          Main.tile[i1 + 1, index].type = type;
          return true;
        }
      }
      else if (WorldGen.SolidTile2(i1, index + 1) && !Main.tile[i1, index].active())
      {
        Main.tile[i1, index].active(true);
        Main.tile[i1, index].frameY = num1;
        Main.tile[i1, index].frameX = num2;
        Main.tile[i1, index].type = type;
        return true;
      }
      return false;
    }

    public static void CheckPile(int i, int y)
    {
      int i1 = i;
      if (Main.tile[i1, y] == null)
        Main.tile[i1, y] = new Tile();
      if (Main.tile[i1 + 1, y] == null)
        Main.tile[i1 + 1, y] = new Tile();
      if (Main.tile[i1, y + 1] == null)
        Main.tile[i1, y + 1] = new Tile();
      if (Main.tile[i1 + 1, y + 1] == null)
        Main.tile[i1 + 1, y + 1] = new Tile();
      Tile tile1 = Main.tile[i1, y];
      if (tile1.frameY == (short) 18 || tile1.type == (ushort) 649)
        WorldGen.Check2x1(i1, y, tile1.type);
      else if (!WorldGen.SolidTileAllowBottomSlope(i1, y + 1))
      {
        WorldGen.KillTile(i1, y);
      }
      else
      {
        if (tile1.type != (ushort) 185)
          return;
        int num = (int) tile1.frameX / 18;
        Tile tile2 = Main.tile[i1, y + 1];
        if (tile2 == null || !tile2.active() || tile2.type < (ushort) 0 || (int) tile2.type >= (int) TileID.Count)
          return;
        ushort type = tile2.type;
        switch (num)
        {
          case 36:
          case 37:
          case 38:
          case 39:
          case 40:
          case 41:
          case 42:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
            if (TileID.Sets.Snow[(int) type] || TileID.Sets.Conversion.Ice[(int) type] || type == (ushort) 162 || type == (ushort) 224)
              break;
            WorldGen.KillTile(i1, y);
            break;
          case 54:
          case 55:
          case 56:
          case 57:
          case 58:
          case 59:
          case 73:
          case 74:
          case 75:
          case 76:
            if (TileID.Sets.Conversion.Sand[(int) type] || TileID.Sets.Conversion.HardenedSand[(int) type] || TileID.Sets.Conversion.Sandstone[(int) type])
              break;
            WorldGen.KillTile(i1, y);
            break;
        }
      }
    }

    public static void Check2x1(int i, int y, ushort type)
    {
      if (WorldGen.destroyObject)
        return;
      int index1 = i;
      bool flag = true;
      if (Main.tile[index1, y] == null)
        Main.tile[index1, y] = new Tile();
      int num1 = (int) Main.tile[index1, y].frameX / 18;
      int num2 = num1 >> 1;
      int num3 = (int) Main.tile[index1, y].frameY / 18;
      int num4 = num1 % 2;
      int index2 = index1 - num4;
      if (Main.tile[index2, y] == null)
        Main.tile[index2, y] = new Tile();
      if (Main.tile[index2 + 1, y] == null)
        Main.tile[index2 + 1, y] = new Tile();
      if (Main.tile[index2, y + 1] == null)
        Main.tile[index2, y + 1] = new Tile();
      if (Main.tile[index2 + 1, y + 1] == null)
        Main.tile[index2 + 1, y + 1] = new Tile();
      if ((int) Main.tile[index2 + 1, y].frameX == (int) Main.tile[index2, y].frameX + 18 && (int) Main.tile[index2, y].type == (int) type && (int) Main.tile[index2 + 1, y].type == (int) type)
        flag = false;
      if (type == (ushort) 29 || type == (ushort) 103 || type == (ushort) 462)
      {
        if (!Main.tile[index2, y + 1].active() || !Main.tileTable[(int) Main.tile[index2, y + 1].type] || Main.tile[index2, y + 1].halfBrick() || Main.tile[index2, y + 1].topSlope())
          flag = true;
        if (!Main.tile[index2 + 1, y + 1].active() || !Main.tileTable[(int) Main.tile[index2 + 1, y + 1].type] || Main.tile[index2 + 1, y + 1].halfBrick() || Main.tile[index2 + 1, y + 1].topSlope())
          flag = true;
      }
      else
      {
        if (!WorldGen.SolidTileAllowBottomSlope(index2, y + 1))
          flag = true;
        if (!WorldGen.SolidTileAllowBottomSlope(index2 + 1, y + 1))
          flag = true;
      }
      if (type == (ushort) 185)
      {
        if (Main.tile[index2, y].frameX >= (short) 1368 && Main.tile[index2, y].frameX <= (short) 1458 && Main.tile[index2, y + 1].type != (ushort) 2 && Main.tile[index2 + 1, y + 1].type != (ushort) 2 && Main.tile[index2, y + 1].type != (ushort) 477 && Main.tile[index2 + 1, y + 1].type != (ushort) 477 && Main.tile[index2, y + 1].type != (ushort) 492 && Main.tile[index2 + 1, y + 1].type != (ushort) 492)
        {
          Main.tile[index2, y].frameX -= (short) 1368;
          Main.tile[index2 + 1, y].frameX -= (short) 1368;
        }
        Tile tile1 = Main.tile[index2, y];
        int num5 = (int) tile1.frameX / 36 + ((int) tile1.frameY / 18 - 1) * 52;
        for (int index3 = index2; index3 < index2 + 2; ++index3)
        {
          Tile tile2 = Main.tile[index3, y + 1];
          if (tile2 != null && tile2.active() && tile2.type >= (ushort) 0 && (int) tile2.type < (int) TileID.Count)
          {
            ushort type1 = tile2.type;
            switch (num5)
            {
              case 25:
              case 26:
              case 27:
              case 28:
              case 29:
              case 30:
                if (!TileID.Sets.Snow[(int) type1] && !TileID.Sets.Conversion.Ice[(int) type1] && type1 != (ushort) 162 && type1 != (ushort) 224)
                {
                  flag = true;
                  continue;
                }
                continue;
              case 41:
              case 42:
              case 43:
              case 44:
              case 45:
              case 46:
              case 62:
              case 63:
              case 64:
                if (!TileID.Sets.Conversion.Sand[(int) type1] && !TileID.Sets.Conversion.HardenedSand[(int) type1] && !TileID.Sets.Conversion.Sandstone[(int) type1])
                {
                  flag = true;
                  continue;
                }
                continue;
              default:
                continue;
            }
          }
        }
      }
      if (!flag)
        return;
      int frameX = (int) Main.tile[index2, y].frameX;
      if (!Main.tile[index2, y].active())
        frameX = (int) Main.tile[index2 + 1, y].frameX;
      WorldGen.destroyObject = true;
      if ((int) Main.tile[index2, y].type == (int) type)
        WorldGen.KillTile(index2, y);
      if ((int) Main.tile[index2 + 1, y].type == (int) type)
        WorldGen.KillTile(index2 + 1, y);
      if (type == (ushort) 16)
      {
        if (num2 == 1)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 716);
        else
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 35);
      }
      if (type == (ushort) 18)
      {
        int Type = 36;
        if (num2 >= 1 && num2 <= 3)
          Type = 634 + num2;
        else if (num2 >= 4 && num2 <= 8)
        {
          Type = 807 + num2;
        }
        else
        {
          switch (num2)
          {
            case 9:
              Type = 916;
              break;
            case 10:
              Type = 1145;
              break;
            case 11:
              Type = 1398;
              break;
            case 12:
              Type = 1401;
              break;
            case 13:
              Type = 1404;
              break;
            case 14:
              Type = 1461;
              break;
            case 15:
              Type = 1511;
              break;
            case 16:
              Type = 1795;
              break;
            case 17:
              Type = 1817;
              break;
            case 18:
              Type = 2229;
              break;
            case 19:
              Type = 2251;
              break;
            case 20:
              Type = 2252;
              break;
            case 21:
              Type = 2253;
              break;
            case 22:
              Type = 2534;
              break;
            case 23:
              Type = 673;
              break;
            case 24:
              Type = 2631;
              break;
            case 25:
              Type = 2632;
              break;
            case 26:
              Type = 2633;
              break;
            case 27:
              Type = 2826;
              break;
            case 28:
              Type = 3156;
              break;
            case 29:
              Type = 3158;
              break;
            case 30:
              Type = 3157;
              break;
            case 31:
              Type = 3909;
              break;
            case 32:
              Type = 3910;
              break;
            case 33:
              Type = 3949;
              break;
            case 34:
              Type = 3975;
              break;
            case 35:
              Type = 4163;
              break;
            case 36:
              Type = 4184;
              break;
            case 37:
              Type = 4205;
              break;
            case 38:
              Type = 4226;
              break;
            case 39:
              Type = 4315;
              break;
            case 40:
              Type = 4584;
              break;
            case 41:
              Type = 5166;
              break;
            case 42:
              Type = 5187;
              break;
            case 43:
              Type = 5208;
              break;
          }
        }
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, Type);
      }
      if (type == (ushort) 185)
      {
        if (frameX >= 576 && frameX <= 610)
        {
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(10, 100));
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100));
          if (WorldGen.genRand.Next(3) != 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(10, 100));
          if (WorldGen.genRand.Next(3) != 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100));
          if (WorldGen.genRand.Next(2) == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(10, 100));
          if (WorldGen.genRand.Next(2) == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100));
          if (WorldGen.genRand.Next(3) == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(10, 100));
          if (WorldGen.genRand.Next(3) == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100));
          if (WorldGen.genRand.Next(4) == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(10, 100));
          if (WorldGen.genRand.Next(4) == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100));
          if (WorldGen.genRand.Next(5) == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(10, 100));
          if (WorldGen.genRand.Next(5) == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100));
        }
        if (frameX >= 612 && frameX <= 646)
        {
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 72, WorldGen.genRand.Next(10, 100));
          if (WorldGen.genRand.Next(2) == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 72, WorldGen.genRand.Next(20, 100));
          if (WorldGen.genRand.Next(3) == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 72, WorldGen.genRand.Next(30, 100));
        }
        if (frameX >= 648 && frameX <= 682)
        {
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 73, WorldGen.genRand.Next(1, 6));
          if (WorldGen.genRand.Next(2) == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 73, WorldGen.genRand.Next(2, 6));
          if (WorldGen.genRand.Next(3) == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 73, WorldGen.genRand.Next(3, 6));
        }
        if (frameX >= 684 && frameX <= 718)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 181, WorldGen.genRand.Next(1, 4));
        if (frameX >= 720 && frameX <= 754)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 180, WorldGen.genRand.Next(1, 4));
        if (frameX >= 756 && frameX <= 790)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 177, WorldGen.genRand.Next(1, 4));
        if (frameX >= 792 && frameX <= 826)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 179, WorldGen.genRand.Next(1, 4));
        if (frameX >= 828 && frameX <= 862)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 178, WorldGen.genRand.Next(1, 4));
        if (frameX >= 864 && frameX <= 898)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 182, WorldGen.genRand.Next(1, 4));
      }
      if (type == (ushort) 462)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 3795);
      if (type == (ushort) 29)
      {
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 87);
        SoundEngine.PlaySound(13, i * 16, y * 16);
      }
      if (type == (ushort) 103)
      {
        int Type = 356;
        if (num2 == 1)
          Type = 2235;
        if (num2 == 2)
          Type = 2242;
        if (num2 == 3)
          Type = 2243;
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, Type);
        SoundEngine.PlaySound(13, i * 16, y * 16);
      }
      else if (type == (ushort) 134)
      {
        if (num2 == 1)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 1220);
        else
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, 525);
      }
      else if (type == (ushort) 649)
      {
        int num6 = num2 + num3 * 53;
        int Type = 0;
        if (num6 < 6)
          Type = 3;
        else if (num6 < 16)
          Type = 154;
        else if (num6 < 17)
          Type = 71;
        else if (num6 < 18)
          Type = 72;
        else if (num6 < 19)
          Type = 73;
        else if (num6 < 20)
          Type = 181;
        else if (num6 < 21)
          Type = 180;
        else if (num6 < 22)
          Type = 177;
        else if (num6 < 23)
          Type = 179;
        else if (num6 < 24)
          Type = 178;
        else if (num6 < 25)
          Type = 182;
        else if (num6 < 31)
          Type = 593;
        else if (num6 < 34)
          Type = 9;
        else if (num6 < 38)
          Type = 150;
        else if (num6 < 41)
          Type = 3;
        else if (num6 < 47)
          Type = 3271;
        else if (num6 < 53)
          Type = 3086;
        else if (num6 < 59)
          Type = 3081;
        else if (num6 < 62)
          Type = 62;
        else if (num6 < 65)
          Type = 169;
        if (Type != 0)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(index2, y), index2 * 16, y * 16, 32, 32, Type);
      }
      WorldGen.destroyObject = false;
      WorldGen.SquareTileFrame(index2, y);
      WorldGen.SquareTileFrame(index2 + 1, y);
    }

    public static void Place2x1(int x, int y, ushort type, int style = 0)
    {
      if (Main.tile[x, y] == null)
        Main.tile[x, y] = new Tile();
      if (Main.tile[x + 1, y] == null)
        Main.tile[x + 1, y] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (Main.tile[x + 1, y + 1] == null)
        Main.tile[x + 1, y + 1] = new Tile();
      bool flag = false;
      if (type != (ushort) 29 && type != (ushort) 103 && WorldGen.SolidTile2(x, y + 1) && WorldGen.SolidTile2(x + 1, y + 1) && !Main.tile[x, y].active() && !Main.tile[x + 1, y].active())
        flag = true;
      else if ((type == (ushort) 29 || type == (ushort) 103) && Main.tile[x, y + 1].active() && Main.tile[x + 1, y + 1].active() && Main.tileTable[(int) Main.tile[x, y + 1].type] && Main.tileTable[(int) Main.tile[x + 1, y + 1].type] && !Main.tile[x, y].active() && !Main.tile[x + 1, y].active())
        flag = true;
      if (!flag)
        return;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) 0;
      Main.tile[x, y].frameX = (short) (36 * style);
      Main.tile[x, y].type = type;
      Main.tile[x + 1, y].active(true);
      Main.tile[x + 1, y].frameY = (short) 0;
      Main.tile[x + 1, y].frameX = (short) (36 * style + 18);
      Main.tile[x + 1, y].type = type;
    }

    public static void Check4x2(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = i;
      int num2 = type != 487 ? num1 + (int) Main.tile[i, j].frameX / 18 * -1 : num1 + (int) Main.tile[i, j].frameX / 18 % 4 * -1;
      if ((type == 79 || type == 90) && Main.tile[i, j].frameX >= (short) 72)
        num2 += 4;
      int num3 = (int) Main.tile[i, j].frameY / 18;
      int style = 0;
      while (num3 > 1)
      {
        num3 -= 2;
        ++style;
      }
      int num4 = j - num3;
      if (type == 487)
        style = (int) Main.tile[i, j].frameX / 72;
      for (int i1 = num2; i1 < num2 + 4; ++i1)
      {
        for (int index = num4; index < num4 + 2; ++index)
        {
          int num5 = (i1 - num2) * 18;
          int num6 = (index - num4) * 18;
          if ((type == 79 || type == 90) && Main.tile[i, j].frameX >= (short) 72)
            num5 = (i1 - num2 + 4) * 18;
          if (type == 487)
            num5 += style * 72;
          else
            num6 += style * 36;
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || (int) Main.tile[i1, index].frameX != num5 || (int) Main.tile[i1, index].frameY != num6)
            flag = true;
        }
        if (Main.tile[i1, num4 + 2] == null)
          Main.tile[i1, num4 + 2] = new Tile();
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num4 + 2) && (!Main.tile[i1, num4 + 2].active() || !TileID.Sets.Platforms[(int) Main.tile[i1, num4 + 2].type]))
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i2 = num2; i2 < num2 + 4; ++i2)
      {
        for (int j1 = num4; j1 < num4 + 3; ++j1)
        {
          if ((int) Main.tile[i2, j1].type == type && Main.tile[i2, j1].active())
            WorldGen.KillTile(i2, j1);
        }
      }
      if (type == 79)
      {
        int Type = style != 0 ? (style != 4 ? (style < 9 || style > 12 ? (style < 5 || style > 8 ? (style < 13 || style > 18 ? (style != 19 ? (style != 20 ? (style != 21 ? (style != 22 ? (style != 23 ? (style != 24 ? (style != 25 ? (style != 26 ? (style != 27 ? (style != 28 ? (style != 29 ? (style != 30 ? (style != 31 ? (style != 32 ? (style != 33 ? (style != 34 ? (style != 35 ? (style != 36 ? (style != 37 ? (style != 38 ? (style != 39 ? (style != 40 ? (style != 41 ? (style != 42 ? style + 643 : 5191) : 5170) : 5149) : 4567) : 4299) : 4209) : 4188) : 4167) : 4146) : 3959) : 3932) : 3897) : 3163) : 3164) : 3162) : 2811) : 2669) : 2568) : 2553) : 2538) : 2520) : 2231) : 2140) : 2139) : 2066 + style - 13) : 1465 + style) : 1710 + style) : 920) : 224;
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, Type);
      }
      if (type == 487)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, WorldGen.GetItemDrop_PicnicTables(style));
      if (type == 90)
      {
        int Type = 0;
        if (style == 0)
          Type = 336;
        else if (style >= 1 && style <= 10)
          Type = 2072 + style - 1;
        else if (style >= 11 && style <= 15)
        {
          Type = 2124 + style - 11;
        }
        else
        {
          switch (style)
          {
            case 16:
              Type = 2232;
              break;
            case 17:
              Type = 2519;
              break;
            case 18:
              Type = 2537;
              break;
            case 19:
              Type = 2552;
              break;
            case 20:
              Type = 2567;
              break;
            case 21:
              Type = 2658;
              break;
            case 22:
              Type = 2659;
              break;
            case 23:
              Type = 2660;
              break;
            case 24:
              Type = 2661;
              break;
            case 25:
              Type = 2662;
              break;
            case 26:
              Type = 2663;
              break;
            case 27:
              Type = 2810;
              break;
            case 28:
              Type = 3159;
              break;
            case 29:
              Type = 3161;
              break;
            case 30:
              Type = 3160;
              break;
            case 31:
              Type = 3895;
              break;
            case 32:
              Type = 3931;
              break;
            case 33:
              Type = 3958;
              break;
            case 34:
              Type = 4145;
              break;
            case 35:
              Type = 4166;
              break;
            case 36:
              Type = 4187;
              break;
            case 37:
              Type = 4208;
              break;
            case 38:
              Type = 4298;
              break;
            case 39:
              Type = 4566;
              break;
            case 40:
              Type = 5148;
              break;
            case 41:
              Type = 5169;
              break;
            case 42:
              Type = 5190;
              break;
          }
        }
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, Type);
      }
      WorldGen.destroyObject = false;
      for (int i3 = num2 - 1; i3 < num2 + 4; ++i3)
      {
        for (int j2 = num4 - 1; j2 < num4 + 4; ++j2)
          WorldGen.TileFrame(i3, j2);
      }
    }

    private static bool OasisPlantWaterCheck(int x, int y, bool boost = false)
    {
      int num1 = 45;
      int num2 = 20;
      if (boost)
      {
        num1 += 4;
        num2 += 3;
      }
      int num3 = 20;
      int num4 = 0;
      for (int index1 = x - num1; index1 <= x + num1; ++index1)
      {
        if (x > WorldGen.beachDistance && x < Main.maxTilesX - WorldGen.beachDistance)
        {
          for (int index2 = y - num2; index2 <= y + num2; ++index2)
          {
            if (WorldGen.InWorld(index1, index2) && !WorldGen.SolidTile(index1, index2))
              num4 += (int) Main.tile[index1, index2].liquid;
          }
        }
      }
      return num4 / (int) byte.MaxValue >= num3;
    }

    public static void PlaceOasisPlant(int X, int Y, ushort type = 530)
    {
      int num1 = WorldGen.genRand.Next(9);
      int num2 = 0;
      int x = X;
      int y = Y;
      if (x < WorldGen.beachDistance || x > Main.maxTilesX - WorldGen.beachDistance || y < 5 || y > Main.maxTilesY - 5)
        return;
      bool flag = true;
      for (int i = x - 1; i < x + 2; ++i)
      {
        for (int index = y - 1; index < y + 1; ++index)
        {
          if (Main.tile[i, index] == null)
            Main.tile[i, index] = new Tile();
          if (Main.tile[i, index].active() && Main.tile[i, index].type != (ushort) 529)
            flag = false;
          if (Main.tile[i, index].liquid > (byte) 0)
            flag = false;
        }
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (!WorldGen.SolidTile(i, y + 1) || !TileID.Sets.Conversion.Sand[(int) Main.tile[i, y + 1].type])
          flag = false;
      }
      if (!flag || !WorldGen.OasisPlantWaterCheck(x, y))
        return;
      short num3 = (short) (54 * num1);
      short num4 = (short) (36 * num2);
      Main.tile[x - 1, y - 1].active(true);
      Main.tile[x - 1, y - 1].frameY = num4;
      Main.tile[x - 1, y - 1].frameX = num3;
      Main.tile[x - 1, y - 1].type = type;
      Main.tile[x, y - 1].active(true);
      Main.tile[x, y - 1].frameY = num4;
      Main.tile[x, y - 1].frameX = (short) ((int) num3 + 18);
      Main.tile[x, y - 1].type = type;
      Main.tile[x + 1, y - 1].active(true);
      Main.tile[x + 1, y - 1].frameY = num4;
      Main.tile[x + 1, y - 1].frameX = (short) ((int) num3 + 36);
      Main.tile[x + 1, y - 1].type = type;
      Main.tile[x - 1, y].active(true);
      Main.tile[x - 1, y].frameY = (short) ((int) num4 + 18);
      Main.tile[x - 1, y].frameX = num3;
      Main.tile[x - 1, y].type = type;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) ((int) num4 + 18);
      Main.tile[x, y].frameX = (short) ((int) num3 + 18);
      Main.tile[x, y].type = type;
      Main.tile[x + 1, y].active(true);
      Main.tile[x + 1, y].frameY = (short) ((int) num4 + 18);
      Main.tile[x + 1, y].frameX = (short) ((int) num3 + 36);
      Main.tile[x + 1, y].type = type;
    }

    public static void CheckOasisPlant(int i, int j, int type = 530)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = j;
      Tile tileSafely = Framing.GetTileSafely(i, j);
      int num2 = (int) tileSafely.frameY % 36;
      int j1 = num1 + num2 / 18 * -1;
      int i1 = (int) tileSafely.frameX / 18;
      int num3 = 0;
      int num4 = (int) Framing.GetTileSafely(i1, j1).frameY / 36;
      while (i1 > 2)
      {
        i1 -= 3;
        ++num3;
      }
      int num5 = i - i1;
      int num6 = num3 * 54;
      for (int i2 = num5; i2 < num5 + 3; ++i2)
      {
        for (int index = j1; index < j1 + 2; ++index)
        {
          if (Main.tile[i2, index] == null)
            Main.tile[i2, index] = new Tile();
          if (!Main.tile[i2, index].active() || (int) Main.tile[i2, index].type != type || (int) Main.tile[i2, index].frameX != (i2 - num5) * 18 + num6 || (int) Main.tile[i2, index].frameY != (index - j1) * 18)
            flag = true;
        }
        if (Main.tile[i2, j1 + 2] == null)
          Main.tile[i2, j1 + 2] = new Tile();
        if (!WorldGen.SolidTile(i2, j1 + 2) || !TileID.Sets.Conversion.Sand[(int) Main.tile[i2, j1 + 2].type])
          flag = true;
      }
      if (!flag)
        return;
      int frameX = (int) Main.tile[i, j].frameX;
      WorldGen.destroyObject = true;
      for (int i3 = num5; i3 < num5 + 3; ++i3)
      {
        for (int j2 = j1; j2 < j1 + 2; ++j2)
        {
          if (Main.tile[i3, j2] == null)
            Main.tile[i3, j2] = new Tile();
          if ((int) Main.tile[i3, j2].type == type && Main.tile[i3, j2].active())
            WorldGen.KillTile(i3, j2);
        }
      }
      WorldGen.destroyObject = false;
      for (int i4 = num5 - 1; i4 < num5 + 4; ++i4)
      {
        for (int j3 = j1 - 1; j3 < j1 + 3; ++j3)
          WorldGen.TileFrame(i4, j3);
      }
    }

    public static void GetCactusType(
      int tileX,
      int tileY,
      int frameX,
      int frameY,
      out bool evil,
      out bool good,
      out bool crimson)
    {
      evil = false;
      good = false;
      crimson = false;
      int index1 = tileX;
      if (frameX == 36)
        --index1;
      if (frameX == 54)
        ++index1;
      if (frameX == 108)
      {
        if (frameY == 18)
          --index1;
        else
          ++index1;
      }
      int index2 = tileY;
      bool flag = false;
      Tile tile = Main.tile[index1, index2];
      if (tile == null)
        return;
      if (tile.type == (ushort) 80 && tile.active())
        flag = true;
      for (; tile != null && (!tile.active() || !Main.tileSolid[(int) tile.type] || !flag); tile = Main.tile[index1, index2])
      {
        if (tile.type == (ushort) 80 && tile.active())
          flag = true;
        ++index2;
        if (index2 > tileY + 20)
          break;
      }
      if (tile.type == (ushort) 112)
        evil = true;
      if (tile.type == (ushort) 116)
        good = true;
      if (tile.type != (ushort) 234)
        return;
      crimson = true;
    }

    public static void GetBiomeInfluence(
      int startX,
      int endX,
      int startY,
      int endY,
      out int corruptCount,
      out int crimsonCount,
      out int hallowedCount)
    {
      corruptCount = 0;
      crimsonCount = 0;
      hallowedCount = 0;
      for (int index1 = startX; index1 <= endX; ++index1)
      {
        for (int index2 = startY; index2 <= endY; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile != null)
          {
            if (TileID.Sets.Corrupt[(int) tile.type])
              ++corruptCount;
            if (TileID.Sets.Crimson[(int) tile.type])
              ++crimsonCount;
            if (TileID.Sets.Hallow[(int) tile.type])
              ++hallowedCount;
          }
        }
      }
    }

    public static void PlaceJunglePlant(int X2, int Y2, ushort type, int styleX, int styleY)
    {
      if (styleY > 0 || type == (ushort) 236 || type == (ushort) 238)
      {
        int index1 = Y2;
        int index2 = X2;
        if (type == (ushort) 95 || type == (ushort) 126)
          ++index1;
        if (X2 < 5 || X2 > Main.maxTilesX - 5 || index1 < 5 || index1 > Main.maxTilesY - 5)
          return;
        bool flag = true;
        for (int i = index2 - 1; i < index2 + 1; ++i)
        {
          for (int index3 = index1 - 1; index3 < index1 + 1; ++index3)
          {
            if (Main.tile[i, index3] == null)
              Main.tile[i, index3] = new Tile();
            Tile tile = Main.tile[i, index3];
            if (tile.active() && tile.type != (ushort) 61 && tile.type != (ushort) 62 && tile.type != (ushort) 655 && tile.type != (ushort) 69 && tile.type != (ushort) 74 && (type != (ushort) 236 || tile.type != (ushort) 233) && (type != (ushort) 238 || tile.type != (ushort) 233) && (tile.type != (ushort) 185 || tile.frameY != (short) 0))
              flag = false;
            if (type == (ushort) 98 && tile.liquid > (byte) 0)
              flag = false;
          }
          if (Main.tile[i, index1 + 1] == null)
            Main.tile[i, index1 + 1] = new Tile();
          if (!WorldGen.SolidTile(i, index1 + 1) || Main.tile[i, index1 + 1].type != (ushort) 60)
            flag = false;
        }
        if (!flag)
          return;
        for (int i = index2 - 1; i < index2 + 1; ++i)
        {
          for (int j = index1 - 1; j < index1 + 1; ++j)
          {
            if (Main.tile[i, j] != null && Main.tile[i, j].active())
              WorldGen.KillTile(i, j, noItem: true);
          }
        }
        short num1 = 36;
        if (type == (ushort) 236 || type == (ushort) 238)
          num1 = (short) 0;
        short num2 = (short) (36 * styleX);
        Main.tile[index2 - 1, index1 - 1].active(true);
        Main.tile[index2 - 1, index1 - 1].frameY = num1;
        Main.tile[index2 - 1, index1 - 1].frameX = num2;
        Main.tile[index2 - 1, index1 - 1].type = type;
        Main.tile[index2, index1 - 1].active(true);
        Main.tile[index2, index1 - 1].frameY = num1;
        Main.tile[index2, index1 - 1].frameX = (short) (18 + (int) num2);
        Main.tile[index2, index1 - 1].type = type;
        Main.tile[index2 - 1, index1].active(true);
        Main.tile[index2 - 1, index1].frameY = (short) ((int) num1 + 18);
        Main.tile[index2 - 1, index1].frameX = num2;
        Main.tile[index2 - 1, index1].type = type;
        Main.tile[index2, index1].active(true);
        Main.tile[index2, index1].frameY = (short) ((int) num1 + 18);
        Main.tile[index2, index1].frameX = (short) (18 + (int) num2);
        Main.tile[index2, index1].type = type;
      }
      else
      {
        int num3 = styleX;
        int index4 = X2;
        int index5 = Y2;
        if (index4 < 5 || index4 > Main.maxTilesX - 5 || index5 < 5 || index5 > Main.maxTilesY - 5)
          return;
        bool flag = true;
        for (int i = index4 - 1; i < index4 + 2; ++i)
        {
          for (int index6 = index5 - 1; index6 < index5 + 1; ++index6)
          {
            if (Main.tile[i, index6] == null)
              Main.tile[i, index6] = new Tile();
            if (Main.tile[i, index6].active() && Main.tile[i, index6].type != (ushort) 61 && Main.tile[i, index6].type != (ushort) 62 && Main.tile[i, index6].type != (ushort) 69 && Main.tile[i, index6].type != (ushort) 655 && Main.tile[i, index6].type != (ushort) 74 && (Main.tile[i, index6].type != (ushort) 185 || Main.tile[i, index6].frameY != (short) 0))
              flag = false;
          }
          if (Main.tile[i, index5 + 1] == null)
            Main.tile[i, index5 + 1] = new Tile();
          if (!WorldGen.SolidTile(i, index5 + 1) || Main.tile[i, index5 + 1].type != (ushort) 60)
            flag = false;
        }
        if (!flag)
          return;
        for (int i = index4 - 1; i < index4 + 2; ++i)
        {
          for (int j = index5 - 1; j < index5 + 1; ++j)
          {
            if (Main.tile[i, j] != null && Main.tile[i, j].active())
              WorldGen.KillTile(i, j, noItem: true);
          }
        }
        short num4 = (short) (54 * num3);
        Main.tile[index4 - 1, index5 - 1].active(true);
        Main.tile[index4 - 1, index5 - 1].frameY = (short) 0;
        Main.tile[index4 - 1, index5 - 1].frameX = num4;
        Main.tile[index4 - 1, index5 - 1].type = type;
        Main.tile[index4, index5 - 1].active(true);
        Main.tile[index4, index5 - 1].frameY = (short) 0;
        Main.tile[index4, index5 - 1].frameX = (short) ((int) num4 + 18);
        Main.tile[index4, index5 - 1].type = type;
        Main.tile[index4 + 1, index5 - 1].active(true);
        Main.tile[index4 + 1, index5 - 1].frameY = (short) 0;
        Main.tile[index4 + 1, index5 - 1].frameX = (short) ((int) num4 + 36);
        Main.tile[index4 + 1, index5 - 1].type = type;
        Main.tile[index4 - 1, index5].active(true);
        Main.tile[index4 - 1, index5].frameY = (short) 18;
        Main.tile[index4 - 1, index5].frameX = num4;
        Main.tile[index4 - 1, index5].type = type;
        Main.tile[index4, index5].active(true);
        Main.tile[index4, index5].frameY = (short) 18;
        Main.tile[index4, index5].frameX = (short) ((int) num4 + 18);
        Main.tile[index4, index5].type = type;
        Main.tile[index4 + 1, index5].active(true);
        Main.tile[index4 + 1, index5].frameY = (short) 18;
        Main.tile[index4 + 1, index5].frameX = (short) ((int) num4 + 36);
        Main.tile[index4 + 1, index5].type = type;
      }
    }

    public static void CheckJunglePlant(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      if (Main.tile[i, j].frameY >= (short) 36 || Main.tile[i, j].type == (ushort) 236 || Main.tile[i, j].type == (ushort) 238)
      {
        bool flag = false;
        int num1 = (int) Main.tile[i, j].frameX / 18;
        int num2 = 0;
        while (num1 > 1)
        {
          num1 -= 2;
          ++num2;
        }
        int num3 = i - num1;
        int num4 = 36;
        if (type == 236 || type == 238)
          num4 = 0;
        int num5 = (int) Main.tile[i, j].frameY / 18;
        while (num5 > 1)
          num5 -= 2;
        int num6 = j - num5;
        int num7 = num2 * 36;
        for (int i1 = num3; i1 < num3 + 2; ++i1)
        {
          for (int index = num6; index < num6 + 2; ++index)
          {
            if (Main.tile[i1, index] == null)
              Main.tile[i1, index] = new Tile();
            if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || (int) Main.tile[i1, index].frameX != (i1 - num3) * 18 + num7 || (int) Main.tile[i1, index].frameY != (index - num6) * 18 + num4)
              flag = true;
          }
          if (Main.tile[i1, num6 + 2] == null)
            Main.tile[i1, num6 + 2] = new Tile();
          if (!WorldGen.SolidTile(i1, num6 + 2) || Main.tile[i1, num6 + 2].type != (ushort) 60)
            flag = true;
        }
        if (!flag)
          return;
        if (type == 238)
        {
          float num8 = (float) (i * 16);
          float num9 = (float) (j * 16);
          float num10 = -1f;
          int plr = 0;
          for (int index = 0; index < (int) byte.MaxValue; ++index)
          {
            float num11 = Math.Abs(Main.player[index].position.X - num8) + Math.Abs(Main.player[index].position.Y - num9);
            if ((double) num11 < (double) num10 || (double) num10 == -1.0)
            {
              plr = index;
              num10 = num11;
            }
          }
          if ((double) num10 / 16.0 < 50.0)
            NPC.SpawnOnPlayer(plr, 262);
        }
        if (type == 236)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1291);
        int frameX = (int) Main.tile[i, j].frameX;
        WorldGen.destroyObject = true;
        for (int i2 = num3; i2 < num3 + 2; ++i2)
        {
          for (int j1 = num6; j1 < num6 + 2; ++j1)
          {
            if (Main.tile[i2, j1] == null)
              Main.tile[i2, j1] = new Tile();
            if ((int) Main.tile[i2, j1].type == type && Main.tile[i2, j1].active())
              WorldGen.KillTile(i2, j1);
          }
        }
        WorldGen.destroyObject = false;
      }
      else
      {
        bool flag = false;
        int num12 = j + (int) Main.tile[i, j].frameY / 18 * -1;
        int num13 = (int) Main.tile[i, j].frameX / 18;
        int num14 = 0;
        while (num13 > 2)
        {
          num13 -= 3;
          ++num14;
        }
        int num15 = i - num13;
        int num16 = num14 * 54;
        for (int i3 = num15; i3 < num15 + 3; ++i3)
        {
          for (int index = num12; index < num12 + 2; ++index)
          {
            if (Main.tile[i3, index] == null)
              Main.tile[i3, index] = new Tile();
            if (!Main.tile[i3, index].active() || (int) Main.tile[i3, index].type != type || (int) Main.tile[i3, index].frameX != (i3 - num15) * 18 + num16 || (int) Main.tile[i3, index].frameY != (index - num12) * 18)
              flag = true;
          }
          if (Main.tile[i3, num12 + 2] == null)
            Main.tile[i3, num12 + 2] = new Tile();
          if (!WorldGen.SolidTile(i3, num12 + 2) || Main.tile[i3, num12 + 2].type != (ushort) 60)
            flag = true;
        }
        if (!flag)
          return;
        int frameX = (int) Main.tile[i, j].frameX;
        WorldGen.destroyObject = true;
        for (int i4 = num15; i4 < num15 + 3; ++i4)
        {
          for (int j2 = num12; j2 < num12 + 3; ++j2)
          {
            if (Main.tile[i4, j2] == null)
              Main.tile[i4, j2] = new Tile();
            if ((int) Main.tile[i4, j2].type == type && Main.tile[i4, j2].active())
              WorldGen.KillTile(i4, j2);
          }
        }
        WorldGen.destroyObject = false;
      }
    }

    public static void CheckSuper(int x, int y, int type)
    {
      if (WorldGen.destroyObject)
        return;
      Tile tile = Main.tile[x, y];
      int style = 0;
      if (type == 376)
        style = (int) tile.frameX / 36;
      if (type == 443)
        style = (int) tile.frameX / 36;
      if (type == 485)
        style = (int) tile.frameX / 36;
      bool flag1 = type == 376;
      bool flag2 = type == 443;
      bool flag3 = type == 444;
      bool flag4 = type == 485;
      TileObjectData tileData = TileObjectData.GetTileData(type, style);
      int num1 = tileData.StyleHorizontal ? 1 : 0;
      int width = tileData.Width;
      int height = tileData.Height;
      int num2 = x;
      int num3 = y;
      int x1 = num2 - (int) tile.frameX / 18 % width;
      int num4 = num3 - (int) tile.frameY / 18 % height;
      int num5 = 0;
      int num6 = 0;
      if (num1 != 0)
        num5 = (int) tile.frameX / tileData.CoordinateFullWidth;
      else
        num6 = (int) tile.frameY / tileData.CoordinateFullHeight;
      bool flag5 = false;
      bool flag6 = false;
      for (int index1 = 0; index1 < width; ++index1)
      {
        for (int index2 = 0; index2 < height; ++index2)
        {
          Tile tileSafely = Framing.GetTileSafely(x1 + index1, num4 + index2);
          if (!tileSafely.active() || (int) tileSafely.type != type || (int) tileSafely.frameX != num5 * tileData.CoordinateFullWidth + index1 * (tileData.CoordinateWidth + 2) || (int) tileSafely.frameY != num6 * tileData.CoordinateFullHeight + index2 * (tileData.CoordinateHeights[0] + 2))
            flag5 = true;
        }
      }
      if (flag1)
      {
        for (int index = 0; index < width; ++index)
        {
          Tile tileSafely = Framing.GetTileSafely(x1 + index, num4 + height);
          if (!tileSafely.active() || !Main.tileSolid[(int) tileSafely.type] && !Main.tileTable[(int) tileSafely.type])
            flag5 = true;
          if (tileSafely.halfBrick())
            flag5 = true;
        }
      }
      if (flag2)
      {
        bool flag7 = true;
        bool flag8 = true;
        for (int index = 0; index < width; ++index)
        {
          if (!WorldGen.AnchorValid(Framing.GetTileSafely(x1 + index, num4 + height), AnchorType.SolidTile | AnchorType.SolidWithTop | AnchorType.SolidSide))
            flag8 = false;
          if (!WorldGen.AnchorValid(Framing.GetTileSafely(x1 + index, num4 - 1), AnchorType.SolidBottom))
            flag7 = false;
        }
        if (!flag7 && !flag8)
          flag5 = true;
        if (!flag5)
        {
          int num7 = 0;
          if (flag8)
          {
            for (int index = 0; index < width; ++index)
              Framing.GetTileSafely(x1 + index, num4).frameX = (short) (index * 18 + style / 2 * 36 + num7 * 36);
          }
          else
          {
            for (int index = 0; index < width; ++index)
              Framing.GetTileSafely(x1 + index, num4).frameX = (short) (index * 18 + (style - 2) / 2 * 36 + 72 + num7 * 36);
          }
        }
      }
      if (flag3)
      {
        bool flag9 = true;
        for (int index = 0; index < width; ++index)
        {
          if (!WorldGen.AnchorValid(Framing.GetTileSafely(x1 + index, num4 - 1), AnchorType.SolidTile))
            flag9 = false;
        }
        if (!flag9)
          flag5 = true;
        for (int index3 = 0; index3 < width; ++index3)
        {
          for (int index4 = 0; index4 < height; ++index4)
          {
            if (Framing.GetTileSafely(x1 + index3, num4 + index4).liquid > (byte) 0)
            {
              flag5 = true;
              flag6 = true;
            }
          }
        }
      }
      if (flag4)
      {
        bool flag10 = true;
        for (int index = 0; index < width; ++index)
        {
          if (!WorldGen.AnchorValid(Framing.GetTileSafely(x1 + index, num4 + height), AnchorType.SolidTile))
            flag10 = false;
        }
        if (!flag10)
          flag5 = true;
      }
      if (!flag5)
        return;
      WorldGen.destroyObject = true;
      for (int index5 = 0; index5 < width; ++index5)
      {
        for (int index6 = 0; index6 < height; ++index6)
        {
          if ((int) Main.tile[x1 + index5, num4 + index6].type == type && Main.tile[x1 + index5, num4 + index6].active())
            WorldGen.KillTile(x1 + index5, num4 + index6);
        }
      }
      int Type = 0;
      if (type == 376)
      {
        switch (style)
        {
          case 0:
            Type = 2334;
            break;
          case 1:
            Type = 2335;
            break;
          case 2:
            Type = 2336;
            break;
          case 3:
            Type = 3203;
            break;
          case 4:
            Type = 3204;
            break;
          case 5:
            Type = 3205;
            break;
          case 6:
            Type = 3206;
            break;
          case 7:
            Type = 3207;
            break;
          case 8:
            Type = 3208;
            break;
          case 9:
            Type = 3979;
            break;
          case 10:
            Type = 3980;
            break;
          case 11:
            Type = 3981;
            break;
          case 12:
            Type = 3982;
            break;
          case 13:
            Type = 3983;
            break;
          case 14:
            Type = 3984;
            break;
          case 15:
            Type = 3985;
            break;
          case 16:
            Type = 3986;
            break;
          case 17:
            Type = 3987;
            break;
          case 18:
            Type = 4405;
            break;
          case 19:
            Type = 4406;
            break;
          case 20:
            Type = 4407;
            break;
          case 21:
            Type = 4408;
            break;
          case 22:
            Type = 4877;
            break;
          case 23:
            Type = 4878;
            break;
          case 24:
            Type = 5002;
            break;
          case 25:
            Type = 5003;
            break;
        }
      }
      if (type == 443)
        Type = 3722;
      if (type == 485 && !WorldGen.gen && Main.netMode != 1)
      {
        int csToSpawnUpToSlot = NPC.GetAvailableAmountOfNPCsToSpawnUpToSlot(1);
        for (int index = 0; index < csToSpawnUpToSlot; ++index)
        {
          int number = NPC.NewNPC((IEntitySource) WorldGen.GetNPCSource_TileBreak(x1, num4), x1 * 16, num4 * 16 + 32, 582);
          Main.npc[number].TargetClosest();
          Main.npc[number].velocity = new Vector2((float) Main.npc[number].direction * 1.5f, -5f);
          NetMessage.SendData(23, number: number);
          int num8 = 20;
          int num9 = -1;
          Main.npc[number].GetImmuneTime(num9, num8);
          NetMessage.SendData(131, number: number, number2: 1f, number3: ((float) num9), number4: ((float) num8));
        }
      }
      if (type == 444 && Main.netMode != 1 && !flag6)
        Projectile.NewProjectile((IEntitySource) WorldGen.GetProjectileSource_TileBreak(x1, num4), (float) (x1 * 16 + 16), (float) (num4 * 16 + 16), 0.0f, 0.0f, 655, 0, 0.0f, Main.myPlayer);
      if (Type != 0)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x1, num4), x1 * 16, num4 * 16, tileData.CoordinateFullWidth, tileData.CoordinateFullHeight, Type);
      WorldGen.destroyObject = false;
      for (int index7 = -1; index7 < width + 1; ++index7)
      {
        for (int index8 = -1; index8 < height + 1; ++index8)
          WorldGen.TileFrame(x1 + index7, num4 + index8);
      }
    }

    public static void Check2x2(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag1 = false;
      int num1 = 0;
      int num2 = (int) Main.tile[i, j].frameX / 18 * -1;
      if (num2 < -1)
      {
        num2 += 2;
        num1 = 36;
      }
      int index1 = num2 + i;
      int num3 = type == 172 ? 38 : 36;
      int frameY = (int) Main.tile[i, j].frameY;
      int num4 = 0;
      while (frameY >= num3)
      {
        frameY -= num3;
        ++num4;
      }
      int y = j - frameY / 18;
      int num5 = 0;
      if (type == 652)
      {
        num5 = (int) Main.tile[i, j].frameX / 36;
        index1 = (int) Main.tile[i, j].frameX % 36 / 18 * -1 + i;
        num1 = num5 * 36;
      }
      for (int i1 = index1; i1 < index1 + 2; ++i1)
      {
        for (int j1 = y; j1 < y + 2; ++j1)
        {
          Tile tileSafely = Framing.GetTileSafely(i1, j1);
          if (!tileSafely.active() || (int) tileSafely.type != type || (int) tileSafely.frameX != (i1 - index1) * 18 + num1 || (int) tileSafely.frameY != (j1 - y) * 18 + num4 * num3)
          {
            flag1 = true;
            break;
          }
        }
        if (type == 95 || type == 126)
        {
          Framing.GetTileSafely(i1, y - 1);
          if (!Main.tile[i1, y - 1].active() || !Main.tileSolid[(int) Main.tile[i1, y - 1].type] || Main.tileSolidTop[(int) Main.tile[i1, y - 1].type])
            flag1 = true;
        }
        else if (!TileID.Sets.Boulders[type] && type != 132)
        {
          Tile tileSafely = Framing.GetTileSafely(i1, y + 2);
          if (!tileSafely.active() || !Main.tileSolid[(int) tileSafely.type] && !Main.tileTable[(int) tileSafely.type])
            flag1 = true;
          if (tileSafely.halfBrick())
            flag1 = true;
        }
      }
      if (TileID.Sets.Boulders[type])
      {
        if (Main.tile[index1, y - 1] == null)
          Main.tile[index1, y - 1] = new Tile();
        if (Main.tile[index1 + 1, y - 1] == null)
          Main.tile[index1 + 1, y - 1] = new Tile();
        ushort type1 = Main.tile[index1, y - 1].type;
        ushort type2 = Main.tile[index1 + 1, y - 1].type;
        if ((TileID.Sets.BasicChest[(int) type1] || TileID.Sets.BasicChest[(int) type2] || type1 == (ushort) 88 || type2 == (ushort) 88 || TileID.Sets.BasicChestFake[(int) type1] || TileID.Sets.BasicChestFake[(int) type2] || type1 == (ushort) 470 || type2 == (ushort) 470 || type1 == (ushort) 475 ? 1 : (type2 == (ushort) 475 ? 1 : 0)) == 0 && !WorldGen.SolidTileAllowBottomSlope(index1, y + 2) && !WorldGen.SolidTileAllowBottomSlope(index1 + 1, y + 2))
          flag1 = true;
      }
      else if (type == 132)
      {
        flag1 = false;
        y = (int) Main.tile[i, j].frameY / 18 * -1 + j;
        int num6 = 0;
        int num7 = (int) Main.tile[i, j].frameX / 18 * -1;
        while (num7 < -1)
        {
          num7 += 2;
          num6 += 36;
        }
        index1 = num7 + i;
        for (int index2 = index1; index2 < index1 + 2; ++index2)
        {
          for (int index3 = y; index3 < y + 2; ++index3)
          {
            if (Main.tile[index2, index3] == null)
              Main.tile[index2, index3] = new Tile();
            if (!Main.tile[index2, index3].active() || (int) Main.tile[index2, index3].type != type || (int) Main.tile[index2, index3].frameX != (index2 - index1) * 18 + num6 || (int) Main.tile[index2, index3].frameY != (index3 - y) * 18)
              flag1 = true;
          }
        }
        if (Main.tile[index1, y + 2] == null)
          Main.tile[index1, y + 2] = new Tile();
        if (Main.tile[index1 + 1, y + 2] == null)
          Main.tile[index1 + 1, y + 2] = new Tile();
        bool flag2 = false;
        ushort type3 = Main.tile[index1, y + 2].type;
        ushort type4 = Main.tile[index1 + 1, y + 2].type;
        if (!Main.tile[index1, y + 2].active() || !Main.tileSolid[(int) type3] && !Main.tileSolidTop[(int) type3] || Main.tile[index1, y + 2].halfBrick() || Main.tile[index1, y + 2].slope() != (byte) 0 && !Main.tile[index1, y + 2].bottomSlope())
          flag2 = true;
        if (!Main.tile[index1 + 1, y + 2].active() || !Main.tileSolid[(int) type4] && !Main.tileSolidTop[(int) type4] || Main.tile[index1 + 1, y + 2].halfBrick() || Main.tile[index1 + 1, y + 2].slope() != (byte) 0 && !Main.tile[index1 + 1, y + 2].bottomSlope())
          flag2 = true;
        if (flag2)
        {
          if (Main.tile[index1, y].wall < (ushort) 1 || Main.tile[index1 + 1, y].wall < (ushort) 1 || Main.tile[index1, y + 1].wall < (ushort) 1 || Main.tile[index1 + 1, y + 1].wall < (ushort) 1)
            flag1 = true;
          else if (num6 < 72)
          {
            for (int index4 = index1; index4 < index1 + 2; ++index4)
            {
              for (int index5 = y; index5 < y + 2; ++index5)
                Main.tile[index4, index5].frameX += (short) 72;
            }
          }
        }
        else if (num6 >= 72)
        {
          for (int index6 = index1; index6 < index1 + 2; ++index6)
          {
            for (int index7 = y; index7 < y + 2; ++index7)
              Main.tile[index6, index7].frameX -= (short) 72;
          }
        }
      }
      if (!flag1)
        return;
      WorldGen.destroyObject = true;
      for (int i2 = index1; i2 < index1 + 2; ++i2)
      {
        for (int j2 = y; j2 < y + 2; ++j2)
        {
          if ((int) Main.tile[i2, j2].type == type && Main.tile[i2, j2].active())
            WorldGen.KillTile(i2, j2);
        }
      }
      int Type = 0;
      if (type <= 565)
      {
        switch (type - 521)
        {
          case 0:
            Type = 4327;
            break;
          case 1:
            Type = 4328;
            break;
          case 2:
            Type = 4329;
            break;
          case 3:
            Type = 4330;
            break;
          case 4:
            Type = 4331;
            break;
          case 5:
            Type = 4332;
            break;
          case 6:
            Type = 4333;
            break;
          default:
            if (type != 564)
            {
              if (type == 565)
              {
                Type = 4552;
                break;
              }
              break;
            }
            Type = 4553;
            break;
        }
      }
      else if (type != 594)
      {
        if (type != 621)
        {
          if (type == 622)
            Type = 5008;
        }
        else
          Type = 3750;
      }
      else
        Type = 4869;
      if (type == 598)
        Type = 4880;
      if (type == 360)
        Type = 3072;
      if (type == 580)
        Type = 4846;
      if (type == 620)
        Type = 4964;
      if (type == 505)
        Type = 4275;
      if (type == 543)
        Type = 4398;
      if (type == 568)
        Type = 4655;
      if (type == 569)
        Type = 4656;
      if (type == 570)
        Type = 4657;
      if (type >= 288 && type <= 295)
        Type = 2178 + type - 288;
      if (type >= 316 && type <= 318)
        Type = 2439 + type - 316;
      if (type == 85)
        Type = 321;
      if (type == 94)
        Type = 352;
      if (type == 95)
        Type = 344;
      if (type == 96)
        Type = 345;
      if (type == 97)
        Type = 346;
      if (type == 98)
        Type = 347;
      if (type == 99)
        Type = 348;
      if (type == 335)
        Type = 2700;
      if (type == 411)
        Type = 3545;
      if (type == 652)
        Type = num5 >= 3 ? (num5 >= 6 ? 331 : 62) : 195;
      if (type == 100)
      {
        if (num4 == 0)
          Type = 349;
        else if (num4 >= 1 && num4 <= 12)
          Type = 2092 + num4 - 1;
        else if (num4 >= 13 && num4 <= 16)
        {
          Type = 2149 + num4 - 13;
        }
        else
        {
          switch (num4)
          {
            case 17:
              Type = 2227;
              break;
            case 18:
              Type = 2522;
              break;
            case 19:
              Type = 2541;
              break;
            case 20:
              Type = 2555;
              break;
            case 21:
              Type = 2570;
              break;
            case 22:
              Type = 2664;
              break;
            case 23:
              Type = 2665;
              break;
            case 24:
              Type = 2666;
              break;
            case 25:
              Type = 2667;
              break;
            case 26:
              Type = 2668;
              break;
            case 27:
              Type = 2825;
              break;
            case 28:
              Type = 3168;
              break;
            case 29:
              Type = 3170;
              break;
            case 30:
              Type = 3169;
              break;
            case 31:
              Type = 3893;
              break;
            case 32:
              Type = 3935;
              break;
            case 33:
              Type = 3961;
              break;
            case 34:
              Type = 4149;
              break;
            case 35:
              Type = 4170;
              break;
            case 36:
              Type = 4191;
              break;
            case 37:
              Type = 4212;
              break;
            case 38:
              Type = 4302;
              break;
            case 39:
              Type = 4570;
              break;
            case 40:
              Type = 5152;
              break;
            case 41:
              Type = 5173;
              break;
            case 42:
              Type = 5194;
              break;
          }
        }
      }
      if (type == 173)
        Type = 714;
      if (type == 125)
        Type = 487;
      if (type == 287)
        Type = 2177;
      if (type == 126)
        Type = 488;
      if (type == 132)
        Type = 513;
      if (type == 142)
        Type = 581;
      if (type == 143)
        Type = 582;
      if (type == 282)
        Type = 250;
      if (type == 319)
        Type = 2490;
      if (type == 490)
        Type = 4075;
      if (type == 172)
      {
        Type = 2827 + num4;
        switch (num4)
        {
          case 29:
            Type = 3147;
            break;
          case 30:
            Type = 3149;
            break;
          case 31:
            Type = 3148;
            break;
          case 32:
            Type = 3896;
            break;
          case 33:
            Type = 3946;
            break;
          case 34:
            Type = 3972;
            break;
          case 35:
            Type = 4160;
            break;
          case 36:
            Type = 4181;
            break;
          case 37:
            Type = 4202;
            break;
          case 38:
            Type = 4223;
            break;
          case 39:
            Type = 4312;
            break;
          case 40:
            Type = 4581;
            break;
          case 41:
            Type = 5163;
            break;
          case 42:
            Type = 5184;
            break;
          case 43:
            Type = 5205;
            break;
        }
      }
      if (Type != 0)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, Type);
      if (!WorldGen.gen && Main.netMode != 1)
      {
        switch (type)
        {
          case 138:
            Projectile.NewProjectile((IEntitySource) WorldGen.GetProjectileSource_TileBreak(index1, y), (float) (index1 * 16) + 15.5f, (float) (y * 16 + 16), 0.0f, 0.0f, 99, 70, 10f, Main.myPlayer);
            break;
          case 484:
            Projectile.NewProjectile((IEntitySource) WorldGen.GetProjectileSource_TileBreak(index1, y), (float) (index1 * 16) + 15.5f, (float) (y * 16 + 16), 0.0f, 0.0f, 727, 35, 10f, Main.myPlayer);
            break;
          case 654:
            Projectile.NewProjectile((IEntitySource) WorldGen.GetProjectileSource_TileBreak(index1, y), (float) (index1 * 16 + 8), (float) (y * 16 + 8), 0.0f, 0.0f, 1002, 400, 10f, Main.myPlayer);
            break;
          case 664:
            Projectile.NewProjectile((IEntitySource) WorldGen.GetProjectileSource_TileBreak(index1, y), (float) (index1 * 16) + 15.5f, (float) (y * 16 + 16), 0.0f, 0.0f, 1013, 70, 10f, Main.myPlayer);
            break;
          case 665:
            Projectile.NewProjectile((IEntitySource) WorldGen.GetProjectileSource_TileBreak(index1, y), (float) (index1 * 16) + 15.5f, (float) (y * 16 + 16), 0.0f, 0.0f, 1014, 70, 10f, Main.myPlayer);
            break;
        }
      }
      WorldGen.destroyObject = false;
      for (int i3 = index1 - 1; i3 < index1 + 3; ++i3)
      {
        for (int j3 = y - 1; j3 < y + 3; ++j3)
          WorldGen.TileFrame(i3, j3);
      }
    }

    public static bool CheckBoulderChest(int i, int j)
    {
      int num1 = (int) Main.tile[i, j].frameX / 18 * -1;
      if (num1 < -1)
        num1 += 2;
      int index = num1 + i;
      int frameY = (int) Main.tile[i, j].frameY;
      while (frameY >= 36)
        frameY -= 36;
      int num2 = j - frameY / 18;
      return WorldGen.IsAContainer(Main.tile[index, num2 - 1]) || WorldGen.IsAContainer(Main.tile[index + 1, num2 - 1]);
    }

    public static bool IsAContainer(Tile t) => TileID.Sets.BasicDresser[(int) t.type] || t.type == (ushort) 470 || t.type == (ushort) 475 || TileID.Sets.BasicChest[(int) t.type] || TileID.Sets.BasicChestFake[(int) t.type];

    public static void OreRunner(int i, int j, double strength, int steps, ushort type)
    {
      double num1 = strength;
      double num2 = (double) steps;
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      Vector2D vector2D2;
      vector2D2.X = (double) WorldGen.genRand.Next(-10, 11) * 0.1;
      vector2D2.Y = (double) WorldGen.genRand.Next(-10, 11) * 0.1;
      while (num1 > 0.0 && num2 > 0.0)
      {
        if (vector2D1.Y < 0.0 && num2 > 0.0 && type == (ushort) 59)
          num2 = 0.0;
        num1 = strength * (num2 / (double) steps);
        --num2;
        int num3 = (int) (vector2D1.X - num1 * 0.5);
        int num4 = (int) (vector2D1.X + num1 * 0.5);
        int num5 = (int) (vector2D1.Y - num1 * 0.5);
        int num6 = (int) (vector2D1.Y + num1 * 0.5);
        if (num3 < 0)
          num3 = 0;
        if (num4 > Main.maxTilesX)
          num4 = Main.maxTilesX;
        if (num5 < 0)
          num5 = 0;
        if (num6 > Main.maxTilesY)
          num6 = Main.maxTilesY;
        for (int index1 = num3; index1 < num4; ++index1)
        {
          for (int index2 = num5; index2 < num6; ++index2)
          {
            if (Math.Abs((double) index1 - vector2D1.X) + Math.Abs((double) index2 - vector2D1.Y) < strength * 0.5 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015) && Main.tile[index1, index2].active() && (Main.tile[index1, index2].type == (ushort) 0 || Main.tile[index1, index2].type == (ushort) 1 || Main.tile[index1, index2].type == (ushort) 23 || Main.tile[index1, index2].type == (ushort) 25 || Main.tile[index1, index2].type == (ushort) 40 || Main.tile[index1, index2].type == (ushort) 53 || Main.tile[index1, index2].type == (ushort) 57 || Main.tile[index1, index2].type == (ushort) 59 || Main.tile[index1, index2].type == (ushort) 60 || Main.tile[index1, index2].type == (ushort) 70 || Main.tile[index1, index2].type == (ushort) 109 || Main.tile[index1, index2].type == (ushort) 112 || Main.tile[index1, index2].type == (ushort) 116 || Main.tile[index1, index2].type == (ushort) 117 || Main.tile[index1, index2].type == (ushort) 147 || Main.tile[index1, index2].type == (ushort) 161 || Main.tile[index1, index2].type == (ushort) 163 || Main.tile[index1, index2].type == (ushort) 164 || Main.tileMoss[(int) Main.tile[index1, index2].type] || Main.tile[index1, index2].type == (ushort) 199 || Main.tile[index1, index2].type == (ushort) 200 || Main.tile[index1, index2].type == (ushort) 203 || Main.tile[index1, index2].type == (ushort) 234 || Main.tile[index1, index2].type == (ushort) 396 || Main.tile[index1, index2].type == (ushort) 397 || Main.tile[index1, index2].type == (ushort) 401 || Main.tile[index1, index2].type == (ushort) 403 || Main.tile[index1, index2].type == (ushort) 400 || Main.tile[index1, index2].type == (ushort) 398 || Main.tile[index1, index2].type == (ushort) 399 || Main.tile[index1, index2].type == (ushort) 402 || Main.remixWorld && Main.tile[index1, index2].type == (ushort) 230 || Main.tile[index1, index2].type == (ushort) 225 && Main.tile[index1, index2].wall != (ushort) 108))
            {
              Main.tile[index1, index2].type = type;
              Main.tile[index1, index2].ClearBlockPaintAndCoating();
              WorldGen.SquareTileFrame(index1, index2);
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index1, index2);
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        if (vector2D2.X > 1.0)
          vector2D2.X = 1.0;
        if (vector2D2.X < -1.0)
          vector2D2.X = -1.0;
      }
    }

    public static void SmashAltar(int i, int j)
    {
      if (Main.netMode == 1 || !Main.hardMode || WorldGen.noTileActions || WorldGen.gen)
        return;
      int num1 = WorldGen.altarCount % 3;
      int num2 = WorldGen.altarCount / 3 + 1;
      double num3 = (double) Main.maxTilesX / 4200.0;
      int num4 = 1 - num1;
      double num5 = (num3 * 310.0 - (double) (85 * num1)) * 0.85 / (double) num2;
      bool flag = false;
      if (Main.drunkWorld)
      {
        switch (WorldGen.SavedOreTiers.Adamantite)
        {
          case 111:
            WorldGen.SavedOreTiers.Adamantite = 223;
            break;
          case 223:
            WorldGen.SavedOreTiers.Adamantite = 111;
            break;
        }
      }
      int type;
      switch (num1)
      {
        case 0:
          if (WorldGen.SavedOreTiers.Cobalt == -1)
          {
            flag = true;
            WorldGen.SavedOreTiers.Cobalt = 107;
            if (WorldGen.genRand.Next(2) == 0)
              WorldGen.SavedOreTiers.Cobalt = 221;
          }
          int index1 = 12;
          if (WorldGen.SavedOreTiers.Cobalt == 221)
          {
            index1 += 9;
            num5 *= 0.89999997615814209;
          }
          switch (Main.netMode)
          {
            case 0:
              Main.NewText(Lang.misc[index1].Value, (byte) 50, B: (byte) 130);
              break;
            case 2:
              ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[index1].Key), new Color(50, (int) byte.MaxValue, 130));
              break;
          }
          type = WorldGen.SavedOreTiers.Cobalt;
          num5 *= 1.0499999523162842;
          break;
        case 1:
          if (Main.drunkWorld)
          {
            if (WorldGen.SavedOreTiers.Mythril == 108)
              WorldGen.SavedOreTiers.Mythril = 222;
            else if (WorldGen.SavedOreTiers.Mythril == 222)
              WorldGen.SavedOreTiers.Mythril = 108;
          }
          if (WorldGen.SavedOreTiers.Mythril == -1)
          {
            flag = true;
            WorldGen.SavedOreTiers.Mythril = 108;
            if (WorldGen.genRand.Next(2) == 0)
              WorldGen.SavedOreTiers.Mythril = 222;
          }
          int index2 = 13;
          if (WorldGen.SavedOreTiers.Mythril == 222)
          {
            index2 += 9;
            num5 *= 0.89999997615814209;
          }
          switch (Main.netMode)
          {
            case 0:
              Main.NewText(Lang.misc[index2].Value, (byte) 50, B: (byte) 130);
              break;
            case 2:
              ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[index2].Key), new Color(50, (int) byte.MaxValue, 130));
              break;
          }
          type = WorldGen.SavedOreTiers.Mythril;
          break;
        default:
          if (Main.drunkWorld)
          {
            switch (WorldGen.SavedOreTiers.Cobalt)
            {
              case 107:
                WorldGen.SavedOreTiers.Cobalt = 221;
                break;
              case 221:
                WorldGen.SavedOreTiers.Cobalt = 107;
                break;
            }
          }
          if (WorldGen.SavedOreTiers.Adamantite == -1)
          {
            flag = true;
            WorldGen.SavedOreTiers.Adamantite = 111;
            if (WorldGen.genRand.Next(2) == 0)
              WorldGen.SavedOreTiers.Adamantite = 223;
          }
          int index3 = 14;
          if (WorldGen.SavedOreTiers.Adamantite == 223)
          {
            index3 += 9;
            num5 *= 0.89999997615814209;
          }
          switch (Main.netMode)
          {
            case 0:
              Main.NewText(Lang.misc[index3].Value, (byte) 50, B: (byte) 130);
              break;
            case 2:
              ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[index3].Key), new Color(50, (int) byte.MaxValue, 130));
              break;
          }
          type = WorldGen.SavedOreTiers.Adamantite;
          break;
      }
      if (flag)
        NetMessage.SendData(7);
      for (int index4 = 0; (double) index4 < num5; ++index4)
      {
        int i1 = WorldGen.genRand.Next(100, Main.maxTilesX - 100);
        double minValue = Main.worldSurface;
        if (type == 108 || type == 222)
          minValue = Main.rockLayer;
        if (type == 111 || type == 223)
          minValue = (Main.rockLayer + Main.rockLayer + (double) Main.maxTilesY) / 3.0;
        int j1 = WorldGen.genRand.Next((int) minValue, Main.maxTilesY - 150);
        if (Main.remixWorld)
        {
          double maxValue = (double) (Main.maxTilesX - 350);
          if (type == 108 || type == 222)
            maxValue = (Main.rockLayer + Main.rockLayer + (double) Main.maxTilesY - 350.0) / 3.0;
          if (type == 111 || type == 223)
            maxValue = Main.rockLayer - 25.0;
          j1 = WorldGen.genRand.Next((int) Main.worldSurface + 15, (int) maxValue);
        }
        if (Main.tenthAnniversaryWorld)
          WorldGen.OreRunner(i1, j1, (double) WorldGen.genRand.Next(5, 11 + num4), WorldGen.genRand.Next(5, 11 + num4), (ushort) type);
        else
          WorldGen.OreRunner(i1, j1, (double) WorldGen.genRand.Next(5, 9 + num4), WorldGen.genRand.Next(5, 9 + num4), (ushort) type);
      }
      if (Main.netMode != 1)
      {
        int num6 = Main.rand.Next(2) + 1;
        for (int index5 = 0; index5 < num6; ++index5)
          NPC.SpawnOnPlayer((int) Player.FindClosest(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16), 82);
      }
      ++WorldGen.altarCount;
      AchievementsHelper.NotifyProgressionEvent(6);
    }

    public static void Check3x1(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      if (Main.tile[i, j] == null)
        Main.tile[i, j] = new Tile();
      int num1 = (int) Main.tile[i, j].frameX / 18;
      int num2 = 0;
      while (num1 > 2)
      {
        num1 -= 3;
        ++num2;
      }
      int num3 = i - num1;
      int num4 = num2 * 54;
      for (int i1 = num3; i1 < num3 + 3; ++i1)
      {
        int index = j;
        if (Main.tile[i1, index] == null)
          Main.tile[i1, index] = new Tile();
        if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || (int) Main.tile[i1, index].frameX != (i1 - num3) * 18 + num4 || Main.tile[i1, index].frameY != (short) 0)
          flag = true;
        if (Main.tile[i1, index - 1] == null)
          Main.tile[i1, index - 1] = new Tile();
        if (Main.tile[i1, index - 1].active() && (TileID.Sets.BasicChest[(int) Main.tile[i1, index - 1].type] || TileID.Sets.BasicChestFake[(int) Main.tile[i1, index - 1].type] || Main.tile[i1, index - 1].type == (ushort) 88 || Main.tile[i1, index - 1].type == (ushort) 470 || Main.tile[i1, index - 1].type == (ushort) 475 || Main.tile[i1, index - 1].type == (ushort) 597))
          return;
        if (!WorldGen.SolidTileAllowBottomSlope(i1, index + 1))
          flag = true;
      }
      if (!flag)
        return;
      int frameX = (int) Main.tile[i, j].frameX;
      WorldGen.destroyObject = true;
      if (type == 235)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1263);
      for (int i2 = num3; i2 < num3 + 3; ++i2)
      {
        int j1 = j;
        if (Main.tile[i2, j1] == null)
          Main.tile[i2, j1] = new Tile();
        if ((int) Main.tile[i2, j1].type == type && Main.tile[i2, j1].active())
          WorldGen.KillTile(i2, j1);
      }
      WorldGen.destroyObject = false;
      for (int i3 = num3 - 1; i3 < num3 + 4; ++i3)
      {
        int j2 = j;
        WorldGen.TileFrame(i3, j2);
      }
    }

    public static void Check3x2(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag1 = false;
      bool flag2 = false;
      int num1 = j;
      if (Main.tile[i, j] == null)
        Main.tile[i, j] = new Tile();
      int num2 = 36;
      int num3 = (int) Main.tile[i, j].frameY / num2;
      int num4 = (int) Main.tile[i, j].frameY % num2;
      int index1 = num1 - num4 / 18;
      int num5 = (int) Main.tile[i, j].frameX / 18;
      int style = 0;
      while (num5 > 2)
      {
        num5 -= 3;
        ++style;
      }
      int index2 = i - num5;
      int num6 = style * 54;
      if (type == 14 && style == 25)
        flag2 = true;
      int j1 = index1 + 2;
      if (flag2)
        --j1;
      for (int i1 = index2; i1 < index2 + 3; ++i1)
      {
        for (int index3 = index1; index3 < j1; ++index3)
        {
          if (Main.tile[i1, index3] == null)
            Main.tile[i1, index3] = new Tile();
          if (!Main.tile[i1, index3].active() || (int) Main.tile[i1, index3].type != type || (int) Main.tile[i1, index3].frameX != (i1 - index2) * 18 + num6 || (int) Main.tile[i1, index3].frameY != (index3 - index1) * 18 + num3 * 36)
            flag1 = true;
        }
        if (type == 285 || type == 286 || type == 298 || type == 299 || type == 310 || type == 339 || type == 538 || type >= 361 && type <= 364 || type == 532 || type == 544 || type == 533 || type == 555 || type == 556 || type == 582 || type == 619 || type == 629)
        {
          if (!WorldGen.SolidTileAllowBottomSlope(i1, j1) && (Main.tile[i1, j1] == null || !Main.tile[i1, j1].nactive() || !Main.tileSolidTop[(int) Main.tile[i1, j1].type] || Main.tile[i1, j1].frameY != (short) 0) && (Main.tile[i1, j1] == null || !Main.tile[i1, j1].active() || !TileID.Sets.Platforms[(int) Main.tile[i1, j1].type]))
            flag1 = true;
        }
        else if (type == 488)
        {
          int num7 = 0;
          if (Main.tile[i1, j1] != null && Main.tile[i1, j1].active())
            num7 = (int) Main.tile[i1, j1].type;
          if ((num7 == 2 || num7 == 477 || num7 == 109 ? 1 : (num7 == 492 ? 1 : 0)) == 0)
            flag1 = true;
        }
        else if (type == 26)
        {
          Tile tile = Main.tile[i1, j1];
          if (!WorldGen.SolidTileAllowBottomSlope(i1, j1) || tile != null && tile.active() && TileID.Sets.Boulders[(int) tile.type])
            flag1 = true;
        }
        else if (type == 186)
        {
          if (!WorldGen.SolidTileAllowBottomSlope(i1, j1))
          {
            flag1 = true;
          }
          else
          {
            Tile tile = Main.tile[i1, j1];
            if (tile != null && tile.active())
            {
              switch (style)
              {
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                  if (!TileID.Sets.Snow[(int) tile.type] && !TileID.Sets.Conversion.Ice[(int) tile.type] && tile.type != (ushort) 162 && tile.type != (ushort) 224)
                  {
                    flag1 = true;
                    break;
                  }
                  break;
                case 32:
                case 33:
                case 34:
                  if (!TileID.Sets.Mud[(int) tile.type] && tile.type != (ushort) 70)
                  {
                    flag1 = true;
                    break;
                  }
                  break;
              }
            }
          }
        }
        if (type == 187)
        {
          if (!WorldGen.SolidTileAllowBottomSlope(i1, j1))
          {
            flag1 = true;
          }
          else
          {
            Tile tile = Main.tile[i1, j1];
            if (tile != null && tile.active())
            {
              switch (style)
              {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                  if (!TileID.Sets.Mud[(int) tile.type] && tile.type != (ushort) 60 && tile.type != (ushort) 226)
                  {
                    flag1 = true;
                    continue;
                  }
                  continue;
                case 6:
                case 7:
                case 8:
                  if (tile.type != (ushort) 57 && tile.type != (ushort) 58 && tile.type != (ushort) 75 && tile.type != (ushort) 76)
                  {
                    flag1 = true;
                    continue;
                  }
                  continue;
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                  if (!TileID.Sets.Conversion.Sand[(int) tile.type] && !TileID.Sets.Conversion.HardenedSand[(int) tile.type] && !TileID.Sets.Conversion.Sandstone[(int) tile.type])
                  {
                    flag1 = true;
                    continue;
                  }
                  continue;
                default:
                  continue;
              }
            }
          }
        }
        else if (!WorldGen.SolidTileAllowBottomSlope(i1, j1))
          flag1 = true;
      }
      if (type == 187 && Main.tile[index2, index1] != null && Main.tile[index2, index1].frameX >= (short) 756 && Main.tile[index2, index1].frameX <= (short) 900 && Main.tile[index2, index1 + 2].type != (ushort) 2 && Main.tile[index2 + 1, index1 + 2].type != (ushort) 2 && Main.tile[index2 + 2, index1 + 2].type != (ushort) 2 && Main.tile[index2, index1 + 2].type != (ushort) 477 && Main.tile[index2 + 1, index1 + 2].type != (ushort) 477 && Main.tile[index2 + 2, index1 + 2].type != (ushort) 477 && Main.tile[index2, index1 + 2].type != (ushort) 492 && Main.tile[index2 + 1, index1 + 2].type != (ushort) 492 && Main.tile[index2 + 2, index1 + 2].type != (ushort) 492)
      {
        Main.tile[index2, index1].frameX -= (short) 378;
        Main.tile[index2 + 1, index1].frameX -= (short) 378;
        Main.tile[index2 + 2, index1].frameX -= (short) 378;
        Main.tile[index2, index1 + 1].frameX -= (short) 378;
        Main.tile[index2 + 1, index1 + 1].frameX -= (short) 378;
        Main.tile[index2 + 2, index1 + 1].frameX -= (short) 378;
        Main.tile[index2, index1].type = (ushort) 186;
        Main.tile[index2 + 1, index1].type = (ushort) 186;
        Main.tile[index2 + 2, index1].type = (ushort) 186;
        Main.tile[index2, index1 + 1].type = (ushort) 186;
        Main.tile[index2 + 1, index1 + 1].type = (ushort) 186;
        Main.tile[index2 + 2, index1 + 1].type = (ushort) 186;
      }
      if (flag1 && type == 488 && WorldGen.gen)
      {
        for (int index4 = index2; index4 < index2 + 3; ++index4)
        {
          for (int index5 = index1; index5 < index1 + 2; ++index5)
          {
            Main.tile[index4, index5].active(true);
            Main.tile[index4, index5].type = (ushort) 488;
            Main.tile[index4, index5].frameX = (short) ((index4 - index2) * 18);
            Main.tile[index4, index5].frameY = (short) ((index5 - index1) * 18);
          }
          Main.tile[index4, index1 + 2].active(true);
          Main.tile[index4, index1 + 2].type = (ushort) 2;
          Main.tile[index4, index1 + 2].slope((byte) 0);
          Main.tile[index4, index1 + 2].halfBrick(false);
        }
        flag1 = false;
      }
      if (!flag1)
        return;
      int frameX = (int) Main.tile[i, j].frameX;
      WorldGen.destroyObject = true;
      int num8 = index1 + 3;
      if (flag2)
      {
        int num9 = num8 - 1;
      }
      for (int i2 = index2; i2 < index2 + 3; ++i2)
      {
        for (int j2 = index1; j2 < index1 + 3; ++j2)
        {
          if (Main.tile[i2, j2] == null)
            Main.tile[i2, j2] = new Tile();
          if ((int) Main.tile[i2, j2].type == type && Main.tile[i2, j2].active())
            WorldGen.KillTile(i2, j2);
        }
      }
      if (type == 14)
      {
        int Type = style < 1 || style > 3 ? (style < 15 || style > 20 ? (style < 4 || style > 7 ? (style != 8 ? (style != 9 ? (style != 10 ? (style != 11 ? (style != 12 ? (style != 13 ? (style != 14 ? (style != 23 ? (style != 21 ? (style != 22 ? (style != 24 ? (style != 25 ? (style != 26 ? (style != 27 ? (style != 28 ? (style != 29 ? (style != 30 ? (style != 31 ? (style != 32 ? (style != 33 ? (style != 34 ? 32 : 3154) : 3155) : 3153) : 2824) : 2743) : 2583) : 677) : 2550) : 2532) : 2259) : 2248) : 1816) : 1794) : 1926) : 1510) : 1460) : 1403) : 1400) : 1397) : 1144) : 917) : 823 + style) : 1698 + style) : 637 + style;
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, Type);
      }
      if (type == 469)
      {
        int Type = 3920;
        if (style == 1)
          Type = 3948;
        if (style == 2)
          Type = 3974;
        if (style == 3)
          Type = 4162;
        if (style == 4)
          Type = 4183;
        if (style == 5)
          Type = 4204;
        if (style == 6)
          Type = 4225;
        if (style == 7)
          Type = 4314;
        if (style == 8)
          Type = 4583;
        if (style == 9)
          Type = 5165;
        if (style == 10)
          Type = 5186;
        if (style == 11)
          Type = 5207;
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, Type);
      }
      else if (type == 114)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 398);
      else if (type == 26)
      {
        if (!WorldGen.noTileActions && !WorldGen.IsGeneratingHardMode)
          WorldGen.SmashAltar(i, j);
      }
      else if (type == 298)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2190);
      else if (type == 299)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2191);
      else if (type >= 361 && type <= 364)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3073 + type - 361);
      else if (type >= 391 && type <= 394)
      {
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 48, 32, 3254 + type - 391);
      }
      else
      {
        switch (type)
        {
          case 17:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 33);
            break;
          case 77:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 221);
            break;
          case 86:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 332);
            break;
          case 87:
            int Type1 = style < 1 || style > 3 ? (style != 4 ? (style < 5 || style > 7 ? (style < 8 || style > 10 ? (style < 11 || style > 20 ? (style != 21 ? (style != 22 ? (style != 23 ? (style != 24 ? (style != 25 ? (style != 26 ? (style != 27 ? (style != 28 ? (style != 29 ? (style != 30 ? (style != 31 ? (style != 32 ? (style != 33 ? (style != 34 ? (style != 35 ? (style != 36 ? (style != 37 ? (style != 38 ? (style != 39 ? (style != 40 ? (style != 41 ? (style != 42 ? 333 : 5203) : 5182) : 5161) : 4579) : 4310) : 4221) : 4200) : 4179) : 4158) : 3971) : 3944) : 3916) : 3915) : 3142) : 3143) : 3141) : 2821) : 2671) : 2580) : 2565) : 2548) : 2531) : 2376 + style - 11) : 2254 + style - 8) : 2245 + style - 5) : 919) : 640 + style;
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, Type1);
            break;
          case 88:
            int dresserItemDrop = WorldGen.GetDresserItemDrop(style);
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, dresserItemDrop);
            break;
          case 89:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, WorldGen.GetItemDrop_Benches(style));
            break;
          case 133:
            if (frameX >= 54)
            {
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1221);
              break;
            }
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 524);
            break;
          case 186:
            if (frameX >= 864)
            {
              if (frameX <= 954)
              {
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100));
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(30, 100));
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(40, 100));
                if (WorldGen.genRand.Next(3) != 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100));
                if (WorldGen.genRand.Next(3) != 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(30, 100));
                if (WorldGen.genRand.Next(3) != 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(40, 100));
                if (WorldGen.genRand.Next(2) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100));
                if (WorldGen.genRand.Next(2) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(30, 100));
                if (WorldGen.genRand.Next(2) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(40, 100));
                if (WorldGen.genRand.Next(3) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100));
                if (WorldGen.genRand.Next(3) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(30, 100));
                if (WorldGen.genRand.Next(3) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(40, 100));
                if (WorldGen.genRand.Next(4) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100));
                if (WorldGen.genRand.Next(4) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(30, 100));
                if (WorldGen.genRand.Next(4) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(40, 100));
                if (WorldGen.genRand.Next(5) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100));
                if (WorldGen.genRand.Next(5) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(30, 100));
                if (WorldGen.genRand.Next(5) == 0)
                {
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(40, 100));
                  break;
                }
                break;
              }
              if (frameX <= 1062)
              {
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, WorldGen.genRand.Next(10, 100));
                if (WorldGen.genRand.Next(2) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, WorldGen.genRand.Next(20, 100));
                if (WorldGen.genRand.Next(3) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, WorldGen.genRand.Next(30, 100));
                if (WorldGen.genRand.Next(4) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, WorldGen.genRand.Next(40, 100));
                if (WorldGen.genRand.Next(5) == 0)
                {
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, WorldGen.genRand.Next(50, 100));
                  break;
                }
                break;
              }
              if (frameX <= 1170)
              {
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, WorldGen.genRand.Next(1, 7));
                if (WorldGen.genRand.Next(2) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, WorldGen.genRand.Next(2, 7));
                if (WorldGen.genRand.Next(3) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, WorldGen.genRand.Next(3, 7));
                if (WorldGen.genRand.Next(4) == 0)
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, WorldGen.genRand.Next(4, 7));
                if (WorldGen.genRand.Next(5) == 0)
                {
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, WorldGen.genRand.Next(5, 7));
                  break;
                }
                break;
              }
              break;
            }
            break;
          case 215:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, WorldGen.GetCampfireItemDrop(style));
            break;
          case 217:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 995);
            break;
          case 218:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 996);
            break;
          case 219:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 997);
            break;
          case 220:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 998);
            break;
          case 228:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1120);
            break;
          case 237:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1292);
            break;
          case 244:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1449);
            break;
          case 285:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2174);
            break;
          case 286:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2175);
            break;
          case 310:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2207);
            break;
          case 339:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2741);
            break;
          case 377:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3198);
            break;
          case 405:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3364);
            break;
          case 486:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4063);
            break;
          case 488:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 9, WorldGen.genRand.Next(10, 21));
            break;
          case 532:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4364);
            break;
          case 533:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4376);
            break;
          case 538:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4380);
            break;
          case 544:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4399);
            break;
          case 555:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4475);
            break;
          case 556:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4476);
            break;
          case 582:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4850);
            break;
          case 619:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4963);
            break;
          case 629:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5133);
            break;
          case 642:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5296);
            break;
          case 647:
            int Type2 = 0;
            if (style < 7)
              Type2 = 154;
            else if (style < 13)
              Type2 = 3;
            else if (style < 16)
              Type2 = 3;
            else if (style < 18)
              Type2 = 71;
            else if (style < 20)
              Type2 = 72;
            else if (style < 22)
              Type2 = 73;
            else if (style < 26)
              Type2 = 9;
            else if (style < 32)
              Type2 = 593;
            else if (style < 35)
              Type2 = 183;
            if (Type2 != 0)
            {
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, Type2);
              break;
            }
            break;
          case 648:
            int num10 = style + num3 * 35;
            int Type3 = 0;
            if (num10 < 6)
              Type3 = 195;
            else if (num10 < 9)
              Type3 = 174;
            else if (num10 < 14)
              Type3 = 150;
            else if (num10 < 17)
              Type3 = 3;
            else if (num10 < 18)
              Type3 = 989;
            else if (num10 < 21)
              Type3 = 1101;
            else if (num10 < 29)
              Type3 = 9;
            else if (num10 < 35)
              Type3 = 3271;
            else if (num10 < 41)
              Type3 = 3086;
            else if (num10 < 47)
              Type3 = 3081;
            else if (num10 < 52)
              Type3 = 62;
            else if (num10 < 55)
              Type3 = 154;
            if (Type3 != 0)
            {
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, Type3);
              break;
            }
            break;
          case 651:
            int Type4 = style >= 3 ? (style >= 6 ? 331 : 62) : 195;
            if (Type4 != 0)
            {
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, Type4);
              break;
            }
            break;
          default:
            if (type == 187 && frameX >= 918 && frameX <= 970)
            {
              if (Main.rand.Next(50) == 0)
              {
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4144);
                break;
              }
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 989);
              break;
            }
            break;
        }
      }
      WorldGen.destroyObject = false;
      for (int i3 = index2 - 1; i3 < index2 + 4; ++i3)
      {
        for (int j3 = index1 - 1; j3 < index1 + 4; ++j3)
          WorldGen.TileFrame(i3, j3);
      }
      if (type != 488)
        return;
      WorldGen.mysticLogsEvent.FallenLogDestroyed();
    }

    private static int GetDresserItemDrop(int style) => style < 1 || style > 3 ? (style != 4 ? (style < 5 || style > 15 ? (style != 16 ? (style != 17 ? (style != 18 ? (style != 19 ? (style != 20 ? (style != 21 ? (style != 22 ? (style != 23 ? (style != 24 ? (style != 25 ? (style != 26 ? (style != 27 ? (style != 28 ? (style != 29 ? (style != 30 ? (style != 31 ? (style != 32 ? (style != 33 ? (style != 34 ? (style != 35 ? (style != 36 ? (style != 37 ? (style != 38 ? (style != 39 ? (style != 40 ? (style != 41 ? (style != 42 ? 334 : 5193) : 5172) : 5151) : 4569) : 4301) : 4211) : 4190) : 4169) : 4148) : 3968) : 3934) : 3914) : 3913) : 3912) : 3911) : 3133) : 3134) : 3132) : 2816) : 2640) : 2639) : 2638) : 2637) : 2577) : 2562) : 2545) : 2529) : 2386 + style - 5) : 918) : 646 + style;

    private static int GetCampfireItemDrop(int style)
    {
      if (style == 0)
        return 966;
      if (style >= 1 && style <= 5)
        return 3046 + style - 1;
      if (style == 6)
        return 3723;
      if (style == 7)
        return 3724;
      if (style >= 8 && style <= 13)
        return 4689 + style - 8;
      if (style == 14)
        return 5299;
      return style == 15 ? 5357 : 966;
    }

    public static void Check3x4(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = i;
      int num2 = j;
      int num3 = 0;
      int num4 = 0;
      int num5 = (int) Main.tile[i, j].frameX / 18;
      int num6 = (int) Main.tile[i, j].frameY / 18;
      for (; num5 >= 3; num5 -= 3)
        ++num3;
      for (; num6 >= 4; num6 -= 4)
        ++num4;
      int num7 = num1 - num5;
      int num8 = num2 - num6;
      for (int i1 = num7; i1 < num7 + 3; ++i1)
      {
        for (int index = num8; index < num8 + 4; ++index)
        {
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || (int) Main.tile[i1, index].frameX != num3 * 54 + (i1 - num7) * 18 || (int) Main.tile[i1, index].frameY != num4 * 72 + (index - num8) * 18)
            flag = true;
        }
        if (Main.tile[i1, num8 + 4] == null)
          Main.tile[i1, num8 + 4] = new Tile();
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num8 + 4))
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i2 = num7; i2 < num7 + 3; ++i2)
      {
        for (int j1 = num8; j1 < num8 + 4; ++j1)
        {
          if ((int) Main.tile[i2, j1].type == type && Main.tile[i2, j1].active())
            WorldGen.KillTile(i2, j1);
        }
      }
      switch (type)
      {
        case 101:
          int Type1 = num3 != 1 ? (num3 != 2 ? (num3 != 3 ? (num3 != 4 ? (num3 != 5 ? (num3 != 6 ? (num3 != 7 ? (num3 != 8 ? (num3 != 9 ? (num3 != 10 ? (num3 != 11 ? (num3 != 12 ? (num3 != 13 ? (num3 != 14 ? (num3 != 15 ? (num3 != 16 ? (num3 != 17 ? (num3 < 18 || num3 > 21 ? (num3 != 22 ? (num3 != 23 ? (num3 != 24 ? (num3 != 25 ? (num3 != 26 ? (num3 != 27 ? (num3 != 28 ? (num3 != 29 ? (num3 != 30 ? (num3 != 31 ? (num3 != 32 ? (num3 != 33 ? (num3 != 34 ? (num3 != 35 ? (num3 != 36 ? (num3 != 37 ? (num3 != 38 ? (num3 != 39 ? (num3 != 40 ? (num3 != 41 ? (num3 != 42 ? (num3 != 43 ? 354 : 5192) : 5171) : 5150) : 4568) : 4300) : 4210) : 4189) : 4168) : 4147) : 3960) : 3933) : 3917) : 3166) : 3167) : 3165) : 2817) : 2670) : 2569) : 2554) : 2540) : 2536) : 2233) : 2135 + num3 - 18) : 2031) : 2030) : 2029) : 2028) : 2027) : 2026) : 2025) : 2024) : 2023) : 2022) : 2021) : 2020) : 1512) : 1463) : 1416) : 1415) : 1414;
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, Type1);
          break;
        case 102:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 355);
          break;
        case 463:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3813);
          break;
        case 617:
          if (num3 == 27)
          {
            short Type2 = 5110;
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, (int) Type2);
            break;
          }
          int Type3 = 4924 + num3;
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, Type3);
          break;
      }
      WorldGen.destroyObject = false;
      for (int i3 = num7 - 1; i3 < num7 + 4; ++i3)
      {
        for (int j2 = num8 - 1; j2 < num8 + 4; ++j2)
          WorldGen.TileFrame(i3, j2);
      }
    }

    public static void Check5x4(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = i;
      int num2 = j;
      int num3 = 0;
      int num4;
      for (num4 = (int) Main.tile[i, j].frameX / 18; num4 >= 5; num4 -= 5)
        ++num3;
      int num5 = num1 - num4;
      int num6 = num2 + (int) Main.tile[i, j].frameY / 18 * -1;
      for (int i1 = num5; i1 < num5 + 5; ++i1)
      {
        for (int index = num6; index < num6 + 4; ++index)
        {
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || (int) Main.tile[i1, index].frameX != num3 * 90 + (i1 - num5) * 18 || (int) Main.tile[i1, index].frameY != (index - num6) * 18)
            flag = true;
        }
        if (Main.tile[i1, num6 + 4] == null)
          Main.tile[i1, num6 + 4] = new Tile();
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num6 + 4))
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i2 = num5; i2 < num5 + 5; ++i2)
      {
        for (int j1 = num6; j1 < num6 + 4; ++j1)
        {
          if ((int) Main.tile[i2, j1].type == type && Main.tile[i2, j1].active())
            WorldGen.KillTile(i2, j1);
        }
      }
      if (type == 464)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3814);
      if (type == 466)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3816);
      WorldGen.destroyObject = false;
      for (int i3 = num5 - 1; i3 < num5 + 6; ++i3)
      {
        for (int j2 = num6 - 1; j2 < num6 + 5; ++j2)
          WorldGen.TileFrame(i3, j2);
      }
    }

    public static void Check6x3(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = i;
      int num2 = j;
      int num3 = num1 + (int) Main.tile[i, j].frameX / 18 * -1;
      int num4 = num2 + (int) Main.tile[i, j].frameY / 18 * -1;
      for (int i1 = num3; i1 < num3 + 6; ++i1)
      {
        for (int index = num4; index < num4 + 3; ++index)
        {
          int num5 = (i1 - num3) * 18;
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || (int) Main.tile[i1, index].frameX != num5 || (int) Main.tile[i1, index].frameY != (index - num4) * 18)
            flag = true;
        }
        if (Main.tile[i1, num4 + 3] == null)
          Main.tile[i1, num4 + 3] = new Tile();
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num4 + 3) && (!Main.tile[i1, num4 + 3].nactive() || !Main.tileSolidTop[(int) Main.tile[i1, num4 + 3].type] || Main.tile[i1, num4 + 3].frameY != (short) 0))
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i2 = num3; i2 < num3 + 6; ++i2)
      {
        for (int j1 = num4; j1 < num4 + 3; ++j1)
        {
          if ((int) Main.tile[i2, j1].type == type && Main.tile[i2, j1].active())
            WorldGen.KillTile(i2, j1);
        }
      }
      if (type == 275)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2162);
      if (type == 413)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3565);
      if (type == 414)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3566);
      if (type == 276)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2163);
      if (type == 277)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2164);
      if (type == 278)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2165);
      if (type == 279)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2166);
      if (type == 280)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2167);
      if (type == 281)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2168);
      if (type == 296)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2186);
      if (type == 297)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2187);
      if (type == 309)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2206);
      if (type == 358)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3070);
      if (type == 359)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3071);
      if (type == 542)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4396);
      if (type == 550)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4461);
      if (type == 551)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4462);
      if (type == 553)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4473);
      if (type == 554)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4474);
      if (type == 558)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4481);
      if (type == 559)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4483);
      if (type == 599)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4882);
      if (type == 600)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4883);
      if (type == 601)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4884);
      if (type == 602)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4885);
      if (type == 603)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4886);
      if (type == 604)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4887);
      if (type == 605)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4888);
      if (type == 606)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4889);
      if (type == 607)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4890);
      if (type == 608)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4891);
      if (type == 609)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4892);
      if (type == 610)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4893);
      if (type == 611)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4894);
      if (type == 612)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4895);
      if (type == 632)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5213);
      if (type == 640)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5301);
      if (type == 643)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5314);
      if (type == 644)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5315);
      if (type == 645)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5316);
      WorldGen.destroyObject = false;
      for (int i3 = num3 - 1; i3 < num3 + 7; ++i3)
      {
        for (int j2 = num4 - 1; j2 < num4 + 4; ++j2)
          WorldGen.TileFrame(i3, j2);
      }
    }

    public static void Place6x3(int x, int y, ushort type, int direction = -1, int style = 0)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
        return;
      bool flag = true;
      for (int i = x - 3; i < x + 3; ++i)
      {
        for (int index = y - 2; index <= y; ++index)
        {
          if (Main.tile[i, index] == null)
            Main.tile[i, index] = new Tile();
          if (Main.tile[i, index].active())
            flag = false;
        }
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (!WorldGen.SolidTile2(i, y + 1) && (!Main.tile[i, y + 1].nactive() || !Main.tileSolidTop[(int) Main.tile[i, y + 1].type] || Main.tile[i, y + 1].frameY != (short) 0))
          flag = false;
      }
      if (!flag)
        return;
      int num1 = 0;
      for (int index1 = x - 3; index1 < x + 3; ++index1)
      {
        int num2 = 0;
        for (int index2 = y - 2; index2 <= y; ++index2)
        {
          Main.tile[index1, index2].active(true);
          Main.tile[index1, index2].frameY = (short) num2;
          Main.tile[index1, index2].frameX = (short) num1;
          Main.tile[index1, index2].type = type;
          num2 += 18;
        }
        num1 += 18;
      }
    }

    public static void Place4x2(int x, int y, ushort type, int direction = -1, int style = 0)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
        return;
      bool flag = true;
      for (int i = x - 1; i < x + 3; ++i)
      {
        for (int index = y - 1; index < y + 1; ++index)
        {
          if (Main.tile[i, index] == null)
            Main.tile[i, index] = new Tile();
          if (Main.tile[i, index].active())
            flag = false;
        }
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (!WorldGen.SolidTile2(i, y + 1))
          flag = false;
      }
      short num1 = 0;
      if (direction == 1)
        num1 = (short) 72;
      int num2 = 36 * style;
      if (!flag)
        return;
      Main.tile[x - 1, y - 1].active(true);
      Main.tile[x - 1, y - 1].frameY = (short) num2;
      Main.tile[x - 1, y - 1].frameX = num1;
      Main.tile[x - 1, y - 1].type = type;
      Main.tile[x, y - 1].active(true);
      Main.tile[x, y - 1].frameY = (short) num2;
      Main.tile[x, y - 1].frameX = (short) (18 + (int) num1);
      Main.tile[x, y - 1].type = type;
      Main.tile[x + 1, y - 1].active(true);
      Main.tile[x + 1, y - 1].frameY = (short) num2;
      Main.tile[x + 1, y - 1].frameX = (short) (36 + (int) num1);
      Main.tile[x + 1, y - 1].type = type;
      Main.tile[x + 2, y - 1].active(true);
      Main.tile[x + 2, y - 1].frameY = (short) num2;
      Main.tile[x + 2, y - 1].frameX = (short) (54 + (int) num1);
      Main.tile[x + 2, y - 1].type = type;
      Main.tile[x - 1, y].active(true);
      Main.tile[x - 1, y].frameY = (short) (num2 + 18);
      Main.tile[x - 1, y].frameX = num1;
      Main.tile[x - 1, y].type = type;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) (num2 + 18);
      Main.tile[x, y].frameX = (short) (18 + (int) num1);
      Main.tile[x, y].type = type;
      Main.tile[x + 1, y].active(true);
      Main.tile[x + 1, y].frameY = (short) (num2 + 18);
      Main.tile[x + 1, y].frameX = (short) (36 + (int) num1);
      Main.tile[x + 1, y].type = type;
      Main.tile[x + 2, y].active(true);
      Main.tile[x + 2, y].frameY = (short) (num2 + 18);
      Main.tile[x + 2, y].frameX = (short) (54 + (int) num1);
      Main.tile[x + 2, y].type = type;
    }

    public static void ShootFromCannon(
      int x,
      int y,
      int angle,
      int ammo,
      int Damage,
      float KnockBack,
      int owner,
      bool fromWire)
    {
      float num1 = 14f;
      float num2 = 0.0f;
      float num3 = 0.0f;
      int Type = 162;
      if (ammo == 2)
        Type = 281;
      if (ammo == 3)
        Type = 178;
      if (ammo == 4)
      {
        Type = 601;
        num1 = 3f;
      }
      if (ammo == 5)
      {
        Type = 601;
        num1 = 3f;
      }
      int ai0 = 0;
      int ai1 = 0;
      if (ammo == 5)
        ai0 = 1;
      if (ammo == 2)
        ai1 = owner + 1;
      if (angle == 0)
      {
        num2 = 10f;
        num3 = 0.0f;
      }
      if (angle == 1)
      {
        num2 = 7.5f;
        num3 = -2.5f;
      }
      if (angle == 2)
      {
        num2 = 5f;
        num3 = -5f;
      }
      if (angle == 3)
      {
        num2 = 2.75f;
        num3 = -6f;
      }
      if (angle == 4)
      {
        num2 = 0.0f;
        num3 = -10f;
      }
      if (angle == 5)
      {
        num2 = -2.75f;
        num3 = -6f;
      }
      if (angle == 6)
      {
        num2 = -5f;
        num3 = -5f;
      }
      if (angle == 7)
      {
        num2 = -7.5f;
        num3 = -2.5f;
      }
      if (angle == 8)
      {
        num2 = -10f;
        num3 = 0.0f;
      }
      Vector2 vector2 = new Vector2((float) ((x + 2) * 16), (float) ((y + 2) * 16));
      float num4 = num2;
      float num5 = num3;
      float num6 = (float) Math.Sqrt((double) num4 * (double) num4 + (double) num5 * (double) num5);
      if (ammo == 4 || ammo == 5)
      {
        if (angle == 4)
          vector2.X += 5f;
        vector2.Y += 5f;
      }
      bool flag = true;
      if (ammo == 2 && !WorldGen.BunnyCannonCanFire())
        flag = false;
      if (!flag)
        return;
      float num7 = num1 / num6;
      float SpeedX = num4 * num7;
      float SpeedY = num5 * num7;
      if (Main.myPlayer != owner && Main.netMode == 2 && (ammo == 4 || ammo == 5))
      {
        NetMessage.SendData(108, owner, number: Damage, number2: KnockBack, number3: ((float) x), number4: ((float) y), number5: angle, number6: ammo, number7: owner);
      }
      else
      {
        if (Main.netMode == 2)
          owner = Main.myPlayer;
        int index = Projectile.NewProjectile(WorldGen.GetProjectileSource_PlayerOrWires(x, y, fromWire, Main.player[owner]), vector2.X, vector2.Y, SpeedX, SpeedY, Type, Damage, KnockBack, owner, (float) ai0, (float) ai1);
        Main.projectile[index].originatedFromActivableTile = true;
      }
    }

    public static bool BunnyCannonCanFire()
    {
      int num1 = 1;
      int num2 = 0;
      int num3 = 100;
      for (int index = 0; index < num3; ++index)
      {
        NPC npc = Main.npc[index];
        if (npc == null || !npc.active)
          ++num2;
      }
      for (int index = 0; index < Main.projectile.Length; ++index)
      {
        Projectile projectile = Main.projectile[index];
        if (projectile != null && projectile.active && projectile.type == 281)
        {
          --num2;
          if (num2 <= 0)
            return false;
        }
      }
      return num2 >= num1;
    }

    public static void SwitchCannon(int i, int j)
    {
      int num1 = (int) Main.tile[i, j].frameX / 18;
      while (num1 >= 4)
        num1 -= 4;
      int num2 = (int) Main.tile[i, j].frameY / 18;
      while (num2 >= 3)
        num2 -= 3;
      int num3 = 1;
      if (num1 < 2)
        num3 = -1;
      int tileX = i - num1;
      int tileY = j - num2;
      if (num3 == 1 && Main.tile[tileX, tileY].frameY <= (short) 52 || num3 == -1 && Main.tile[tileX, tileY].frameY >= (short) 432)
        return;
      int num4 = num3 * -54;
      for (int index1 = tileX; index1 < tileX + 4; ++index1)
      {
        for (int index2 = tileY; index2 < tileY + 3; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 209)
            Main.tile[index1, index2].frameY += (short) num4;
        }
      }
      NetMessage.SendTileSquare(-1, tileX, tileY, 4, 3);
    }

    public static void CheckCannon(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = (int) Main.tile[i, j].frameX / 18;
      int num2 = 0;
      for (; num1 >= 4; num1 -= 4)
        ++num2;
      int num3 = i - num1;
      int num4 = (int) Main.tile[i, j].frameY / 18;
      int num5 = 0;
      for (; num4 >= 3; num4 -= 3)
        num5 += 54;
      int num6 = j - num4;
      int num7 = 72 * num2;
      for (int i1 = num3; i1 < num3 + 4; ++i1)
      {
        int num8 = num5;
        for (int index = num6; index < num6 + 3; ++index)
        {
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || (int) Main.tile[i1, index].frameX != num7 || (int) Main.tile[i1, index].frameY != num8)
            flag = true;
          num8 += 18;
        }
        if (Main.tile[i1, num6 + 3] == null)
          Main.tile[i1, num6 + 3] = new Tile();
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num6 + 3) && i1 != num3 && i1 != num3 + 3)
          flag = true;
        num7 += 18;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i2 = num3; i2 < num3 + 4; ++i2)
      {
        for (int j1 = num6; j1 < num6 + 3; ++j1)
        {
          if ((int) Main.tile[i2, j1].type == type && Main.tile[i2, j1].active())
            WorldGen.KillTile(i2, j1);
        }
      }
      int Type = 928;
      switch (num2)
      {
        case 1:
          Type = 1337;
          break;
        case 2:
          Type = 3369;
          break;
        case 3:
        case 4:
          Type = 3664;
          break;
      }
      Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, Type);
      WorldGen.destroyObject = false;
      for (int i3 = num3; i3 < num3 + 4; ++i3)
      {
        for (int j2 = num6; j2 < num6 + 3; ++j2)
          WorldGen.TileFrame(i3, j2);
      }
    }

    public static void PlaceCannon(int x, int y, ushort type, int style = 0)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
        return;
      bool flag = true;
      for (int i = x - 1; i < x + 3; ++i)
      {
        for (int index = y - 2; index < y + 1; ++index)
        {
          if (Main.tile[i, index] == null)
            Main.tile[i, index] = new Tile();
          if (Main.tile[i, index].active())
            flag = false;
        }
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (!WorldGen.SolidTile2(i, y + 1) && i != x - 1 && i != x + 2)
          flag = false;
      }
      int num1 = 72 * style;
      int num2 = 0;
      if (!flag)
        return;
      Main.tile[x - 1, y - 2].active(true);
      Main.tile[x - 1, y - 2].frameY = (short) num2;
      Main.tile[x - 1, y - 2].frameX = (short) num1;
      Main.tile[x - 1, y - 2].type = type;
      Main.tile[x, y - 2].active(true);
      Main.tile[x, y - 2].frameY = (short) num2;
      Main.tile[x, y - 2].frameX = (short) (18 + num1);
      Main.tile[x, y - 2].type = type;
      Main.tile[x + 1, y - 2].active(true);
      Main.tile[x + 1, y - 2].frameY = (short) num2;
      Main.tile[x + 1, y - 2].frameX = (short) (36 + num1);
      Main.tile[x + 1, y - 2].type = type;
      Main.tile[x + 2, y - 2].active(true);
      Main.tile[x + 2, y - 2].frameY = (short) num2;
      Main.tile[x + 2, y - 2].frameX = (short) (54 + num1);
      Main.tile[x + 2, y - 2].type = type;
      Main.tile[x - 1, y - 1].active(true);
      Main.tile[x - 1, y - 1].frameY = (short) (num2 + 18);
      Main.tile[x - 1, y - 1].frameX = (short) num1;
      Main.tile[x - 1, y - 1].type = type;
      Main.tile[x, y - 1].active(true);
      Main.tile[x, y - 1].frameY = (short) (num2 + 18);
      Main.tile[x, y - 1].frameX = (short) (18 + num1);
      Main.tile[x, y - 1].type = type;
      Main.tile[x + 1, y - 1].active(true);
      Main.tile[x + 1, y - 1].frameY = (short) (num2 + 18);
      Main.tile[x + 1, y - 1].frameX = (short) (36 + num1);
      Main.tile[x + 1, y - 1].type = type;
      Main.tile[x + 2, y - 1].active(true);
      Main.tile[x + 2, y - 1].frameY = (short) (num2 + 18);
      Main.tile[x + 2, y - 1].frameX = (short) (54 + num1);
      Main.tile[x + 2, y - 1].type = type;
      Main.tile[x - 1, y].active(true);
      Main.tile[x - 1, y].frameY = (short) (num2 + 36);
      Main.tile[x - 1, y].frameX = (short) num1;
      Main.tile[x - 1, y].type = type;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) (num2 + 36);
      Main.tile[x, y].frameX = (short) (18 + num1);
      Main.tile[x, y].type = type;
      Main.tile[x + 1, y].active(true);
      Main.tile[x + 1, y].frameY = (short) (num2 + 36);
      Main.tile[x + 1, y].frameX = (short) (36 + num1);
      Main.tile[x + 1, y].type = type;
      Main.tile[x + 2, y].active(true);
      Main.tile[x + 2, y].frameY = (short) (num2 + 36);
      Main.tile[x + 2, y].frameX = (short) (54 + num1);
      Main.tile[x + 2, y].type = type;
    }

    public static void SwitchMB(int i, int j)
    {
      int num1 = (int) Main.tile[i, j].frameY / 18;
      while (num1 >= 2)
        num1 -= 2;
      int num2 = (int) Main.tile[i, j].frameX / 18;
      if (num2 >= 2)
        num2 -= 2;
      int num3 = i - num2;
      int num4 = j - num1;
      for (int index1 = num3; index1 < num3 + 2; ++index1)
      {
        for (int index2 = num4; index2 < num4 + 2; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (Main.tile[index1, index2].active() && (Main.tile[index1, index2].type == (ushort) 139 || Main.tile[index1, index2].type == (ushort) 35))
          {
            if (Main.tile[index1, index2].frameX < (short) 36)
              Main.tile[index1, index2].frameX += (short) 36;
            else
              Main.tile[index1, index2].frameX -= (short) 36;
          }
        }
      }
      if (Wiring.running)
      {
        Wiring.SkipWire(num3, num4);
        Wiring.SkipWire(num3 + 1, num4);
        Wiring.SkipWire(num3, num4 + 1);
        Wiring.SkipWire(num3 + 1, num4 + 1);
      }
      NetMessage.SendTileSquare(-1, num3, num4, 2, 2);
    }

    public static void SwitchMonolith(int i, int j)
    {
      int num1 = (int) Main.tile[i, j].frameX / 18;
      while (num1 >= 2)
        num1 -= 2;
      int num2 = (int) Main.tile[i, j].frameY / 18;
      while (num2 >= 3)
        num2 -= 3;
      int num3 = i - num1;
      int num4 = j - num2;
      for (int index1 = num3; index1 < num3 + 2; ++index1)
      {
        for (int index2 = num4; index2 < num4 + 3; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          Tile tile = Main.tile[index1, index2];
          if (tile.active())
          {
            if (tile.type == (ushort) 410)
            {
              if (tile.frameY < (short) 56)
                tile.frameY += (short) 56;
              else
                tile.frameY -= (short) 56;
            }
            else if (tile.type == (ushort) 480)
            {
              if (tile.frameY < (short) 54)
                tile.frameY += (short) 54;
              else
                tile.frameY -= (short) 54;
            }
            else if (tile.type == (ushort) 509)
            {
              if (tile.frameY < (short) 54)
                tile.frameY += (short) 54;
              else
                tile.frameY -= (short) 54;
            }
            else if (tile.type == (ushort) 657)
            {
              if (tile.frameY < (short) 54)
                tile.frameY += (short) 54;
              else
                tile.frameY -= (short) 54;
            }
            else if (tile.type == (ushort) 658)
            {
              short num5 = 54;
              short num6 = 3;
              short num7 = (short) ((int) num5 * (int) num6);
              tile.frameY += num5;
              if ((int) tile.frameY >= (int) num7)
                tile.frameY -= num7;
            }
          }
        }
      }
      if (Wiring.running)
      {
        Wiring.SkipWire(num3, num4);
        Wiring.SkipWire(num3, num4 + 1);
        Wiring.SkipWire(num3, num4 + 2);
        Wiring.SkipWire(num3 + 1, num4);
        Wiring.SkipWire(num3 + 1, num4 + 1);
        Wiring.SkipWire(num3 + 1, num4 + 2);
      }
      NetMessage.SendTileSquare(-1, num3, num4, 2, 3);
    }

    public static void SwitchFountain(int i, int j)
    {
      int num1 = (int) Main.tile[i, j].frameX / 18;
      while (num1 >= 2)
        num1 -= 2;
      int num2 = (int) Main.tile[i, j].frameY / 18;
      if (num2 >= 4)
        num2 -= 4;
      int num3 = i - num1;
      int num4 = j - num2;
      for (int index1 = num3; index1 < num3 + 2; ++index1)
      {
        for (int index2 = num4; index2 < num4 + 4; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 207)
          {
            if (Main.tile[index1, index2].frameY < (short) 72)
              Main.tile[index1, index2].frameY += (short) 72;
            else
              Main.tile[index1, index2].frameY -= (short) 72;
          }
        }
      }
      if (Wiring.running)
      {
        Wiring.SkipWire(num3, num4);
        Wiring.SkipWire(num3, num4 + 1);
        Wiring.SkipWire(num3, num4 + 2);
        Wiring.SkipWire(num3, num4 + 3);
        Wiring.SkipWire(num3 + 1, num4);
        Wiring.SkipWire(num3 + 1, num4 + 1);
        Wiring.SkipWire(num3 + 1, num4 + 2);
        Wiring.SkipWire(num3 + 1, num4 + 3);
      }
      NetMessage.SendTileSquare(-1, num3, num4, 2, 4);
    }

    public static void CheckMB(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = 0;
      int num2;
      for (num2 = (int) Main.tile[i, j].frameY / 18; num2 >= 2; num2 -= 2)
        ++num1;
      int num3 = (int) Main.tile[i, j].frameX / 18;
      int num4 = 0;
      if (num3 >= 2)
      {
        num3 -= 2;
        ++num4;
      }
      int num5 = i - num3;
      int num6 = j - num2;
      for (int index1 = num5; index1 < num5 + 2; ++index1)
      {
        for (int index2 = num6; index2 < num6 + 2; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (!Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != type || (int) Main.tile[index1, index2].frameX != (index1 - num5) * 18 + num4 * 36 || (int) Main.tile[index1, index2].frameY != (index2 - num6) * 18 + num1 * 36)
            flag = true;
        }
        if (!Main.tile[index1, num6 + 2].nactive())
          flag = true;
        else if (!Main.tileSolid[(int) Main.tile[index1, num6 + 2].type] && !Main.tileTable[(int) Main.tile[index1, num6 + 2].type])
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i1 = num5; i1 < num5 + 2; ++i1)
      {
        for (int j1 = num6; j1 < num6 + 3; ++j1)
        {
          if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
            WorldGen.KillTile(i1, j1);
        }
      }
      if (type == 35)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1813);
      else if (num1 == 28)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1963);
      else if (num1 == 29)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1964);
      else if (num1 == 30)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1965);
      else if (num1 == 31)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2742);
      else if (num1 == 32)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3044);
      else if (num1 == 33)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3235);
      else if (num1 == 34)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3236);
      else if (num1 == 35)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3237);
      else if (num1 == 36)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3370);
      else if (num1 == 37)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3371);
      else if (num1 == 38)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3796);
      else if (num1 == 39)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3869);
      else if (num1 == 43)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4077);
      else if (num1 == 41)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4078);
      else if (num1 == 42)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4079);
      else if (num1 == 44)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4080);
      else if (num1 == 45)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4081);
      else if (num1 == 40)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4082);
      else if (num1 == 46)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4237);
      else if (num1 == 47)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4356);
      else if (num1 == 48)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4357);
      else if (num1 == 49)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4358);
      else if (num1 == 50)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4421);
      else if (num1 == 51)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4606);
      else if (num1 == 52)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4979);
      else if (num1 == 53)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4985);
      else if (num1 == 54)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4990);
      else if (num1 == 55)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4991);
      else if (num1 == 56)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4992);
      else if (num1 == 57)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5006);
      else if (num1 == 58)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5014);
      else if (num1 == 59)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5015);
      else if (num1 == 60)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5016);
      else if (num1 == 61)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5017);
      else if (num1 == 62)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5018);
      else if (num1 == 63)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5019);
      else if (num1 == 64)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5020);
      else if (num1 == 65)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5021);
      else if (num1 == 66)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5022);
      else if (num1 == 67)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5023);
      else if (num1 == 68)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5024);
      else if (num1 == 69)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5025);
      else if (num1 == 70)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5026);
      else if (num1 == 71)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5027);
      else if (num1 == 72)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5028);
      else if (num1 == 73)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5029);
      else if (num1 == 74)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5030);
      else if (num1 == 75)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5031);
      else if (num1 == 76)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5032);
      else if (num1 == 77)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5033);
      else if (num1 == 78)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5034);
      else if (num1 == 79)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5035);
      else if (num1 == 80)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5036);
      else if (num1 == 81)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5037);
      else if (num1 == 82)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5038);
      else if (num1 == 83)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5039);
      else if (num1 == 84)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5040);
      else if (num1 == 85)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5044);
      else if (num1 == 86)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5112);
      else if (num1 == 87)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5362);
      else if (num1 >= 13)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1596 + num1 - 13);
      else
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 562 + num1);
      for (int i2 = num5 - 1; i2 < num5 + 3; ++i2)
      {
        for (int j2 = num6 - 1; j2 < num6 + 3; ++j2)
          WorldGen.TileFrame(i2, j2);
      }
      WorldGen.destroyObject = false;
    }

    public static void PlaceMB(int X, int y, ushort type, int style)
    {
      int index1 = X + 1;
      if (index1 < 5 || index1 > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
        return;
      bool flag = true;
      for (int index2 = index1 - 1; index2 < index1 + 1; ++index2)
      {
        for (int index3 = y - 1; index3 < y + 1; ++index3)
        {
          if (Main.tile[index2, index3] == null)
            Main.tile[index2, index3] = new Tile();
          if (Main.tile[index2, index3].active())
            flag = false;
        }
        if (Main.tile[index2, y + 1] == null)
          Main.tile[index2, y + 1] = new Tile();
        if (!Main.tile[index2, y + 1].active() || Main.tile[index2, y + 1].halfBrick() || !Main.tileSolid[(int) Main.tile[index2, y + 1].type] && !Main.tileTable[(int) Main.tile[index2, y + 1].type])
          flag = false;
      }
      if (!flag)
        return;
      Main.tile[index1 - 1, y - 1].active(true);
      Main.tile[index1 - 1, y - 1].frameY = (short) (style * 36);
      Main.tile[index1 - 1, y - 1].frameX = (short) 0;
      Main.tile[index1 - 1, y - 1].type = type;
      Main.tile[index1, y - 1].active(true);
      Main.tile[index1, y - 1].frameY = (short) (style * 36);
      Main.tile[index1, y - 1].frameX = (short) 18;
      Main.tile[index1, y - 1].type = type;
      Main.tile[index1 - 1, y].active(true);
      Main.tile[index1 - 1, y].frameY = (short) (style * 36 + 18);
      Main.tile[index1 - 1, y].frameX = (short) 0;
      Main.tile[index1 - 1, y].type = type;
      Main.tile[index1, y].active(true);
      Main.tile[index1, y].frameY = (short) (style * 36 + 18);
      Main.tile[index1, y].frameX = (short) 18;
      Main.tile[index1, y].type = type;
    }

    public static void Place2x2(int x, int y, ushort type, int style)
    {
      if (type == (ushort) 95 || type == (ushort) 126)
        ++y;
      if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
        return;
      if (type == (ushort) 172)
      {
        if (!WorldGen.CanPlaceSink(x, y, type, style))
          return;
      }
      else
      {
        for (int i = x - 1; i < x + 1; ++i)
        {
          for (int j = y - 1; j < y + 1; ++j)
          {
            Tile tileSafely = Framing.GetTileSafely(i, j);
            if (tileSafely.active() || type == (ushort) 98 && tileSafely.liquid > (byte) 0)
              return;
          }
          switch (type)
          {
            case 95:
            case 126:
              Tile tileSafely1 = Framing.GetTileSafely(i, y - 2);
              if (!tileSafely1.nactive() || !Main.tileSolid[(int) tileSafely1.type] || Main.tileSolidTop[(int) tileSafely1.type])
                return;
              continue;
            case 132:
              continue;
            default:
              Tile tileSafely2 = Framing.GetTileSafely(i, y + 1);
              if (!tileSafely2.nactive() || !WorldGen.SolidTile2(tileSafely2) && !Main.tileTable[(int) tileSafely2.type])
                return;
              continue;
          }
        }
      }
      if (type == (ushort) 132)
      {
        bool flag = true;
        if (Main.tile[x - 1, y + 1] == null)
          Main.tile[x - 1, y + 1] = new Tile();
        if (Main.tile[x, y + 1] == null)
          Main.tile[x, y + 1] = new Tile();
        if (!Main.tile[x - 1, y + 1].nactive() || !WorldGen.SolidTile2(x - 1, y + 1) && !Main.tileTable[(int) Main.tile[x - 1, y + 1].type])
          flag = false;
        if (!Main.tile[x, y + 1].nactive() || !WorldGen.SolidTile2(x, y + 1) && !Main.tileTable[(int) Main.tile[x, y + 1].type])
          flag = false;
        if (!flag && (Main.tile[x - 1, y - 1].wall < (ushort) 1 || Main.tile[x, y - 1].wall < (ushort) 1 || Main.tile[x - 1, y].wall < (ushort) 1 || Main.tile[x - 1, y].wall < (ushort) 1))
          return;
      }
      --x;
      --y;
      int num = type == (ushort) 172 ? 38 : 36;
      for (int index1 = 0; index1 < 2; ++index1)
      {
        for (int index2 = 0; index2 < 2; ++index2)
        {
          Tile tile = Main.tile[x + index1, y + index2];
          tile.active(true);
          tile.frameX = (short) (index1 * 18);
          tile.frameY = (short) (style * num + index2 * 18);
          tile.type = type;
        }
      }
    }

    public static bool PlaceObject(
      int x,
      int y,
      int type,
      bool mute = false,
      int style = 0,
      int alternate = 0,
      int random = -1,
      int direction = -1)
    {
      TileObject objectData;
      if (type >= (int) TileID.Count || !TileObject.CanPlace(x, y, type, style, direction, out objectData))
        return false;
      objectData.random = random;
      if (TileObject.Place(objectData))
      {
        WorldGen.SquareTileFrame(x, y);
        if (!mute)
          SoundEngine.PlaySound(0, x * 16, y * 16);
      }
      return true;
    }

    public static bool ShiftTrapdoor(int x, int y, bool playerAbove, int onlyCloseOrOpen = -1)
    {
      Tile tileSafely1 = Framing.GetTileSafely(x, y);
      if (tileSafely1.type == (ushort) 386 && onlyCloseOrOpen != 1)
      {
        Point topLeftAndStyles = WorldGen.GetTopLeftAndStyles(ref x, ref y, 2, 2, 18, 18);
        if (topLeftAndStyles.X == 0)
        {
          if (Main.netMode != 1 && Wiring.running)
          {
            Wiring.SkipWire(x, y);
            Wiring.SkipWire(x, y + 1);
            Wiring.SkipWire(x + 1, y);
            Wiring.SkipWire(x + 1, y + 1);
          }
          if (!Collision.EmptyTile(x, y + 1, true) || !Collision.EmptyTile(x + 1, y + 1, true))
            return false;
          SoundEngine.PlaySound(8, x * 16 + 16, y * 16 + 16);
          for (int index = 0; index < 2; ++index)
            Framing.GetTileSafely(x + index, y).ClearTile();
          for (int index = 0; index < 2; ++index)
          {
            Tile tileSafely2 = Framing.GetTileSafely(x + index, y + 1);
            tileSafely2.type = (ushort) 387;
            tileSafely2.frameX = (short) (index * 18);
            tileSafely2.frameY = (short) (topLeftAndStyles.Y * 18);
          }
          for (int index1 = -1; index1 < 3; ++index1)
          {
            for (int index2 = 0; index2 < 3; ++index2)
              WorldGen.TileFrame(x + index1, y + index2);
          }
          return true;
        }
        if (topLeftAndStyles.X == 1)
        {
          if (Main.netMode != 1 && Wiring.running)
          {
            Wiring.SkipWire(x, y - 1);
            Wiring.SkipWire(x, y);
            Wiring.SkipWire(x + 1, y - 1);
            Wiring.SkipWire(x + 1, y);
          }
          if (!Collision.EmptyTile(x, y, true) || !Collision.EmptyTile(x + 1, y, true))
            return false;
          SoundEngine.PlaySound(8, x * 16 + 16, y * 16);
          for (int index = 0; index < 2; ++index)
            Framing.GetTileSafely(x + index, y + 1).ClearTile();
          for (int index = 0; index < 2; ++index)
          {
            Tile tileSafely3 = Framing.GetTileSafely(x + index, y);
            tileSafely3.type = (ushort) 387;
            tileSafely3.frameX = (short) (index * 18);
            tileSafely3.frameY = (short) (topLeftAndStyles.Y * 18);
          }
          for (int index3 = -1; index3 < 3; ++index3)
          {
            for (int index4 = -1; index4 < 2; ++index4)
              WorldGen.TileFrame(x + index3, y + index4);
          }
          return true;
        }
      }
      if (tileSafely1.type == (ushort) 387 && onlyCloseOrOpen != 0)
      {
        WorldGen.GetTopLeftAndStyles(ref x, ref y, 2, 1, 18, 18);
        int directionInt = playerAbove.ToDirectionInt();
        for (int index = 0; index < 2; ++index)
        {
          Tile tileSafely4 = Framing.GetTileSafely(x + index, y + directionInt);
          if (tileSafely4.active() && !Main.tileCut[(int) tileSafely4.type])
            return false;
        }
        if (Main.netMode != 1 && Wiring.running)
        {
          Wiring.SkipWire(x, y);
          Wiring.SkipWire(x, y + directionInt);
          Wiring.SkipWire(x + 1, y);
          Wiring.SkipWire(x + 1, y + directionInt);
        }
        SoundEngine.PlaySound(8, x * 16 + 16, y * 16);
        for (int index = 0; index < 2; ++index)
        {
          Tile tileSafely5 = Framing.GetTileSafely(x + index, y + directionInt);
          if (tileSafely5.active() && Main.tileCut[(int) tileSafely5.type])
            WorldGen.KillTile(x + index, y + directionInt);
        }
        for (int index5 = 0; index5 < 2; ++index5)
        {
          TileColorCache cache = Framing.GetTileSafely(x + index5, y).BlockColorAndCoating();
          for (int index6 = 0; index6 < 2; ++index6)
          {
            Tile tileSafely6 = Framing.GetTileSafely(x + index5, y + index6 - (!playerAbove).ToInt());
            tileSafely6.type = (ushort) 386;
            tileSafely6.frameX = (short) (index5 * 18 + playerAbove.ToInt() * 36);
            tileSafely6.frameY = (short) (index6 * 18);
            tileSafely6.UseBlockColors(cache);
            tileSafely6.active(true);
          }
        }
        for (int index7 = -1; index7 < 3; ++index7)
        {
          for (int index8 = -1; index8 < 3; ++index8)
            WorldGen.TileFrame(x + index7, y + index8 - (!playerAbove).ToInt() * 2);
        }
        return true;
      }
      SoundEngine.PlaySound(9, x * 16, y * 16);
      return false;
    }

    public static void CheckTrapDoor(int x, int y, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int w = 0;
      int h = 0;
      Point point = new Point();
      if (type == 387)
      {
        w = 2;
        h = 1;
        point = WorldGen.GetTopLeftAndStyles(ref x, ref y, w, h, 18, 18);
        flag = flag || !WorldGen.CheckTileFrames(type, x, y, w, h, point.X, 18, point.Y, 18) || !WorldGen.CheckTileAnchors(x, y, w, h, 1, AnchorType.SolidTile);
      }
      if (type == 386)
      {
        w = 2;
        h = 2;
        point = WorldGen.GetTopLeftAndStyles(ref x, ref y, w, h, 18, 18);
        flag = flag || !WorldGen.CheckTileFrames(type, x, y, w, h, point.X, 18, point.Y, 18);
        if (point.X == 0)
          flag = flag || !WorldGen.CheckTileAnchors(x, y + 1, w, 1, 1, AnchorType.SolidTile);
        else if (point.X == 1)
          flag = flag || !WorldGen.CheckTileAnchors(x, y, w, 1, 1, AnchorType.SolidTile);
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i = x; i < x + w; ++i)
      {
        for (int j = y; j < y + h; ++j)
          WorldGen.KillTile(i, j);
      }
      int Type = 3239;
      if (point.Y == 0)
        Type = 3239;
      Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, w * 16, h * 16, Type);
      for (int i = x - 1; i < x + w + 1; ++i)
      {
        for (int j = y - 1; j < y + h + 1; ++j)
          WorldGen.TileFrame(i, j);
      }
      WorldGen.destroyObject = false;
    }

    public static void CheckTallGate(int x, int y, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      Tile tileSafely1 = Framing.GetTileSafely(x, y);
      Point point = new Point((int) tileSafely1.frameX / 18, 0);
      TileObjectData tileData = TileObjectData.GetTileData(type, point.X);
      point.Y = (int) tileSafely1.frameY / tileData.CoordinateFullHeight;
      int width = tileData.Width;
      int height = tileData.Height;
      int index1 = 0;
      for (int index2 = (int) tileSafely1.frameY % tileData.CoordinateFullHeight; index1 < height && index2 - tileData.CoordinateHeights[index1] >= 0; ++index1)
        index2 -= tileData.CoordinateHeights[index1];
      int coordinateFullHeight = tileData.CoordinateFullHeight;
      y -= index1;
      int num = point.Y * tileData.CoordinateFullHeight;
      for (int index3 = 0; index3 < height; ++index3)
      {
        Tile tileSafely2 = Framing.GetTileSafely(x, y + index3);
        if ((int) tileSafely2.frameX != point.X * tileData.CoordinateFullWidth || (int) tileSafely2.frameY != num)
        {
          flag = true;
          break;
        }
        num += tileData.CoordinateHeights[index3] + tileData.CoordinatePadding;
      }
      if (!flag && WorldGen.CheckTileAnchors(x, y, width, height, 2, AnchorType.SolidTile))
        return;
      WorldGen.destroyObject = true;
      for (int i = x; i < x + width; ++i)
      {
        for (int j = y; j < y + height; ++j)
          WorldGen.KillTile(i, j);
      }
      int Type = 3240;
      if (point.Y == 0)
        Type = 3240;
      Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, width * 16, height * 16, Type);
      for (int i = x - 1; i < x + width + 1; ++i)
      {
        for (int j = y - 1; j < y + height + 1; ++j)
          WorldGen.TileFrame(i, j);
      }
      WorldGen.destroyObject = false;
    }

    public static bool ShiftTallGate(int x, int y, bool closing, bool forced = false)
    {
      ushort num1 = closing ? (ushort) 388 : (ushort) 389;
      ushort num2 = closing ? (ushort) 389 : (ushort) 388;
      Tile tileSafely = Framing.GetTileSafely(x, y);
      if ((int) tileSafely.type != (int) num2)
        return false;
      Point point = new Point((int) tileSafely.frameX / 18, 0);
      TileObjectData tileData = TileObjectData.GetTileData(388, point.X);
      point.Y = (int) tileSafely.frameY / tileData.CoordinateFullHeight;
      int width = tileData.Width;
      int height = tileData.Height;
      int index1 = 0;
      for (int index2 = (int) tileSafely.frameY % tileData.CoordinateFullHeight; index1 < height && index2 - tileData.CoordinateHeights[index1] >= 0; ++index1)
        index2 -= tileData.CoordinateHeights[index1];
      int coordinateFullHeight = tileData.CoordinateFullHeight;
      y -= index1;
      if (Main.netMode != 1 && Wiring.running)
      {
        for (int index3 = 0; index3 < height; ++index3)
          Wiring.SkipWire(x, y + index3);
      }
      for (int index4 = 0; index4 < height; ++index4)
      {
        if (!forced && !Collision.EmptyTile(x, y + index4, true))
          return false;
      }
      SoundEngine.PlaySound(8, x * 16 + 16, y * 16 + 16);
      for (int index5 = 0; index5 < height; ++index5)
        Framing.GetTileSafely(x, y + index5).type = num1;
      for (int index6 = -1; index6 < 2; ++index6)
      {
        for (int index7 = -1; index7 < height + 1; ++index7)
          WorldGen.TileFrame(x + index6, y + index7);
      }
      return true;
    }

    public static Point GetTopLeftAndStyles(
      ref int x,
      ref int y,
      int w,
      int h,
      int frameXinc,
      int frameYinc)
    {
      Tile tileSafely = Framing.GetTileSafely(x, y);
      Point topLeftAndStyles = new Point((int) tileSafely.frameX / (w * frameXinc), (int) tileSafely.frameY / (h * frameYinc));
      if (frameXinc != 0)
        x -= (int) tileSafely.frameX / frameXinc % w;
      if (frameYinc == 0)
        return topLeftAndStyles;
      y -= (int) tileSafely.frameY / frameYinc % h;
      return topLeftAndStyles;
    }

    public static bool CheckTileFrames(
      int type,
      int sx,
      int sy,
      int w,
      int h,
      int styleX,
      int frameXinc,
      int styleY,
      int frameYinc)
    {
      for (int index1 = 0; index1 < w; ++index1)
      {
        for (int index2 = 0; index2 < h; ++index2)
        {
          Tile tileSafely = Framing.GetTileSafely(sx + index1, sy + index2);
          if (!tileSafely.active() || (int) tileSafely.type != type || (int) tileSafely.frameX != styleX * w * frameXinc + index1 * frameXinc || (int) tileSafely.frameY != styleY * h * frameYinc + index2 * frameYinc)
            return false;
        }
      }
      return true;
    }

    public static bool CheckTileAnchors(
      int sx,
      int sy,
      int w,
      int h,
      int mode,
      AnchorType anchor)
    {
      if ((mode & 1) == 1)
      {
        for (int j = sy; j < sy + h; ++j)
        {
          if (!WorldGen.AnchorValid(Framing.GetTileSafely(sx - 1, j), anchor) || !WorldGen.AnchorValid(Framing.GetTileSafely(sx + w, j), anchor))
            return false;
        }
      }
      if ((mode & 2) == 2)
      {
        for (int i = sx; i < sx + w; ++i)
        {
          if (!WorldGen.AnchorValid(Framing.GetTileSafely(i, sy - 1), anchor) || !WorldGen.AnchorValid(Framing.GetTileSafely(i, sy + h), anchor))
            return false;
        }
      }
      return true;
    }

    public static bool AnchorValid(Tile tileCache, AnchorType anchor)
    {
      bool flag = false;
      if (tileCache.nactive())
      {
        if ((anchor & AnchorType.SolidTile) == AnchorType.SolidTile && Main.tileSolid[(int) tileCache.type] && !Main.tileSolidTop[(int) tileCache.type] && !Main.tileNoAttach[(int) tileCache.type] && tileCache.blockType() == 0)
          flag = true;
        if ((anchor & AnchorType.SolidBottom) == AnchorType.SolidBottom && (Main.tileSolid[(int) tileCache.type] && (!Main.tileSolidTop[(int) tileCache.type] || TileID.Sets.Platforms[(int) tileCache.type] && (tileCache.halfBrick() || tileCache.topSlope())) || tileCache.topSlope() || tileCache.halfBrick()) && !TileID.Sets.NotReallySolid[(int) tileCache.type] && !tileCache.bottomSlope())
          flag = true;
        if (!flag && ((anchor & AnchorType.SolidWithTop) == AnchorType.SolidWithTop || (anchor & AnchorType.Table) == AnchorType.Table))
        {
          if (TileID.Sets.Platforms[(int) tileCache.type])
          {
            int num = (int) tileCache.frameX / TileObjectData.PlatformFrameWidth();
            if (!tileCache.halfBrick() && num >= 0 && num <= 7 || num >= 12 && num <= 16 || num >= 25 && num <= 26)
              flag = true;
          }
          else if (Main.tileSolid[(int) tileCache.type] && Main.tileSolidTop[(int) tileCache.type])
            flag = true;
        }
        if (!flag && (anchor & AnchorType.Table) == AnchorType.Table && !TileID.Sets.Platforms[(int) tileCache.type] && Main.tileTable[(int) tileCache.type] && tileCache.blockType() == 0)
          flag = true;
        if (!flag && (anchor & AnchorType.SolidSide) == AnchorType.SolidSide && Main.tileSolid[(int) tileCache.type] && !Main.tileSolidTop[(int) tileCache.type])
        {
          switch (tileCache.blockType())
          {
            case 4:
            case 5:
              flag = true;
              break;
          }
        }
      }
      else if (!flag && (anchor & AnchorType.EmptyTile) == AnchorType.EmptyTile)
        flag = true;
      return flag;
    }

    public static bool CanPlaceSink(int x, int y, ushort type, int style)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
        return false;
      bool flag = true;
      --x;
      --y;
      for (int index1 = 0; index1 < 2; ++index1)
      {
        for (int index2 = 0; index2 < 2; ++index2)
        {
          if (Framing.GetTileSafely(x + index1, y + index2).active())
            flag = false;
        }
        Tile tileSafely = Framing.GetTileSafely(x + index1, y + 2);
        if (!tileSafely.nactive() || !WorldGen.SolidTile(tileSafely))
          flag = false;
      }
      return flag;
    }

    public static void Place3x4(int x, int y, ushort type, int style)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
        return;
      bool flag = true;
      for (int i = x - 1; i < x + 2; ++i)
      {
        for (int index = y - 3; index < y + 1; ++index)
        {
          if (Main.tile[i, index] == null)
            Main.tile[i, index] = new Tile();
          if (Main.tile[i, index].active())
            flag = false;
        }
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (!WorldGen.SolidTile2(i, y + 1))
          flag = false;
      }
      if (!flag)
        return;
      int num1 = style * 54;
      for (int index = -3; index <= 0; ++index)
      {
        short num2 = (short) ((3 + index) * 18);
        Main.tile[x - 1, y + index].active(true);
        Main.tile[x - 1, y + index].frameY = num2;
        Main.tile[x - 1, y + index].frameX = (short) num1;
        Main.tile[x - 1, y + index].type = type;
        Main.tile[x, y + index].active(true);
        Main.tile[x, y + index].frameY = num2;
        Main.tile[x, y + index].frameX = (short) (num1 + 18);
        Main.tile[x, y + index].type = type;
        Main.tile[x + 1, y + index].active(true);
        Main.tile[x + 1, y + index].frameY = num2;
        Main.tile[x + 1, y + index].frameX = (short) (num1 + 36);
        Main.tile[x + 1, y + index].type = type;
      }
    }

    public static void Place5x4(int x, int y, ushort type, int style)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
        return;
      bool flag = true;
      for (int i = x - 2; i < x + 3; ++i)
      {
        for (int index = y - 3; index < y + 1; ++index)
        {
          if (Main.tile[i, index] == null)
            Main.tile[i, index] = new Tile();
          if (Main.tile[i, index].active())
            flag = false;
        }
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (!WorldGen.SolidTile2(i, y + 1))
          flag = false;
      }
      if (!flag)
        return;
      int num1 = style * 54;
      for (int index = -3; index <= 0; ++index)
      {
        short num2 = (short) ((3 + index) * 18);
        Main.tile[x - 2, y + index].active(true);
        Main.tile[x - 2, y + index].frameY = num2;
        Main.tile[x - 2, y + index].frameX = (short) (num1 - 36);
        Main.tile[x - 2, y + index].type = type;
        Main.tile[x - 1, y + index].active(true);
        Main.tile[x - 1, y + index].frameY = num2;
        Main.tile[x - 1, y + index].frameX = (short) (num1 - 18);
        Main.tile[x - 1, y + index].type = type;
        Main.tile[x, y + index].active(true);
        Main.tile[x, y + index].frameY = num2;
        Main.tile[x, y + index].frameX = (short) num1;
        Main.tile[x, y + index].type = type;
        Main.tile[x + 1, y + index].active(true);
        Main.tile[x + 1, y + index].frameY = num2;
        Main.tile[x + 1, y + index].frameX = (short) (num1 + 18);
        Main.tile[x + 1, y + index].type = type;
        Main.tile[x + 1, y + index].active(true);
        Main.tile[x + 1, y + index].frameY = num2;
        Main.tile[x + 1, y + index].frameX = (short) (num1 + 36);
        Main.tile[x + 1, y + index].type = type;
      }
    }

    public static void Place3x1(int x, int y, ushort type, int style = 0)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
        return;
      bool flag = true;
      for (int i = x - 1; i < x + 2; ++i)
      {
        int index = y;
        if (Main.tile[i, index] == null)
          Main.tile[i, index] = new Tile();
        if (Main.tile[i, index].active())
          flag = false;
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (!WorldGen.SolidTile2(i, y + 1))
          flag = false;
      }
      if (!flag)
        return;
      short num = (short) (54 * style);
      Main.tile[x - 1, y].active(true);
      Main.tile[x - 1, y].frameY = (short) 0;
      Main.tile[x - 1, y].frameX = num;
      Main.tile[x - 1, y].type = type;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) 0;
      Main.tile[x, y].frameX = (short) ((int) num + 18);
      Main.tile[x, y].type = type;
      Main.tile[x + 1, y].active(true);
      Main.tile[x + 1, y].frameY = (short) 0;
      Main.tile[x + 1, y].frameX = (short) ((int) num + 36);
      Main.tile[x + 1, y].type = type;
    }

    public static void Place3x2(int x, int y, ushort type, int style = 0)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
        return;
      bool flag1 = false;
      bool flag2 = true;
      if (type == (ushort) 14 && style == 25)
        flag1 = true;
      int num1 = y - 1;
      if (flag1)
        num1 = y;
      for (int i = x - 1; i < x + 2; ++i)
      {
        for (int index = num1; index < y + 1; ++index)
        {
          if (Main.tile[i, index] == null)
            Main.tile[i, index] = new Tile();
          if (Main.tile[i, index].active())
            flag2 = false;
          if (type == (ushort) 215 && Main.tile[i, index].liquid > (byte) 0)
            flag2 = false;
        }
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (type == (ushort) 285 || type == (ushort) 286 || type == (ushort) 298 || type == (ushort) 299 || type == (ushort) 310 || type >= (ushort) 361 && type <= (ushort) 364 || type == (ushort) 582 || type == (ushort) 619)
        {
          if (!WorldGen.SolidTile2(i, y + 1) && (!Main.tile[i, y + 1].nactive() || !Main.tileSolidTop[(int) Main.tile[i, y + 1].type] || Main.tile[i, y + 1].frameY != (short) 0))
            flag2 = false;
        }
        else
        {
          if (type == (ushort) 26 && TileID.Sets.Boulders[(int) Main.tile[i, y + 1].type])
            flag2 = false;
          if (!WorldGen.SolidTile2(i, y + 1))
            flag2 = false;
        }
      }
      if (type == (ushort) 88)
      {
        if (Chest.CreateChest(x - 1, y - 1) == -1)
          flag2 = false;
        else if (Main.netMode == 1)
          NetMessage.SendData(34, number: 2, number2: ((float) x), number3: ((float) y), number4: ((float) style));
      }
      if (!flag2)
        return;
      short num2 = (short) (54 * style);
      if (flag1)
      {
        Main.tile[x - 1, y].active(true);
        Main.tile[x - 1, y].frameY = (short) 0;
        Main.tile[x - 1, y].frameX = num2;
        Main.tile[x - 1, y].type = type;
        Main.tile[x, y].active(true);
        Main.tile[x, y].frameY = (short) 0;
        Main.tile[x, y].frameX = (short) ((int) num2 + 18);
        Main.tile[x, y].type = type;
        Main.tile[x + 1, y].active(true);
        Main.tile[x + 1, y].frameY = (short) 0;
        Main.tile[x + 1, y].frameX = (short) ((int) num2 + 36);
        Main.tile[x + 1, y].type = type;
      }
      else
      {
        Main.tile[x - 1, y - 1].active(true);
        Main.tile[x - 1, y - 1].frameY = (short) 0;
        Main.tile[x - 1, y - 1].frameX = num2;
        Main.tile[x - 1, y - 1].type = type;
        Main.tile[x, y - 1].active(true);
        Main.tile[x, y - 1].frameY = (short) 0;
        Main.tile[x, y - 1].frameX = (short) ((int) num2 + 18);
        Main.tile[x, y - 1].type = type;
        Main.tile[x + 1, y - 1].active(true);
        Main.tile[x + 1, y - 1].frameY = (short) 0;
        Main.tile[x + 1, y - 1].frameX = (short) ((int) num2 + 36);
        Main.tile[x + 1, y - 1].type = type;
        Main.tile[x - 1, y].active(true);
        Main.tile[x - 1, y].frameY = (short) 18;
        Main.tile[x - 1, y].frameX = num2;
        Main.tile[x - 1, y].type = type;
        Main.tile[x, y].active(true);
        Main.tile[x, y].frameY = (short) 18;
        Main.tile[x, y].frameX = (short) ((int) num2 + 18);
        Main.tile[x, y].type = type;
        Main.tile[x + 1, y].active(true);
        Main.tile[x + 1, y].frameY = (short) 18;
        Main.tile[x + 1, y].frameX = (short) ((int) num2 + 36);
        Main.tile[x + 1, y].type = type;
      }
    }

    public static void Place2x2Style(int x, int y, ushort type, int style = 0)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
        return;
      short num1 = 0;
      if (type == (ushort) 254)
        num1 = (short) ((int) (short) (x % 12 / 2) * 36);
      bool flag = true;
      for (int i = x - 1; i < x + 1; ++i)
      {
        for (int index = y - 1; index < y + 1; ++index)
        {
          if (Main.tile[i, index] == null)
            Main.tile[i, index] = new Tile();
          if (Main.tile[i, index].active())
            flag = false;
        }
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (!WorldGen.SolidTile(i, y + 1))
          flag = false;
        if (type == (ushort) 254 && Main.tile[i, y + 1].type != (ushort) 2 && Main.tile[i, y + 1].type != (ushort) 477 && Main.tile[i, y + 1].type != (ushort) 492 && Main.tile[i, y + 1].type != (ushort) 109)
          flag = false;
      }
      if (!flag)
        return;
      short num2 = (short) (36 * style);
      Main.tile[x - 1, y - 1].active(true);
      Main.tile[x - 1, y - 1].frameY = num1;
      Main.tile[x - 1, y - 1].frameX = num2;
      Main.tile[x - 1, y - 1].type = type;
      Main.tile[x, y - 1].active(true);
      Main.tile[x, y - 1].frameY = num1;
      Main.tile[x, y - 1].frameX = (short) ((int) num2 + 18);
      Main.tile[x, y - 1].type = type;
      Main.tile[x - 1, y].active(true);
      Main.tile[x - 1, y].frameY = (short) ((int) num1 + 18);
      Main.tile[x - 1, y].frameX = num2;
      Main.tile[x - 1, y].type = type;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) ((int) num1 + 18);
      Main.tile[x, y].frameX = (short) ((int) num2 + 18);
      Main.tile[x, y].type = type;
    }

    public static bool NearFriendlyWall(int x, int y)
    {
      try
      {
        if (x < 2 || x >= Main.maxTilesX - 2 || y < 2 || y >= Main.maxTilesY - 2 || Main.tile[x, y].wall == (ushort) 0 || Main.wallHouse[(int) Main.tile[x, y].wall] || Main.tile[x - 1, y].wall == (ushort) 0 || Main.wallHouse[(int) Main.tile[x - 1, y].wall] || Main.tile[x + 1, y].wall == (ushort) 0 || Main.wallHouse[(int) Main.tile[x + 1, y].wall] || Main.tile[x, y - 1].wall == (ushort) 0 || Main.wallHouse[(int) Main.tile[x, y - 1].wall] || Main.tile[x, y + 1].wall == (ushort) 0)
          return true;
        if (Main.wallHouse[(int) Main.tile[x, y + 1].wall])
          return true;
      }
      catch
      {
      }
      return false;
    }

    public static void Check2x2Style(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = j;
      int num2 = (int) Main.tile[i, j].frameY / 18;
      while (num2 > 1)
        num2 -= 2;
      int num3 = num1 - num2;
      int num4 = (int) Main.tile[i, j].frameX / 18;
      int num5 = 0;
      while (num4 > 1)
      {
        num4 -= 2;
        ++num5;
      }
      int num6 = i - num4;
      int num7 = num5 * 36;
      for (int i1 = num6; i1 < num6 + 2; ++i1)
      {
        for (int index = num3; index < num3 + 2; ++index)
        {
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || (int) Main.tile[i1, index].frameX != (i1 - num6) * 18 + num7)
            flag = true;
        }
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num3 + 2))
          flag = true;
        else if (type == 254)
        {
          Tile tile = Main.tile[i1, num3 + 2];
          if (tile != null && tile.active() && tile.type >= (ushort) 0 && (int) tile.type < (int) TileID.Count)
          {
            switch (tile.type)
            {
              case 2:
              case 109:
              case 477:
              case 492:
                continue;
              default:
                flag = true;
                continue;
            }
          }
        }
      }
      if (!flag)
        return;
      int frameX = (int) Main.tile[i, j].frameX;
      WorldGen.destroyObject = true;
      for (int i2 = num6; i2 < num6 + 2; ++i2)
      {
        for (int j1 = num3; j1 < num3 + 2; ++j1)
        {
          if (Main.tile[i2, j1] == null)
            Main.tile[i2, j1] = new Tile();
          if ((int) Main.tile[i2, j1].type == type && Main.tile[i2, j1].active())
            WorldGen.KillTile(i2, j1);
        }
      }
      switch (type)
      {
        case 96:
          if (num5 == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 345);
          if (num5 == 1)
          {
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1791);
            break;
          }
          break;
        case 254:
          if (frameX >= 72)
          {
            if (frameX < 108)
            {
              if (WorldGen.genRand.Next(2) == 0)
              {
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1725, WorldGen.genRand.Next(1, 3));
                break;
              }
              break;
            }
            if (frameX < 144)
            {
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1725, WorldGen.genRand.Next(2, 6));
              break;
            }
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1725, WorldGen.genRand.Next(5, 11));
            if (Main.halloween && WorldGen.genRand.Next(200) == 0)
            {
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1799);
              break;
            }
            break;
          }
          break;
        case 441:
          int Type1 = -1;
          switch (num5)
          {
            case 0:
              Type1 = 3665;
              break;
            case 1:
              Type1 = 3666;
              break;
            case 3:
              Type1 = 3667;
              break;
            case 7:
              Type1 = 3668;
              break;
            case 8:
              Type1 = 3669;
              break;
            case 9:
              Type1 = 3670;
              break;
            case 10:
              Type1 = 3671;
              break;
            case 11:
              Type1 = 3672;
              break;
            case 12:
              Type1 = 3673;
              break;
            case 13:
              Type1 = 3674;
              break;
            case 14:
              Type1 = 3675;
              break;
            case 15:
              Type1 = 3676;
              break;
            case 16:
              Type1 = 3677;
              break;
            case 17:
              Type1 = 3678;
              break;
            case 18:
              Type1 = 3679;
              break;
            case 19:
              Type1 = 3680;
              break;
            case 20:
              Type1 = 3681;
              break;
            case 21:
              Type1 = 3682;
              break;
            case 22:
              Type1 = 3683;
              break;
            case 28:
              Type1 = 3684;
              break;
            case 29:
              Type1 = 3685;
              break;
            case 30:
              Type1 = 3686;
              break;
            case 31:
              Type1 = 3687;
              break;
            case 32:
              Type1 = 3688;
              break;
            case 33:
              Type1 = 3689;
              break;
            case 34:
              Type1 = 3690;
              break;
            case 35:
              Type1 = 3691;
              break;
            case 37:
              Type1 = 3692;
              break;
            case 39:
              Type1 = 3693;
              break;
            case 41:
              Type1 = 3694;
              break;
            case 42:
              Type1 = 3695;
              break;
            case 43:
              Type1 = 3696;
              break;
            case 44:
              Type1 = 3697;
              break;
            case 45:
              Type1 = 3698;
              break;
            case 46:
              Type1 = 3699;
              break;
            case 47:
              Type1 = 3700;
              break;
            case 48:
              Type1 = 3701;
              break;
            case 49:
              Type1 = 3702;
              break;
            case 50:
              Type1 = 3703;
              break;
            case 51:
              Type1 = 3704;
              break;
          }
          if (Type1 != -1)
          {
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, Type1);
            break;
          }
          break;
        case 457:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3749);
          break;
        case 468:
          int Type2 = -1;
          switch (num5)
          {
            case 0:
              Type2 = 3886;
              break;
            case 1:
              Type2 = 3887;
              break;
            case 2:
              Type2 = 3950;
              break;
            case 3:
              Type2 = 3976;
              break;
            case 4:
              Type2 = -1;
              break;
            case 5:
              Type2 = 4164;
              break;
            case 6:
              Type2 = 4185;
              break;
            case 7:
              Type2 = 4206;
              break;
            case 8:
              Type2 = 4227;
              break;
            case 9:
              Type2 = 4266;
              break;
            case 10:
              Type2 = 4268;
              break;
            case 11:
              Type2 = 4585;
              break;
            case 12:
              Type2 = 4713;
              break;
            case 13:
              Type2 = -1;
              break;
            case 14:
              Type2 = 5167;
              break;
            case 15:
              Type2 = 5188;
              break;
            case 16:
              Type2 = 5209;
              break;
          }
          if (Type2 != -1)
          {
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, Type2);
            break;
          }
          break;
      }
      WorldGen.destroyObject = false;
      for (int i3 = num6 - 1; i3 < num6 + 3; ++i3)
      {
        for (int j2 = num3 - 1; j2 < num3 + 3; ++j2)
          WorldGen.TileFrame(i3, j2);
      }
    }

    public static void PlacePumpkin(int x, int superY)
    {
      ushort num1 = 254;
      int index1 = superY;
      int num2 = WorldGen.genRand.Next(6) * 36;
      if (x < 5 || x > Main.maxTilesX - 5 || index1 < 5 || index1 > Main.maxTilesY - 5)
        return;
      bool flag = true;
      for (int i = x - 1; i < x + 1; ++i)
      {
        for (int index2 = index1 - 1; index2 < index1 + 1; ++index2)
        {
          if (Main.tile[i, index2] == null)
            Main.tile[i, index2] = new Tile();
          if (Main.tile[i, index2].active() && Main.tile[i, index2].type != (ushort) 3 && Main.tile[i, index2].type != (ushort) 73 && Main.tile[i, index2].type != (ushort) 113 && Main.tile[i, index2].type != (ushort) 110 && (Main.tile[i, index2].type != (ushort) 185 || Main.tile[i, index2].frameY != (short) 0))
            flag = false;
          if (Main.tile[i, index2].liquid > (byte) 0)
            flag = false;
        }
        if (!WorldGen.SolidTile(i, index1 + 1) || Main.tile[i, index1 + 1].type != (ushort) 2 && Main.tile[i, index1 + 1].type != (ushort) 109)
          flag = false;
      }
      if (!flag)
        return;
      Main.tile[x - 1, index1 - 1].active(true);
      Main.tile[x - 1, index1 - 1].frameY = (short) num2;
      Main.tile[x - 1, index1 - 1].frameX = (short) 0;
      Main.tile[x - 1, index1 - 1].type = num1;
      Main.tile[x, index1 - 1].active(true);
      Main.tile[x, index1 - 1].frameY = (short) num2;
      Main.tile[x, index1 - 1].frameX = (short) 18;
      Main.tile[x, index1 - 1].type = num1;
      Main.tile[x - 1, index1].active(true);
      Main.tile[x - 1, index1].frameY = (short) (num2 + 18);
      Main.tile[x - 1, index1].frameX = (short) 0;
      Main.tile[x - 1, index1].type = num1;
      Main.tile[x, index1].active(true);
      Main.tile[x, index1].frameY = (short) (num2 + 18);
      Main.tile[x, index1].frameX = (short) 18;
      Main.tile[x, index1].type = num1;
    }

    public static void GrowPumpkin(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = j;
      int num2 = (int) Main.tile[i, j].frameY / 18;
      while (num2 > 1)
        num2 -= 2;
      int tileY = num1 - num2;
      int num3 = (int) Main.tile[i, j].frameX / 18;
      int num4 = 0;
      while (num3 > 1)
      {
        num3 -= 2;
        ++num4;
      }
      int tileX = i - num3;
      int num5 = num4 * 36;
      if (num4 >= 4)
        return;
      for (int i1 = tileX; i1 < tileX + 2; ++i1)
      {
        for (int index = tileY; index < tileY + 2; ++index)
        {
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || (int) Main.tile[i1, index].frameX != (i1 - tileX) * 18 + num5)
            flag = true;
        }
        if (!WorldGen.SolidTile(i1, tileY + 2) || Main.tile[i1, tileY + 2].type != (ushort) 2 && Main.tile[i1, tileY + 2].type != (ushort) 477 && Main.tile[i1, tileY + 2].type != (ushort) 492 && Main.tile[i1, tileY + 2].type != (ushort) 109)
          flag = true;
      }
      if (!flag)
      {
        for (int index1 = tileX; index1 < tileX + 2; ++index1)
        {
          for (int index2 = tileY; index2 < tileY + 2; ++index2)
          {
            if (Main.tile[index1, index2] == null)
              Main.tile[index1, index2] = new Tile();
            if ((int) Main.tile[index1, index2].type == type && Main.tile[index1, index2].active())
              Main.tile[index1, index2].frameX += (short) 36;
          }
        }
      }
      if (Main.netMode != 2)
        return;
      NetMessage.SendTileSquare(-1, tileX, tileY, 2, 2);
    }

    public static void FixHearts()
    {
      for (int i = 0; i < Main.maxTilesX; ++i)
      {
        for (int j = 0; j < Main.maxTilesY; ++j)
        {
          Tile tile = Main.tile[i, j];
          if (tile.active() && tile.type == (ushort) 12 && tile.frameX == (short) 0 && tile.frameY == (short) 0)
            WorldGen.FixHeart(i, j);
        }
      }
    }

    public static void DestroyHeart(int i, int j)
    {
      WorldGen.destroyObject = true;
      for (int i1 = i; i1 < i + 2; ++i1)
      {
        for (int j1 = j; j1 < j + 2; ++j1)
        {
          if (i1 < Main.maxTilesX && j1 < Main.maxTilesY)
          {
            Tile tile = Main.tile[i1, j1];
            if (tile.active() && tile.type == (ushort) 12)
              WorldGen.KillTile(i1, j1);
          }
        }
      }
      WorldGen.destroyObject = false;
    }

    public static void FixHeart(int i, int j)
    {
      if (i < Main.offLimitBorderTiles || i >= Main.maxTilesX - Main.offLimitBorderTiles || j < Main.offLimitBorderTiles || j >= Main.maxTilesY - Main.offLimitBorderTiles)
      {
        WorldGen.DestroyHeart(i, j);
      }
      else
      {
        Tile tile1 = Main.tile[i, j + 2];
        Tile tile2 = Main.tile[i + 1, j + 2];
        if (tile1.active() && !Main.tileSolid[(int) tile1.type] && Main.tileCut[(int) tile1.type])
          WorldGen.KillTile(i, j + 2);
        if (tile2.active() && !Main.tileSolid[(int) tile2.type] && Main.tileCut[(int) tile2.type])
          WorldGen.KillTile(i + 1, j + 2);
        if (!tile1.active())
        {
          if (!tile2.active())
          {
            WorldGen.DestroyHeart(i, j);
            return;
          }
          if (Main.tileSolid[(int) tile2.type])
          {
            tile1.type = tile2.type;
            tile1.active(true);
          }
        }
        if (!tile2.active() && Main.tileSolid[(int) tile1.type])
        {
          tile2.type = tile1.type;
          tile2.active(true);
        }
        if (!tile1.nactive() || !Main.tileSolid[(int) tile1.type] || !tile2.nactive() || !Main.tileSolid[(int) tile2.type])
        {
          WorldGen.DestroyHeart(i, j);
        }
        else
        {
          if (tile1.blockType() != 0)
          {
            tile1.slope((byte) 0);
            tile1.halfBrick(false);
          }
          if (tile2.blockType() == 0)
            return;
          tile2.slope((byte) 0);
          tile2.halfBrick(false);
        }
      }
    }

    public static void FixChands()
    {
      for (int i = 5; i < Main.maxTilesX - 5; ++i)
      {
        for (int j = 5; j < Main.maxTilesY - 5; ++j)
        {
          if (Main.tile[i, j].active())
          {
            int type = (int) Main.tile[i, j].type;
            if (Main.tile[i, j].active() && (type == 35 || type == 36 || type == 170 || type == 171 || type == 172))
              WorldGen.FixChand(i, j);
          }
        }
      }
    }

    public static void FixChand(int i, int j)
    {
      int num1 = 0;
      int type = (int) Main.tile[i, j].type;
      if (Main.tile[i, j].active())
      {
        if (type == 35)
          num1 = 1;
        if (type == 36)
          num1 = 2;
        if (type == 170)
          num1 = 3;
        if (type == 171)
          num1 = 4;
        if (type == 172)
          num1 = 5;
      }
      if (num1 <= 0)
        return;
      int num2 = j;
      int num3 = (int) Main.tile[i, j].frameX / 18;
      while (num3 >= 3)
        num3 -= 3;
      if (num3 >= 3)
        num3 -= 3;
      int num4 = i - num3;
      int num5 = num2 + (int) Main.tile[i, j].frameY / 18 * -1;
      for (int index1 = num4; index1 < num4 + 3; ++index1)
      {
        for (int index2 = num5; index2 < num5 + 3; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (Main.tile[index1, index2].active() && (int) Main.tile[index1, index2].type == type)
          {
            Main.tile[index1, index2].type = (ushort) 34;
            Main.tile[index1, index2].frameY += (short) (num1 * 54);
          }
        }
      }
    }

    public static void PlaceChand(int x, int y, ushort type, int style = 0)
    {
      bool flag = true;
      int num1 = 0;
      for (int index1 = x - 1; index1 < x + 2; ++index1)
      {
        for (int index2 = y; index2 < y + 3; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (Main.tile[index1, index2].active())
            flag = false;
        }
      }
      if (Main.tile[x, y - 1] == null)
        Main.tile[x, y - 1] = new Tile();
      if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[(int) Main.tile[x, y - 1].type] || Main.tileSolidTop[(int) Main.tile[x, y - 1].type])
        flag = false;
      if (!flag)
        return;
      int num2 = style / 36 * 18 * 6;
      int num3 = style * 18 * 3;
      Main.tile[x - 1, y + num1].active(true);
      Main.tile[x - 1, y + num1].frameY = (short) num3;
      Main.tile[x - 1, y + num1].frameX = (short) num2;
      Main.tile[x - 1, y + num1].type = type;
      Main.tile[x, y + num1].active(true);
      Main.tile[x, y + num1].frameY = (short) num3;
      Main.tile[x, y + num1].frameX = (short) (num2 + 18);
      Main.tile[x, y + num1].type = type;
      Main.tile[x + 1, y + num1].active(true);
      Main.tile[x + 1, y + num1].frameY = (short) num3;
      Main.tile[x + 1, y + num1].frameX = (short) (num2 + 36);
      Main.tile[x + 1, y + num1].type = type;
      Main.tile[x - 1, y + 1 + num1].active(true);
      Main.tile[x - 1, y + 1 + num1].frameY = (short) (num3 + 18);
      Main.tile[x - 1, y + 1 + num1].frameX = (short) num2;
      Main.tile[x - 1, y + 1 + num1].type = type;
      Main.tile[x, y + 1 + num1].active(true);
      Main.tile[x, y + 1 + num1].frameY = (short) (num3 + 18);
      Main.tile[x, y + 1 + num1].frameX = (short) (num2 + 18);
      Main.tile[x, y + 1 + num1].type = type;
      Main.tile[x + 1, y + 1 + num1].active(true);
      Main.tile[x + 1, y + 1 + num1].frameY = (short) (num3 + 18);
      Main.tile[x + 1, y + 1 + num1].frameX = (short) (num2 + 36);
      Main.tile[x + 1, y + 1 + num1].type = type;
      Main.tile[x - 1, y + 2 + num1].active(true);
      Main.tile[x - 1, y + 2 + num1].frameY = (short) (num3 + 36);
      Main.tile[x - 1, y + 2 + num1].frameX = (short) num2;
      Main.tile[x - 1, y + 2 + num1].type = type;
      Main.tile[x, y + 2 + num1].active(true);
      Main.tile[x, y + 2 + num1].frameY = (short) (num3 + 36);
      Main.tile[x, y + 2 + num1].frameX = (short) (num2 + 18);
      Main.tile[x, y + 2 + num1].type = type;
      Main.tile[x + 1, y + 2 + num1].active(true);
      Main.tile[x + 1, y + 2 + num1].frameY = (short) (num3 + 36);
      Main.tile[x + 1, y + 2 + num1].frameX = (short) (num2 + 36);
      Main.tile[x + 1, y + 2 + num1].type = type;
    }

    public static void CheckChand(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = 3;
      if (type == 454)
        num1 = 4;
      int num2 = (int) Main.tile[i, j].frameX / 18;
      int num3 = 0;
      for (; num2 >= num1; num2 -= num1)
        ++num3;
      int num4 = i - num2;
      int num5 = 18 * num1 * num3;
      if (num2 >= num1)
        num2 -= num1;
      int num6 = i - num2;
      int num7 = (int) Main.tile[i, j].frameY / 18;
      int num8 = 0;
      for (; num7 >= 3; num7 -= 3)
        ++num8;
      if (num5 >= 108)
        num8 += 37 * (num5 / 108);
      int num9 = 54 * num8;
      if (num5 >= 108)
        num9 -= 54 * (num5 / 108) * 37;
      if (num7 >= 3)
        num7 -= 3;
      int num10 = j - num7;
      for (int index1 = num6; index1 < num6 + num1; ++index1)
      {
        for (int index2 = num10; index2 < num10 + 3; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (!Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != type || (int) Main.tile[index1, index2].frameX != (index1 - num4) * 18 + num5 || (int) Main.tile[index1, index2].frameY != (index2 - num10) * 18 + num9)
            flag = true;
        }
      }
      if (Main.tile[num6 + 1, num10 - 1] == null)
        Main.tile[num6 + 1, num10 - 1] = new Tile();
      if (!Main.tile[num6 + 1, num10 - 1].nactive() || !Main.tileSolid[(int) Main.tile[num6 + 1, num10 - 1].type] || Main.tileSolidTop[(int) Main.tile[num6 + 1, num10 - 1].type])
        flag = true;
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i1 = num6; i1 < num6 + num1; ++i1)
      {
        for (int j1 = num10; j1 < num10 + 3; ++j1)
        {
          if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
            WorldGen.KillTile(i1, j1);
        }
      }
      if (type == 454)
      {
        switch (Main.rand.Next(9))
        {
          case 2:
          case 3:
          case 4:
            int num11 = Main.rand.Next(10, 31);
            while (num11 > 0)
            {
              int Stack = Main.rand.Next(2, 11);
              if (Stack > num11)
                Stack = num11;
              num11 -= Stack;
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, Stack);
            }
            break;
          case 5:
          case 6:
            int num12 = Main.rand.Next(60, 80);
            while (num12 > 0)
            {
              int Stack = Main.rand.Next(3, 16);
              if (Stack > num12)
                Stack = num12;
              num12 -= Stack;
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16 - 10, j * 16 - 10, 52, 52, 72, Stack);
            }
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1358);
            break;
          case 7:
            int num13 = Main.rand.Next(10, 31);
            while (num13 > 0)
            {
              int Stack = Main.rand.Next(2, 9);
              if (Stack > num13)
                Stack = num13;
              num13 -= Stack;
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16 - 10, j * 16 - 10, 52, 52, 72, Stack);
            }
            if (Main.rand.Next(8) == 0)
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3532);
            if (Main.rand.Next(8) == 0)
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3532);
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73);
            break;
          case 8:
            int num14 = 100;
            while (num14 > 0)
            {
              int Stack = Main.rand.Next(3, 16);
              if (Stack > num14)
                Stack = num14;
              num14 -= Stack;
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16 - 10, j * 16 - 10, 52, 52, 72, Stack);
            }
            int num15 = Main.rand.Next(30, 91);
            while (num15 > 0)
            {
              int Stack = Main.rand.Next(7, 14);
              if (Stack > num15)
                Stack = num15;
              num15 -= Stack;
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16 - 10, j * 16 - 10, 52, 52, 1349, Stack);
            }
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1358);
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73);
            break;
        }
      }
      if (type == 34)
      {
        int Type = num8 != 1 ? (num8 != 2 ? (num8 != 3 ? (num8 != 4 ? (num8 != 5 ? (num8 != 6 ? (num8 < 7 || num8 > 17 ? (num8 < 18 || num8 > 21 ? (num8 != 22 ? (num8 != 23 ? (num8 != 24 ? (num8 != 25 ? (num8 != 26 ? (num8 != 27 ? (num8 != 28 ? (num8 != 29 ? (num8 != 30 ? (num8 != 31 ? (num8 != 32 ? (num8 != 33 ? (num8 != 34 ? (num8 != 35 ? (num8 != 36 ? (num8 != 37 ? (num8 != 38 ? (num8 != 39 ? (num8 != 40 ? (num8 != 41 ? (num8 != 42 ? (num8 != 43 ? (num8 != 44 ? (num8 != 45 ? (num8 != 46 ? (num8 != 47 ? (num8 != 48 ? 106 : 5197) : 5176) : 5155) : 4573) : 4305) : 4215) : 4194) : 4173) : 4152) : 3964) : 3938) : 3894) : 3178) : 3179) : 3177) : 2813) : 2657) : 2656) : 2655) : 2654) : 2653) : 2652) : 2573) : 2558) : 2543) : 2525) : 2224) : 2141 + num8 - 18) : 2055 + num8 - 7) : 1812) : 712) : 711) : 710) : 108) : 107;
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, Type);
      }
      WorldGen.destroyObject = false;
      for (int i2 = num6 - 1; i2 < num6 + num1 + 1; ++i2)
      {
        for (int j2 = num10 - 1; j2 < num10 + 4; ++j2)
          WorldGen.TileFrame(i2, j2);
      }
    }

    public static void Check3x3(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = j;
      int num2 = (int) Main.tile[i, j].frameX / 18;
      int num3 = 0;
      for (; num2 >= 3; num2 -= 3)
        ++num3;
      int num4 = i - num2;
      int num5 = 54 * num3;
      int num6 = (int) Main.tile[i, j].frameY / 54;
      int num7 = (int) Main.tile[i, j].frameY % 54 / 18;
      if (num2 >= 3)
        num2 -= 3;
      int num8 = i - num2;
      int num9 = num1 - num7;
      for (int index1 = num8; index1 < num8 + 3; ++index1)
      {
        for (int index2 = num9; index2 < num9 + 3; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (!Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != type || (int) Main.tile[index1, index2].frameX != (index1 - num4) * 18 + num5 || (int) Main.tile[index1, index2].frameY != (index2 - num9) * 18 + num6 * 54)
            flag = true;
        }
      }
      if (type == 106 || type == 212 || type == 219 || type == 220 || type == 228 || type == 231 || type == 243 || type == 247 || type == 283 || type >= 300 && type <= 308 || type == 354 || type == 355 || type == 499 || type == 406 || type == 412 || type == 452 || type == 455 || type == 491 || type == 642)
      {
        for (int i1 = num8; i1 < num8 + 3; ++i1)
        {
          if (Main.tile[i1, num9 + 3] == null)
            Main.tile[i1, num9 + 3] = new Tile();
          if (!WorldGen.SolidTileAllowBottomSlope(i1, num9 + 3))
          {
            flag = true;
            break;
          }
        }
      }
      else
      {
        if (Main.tile[num8 + 1, num9 - 1] == null)
          Main.tile[num8 + 1, num9 - 1] = new Tile();
        if (!Main.tile[num8 + 1, num9 - 1].nactive() || !Main.tileSolid[(int) Main.tile[num8 + 1, num9 - 1].type] || Main.tileSolidTop[(int) Main.tile[num8 + 1, num9 - 1].type])
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i2 = num8; i2 < num8 + 3; ++i2)
      {
        for (int j1 = num9; j1 < num9 + 3; ++j1)
        {
          if ((int) Main.tile[i2, j1].type == type && Main.tile[i2, j1].active())
            WorldGen.KillTile(i2, j1);
        }
      }
      switch (type)
      {
        case 106:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 363);
          break;
        case 212:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 951);
          break;
        case 219:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 997);
          break;
        case 220:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 998);
          break;
        case 228:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1120);
          break;
        case 243:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1430);
          break;
        case 247:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1551);
          break;
        case 283:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2172);
          break;
        case 642:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5296);
          break;
        default:
          if (type >= 300 && type <= 306)
          {
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2192 + type - 300);
            break;
          }
          switch (type)
          {
            case 231:
              int x = (i + 1) * 16 + 8;
              int y = j * 16;
              Gore.NewGore(new Vector2((float) x, (float) y), new Vector2(), 300);
              Gore.NewGore(new Vector2((float) x, (float) (y + 8)), new Vector2(), 301);
              Gore.NewGore(new Vector2((float) x, (float) (y + 16)), new Vector2(), 302);
              float num10 = (float) (i * 16);
              float num11 = (float) (j * 16);
              float num12 = -1f;
              int plr = 0;
              for (int index = 0; index < (int) byte.MaxValue; ++index)
              {
                if (Main.player[index].active && !Main.player[index].dead)
                {
                  float num13 = Math.Abs(Main.player[index].position.X - num10) + Math.Abs(Main.player[index].position.Y - num11);
                  if ((double) num13 < (double) num12 || (double) num12 == -1.0)
                  {
                    plr = index;
                    num12 = num13;
                  }
                }
              }
              if ((double) num12 < 4800.0 && !Main.gameMenu)
              {
                NPC.SpawnOnPlayer(plr, 222);
                break;
              }
              break;
            case 307:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2203);
              break;
            case 308:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2204);
              break;
            case 354:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2999);
              break;
            case 355:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3000);
              break;
            case 406:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3365);
              break;
            case 412:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3549);
              break;
            case 452:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3742);
              break;
            case 455:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3747);
              break;
            case 491:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4076);
              break;
            case 499:
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4142);
              break;
          }
          break;
      }
      WorldGen.destroyObject = false;
      for (int i3 = num8 - 1; i3 < num8 + 4; ++i3)
      {
        for (int j2 = num9 - 1; j2 < num9 + 4; ++j2)
          WorldGen.TileFrame(i3, j2);
      }
    }

    public static void Check2x5(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = j;
      int num2 = (int) Main.tile[i, j].frameX / 18;
      int num3 = 0;
      for (; num2 >= 2; num2 -= 2)
        ++num3;
      int num4 = i - num2;
      int num5 = 36 * num3;
      int num6 = (int) Main.tile[i, j].frameY % 80 / 18;
      if (num2 >= 3)
        num2 -= 2;
      int num7 = i - num2;
      int num8 = num1 - num6;
      for (int index1 = num7; index1 < num7 + 2; ++index1)
      {
        for (int index2 = num8; index2 < num8 + 5; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (!Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != type || (int) Main.tile[index1, index2].frameX != (index1 - num4) * 18 + num5 || (int) Main.tile[index1, index2].frameY != (index2 - num8) * 18)
            flag = true;
        }
      }
      for (int i1 = num7; i1 < num7 + 2; ++i1)
      {
        if (Main.tile[i1, num8 + 5] == null)
          Main.tile[i1, num8 + 5] = new Tile();
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num8 + 5))
        {
          flag = true;
          break;
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i2 = num7; i2 < num7 + 2; ++i2)
      {
        for (int j1 = num8; j1 < num8 + 5; ++j1)
        {
          if ((int) Main.tile[i2, j1].type == type && Main.tile[i2, j1].active())
            WorldGen.KillTile(i2, j1);
        }
      }
      switch (type)
      {
        case 547:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4430 + num3);
          break;
        case 623:
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5081 + num3);
          break;
      }
      WorldGen.destroyObject = false;
      for (int i3 = num7 - 1; i3 < num7 + 3; ++i3)
      {
        for (int j2 = num8 - 1; j2 < num8 + 6; ++j2)
          WorldGen.TileFrame(i3, j2);
      }
    }

    public static void Check3x5(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = j;
      int num2 = (int) Main.tile[i, j].frameX / 18;
      int num3 = 0;
      for (; num2 >= 3; num2 -= 3)
        ++num3;
      int num4 = i - num2;
      int num5 = 54 * num3;
      int num6 = (int) Main.tile[i, j].frameY % 90 / 18;
      if (num2 >= 4)
        num2 -= 3;
      int num7 = i - num2;
      int num8 = num1 - num6;
      for (int index1 = num7; index1 < num7 + 3; ++index1)
      {
        for (int index2 = num8; index2 < num8 + 5; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (!Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != type || (int) Main.tile[index1, index2].frameX != (index1 - num4) * 18 + num5 || (int) Main.tile[index1, index2].frameY != (index2 - num8) * 18)
            flag = true;
        }
      }
      for (int i1 = num7; i1 < num7 + 3; ++i1)
      {
        if (Main.tile[i1, num8 + 5] == null)
          Main.tile[i1, num8 + 5] = new Tile();
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num8 + 5))
        {
          flag = true;
          break;
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i2 = num7; i2 < num7 + 3; ++i2)
      {
        for (int j1 = num8; j1 < num8 + 5; ++j1)
        {
          if ((int) Main.tile[i2, j1].type == type && Main.tile[i2, j1].active())
            WorldGen.KillTile(i2, j1);
        }
      }
      if (type == 613)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4904 + num3);
      WorldGen.destroyObject = false;
      for (int i3 = num7 - 1; i3 < num7 + 4; ++i3)
      {
        for (int j2 = num8 - 1; j2 < num8 + 6; ++j2)
          WorldGen.TileFrame(i3, j2);
      }
    }

    public static void Check3x6(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = j;
      int num2 = (int) Main.tile[i, j].frameX / 18;
      int num3 = 0;
      for (; num2 >= 3; num2 -= 3)
        ++num3;
      int num4 = i - num2;
      int num5 = 54 * num3;
      int num6 = (int) Main.tile[i, j].frameY % 96 / 18;
      if (num2 >= 4)
        num2 -= 3;
      int num7 = i - num2;
      int num8 = num1 - num6;
      for (int index1 = num7; index1 < num7 + 3; ++index1)
      {
        for (int index2 = num8; index2 < num8 + 6; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (!Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != type || (int) Main.tile[index1, index2].frameX != (index1 - num4) * 18 + num5 || (int) Main.tile[index1, index2].frameY != (index2 - num8) * 18)
            flag = true;
        }
      }
      for (int i1 = num7; i1 < num7 + 3; ++i1)
      {
        if (Main.tile[i1, num8 + 6] == null)
          Main.tile[i1, num8 + 6] = new Tile();
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num8 + 6))
        {
          flag = true;
          break;
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i2 = num7; i2 < num7 + 3; ++i2)
      {
        for (int j1 = num8; j1 < num8 + 6; ++j1)
        {
          if ((int) Main.tile[i2, j1].type == type && Main.tile[i2, j1].active())
            WorldGen.KillTile(i2, j1);
        }
      }
      if (type == 548)
      {
        if (num3 >= 7)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4902 + num3 - 7);
        else
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4435 + num3);
      }
      if (type == 614)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4906);
      WorldGen.destroyObject = false;
      for (int i3 = num7 - 1; i3 < num7 + 4; ++i3)
      {
        for (int j2 = num8 - 1; j2 < num8 + 7; ++j2)
          WorldGen.TileFrame(i3, j2);
      }
    }

    public static void Place3x3(int x, int y, ushort type, int style = 0)
    {
      bool flag = true;
      int num1 = 0;
      if (type == (ushort) 106 || type == (ushort) 212 || type == (ushort) 219 || type == (ushort) 220 || type == (ushort) 228 || type == (ushort) 231 || type == (ushort) 243 || type == (ushort) 247 || type == (ushort) 283 || type >= (ushort) 300 && type <= (ushort) 308 || type == (ushort) 354 || type == (ushort) 355 || type == (ushort) 642)
      {
        num1 = -2;
        for (int index1 = x - 1; index1 < x + 2; ++index1)
        {
          for (int index2 = y - 2; index2 < y + 1; ++index2)
          {
            if (Main.tile[index1, index2] == null)
              Main.tile[index1, index2] = new Tile();
            if (Main.tile[index1, index2].active())
              flag = false;
          }
        }
        for (int i = x - 1; i < x + 2; ++i)
        {
          if (Main.tile[i, y + 1] == null)
            Main.tile[i, y + 1] = new Tile();
          if (!WorldGen.SolidTile2(i, y + 1))
          {
            flag = false;
            break;
          }
        }
      }
      else
      {
        for (int index3 = x - 1; index3 < x + 2; ++index3)
        {
          for (int index4 = y; index4 < y + 3; ++index4)
          {
            if (Main.tile[index3, index4] == null)
              Main.tile[index3, index4] = new Tile();
            if (Main.tile[index3, index4].active())
              flag = false;
          }
        }
        if (Main.tile[x, y - 1] == null)
          Main.tile[x, y - 1] = new Tile();
        if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[(int) Main.tile[x, y - 1].type] || Main.tileSolidTop[(int) Main.tile[x, y - 1].type])
          flag = false;
      }
      if (!flag)
        return;
      int num2 = style * 18 * 3;
      Main.tile[x - 1, y + num1].active(true);
      Main.tile[x - 1, y + num1].frameY = (short) 0;
      Main.tile[x - 1, y + num1].frameX = (short) num2;
      Main.tile[x - 1, y + num1].type = type;
      Main.tile[x, y + num1].active(true);
      Main.tile[x, y + num1].frameY = (short) 0;
      Main.tile[x, y + num1].frameX = (short) (num2 + 18);
      Main.tile[x, y + num1].type = type;
      Main.tile[x + 1, y + num1].active(true);
      Main.tile[x + 1, y + num1].frameY = (short) 0;
      Main.tile[x + 1, y + num1].frameX = (short) (num2 + 36);
      Main.tile[x + 1, y + num1].type = type;
      Main.tile[x - 1, y + 1 + num1].active(true);
      Main.tile[x - 1, y + 1 + num1].frameY = (short) 18;
      Main.tile[x - 1, y + 1 + num1].frameX = (short) num2;
      Main.tile[x - 1, y + 1 + num1].type = type;
      Main.tile[x, y + 1 + num1].active(true);
      Main.tile[x, y + 1 + num1].frameY = (short) 18;
      Main.tile[x, y + 1 + num1].frameX = (short) (num2 + 18);
      Main.tile[x, y + 1 + num1].type = type;
      Main.tile[x + 1, y + 1 + num1].active(true);
      Main.tile[x + 1, y + 1 + num1].frameY = (short) 18;
      Main.tile[x + 1, y + 1 + num1].frameX = (short) (num2 + 36);
      Main.tile[x + 1, y + 1 + num1].type = type;
      Main.tile[x - 1, y + 2 + num1].active(true);
      Main.tile[x - 1, y + 2 + num1].frameY = (short) 36;
      Main.tile[x - 1, y + 2 + num1].frameX = (short) num2;
      Main.tile[x - 1, y + 2 + num1].type = type;
      Main.tile[x, y + 2 + num1].active(true);
      Main.tile[x, y + 2 + num1].frameY = (short) 36;
      Main.tile[x, y + 2 + num1].frameX = (short) (num2 + 18);
      Main.tile[x, y + 2 + num1].type = type;
      Main.tile[x + 1, y + 2 + num1].active(true);
      Main.tile[x + 1, y + 2 + num1].frameY = (short) 36;
      Main.tile[x + 1, y + 2 + num1].frameX = (short) (num2 + 36);
      Main.tile[x + 1, y + 2 + num1].type = type;
    }

    public static void PlaceSunflower(int x, int y, ushort type = 27)
    {
      if ((double) y > Main.worldSurface - 1.0 && !Main.remixWorld)
        return;
      bool flag = true;
      for (int index1 = x; index1 < x + 2; ++index1)
      {
        for (int index2 = y - 3; index2 < y + 1; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (Main.tile[index1, index2].active() || Main.tile[index1, index2].wall > (ushort) 0)
            flag = false;
        }
        if (Main.tile[index1, y + 1] == null)
          Main.tile[index1, y + 1] = new Tile();
        if (!Main.tile[index1, y + 1].nactive() || Main.tile[index1, y + 1].halfBrick() || Main.tile[index1, y + 1].slope() != (byte) 0 || Main.tile[index1, y + 1].type != (ushort) 2 && Main.tile[index1, y + 1].type != (ushort) 109)
          flag = false;
      }
      if (!flag)
        return;
      int num1 = WorldGen.genRand.Next(3);
      for (int index3 = 0; index3 < 2; ++index3)
      {
        for (int index4 = -3; index4 < 1; ++index4)
        {
          int num2 = index3 * 18 + WorldGen.genRand.Next(3) * 36;
          if (index4 <= -2)
            num2 = index3 * 18 + num1 * 36;
          int num3 = (index4 + 3) * 18;
          Main.tile[x + index3, y + index4].active(true);
          Main.tile[x + index3, y + index4].frameX = (short) num2;
          Main.tile[x + index3, y + index4].frameY = (short) num3;
          Main.tile[x + index3, y + index4].type = type;
        }
      }
    }

    public static void FixSunflowers()
    {
      for (int i = 5; i < Main.maxTilesX - 5; ++i)
      {
        for (int j = 5; (double) j < Main.worldSurface; ++j)
        {
          if (Main.tile[i, j].active() && Main.tile[i, j].type == (ushort) 27)
            WorldGen.FixSunflower(i, j);
        }
      }
    }

    public static void FixSunflower(int i, int j)
    {
      if (Main.tile[i, j].type != (ushort) 27)
        return;
      int num1 = 0;
      int num2 = j;
      int num3 = num1 + (int) Main.tile[i, j].frameX / 18;
      int num4 = num2 + (int) Main.tile[i, j].frameY / 18 * -1;
      while (num3 > 1)
        num3 -= 2;
      int num5 = num3 * -1 + i;
      int num6 = WorldGen.genRand.Next(3) * 36;
      int num7 = 0;
      for (int index1 = num5; index1 < num5 + 2; ++index1)
      {
        for (int index2 = num4; index2 < num4 + 4; ++index2)
          Main.tile[index1, index2].frameX = (short) (num7 + num6);
        num7 += 18;
      }
    }

    public static void CheckSunflower(int i, int j, int type = 27)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = 0;
      int num2 = j;
      int num3 = num1 + (int) Main.tile[i, j].frameX / 18;
      int num4 = num2 + (int) Main.tile[i, j].frameY / 18 * -1;
      while (num3 > 1)
        num3 -= 2;
      int num5 = num3 * -1 + i;
      for (int i1 = num5; i1 < num5 + 2; ++i1)
      {
        for (int index = num4; index < num4 + 4; ++index)
        {
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          int num6 = (int) Main.tile[i1, index].frameX / 18;
          while (num6 > 1)
            num6 -= 2;
          if (!Main.tile[i1, index].nactive() || (int) Main.tile[i1, index].type != type || num6 != i1 - num5 || (int) Main.tile[i1, index].frameY != (index - num4) * 18)
            flag = true;
        }
        if (Main.tile[i1, num4 + 4] == null)
          Main.tile[i1, num4 + 4] = new Tile();
        if (!Main.tile[i1, num4 + 4].nactive() || Main.tile[i1, num4 + 4].type != (ushort) 2 && Main.tile[i1, num4 + 4].type != (ushort) 477 && Main.tile[i1, num4 + 4].type != (ushort) 492 && Main.tile[i1, num4 + 4].type != (ushort) 109 && Main.tile[i1, num4 + 4].type != (ushort) 60 && Main.tile[i1, num4 + 4].type != (ushort) 633)
          flag = true;
        if (!WorldGen.SolidTile(i1, num4 + 4))
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i2 = num5; i2 < num5 + 2; ++i2)
      {
        for (int j1 = num4; j1 < num4 + 4; ++j1)
        {
          if ((int) Main.tile[i2, j1].type == type && Main.tile[i2, j1].active())
            WorldGen.KillTile(i2, j1);
        }
      }
      Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 63);
      WorldGen.destroyObject = false;
    }

    public static void CheckDye(int x, int y)
    {
      switch ((int) Main.tile[x, y].frameX / 34)
      {
        case 6:
          if (Main.tile[x, y + 1].nactive() && Main.tile[x, y + 1].type == (ushort) 80)
            break;
          WorldGen.KillTile(x, y);
          break;
        case 7:
          if (WorldGen.SolidTile(x, y - 1))
            break;
          WorldGen.KillTile(x, y);
          break;
        default:
          if (WorldGen.SolidTile(x, y + 1))
            break;
          WorldGen.KillTile(x, y);
          break;
      }
    }

    public static void CheckRockGolemHead(int x, int y)
    {
      if (WorldGen.SolidTileAllowBottomSlope(x, y + 1))
        return;
      WorldGen.KillTile(x, y);
    }

    public static void CheckStinkbugBlocker(int x, int y)
    {
      Tile tileSafely = Framing.GetTileSafely(x, y);
      int num = (int) tileSafely.frameX / 18;
      int style = -1;
      if (WorldGen.AttemptReorientingStinkbugBlocker(x, y, (int) tileSafely.wall, ref style))
      {
        if (style == num)
          return;
        tileSafely.frameX = (short) (style * 18);
      }
      else
        WorldGen.KillTile(x, y);
    }

    public static bool AttemptReorientingStinkbugBlocker(int x, int y, int wall, ref int style)
    {
      style = -1;
      if (style == -1 && WorldGen.SolidTileAllowBottomSlope(x, y + 1))
        style = 0;
      if (style == -1 && WorldGen.SolidTileAllowBottomSlope(x, y - 1))
        style = 1;
      if (style == -1 && WorldGen.SolidTileAllowBottomSlope(x + 1, y))
        style = 2;
      if (style == -1 && WorldGen.SolidTileAllowBottomSlope(x - 1, y))
        style = 3;
      if (style == -1 && wall > 0)
        style = 4;
      return style > -1;
    }

    public static void CheckGnome(int x, int j)
    {
      if (WorldGen.destroyObject)
        return;
      int num1 = 567;
      int num2 = j;
      bool flag = true;
      Tile tileSafely1 = Framing.GetTileSafely(x, num2);
      Tile tileSafely2 = Framing.GetTileSafely(x, num2 + 1);
      if (tileSafely1.frameY > (short) 0)
      {
        --num2;
        tileSafely1 = Framing.GetTileSafely(x, num2);
        tileSafely2 = Framing.GetTileSafely(x, num2 + 1);
      }
      int num3 = (int) tileSafely1.frameX / 28;
      if (tileSafely1.frameY == (short) 0 && tileSafely2.frameY == (short) 20 && (int) tileSafely1.type == num1 && (int) tileSafely2.type == num1)
        flag = false;
      if (Main.tile[x, num2 + 2] == null)
        Main.tile[x, num2 + 2] = new Tile();
      if (!WorldGen.SolidTileAllowBottomSlope(x, num2 + 2) && !TileID.Sets.Platforms[(int) Main.tile[x, num2 + 2].type])
        flag = true;
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      if ((int) tileSafely1.type == num1)
        WorldGen.KillTile(x, num2);
      if ((int) tileSafely2.type == num1)
        WorldGen.KillTile(x, num2 + 1);
      Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, num2), x * 16, num2 * 16, 16, 32, 4609);
      WorldGen.destroyObject = false;
    }

    public static void PlaceGnome(int x, int y, int style) => WorldGen.PlaceObject(x, y, 567, style: style);

    public static void PlaceDye(int x, int y, int style)
    {
      bool flag = false;
      if (Main.tile[x, y + 1] == null || Main.tile[x, y - 1] == null)
        return;
      if (style == 7)
      {
        if (Main.tile[x, y + 1].active() && Main.tile[x, y + 1].type != (ushort) 3 && Main.tile[x, y + 1].type != (ushort) 51 && Main.tile[x, y + 1].type != (ushort) 61 && Main.tile[x, y + 1].type != (ushort) 73 && Main.tile[x, y + 1].type != (ushort) 74 && Main.tile[x, y + 1].type != (ushort) 184)
          return;
        if (WorldGen.SolidTile(x, y - 1) && !Main.tile[x, y + 1].active())
          flag = true;
      }
      else
      {
        if (Main.tile[x, y - 1].active() && Main.tile[x, y - 1].type != (ushort) 3 && Main.tile[x, y - 1].type != (ushort) 51 && Main.tile[x, y - 1].type != (ushort) 61 && Main.tile[x, y - 1].type != (ushort) 73 && Main.tile[x, y - 1].type != (ushort) 74 && Main.tile[x, y - 1].type != (ushort) 184)
          return;
        if (style == 6)
        {
          if (Main.tile[x, y + 1].nactive() && Main.tile[x, y + 1].type == (ushort) 80 && !Main.tile[x - 1, y + 1].active() && !Main.tile[x + 1, y + 1].active())
            flag = true;
        }
        else if (WorldGen.SolidTile(x, y + 1) && !Main.tile[x, y - 1].active())
        {
          switch (style)
          {
            case 5:
              if (Main.tile[x, y].liquid == byte.MaxValue && !Main.tile[x, y].lava() && !Main.tile[x, y].honey() && !Main.tile[x, y].shimmer())
              {
                flag = true;
                break;
              }
              break;
            case 8:
            case 9:
            case 10:
            case 11:
              flag = true;
              break;
            default:
              if (Main.tile[x, y].liquid == (byte) 0)
              {
                if (style == 3 || style == 4)
                {
                  if (Main.tile[x, y].wall == (ushort) 0)
                  {
                    flag = true;
                    break;
                  }
                  break;
                }
                flag = true;
                break;
              }
              break;
          }
        }
      }
      if (!flag)
        return;
      Main.tile[x, y].type = (ushort) 227;
      Main.tile[x, y].active(true);
      Main.tile[x, y].halfBrick(false);
      Main.tile[x, y].slope((byte) 0);
      Main.tile[x, y].frameY = (short) 0;
      Main.tile[x, y].frameX = (short) (34 * style);
    }

    public static bool PlacePot(int x, int y, ushort type = 28, int style = 0)
    {
      bool flag = true;
      if (WorldGen.remixWorldGen && (double) x > (double) Main.maxTilesX * 0.48 && (double) x < (double) Main.maxTilesX * 0.52 && y > Main.maxTilesY - 220)
        flag = false;
      for (int index1 = x; index1 < x + 2; ++index1)
      {
        for (int index2 = y - 1; index2 < y + 1; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (Main.tile[index1, index2].active())
            flag = false;
        }
        if (Main.tile[index1, y + 1] == null)
          Main.tile[index1, y + 1] = new Tile();
        if (!Main.tile[index1, y + 1].nactive() || Main.tile[index1, y + 1].halfBrick() || Main.tile[index1, y + 1].slope() != (byte) 0 || !Main.tileSolid[(int) Main.tile[index1, y + 1].type])
          flag = false;
      }
      if (!flag)
        return false;
      int num1 = WorldGen.genRand.Next(3) * 36;
      for (int index3 = 0; index3 < 2; ++index3)
      {
        for (int index4 = -1; index4 < 1; ++index4)
        {
          int num2 = index3 * 18 + num1;
          int num3 = (index4 + 1) * 18;
          Main.tile[x + index3, y + index4].active(true);
          Main.tile[x + index3, y + index4].frameX = (short) num2;
          Main.tile[x + index3, y + index4].frameY = (short) (num3 + style * 36);
          Main.tile[x + index3, y + index4].type = type;
          Main.tile[x + index3, y + index4].halfBrick(false);
        }
      }
      return true;
    }

    public static bool CheckCactus(int i, int j)
    {
      int index1 = j;
      int index2 = i;
      while (Main.tile[index2, index1] != null && Main.tile[index2, index1].active() && Main.tile[index2, index1].type == (ushort) 80)
      {
        ++index1;
        if (Main.tile[index2, index1] == null)
          return false;
        if (!Main.tile[index2, index1].active() || Main.tile[index2, index1].type != (ushort) 80)
        {
          if (Main.tile[index2 - 1, index1] != null && Main.tile[index2 - 1, index1].active() && Main.tile[index2 - 1, index1].type == (ushort) 80 && Main.tile[index2 - 1, index1 - 1] != null && Main.tile[index2 - 1, index1 - 1].active() && Main.tile[index2 - 1, index1 - 1].type == (ushort) 80 && index2 >= i)
            --index2;
          if (Main.tile[index2 + 1, index1] != null && Main.tile[index2 + 1, index1].active() && Main.tile[index2 + 1, index1].type == (ushort) 80 && Main.tile[index2 + 1, index1 - 1] != null && Main.tile[index2 + 1, index1 - 1].active() && Main.tile[index2 + 1, index1 - 1].type == (ushort) 80 && index2 <= i)
            ++index2;
        }
      }
      if (!Main.tile[index2, index1].nactive() || Main.tile[index2, index1].halfBrick() || Main.tile[index2, index1].slope() != (byte) 0 || Main.tile[index2, index1].type != (ushort) 53 && Main.tile[index2, index1].type != (ushort) 112 && Main.tile[index2, index1].type != (ushort) 116 && Main.tile[index2, index1].type != (ushort) 234)
      {
        WorldGen.KillTile(i, j);
        return true;
      }
      if (i != index2)
      {
        if ((!Main.tile[i, j + 1].active() || Main.tile[i, j + 1].type != (ushort) 80) && (!Main.tile[i - 1, j].active() || Main.tile[i - 1, j].type != (ushort) 80) && (!Main.tile[i + 1, j].active() || Main.tile[i + 1, j].type != (ushort) 80))
        {
          WorldGen.KillTile(i, j);
          return true;
        }
      }
      else if (i == index2 && (!Main.tile[i, j + 1].active() || Main.tile[i, j + 1].type != (ushort) 80 && Main.tile[i, j + 1].type != (ushort) 53 && Main.tile[i, j + 1].type != (ushort) 112 && Main.tile[i, j + 1].type != (ushort) 116 && Main.tile[i, j + 1].type != (ushort) 234))
      {
        WorldGen.KillTile(i, j);
        return true;
      }
      return false;
    }

    public static void PlantCactus(int i, int j)
    {
      WorldGen.GrowCactus(i, j);
      for (int index = 0; index < 150; ++index)
        WorldGen.GrowCactus(WorldGen.genRand.Next(i - 1, i + 2), WorldGen.genRand.Next(j - 10, j + 2));
    }

    public static void CheckOrb(int i, int j, int type)
    {
      if (Main.tile[i, j] == null)
        return;
      int frameX = (int) Main.tile[i, j].frameX;
      bool flag = false;
      if (frameX >= 36)
        flag = true;
      if (WorldGen.destroyObject)
        return;
      int x = Main.tile[i, j].frameX == (short) 0 || Main.tile[i, j].frameX == (short) 36 ? i : i - 1;
      int y = Main.tile[i, j].frameY != (short) 0 ? j - 1 : j;
      for (int index1 = 0; index1 < 2; ++index1)
      {
        for (int index2 = 0; index2 < 2; ++index2)
        {
          Tile tile = Main.tile[x + index1, y + index2];
          if (tile != null && (!tile.nactive() || (int) tile.type != type))
          {
            WorldGen.destroyObject = true;
            break;
          }
        }
        if (!WorldGen.destroyObject)
        {
          if ((type == 12 || type == 639) && Main.tile[x + index1, y + 2] != null && !WorldGen.SolidTileAllowBottomSlope(x + index1, y + 2))
          {
            WorldGen.destroyObject = true;
            break;
          }
        }
        else
          break;
      }
      if (!WorldGen.destroyObject)
        return;
      for (int i1 = x; i1 < x + 2; ++i1)
      {
        for (int j1 = y; j1 < y + 2; ++j1)
        {
          if (Main.tile[i1, j1] != null && (int) Main.tile[i1, j1].type == type)
            WorldGen.KillTile(i1, j1);
        }
      }
      if (Main.netMode != 1 && !WorldGen.noTileActions)
      {
        switch (type)
        {
          case 12:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 29);
            break;
          case 31:
            if (flag)
            {
              int num = Main.rand.Next(5);
              if (!WorldGen.shadowOrbSmashed)
                num = 0;
              switch (num)
              {
                case 0:
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 800, pfix: -1);
                  int Stack = WorldGen.genRand.Next(100, 101);
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 97, Stack);
                  break;
                case 1:
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1256, pfix: -1);
                  break;
                case 2:
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 802, pfix: -1);
                  break;
                case 3:
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3062, pfix: -1);
                  break;
                case 4:
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1290, pfix: -1);
                  break;
              }
            }
            else
            {
              int num = Main.rand.Next(5);
              if (!WorldGen.shadowOrbSmashed)
                num = 0;
              switch (num)
              {
                case 0:
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 96, pfix: -1);
                  int Stack = WorldGen.genRand.Next(100, 101);
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 97, Stack);
                  break;
                case 1:
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 64, pfix: -1);
                  break;
                case 2:
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 162, pfix: -1);
                  break;
                case 3:
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 115, pfix: -1);
                  break;
                case 4:
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 111, pfix: -1);
                  break;
              }
            }
            WorldGen.shadowOrbSmashed = true;
            ++WorldGen.shadowOrbCount;
            if (WorldGen.shadowOrbCount >= 3)
            {
              if (!(NPC.AnyNPCs(266) & flag) && (!NPC.AnyNPCs(13) || flag))
              {
                WorldGen.shadowOrbCount = 0;
                float num1 = (float) (x * 16);
                float num2 = (float) (y * 16);
                float num3 = -1f;
                int plr = 0;
                for (int index = 0; index < (int) byte.MaxValue; ++index)
                {
                  float num4 = Math.Abs(Main.player[index].position.X - num1) + Math.Abs(Main.player[index].position.Y - num2);
                  if ((double) num4 < (double) num3 || (double) num3 == -1.0)
                  {
                    plr = index;
                    num3 = num4;
                  }
                }
                if (flag)
                  NPC.SpawnOnPlayer(plr, 266);
                else
                  NPC.SpawnOnPlayer(plr, 13);
              }
            }
            else
            {
              LocalizedText localizedText = Lang.misc[10];
              if (WorldGen.shadowOrbCount == 2)
                localizedText = Lang.misc[11];
              switch (Main.netMode)
              {
                case 0:
                  Main.NewText(localizedText.ToString(), (byte) 50, B: (byte) 130);
                  break;
                case 2:
                  ChatHelper.BroadcastChatMessage(NetworkText.FromKey(localizedText.Key), new Color(50, (int) byte.MaxValue, 130));
                  break;
              }
            }
            AchievementsHelper.NotifyProgressionEvent(7);
            break;
          case 639:
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 109);
            break;
        }
      }
      if (flag)
        SoundEngine.PlaySound(4, i * 16, j * 16);
      else
        SoundEngine.PlaySound(13, i * 16, j * 16);
      WorldGen.destroyObject = false;
    }

    public static void CheckPalmTree(int i, int j)
    {
      int num1 = -1;
      int num2 = -1;
      int type = (int) Main.tile[i, j].type;
      int frameX = (int) Main.tile[i, j].frameX;
      int frameY = (int) Main.tile[i, j].frameY;
      if (Main.tile[i, j - 1] != null && Main.tile[i, j - 1].active())
        num1 = (int) Main.tile[i, j - 1].type;
      if (Main.tile[i, j + 1] != null && Main.tile[i, j + 1].active())
        num2 = (int) Main.tile[i, j + 1].type;
      if (num2 == 53)
        num2 = 53;
      if (num2 == 234)
        num2 = 53;
      if (num2 == 116)
        num2 = 53;
      if (num2 == 112)
        num2 = 53;
      if (num2 != 53 && num2 != type)
        WorldGen.KillTile(i, j);
      if ((Main.tile[i, j].frameX == (short) 66 || Main.tile[i, j].frameX == (short) 220) && num2 != 53)
        WorldGen.KillTile(i, j);
      if (num1 != type && Main.tile[i, j].frameX <= (short) 44)
        Main.tile[i, j].frameX = (short) (WorldGen.genRand.Next(7, 10) * 22);
      else if (num1 != type && Main.tile[i, j].frameX == (short) 66)
        Main.tile[i, j].frameX = (short) 220;
      if ((int) Main.tile[i, j].frameX == frameX || (int) Main.tile[i, j].frameY == frameY || frameX < 0 || frameY < 0)
        return;
      WorldGen.TileFrame(i - 1, j);
      WorldGen.TileFrame(i + 1, j);
      WorldGen.TileFrame(i, j - 1);
      WorldGen.TileFrame(i, j + 1);
    }

    public static void CheckTreeWithSettings(int x, int y, WorldGen.CheckTreeSettings settings)
    {
      int num1 = -1;
      int num2 = -1;
      int num3 = -1;
      int groundTileType = -1;
      Tile tile = Main.tile[x, y];
      int type = (int) tile.type;
      int frameX = (int) tile.frameX;
      int frameY = (int) tile.frameY;
      if (Main.tile[x - 1, y] != null && Main.tile[x - 1, y].active())
        num2 = (int) Main.tile[x - 1, y].type;
      if (Main.tile[x + 1, y] != null && Main.tile[x + 1, y].active())
        num3 = (int) Main.tile[x + 1, y].type;
      if (Main.tile[x, y - 1] != null && Main.tile[x, y - 1].active())
        num1 = (int) Main.tile[x, y - 1].type;
      if (Main.tile[x, y + 1] != null && Main.tile[x, y + 1].active())
        groundTileType = (int) Main.tile[x, y + 1].type;
      bool flag1 = settings.IsGroundValid(groundTileType);
      bool flag2 = num3 == type;
      bool flag3 = num2 == type;
      if (!flag1 && groundTileType != type && (tile.frameX == (short) 0 && tile.frameY <= (short) 130 || tile.frameX == (short) 22 && tile.frameY <= (short) 130 || tile.frameX == (short) 44 && tile.frameY <= (short) 130))
        WorldGen.KillTile(x, y);
      if (tile.frameX >= (short) 22 && tile.frameX <= (short) 44 && tile.frameY >= (short) 132 && tile.frameY <= (short) 176)
      {
        if (!flag1)
          WorldGen.KillTile(x, y);
        else if (!(tile.frameX == (short) 22 & flag3) && !(tile.frameX == (short) 44 & flag2))
          WorldGen.KillTile(x, y);
      }
      else if (tile.frameX == (short) 88 && tile.frameY >= (short) 0 && tile.frameY <= (short) 44 || tile.frameX == (short) 66 && tile.frameY >= (short) 66 && tile.frameY <= (short) 130 || tile.frameX == (short) 110 && tile.frameY >= (short) 66 && tile.frameY <= (short) 110 || tile.frameX == (short) 132 && tile.frameY >= (short) 0 && tile.frameY <= (short) 176)
      {
        if (flag3 & flag2)
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 110;
            tile.frameY = (short) 66;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 110;
            tile.frameY = (short) 88;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 110;
            tile.frameY = (short) 110;
          }
        }
        else if (flag3)
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 88;
            tile.frameY = (short) 0;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 88;
            tile.frameY = (short) 22;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 88;
            tile.frameY = (short) 44;
          }
        }
        else if (flag2)
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 66;
            tile.frameY = (short) 66;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 66;
            tile.frameY = (short) 88;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 66;
            tile.frameY = (short) 110;
          }
        }
        else
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 0;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 22;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 44;
          }
        }
      }
      if (tile.frameY >= (short) 132 && tile.frameY <= (short) 176 && (tile.frameX == (short) 0 || tile.frameX == (short) 66 || tile.frameX == (short) 88))
      {
        if (!flag1)
          WorldGen.KillTile(x, y);
        if (!flag3 && !flag2)
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 0;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 22;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 44;
          }
        }
        else if (!flag3)
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 132;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 154;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 176;
          }
        }
        else if (!flag2)
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 66;
            tile.frameY = (short) 132;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 66;
            tile.frameY = (short) 154;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 66;
            tile.frameY = (short) 176;
          }
        }
        else
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 88;
            tile.frameY = (short) 132;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 88;
            tile.frameY = (short) 154;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 88;
            tile.frameY = (short) 176;
          }
        }
      }
      if (tile.frameX == (short) 66 && (tile.frameY == (short) 0 || tile.frameY == (short) 22 || tile.frameY == (short) 44) || tile.frameX == (short) 44 && (tile.frameY == (short) 198 || tile.frameY == (short) 220 || tile.frameY == (short) 242))
      {
        if (!flag2)
          WorldGen.KillTile(x, y);
      }
      else if (tile.frameX == (short) 88 && (tile.frameY == (short) 66 || tile.frameY == (short) 88 || tile.frameY == (short) 110) || tile.frameX == (short) 66 && (tile.frameY == (short) 198 || tile.frameY == (short) 220 || tile.frameY == (short) 242))
      {
        if (!flag3)
          WorldGen.KillTile(x, y);
      }
      else if (groundTileType == -1)
        WorldGen.KillTile(x, y);
      else if (num1 != type && tile.frameY < (short) 198 && (tile.frameX != (short) 22 && tile.frameX != (short) 44 || tile.frameY < (short) 132))
      {
        if (flag3 | flag2)
        {
          if (groundTileType == type)
          {
            if (flag3 & flag2)
            {
              if (tile.frameNumber() == (byte) 0)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 132;
              }
              if (tile.frameNumber() == (byte) 1)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 154;
              }
              if (tile.frameNumber() == (byte) 2)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 176;
              }
            }
            else if (flag3)
            {
              if (tile.frameNumber() == (byte) 0)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 0;
              }
              if (tile.frameNumber() == (byte) 1)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 22;
              }
              if (tile.frameNumber() == (byte) 2)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 44;
              }
            }
            else if (flag2)
            {
              if (tile.frameNumber() == (byte) 0)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 66;
              }
              if (tile.frameNumber() == (byte) 1)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 88;
              }
              if (tile.frameNumber() == (byte) 2)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 110;
              }
            }
          }
          else if (flag3 & flag2)
          {
            if (tile.frameNumber() == (byte) 0)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 132;
            }
            if (tile.frameNumber() == (byte) 1)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 154;
            }
            if (tile.frameNumber() == (byte) 2)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 176;
            }
          }
          else if (flag3)
          {
            if (tile.frameNumber() == (byte) 0)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 0;
            }
            if (tile.frameNumber() == (byte) 1)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 22;
            }
            if (tile.frameNumber() == (byte) 2)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 44;
            }
          }
          else if (flag2)
          {
            if (tile.frameNumber() == (byte) 0)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 66;
            }
            if (tile.frameNumber() == (byte) 1)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 88;
            }
            if (tile.frameNumber() == (byte) 2)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 110;
            }
          }
        }
        else
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 110;
            tile.frameY = (short) 0;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 110;
            tile.frameY = (short) 22;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 110;
            tile.frameY = (short) 44;
          }
        }
      }
      if ((int) tile.frameX == frameX || (int) tile.frameY == frameY || frameX < 0 || frameY < 0)
        return;
      WorldGen.TileFrame(x - 1, y);
      WorldGen.TileFrame(x + 1, y);
      WorldGen.TileFrame(x, y - 1);
      WorldGen.TileFrame(x, y + 1);
    }

    public static void CheckTree(int i, int j)
    {
      int num1 = -1;
      int num2 = -1;
      int num3 = -1;
      int num4 = -1;
      int type1 = (int) Main.tile[i, j].type;
      int frameX = (int) Main.tile[i, j].frameX;
      int frameY = (int) Main.tile[i, j].frameY;
      if (Main.tile[i - 1, j] != null && Main.tile[i - 1, j].active())
        num2 = (int) Main.tile[i - 1, j].type;
      if (Main.tile[i + 1, j] != null && Main.tile[i + 1, j].active())
        num3 = (int) Main.tile[i + 1, j].type;
      if (Main.tile[i, j - 1] != null && Main.tile[i, j - 1].active())
        num1 = (int) Main.tile[i, j - 1].type;
      if (Main.tile[i, j + 1] != null && Main.tile[i, j + 1].active())
        num4 = (int) Main.tile[i, j + 1].type;
      if (Main.tile[i - 1, j - 1] != null && Main.tile[i - 1, j - 1].active())
      {
        int type2 = (int) Main.tile[i - 1, j - 1].type;
      }
      if (Main.tile[i + 1, j - 1] != null && Main.tile[i + 1, j - 1].active())
      {
        int type3 = (int) Main.tile[i + 1, j - 1].type;
      }
      if (Main.tile[i - 1, j + 1] != null && Main.tile[i - 1, j + 1].active())
      {
        int type4 = (int) Main.tile[i - 1, j + 1].type;
      }
      if (Main.tile[i + 1, j + 1] != null && Main.tile[i + 1, j + 1].active())
      {
        int type5 = (int) Main.tile[i + 1, j + 1].type;
      }
      if (num4 == 23 || num4 == 661)
        num4 = 2;
      if (num4 == 477)
        num4 = 2;
      if (num4 == 60)
        num4 = 2;
      if (num4 == 70)
        num4 = 2;
      if (num4 == 109)
        num4 = 2;
      if (num4 == 147)
        num4 = 2;
      if (num4 == 199 || num4 == 662)
        num4 = 2;
      if (num4 == 492)
        num4 = 2;
      if (num4 != 2 && num4 != type1 && (Main.tile[i, j].frameX == (short) 0 && Main.tile[i, j].frameY <= (short) 130 || Main.tile[i, j].frameX == (short) 22 && Main.tile[i, j].frameY <= (short) 130 || Main.tile[i, j].frameX == (short) 44 && Main.tile[i, j].frameY <= (short) 130))
        WorldGen.KillTile(i, j);
      if (Main.tile[i, j].frameX >= (short) 22 && Main.tile[i, j].frameX <= (short) 44 && Main.tile[i, j].frameY >= (short) 132 && Main.tile[i, j].frameY <= (short) 176)
      {
        if (num4 != 2)
          WorldGen.KillTile(i, j);
        else if ((Main.tile[i, j].frameX != (short) 22 || num2 != type1) && (Main.tile[i, j].frameX != (short) 44 || num3 != type1))
          WorldGen.KillTile(i, j);
      }
      else if (Main.tile[i, j].frameX == (short) 88 && Main.tile[i, j].frameY >= (short) 0 && Main.tile[i, j].frameY <= (short) 44 || Main.tile[i, j].frameX == (short) 66 && Main.tile[i, j].frameY >= (short) 66 && Main.tile[i, j].frameY <= (short) 130 || Main.tile[i, j].frameX == (short) 110 && Main.tile[i, j].frameY >= (short) 66 && Main.tile[i, j].frameY <= (short) 110 || Main.tile[i, j].frameX == (short) 132 && Main.tile[i, j].frameY >= (short) 0 && Main.tile[i, j].frameY <= (short) 176)
      {
        if (num2 == type1 && num3 == type1)
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 110;
            Main.tile[i, j].frameY = (short) 66;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 110;
            Main.tile[i, j].frameY = (short) 88;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 110;
            Main.tile[i, j].frameY = (short) 110;
          }
        }
        else if (num2 == type1)
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 88;
            Main.tile[i, j].frameY = (short) 0;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 88;
            Main.tile[i, j].frameY = (short) 22;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 88;
            Main.tile[i, j].frameY = (short) 44;
          }
        }
        else if (num3 == type1)
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 66;
            Main.tile[i, j].frameY = (short) 66;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 66;
            Main.tile[i, j].frameY = (short) 88;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 66;
            Main.tile[i, j].frameY = (short) 110;
          }
        }
        else
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 0;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 22;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 44;
          }
        }
      }
      if (Main.tile[i, j].frameY >= (short) 132 && Main.tile[i, j].frameY <= (short) 176 && (Main.tile[i, j].frameX == (short) 0 || Main.tile[i, j].frameX == (short) 66 || Main.tile[i, j].frameX == (short) 88))
      {
        if (num4 != 2)
          WorldGen.KillTile(i, j);
        if (num2 != type1 && num3 != type1)
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 0;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 22;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 44;
          }
        }
        else if (num2 != type1)
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 132;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 154;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 176;
          }
        }
        else if (num3 != type1)
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 66;
            Main.tile[i, j].frameY = (short) 132;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 66;
            Main.tile[i, j].frameY = (short) 154;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 66;
            Main.tile[i, j].frameY = (short) 176;
          }
        }
        else
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 88;
            Main.tile[i, j].frameY = (short) 132;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 88;
            Main.tile[i, j].frameY = (short) 154;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 88;
            Main.tile[i, j].frameY = (short) 176;
          }
        }
      }
      if (Main.tile[i, j].frameX == (short) 66 && (Main.tile[i, j].frameY == (short) 0 || Main.tile[i, j].frameY == (short) 22 || Main.tile[i, j].frameY == (short) 44) || Main.tile[i, j].frameX == (short) 44 && (Main.tile[i, j].frameY == (short) 198 || Main.tile[i, j].frameY == (short) 220 || Main.tile[i, j].frameY == (short) 242))
      {
        if (num3 != type1)
          WorldGen.KillTile(i, j);
      }
      else if (Main.tile[i, j].frameX == (short) 88 && (Main.tile[i, j].frameY == (short) 66 || Main.tile[i, j].frameY == (short) 88 || Main.tile[i, j].frameY == (short) 110) || Main.tile[i, j].frameX == (short) 66 && (Main.tile[i, j].frameY == (short) 198 || Main.tile[i, j].frameY == (short) 220 || Main.tile[i, j].frameY == (short) 242))
      {
        if (num2 != type1)
          WorldGen.KillTile(i, j);
      }
      else if (num4 == -1 || num4 == 23)
        WorldGen.KillTile(i, j);
      else if (num1 != type1 && Main.tile[i, j].frameY < (short) 198 && (Main.tile[i, j].frameX != (short) 22 && Main.tile[i, j].frameX != (short) 44 || Main.tile[i, j].frameY < (short) 132))
      {
        if (num2 == type1 || num3 == type1)
        {
          if (num4 == type1)
          {
            if (num2 == type1 && num3 == type1)
            {
              if (Main.tile[i, j].frameNumber() == (byte) 0)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 132;
              }
              if (Main.tile[i, j].frameNumber() == (byte) 1)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 154;
              }
              if (Main.tile[i, j].frameNumber() == (byte) 2)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 176;
              }
            }
            else if (num2 == type1)
            {
              if (Main.tile[i, j].frameNumber() == (byte) 0)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 0;
              }
              if (Main.tile[i, j].frameNumber() == (byte) 1)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 22;
              }
              if (Main.tile[i, j].frameNumber() == (byte) 2)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 44;
              }
            }
            else if (num3 == type1)
            {
              if (Main.tile[i, j].frameNumber() == (byte) 0)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 66;
              }
              if (Main.tile[i, j].frameNumber() == (byte) 1)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 88;
              }
              if (Main.tile[i, j].frameNumber() == (byte) 2)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 110;
              }
            }
          }
          else if (num2 == type1 && num3 == type1)
          {
            if (Main.tile[i, j].frameNumber() == (byte) 0)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 132;
            }
            if (Main.tile[i, j].frameNumber() == (byte) 1)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 154;
            }
            if (Main.tile[i, j].frameNumber() == (byte) 2)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 176;
            }
          }
          else if (num2 == type1)
          {
            if (Main.tile[i, j].frameNumber() == (byte) 0)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 0;
            }
            if (Main.tile[i, j].frameNumber() == (byte) 1)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 22;
            }
            if (Main.tile[i, j].frameNumber() == (byte) 2)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 44;
            }
          }
          else if (num3 == type1)
          {
            if (Main.tile[i, j].frameNumber() == (byte) 0)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 66;
            }
            if (Main.tile[i, j].frameNumber() == (byte) 1)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 88;
            }
            if (Main.tile[i, j].frameNumber() == (byte) 2)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 110;
            }
          }
        }
        else
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 110;
            Main.tile[i, j].frameY = (short) 0;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 110;
            Main.tile[i, j].frameY = (short) 22;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 110;
            Main.tile[i, j].frameY = (short) 44;
          }
        }
      }
      if ((int) Main.tile[i, j].frameX == frameX || (int) Main.tile[i, j].frameY == frameY || frameX < 0 || frameY < 0)
        return;
      WorldGen.TileFrame(i - 1, j);
      WorldGen.TileFrame(i + 1, j);
      WorldGen.TileFrame(i, j - 1);
      WorldGen.TileFrame(i, j + 1);
    }

    public static bool TileIsExposedToAir(int x, int y)
    {
      if (!WorldGen.InWorld(x, y, 2))
        return false;
      for (int index1 = x - 1; index1 <= x + 1; ++index1)
      {
        for (int index2 = y - 1; index2 <= y + 1; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile != null && (!tile.active() || !Main.tileSolid[(int) tile.type] || TileID.Sets.Platforms[(int) tile.type]))
            return true;
        }
      }
      return false;
    }

    public static bool TryKillingTreesAboveIfTheyWouldBecomeInvalid(int i, int j, int newFloorType)
    {
      if (newFloorType < 0 || newFloorType >= (int) TileID.Count || !WorldGen.InWorld(i, j, 2))
        return false;
      Tile tile = Main.tile[i, j - 1];
      if (tile == null || !tile.active())
        return false;
      int type = (int) tile.type;
      if (!WorldGen.IsTreeType((int) tile.type) && tile.type != (ushort) 323)
        return false;
      bool flag;
      switch (type)
      {
        case 72:
          flag = newFloorType == 70;
          break;
        case 323:
          flag = TileID.Sets.Conversion.Sand[newFloorType];
          break;
        default:
          flag = TileID.Sets.Conversion.Grass[newFloorType] || TileID.Sets.Conversion.JungleGrass[newFloorType] || TileID.Sets.Conversion.Snow[newFloorType];
          break;
      }
      WorldGen.GrowTreeSettings profile;
      if (flag && WorldGen.GrowTreeSettings.Profiles.TryGetFromTreeId(type, out profile))
        flag = profile.GroundTest(newFloorType);
      if (!flag)
      {
        WorldGen.KillTile(i, j - 1);
        if (Main.netMode == 1)
          NetMessage.SendData(17, number2: ((float) i), number3: ((float) (j - 1)));
      }
      return true;
    }

    public static void Convert(int i, int j, int conversionType, int size = 4)
    {
      for (int index1 = i - size; index1 <= i + size; ++index1)
      {
        for (int index2 = j - size; index2 <= j + size; ++index2)
        {
          if (WorldGen.InWorld(index1, index2, 1) && Math.Abs(index1 - i) + Math.Abs(index2 - j) < 6)
          {
            Tile tile = Main.tile[index1, index2];
            int type = (int) tile.type;
            int wall = (int) tile.wall;
            switch (conversionType)
            {
              case 1:
                if (type <= (int) TileID.Count && wall <= (int) WallID.Count)
                {
                  if (WallID.Sets.Conversion.Grass[wall] && wall != 69)
                  {
                    tile.wall = (ushort) 69;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (TileID.Sets.Conversion.JungleGrass[type] && type != 661)
                  {
                    tile.type = (ushort) 661;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.Stone[wall] && wall != 3)
                  {
                    tile.wall = (ushort) 3;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 217)
                  {
                    tile.wall = (ushort) 217;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 220)
                  {
                    tile.wall = (ushort) 220;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 188)
                  {
                    tile.wall = (ushort) 188;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 189)
                  {
                    tile.wall = (ushort) 189;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 190)
                  {
                    tile.wall = (ushort) 190;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 191)
                  {
                    tile.wall = (ushort) 191;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 25)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 25);
                    tile.type = (ushort) 25;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.Grass[type] && type != 23)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 23);
                    tile.type = (ushort) 23;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.Ice[type] && type != 163)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 163);
                    tile.type = (ushort) 163;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.Sand[type] && type != 112)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 112);
                    tile.type = (ushort) 112;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.HardenedSand[type] && type != 398)
                  {
                    tile.type = (ushort) 398;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.Sandstone[type] && type != 400)
                  {
                    tile.type = (ushort) 400;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.Thorn[type] && type != 32)
                  {
                    tile.type = (ushort) 32;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  continue;
                }
                continue;
              case 2:
                if (type <= (int) TileID.Count && wall <= (int) WallID.Count)
                {
                  if (WallID.Sets.Conversion.Grass[wall] && wall != 70)
                  {
                    tile.wall = (ushort) 70;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.Stone[wall] && wall != 28)
                  {
                    tile.wall = (ushort) 28;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 219)
                  {
                    tile.wall = (ushort) 219;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 222)
                  {
                    tile.wall = (ushort) 222;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 200)
                  {
                    tile.wall = (ushort) 200;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 201)
                  {
                    tile.wall = (ushort) 201;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 202)
                  {
                    tile.wall = (ushort) 202;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 203)
                  {
                    tile.wall = (ushort) 203;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 117)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 117);
                    tile.type = (ushort) 117;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (TileID.Sets.Conversion.GolfGrass[type] && type != 492)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 492);
                    tile.type = (ushort) 492;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (TileID.Sets.Conversion.Grass[type] && type != 109 && type != 492)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 109);
                    tile.type = (ushort) 109;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (TileID.Sets.Conversion.Ice[type] && type != 164)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 164);
                    tile.type = (ushort) 164;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (TileID.Sets.Conversion.Sand[type] && type != 116)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 116);
                    tile.type = (ushort) 116;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (TileID.Sets.Conversion.HardenedSand[type] && type != 402)
                  {
                    tile.type = (ushort) 402;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (TileID.Sets.Conversion.Sandstone[type] && type != 403)
                  {
                    tile.type = (ushort) 403;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (TileID.Sets.Conversion.Thorn[type])
                  {
                    WorldGen.KillTile(index1, index2);
                    if (Main.netMode == 1)
                      NetMessage.SendData(17, number2: ((float) index1), number3: ((float) index2));
                  }
                  if (type == 59 && (Main.tile[index1 - 1, index2].type == (ushort) 109 || Main.tile[index1 + 1, index2].type == (ushort) 109 || Main.tile[index1, index2 - 1].type == (ushort) 109 || Main.tile[index1, index2 + 1].type == (ushort) 109))
                  {
                    tile.type = (ushort) 0;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  continue;
                }
                continue;
              case 3:
                if (WallID.Sets.CanBeConvertedToGlowingMushroom[wall])
                {
                  tile.wall = (ushort) 80;
                  WorldGen.SquareWallFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                }
                if (tile.type == (ushort) 60)
                {
                  WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 70);
                  tile.type = (ushort) 70;
                  WorldGen.SquareTileFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                  continue;
                }
                if (TileID.Sets.Conversion.Thorn[type])
                {
                  WorldGen.KillTile(index1, index2);
                  if (Main.netMode == 1)
                  {
                    NetMessage.SendData(17, number2: ((float) index1), number3: ((float) index2));
                    continue;
                  }
                  continue;
                }
                continue;
              case 4:
                if (type <= (int) TileID.Count && wall <= (int) WallID.Count)
                {
                  if (WallID.Sets.Conversion.Grass[wall] && wall != 81)
                  {
                    tile.wall = (ushort) 81;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.Stone[wall] && wall != 83)
                  {
                    tile.wall = (ushort) 83;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 218)
                  {
                    tile.wall = (ushort) 218;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 221)
                  {
                    tile.wall = (ushort) 221;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 192)
                  {
                    tile.wall = (ushort) 192;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 193)
                  {
                    tile.wall = (ushort) 193;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 194)
                  {
                    tile.wall = (ushort) 194;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 195)
                  {
                    tile.wall = (ushort) 195;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 203)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 203);
                    tile.type = (ushort) 203;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.JungleGrass[type] && type != 662)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 662);
                    tile.type = (ushort) 662;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.Grass[type] && type != 199)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 199);
                    tile.type = (ushort) 199;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.Ice[type] && type != 200)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 200);
                    tile.type = (ushort) 200;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.Sand[type] && type != 234)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 234);
                    tile.type = (ushort) 234;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.HardenedSand[type] && type != 399)
                  {
                    tile.type = (ushort) 399;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.Sandstone[type] && type != 401)
                  {
                    tile.type = (ushort) 401;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.Thorn[type] && type != 352)
                  {
                    tile.type = (ushort) 352;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  continue;
                }
                continue;
              case 5:
                if (type >= 0 && type <= (int) TileID.Count && wall >= 0 && wall <= (int) WallID.Count)
                {
                  if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.NewWall1[wall] || WallID.Sets.Conversion.NewWall2[wall] || WallID.Sets.Conversion.NewWall3[wall] || WallID.Sets.Conversion.NewWall4[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 187)
                  {
                    tile.wall = (ushort) 187;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Dirt[wall] || WallID.Sets.Conversion.Snow[wall]) && wall != 216)
                  {
                    tile.wall = (ushort) 216;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  if ((TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 53)
                  {
                    int newFloorType = 53;
                    if (WorldGen.BlockBelowMakesSandConvertIntoHardenedSand(index1, index2))
                      newFloorType = 397;
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, newFloorType);
                    tile.type = (ushort) newFloorType;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.HardenedSand[type] && type != 397)
                  {
                    tile.type = (ushort) 397;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type] || TileID.Sets.Conversion.Ice[type] || TileID.Sets.Conversion.Sandstone[type]) && type != 396)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 396);
                    tile.type = (ushort) 396;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.Thorn[type] && type != 69)
                  {
                    WorldGen.KillTile(index1, index2);
                    if (Main.netMode == 1)
                    {
                      NetMessage.SendData(17, number2: ((float) index1), number3: ((float) index2));
                      continue;
                    }
                    continue;
                  }
                  continue;
                }
                continue;
              case 6:
                if (type >= 0 && type <= (int) TileID.Count && wall >= 0 && wall <= (int) WallID.Count)
                {
                  if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.NewWall1[wall] || WallID.Sets.Conversion.NewWall2[wall] || WallID.Sets.Conversion.NewWall3[wall] || WallID.Sets.Conversion.NewWall4[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 71)
                  {
                    tile.wall = (ushort) 71;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Dirt[wall] || WallID.Sets.Conversion.Snow[wall]) && wall != 40)
                  {
                    tile.wall = (ushort) 40;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  if ((TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.HardenedSand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 147)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 147);
                    tile.type = (ushort) 147;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type] || TileID.Sets.Conversion.Ice[type] || TileID.Sets.Conversion.Sandstone[type]) && type != 161)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 161);
                    tile.type = (ushort) 161;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.Thorn[type] && type != 69)
                  {
                    WorldGen.KillTile(index1, index2);
                    if (Main.netMode == 1)
                    {
                      NetMessage.SendData(17, number2: ((float) index1), number3: ((float) index2));
                      continue;
                    }
                    continue;
                  }
                  continue;
                }
                continue;
              case 7:
                if (type >= 0 && type <= (int) TileID.Count && wall >= 0 && wall <= (int) WallID.Count)
                {
                  if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 1)
                  {
                    tile.wall = (ushort) 1;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Snow[wall] || WallID.Sets.Conversion.Dirt[wall]) && wall != 2)
                  {
                    tile.wall = (ushort) 2;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 196)
                  {
                    tile.wall = (ushort) 196;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 197)
                  {
                    tile.wall = (ushort) 197;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 198)
                  {
                    tile.wall = (ushort) 198;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 199)
                  {
                    tile.wall = (ushort) 199;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  if ((TileID.Sets.Conversion.Stone[type] || TileID.Sets.Conversion.Ice[type] || TileID.Sets.Conversion.Sandstone[type]) && type != 1)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 1);
                    tile.type = (ushort) 1;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.GolfGrass[type] && type != 477)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 477);
                    tile.type = (ushort) 477;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.Grass[type] && type != 2 && type != 477)
                  {
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 2);
                    tile.type = (ushort) 2;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if ((TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.HardenedSand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 0)
                  {
                    int newFloorType = 0;
                    if (WorldGen.TileIsExposedToAir(index1, index2))
                      newFloorType = 2;
                    WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, newFloorType);
                    tile.type = (ushort) newFloorType;
                    WorldGen.SquareTileFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                    continue;
                  }
                  if (TileID.Sets.Conversion.Thorn[type] && type != 69)
                  {
                    WorldGen.KillTile(index1, index2);
                    if (Main.netMode == 1)
                    {
                      NetMessage.SendData(17, number2: ((float) index1), number3: ((float) index2));
                      continue;
                    }
                    continue;
                  }
                  continue;
                }
                continue;
              default:
                if (tile.wall == (ushort) 69 || tile.wall == (ushort) 70 || tile.wall == (ushort) 81)
                {
                  tile.wall = (double) index2 >= Main.worldSurface ? (ushort) 64 : (WorldGen.genRand.Next(10) != 0 ? (ushort) 63 : (ushort) 65);
                  WorldGen.SquareWallFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                }
                else if (WallID.Sets.Conversion.Stone[wall] && wall != 1 && wall != 262 && wall != 274 && wall != 61 && wall != 185)
                {
                  tile.wall = (ushort) 1;
                  WorldGen.SquareWallFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                }
                else if (WallID.Sets.Conversion.Stone[wall] && wall == 262)
                {
                  tile.wall = (ushort) 61;
                  WorldGen.SquareWallFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                }
                else if (WallID.Sets.Conversion.Stone[wall] && wall == 274)
                {
                  tile.wall = (ushort) 185;
                  WorldGen.SquareWallFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                }
                if (WallID.Sets.Conversion.NewWall1[wall] && wall != 212)
                {
                  tile.wall = (ushort) 212;
                  WorldGen.SquareWallFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                }
                else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 213)
                {
                  tile.wall = (ushort) 213;
                  WorldGen.SquareWallFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                }
                else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 214)
                {
                  tile.wall = (ushort) 214;
                  WorldGen.SquareWallFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                }
                else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 215)
                {
                  tile.wall = (ushort) 215;
                  WorldGen.SquareWallFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                }
                else if (tile.wall == (ushort) 80)
                {
                  if ((double) index2 < Main.worldSurface + 4.0 + (double) WorldGen.genRand.Next(3) || (double) index2 > ((double) Main.maxTilesY + Main.rockLayer) / 2.0 - 3.0 + (double) WorldGen.genRand.Next(3))
                  {
                    tile.wall = (ushort) 15;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                  else
                  {
                    tile.wall = (ushort) 64;
                    WorldGen.SquareWallFrame(index1, index2);
                    NetMessage.SendTileSquare(-1, index1, index2);
                  }
                }
                else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 216)
                {
                  tile.wall = (ushort) 216;
                  WorldGen.SquareWallFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                }
                else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 187)
                {
                  tile.wall = (ushort) 187;
                  WorldGen.SquareWallFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                }
                if (tile.type == (ushort) 492)
                {
                  WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 477);
                  tile.type = (ushort) 477;
                  WorldGen.SquareTileFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                  continue;
                }
                if (TileID.Sets.Conversion.JungleGrass[type] && type != 60)
                {
                  WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 60);
                  tile.type = (ushort) 60;
                  WorldGen.SquareTileFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                  continue;
                }
                if (TileID.Sets.Conversion.Grass[type] && type != 2 && type != 477)
                {
                  WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 2);
                  tile.type = (ushort) 2;
                  WorldGen.SquareTileFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                  continue;
                }
                if (TileID.Sets.Conversion.Stone[type] && type != 1)
                {
                  WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 1);
                  tile.type = (ushort) 1;
                  WorldGen.SquareTileFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                  continue;
                }
                if (TileID.Sets.Conversion.Sand[type] && type != 53)
                {
                  WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 53);
                  tile.type = (ushort) 53;
                  WorldGen.SquareTileFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                  continue;
                }
                if (TileID.Sets.Conversion.HardenedSand[type] && type != 397)
                {
                  tile.type = (ushort) 397;
                  WorldGen.SquareTileFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                  continue;
                }
                if (TileID.Sets.Conversion.Sandstone[type] && type != 396)
                {
                  tile.type = (ushort) 396;
                  WorldGen.SquareTileFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                  continue;
                }
                if (TileID.Sets.Conversion.Ice[type] && type != 161)
                {
                  WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 161);
                  tile.type = (ushort) 161;
                  WorldGen.SquareTileFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                  continue;
                }
                if (TileID.Sets.Conversion.MushroomGrass[type])
                {
                  WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid(index1, index2, 60);
                  tile.type = (ushort) 60;
                  WorldGen.SquareTileFrame(index1, index2);
                  NetMessage.SendTileSquare(-1, index1, index2);
                  continue;
                }
                if (tile.type == (ushort) 32 || Main.tile[index1, index2].type == (ushort) 352)
                {
                  WorldGen.KillTile(index1, index2);
                  if (Main.netMode == 1)
                  {
                    NetMessage.SendData(17, number2: ((float) index1), number3: ((float) index2));
                    continue;
                  }
                  continue;
                }
                continue;
            }
          }
        }
      }
    }

    public static void CactusFrame(int i, int j)
    {
      try
      {
        int index1 = j;
        int index2 = i;
        if (WorldGen.CheckCactus(i, j))
          return;
        while (Main.tile[index2, index1].active() && Main.tile[index2, index1].type == (ushort) 80)
        {
          ++index1;
          if (Main.tile[index2, index1] == null)
            return;
          if (!Main.tile[index2, index1].active() || Main.tile[index2, index1].type != (ushort) 80)
          {
            if (Main.tile[index2 - 1, index1] != null && Main.tile[index2 - 1, index1].active() && Main.tile[index2 - 1, index1].type == (ushort) 80 && Main.tile[index2 - 1, index1 - 1].active() && Main.tile[index2 - 1, index1 - 1].type == (ushort) 80 && index2 >= i)
              --index2;
            if (Main.tile[index2 + 1, index1] != null && Main.tile[index2 + 1, index1].active() && Main.tile[index2 + 1, index1].type == (ushort) 80 && Main.tile[index2 + 1, index1 - 1].active() && Main.tile[index2 + 1, index1 - 1].type == (ushort) 80 && index2 <= i)
              ++index2;
          }
        }
        int num1 = index1 - 1;
        int num2 = i - index2;
        num1 = j;
        if (Main.tile[i - 2, j] == null)
          return;
        int type = (int) Main.tile[i - 2, j].type;
        if (Main.tile[i - 1, j] == null)
          return;
        int num3 = (int) Main.tile[i - 1, j].type;
        if (Main.tile[i + 1, j] == null)
          return;
        int num4 = (int) Main.tile[i + 1, j].type;
        if (Main.tile[i, j - 1] == null)
          return;
        int num5 = (int) Main.tile[i, j - 1].type;
        if (num5 == 227)
          num5 = 80;
        int index3 = (int) Main.tile[i, j + 1].type;
        int num6 = (int) Main.tile[i - 1, j + 1].type;
        int num7 = (int) Main.tile[i + 1, j + 1].type;
        if (!Main.tile[i - 1, j].active())
          num3 = -1;
        if (!Main.tile[i + 1, j].active())
          num4 = -1;
        if (!Main.tile[i, j - 1].active())
          num5 = -1;
        if (!Main.tile[i, j + 1].active())
          index3 = -1;
        if (!Main.tile[i - 1, j + 1].active())
          num6 = -1;
        if (!Main.tile[i + 1, j + 1].active())
          num7 = -1;
        short num8 = Main.tile[i, j].frameX;
        short num9 = Main.tile[i, j].frameY;
        switch (num2)
        {
          case -1:
            if (num4 == 80)
            {
              if (num5 != 80 && index3 != 80)
              {
                num8 = (short) 108;
                num9 = (short) 36;
                break;
              }
              if (index3 != 80)
              {
                num8 = (short) 54;
                num9 = (short) 36;
                break;
              }
              if (num5 != 80)
              {
                num8 = (short) 54;
                num9 = (short) 0;
                break;
              }
              num8 = (short) 54;
              num9 = (short) 18;
              break;
            }
            if (num5 != 80)
            {
              num8 = (short) 54;
              num9 = (short) 0;
              break;
            }
            num8 = (short) 54;
            num9 = (short) 18;
            break;
          case 0:
            if (num5 != 80)
            {
              if (num3 == 80 && num4 == 80 && num6 != 80 && num7 != 80 && type != 80)
              {
                num8 = (short) 90;
                num9 = (short) 0;
                break;
              }
              if (num3 == 80 && num6 != 80 && type != 80)
              {
                num8 = (short) 72;
                num9 = (short) 0;
                break;
              }
              if (num4 == 80 && num7 != 80)
              {
                num8 = (short) 18;
                num9 = (short) 0;
                break;
              }
              num8 = (short) 0;
              num9 = (short) 0;
              break;
            }
            if (num3 == 80 && num4 == 80 && num6 != 80 && num7 != 80 && type != 80)
            {
              num8 = (short) 90;
              num9 = (short) 36;
              break;
            }
            if (num3 == 80 && num6 != 80 && type != 80)
            {
              num8 = (short) 72;
              num9 = (short) 36;
              break;
            }
            if (num4 == 80 && num7 != 80)
            {
              num8 = (short) 18;
              num9 = (short) 36;
              break;
            }
            if (index3 >= 0 && Main.tileSolid[index3])
            {
              num8 = (short) 0;
              num9 = (short) 36;
              break;
            }
            num8 = (short) 0;
            num9 = (short) 18;
            break;
          case 1:
            if (num3 == 80)
            {
              if (num5 != 80 && index3 != 80)
              {
                num8 = (short) 108;
                num9 = (short) 18;
                break;
              }
              if (index3 != 80)
              {
                num8 = (short) 36;
                num9 = (short) 36;
                break;
              }
              if (num5 != 80)
              {
                num8 = (short) 36;
                num9 = (short) 0;
                break;
              }
              num8 = (short) 36;
              num9 = (short) 18;
              break;
            }
            if (num5 != 80)
            {
              num8 = (short) 36;
              num9 = (short) 0;
              break;
            }
            num8 = (short) 36;
            num9 = (short) 18;
            break;
        }
        if ((int) num8 == (int) Main.tile[i, j].frameX && (int) num9 == (int) Main.tile[i, j].frameY)
          return;
        Main.tile[i, j].frameX = num8;
        Main.tile[i, j].frameY = num9;
        WorldGen.DiamondTileFrame(i, j);
      }
      catch
      {
        Main.tile[i, j].frameX = (short) 0;
        Main.tile[i, j].frameY = (short) 0;
      }
    }

    public static void GrowCactus(int i, int j)
    {
      int index1 = j;
      int i1 = i;
      if (!Main.tile[i, j].nactive() || Main.tile[i, j].halfBrick() || !WorldGen.gen && Main.tile[i, j].slope() != (byte) 0 || Main.tile[i, j - 1].liquid > (byte) 0 || Main.tile[i, j].type != (ushort) 53 && Main.tile[i, j].type != (ushort) 80 && Main.tile[i, j].type != (ushort) 234 && Main.tile[i, j].type != (ushort) 112 && Main.tile[i, j].type != (ushort) 116)
        return;
      int num1 = 0;
      for (int index2 = i - WorldGen.cactusWaterWidth; index2 < i + WorldGen.cactusWaterWidth; ++index2)
      {
        for (int index3 = j - WorldGen.cactusWaterHeight; index3 < j + WorldGen.cactusWaterHeight; ++index3)
          num1 += (int) Main.tile[index2, index3].liquid;
      }
      if ((!Main.remixWorld || (double) j <= Main.worldSurface) && num1 / (int) byte.MaxValue > WorldGen.cactusWaterLimit)
        return;
      if (Main.tile[i, j].type == (ushort) 53 || Main.tile[i, j].type == (ushort) 112 || Main.tile[i, j].type == (ushort) 116 || Main.tile[i, j].type == (ushort) 234)
      {
        if (Main.tile[i, j - 1].active() || Main.tile[i - 1, j - 1].active() || Main.tile[i + 1, j - 1].active())
          return;
        int num2 = 0;
        int num3 = 0;
        for (int index4 = i - 6; index4 <= i + 6; ++index4)
        {
          for (int index5 = j - 3; index5 <= j + 1; ++index5)
          {
            try
            {
              if (Main.tile[index4, index5].active())
              {
                if (Main.tile[index4, index5].type == (ushort) 80)
                {
                  ++num2;
                  if (num2 >= 4)
                    return;
                }
                if (Main.tile[index4, index5].type != (ushort) 53 && Main.tile[index4, index5].type != (ushort) 112 && Main.tile[index4, index5].type != (ushort) 116)
                {
                  if (Main.tile[index4, index5].type != (ushort) 234)
                    continue;
                }
                ++num3;
              }
            }
            catch
            {
            }
          }
        }
        if (num3 <= 10)
          return;
        if (WorldGen.gen && WorldGen.genRand.Next(2) == 0)
          Main.tile[i, j].slope((byte) 0);
        Main.tile[i, j - 1].active(true);
        Main.tile[i, j - 1].type = (ushort) 80;
        if (Main.netMode == 2)
          NetMessage.SendTileSquare(-1, i, j - 1);
        WorldGen.SquareTileFrame(i1, index1 - 1);
      }
      else
      {
        if (Main.tile[i, j].type != (ushort) 80)
          return;
        while (Main.tile[i1, index1].active() && Main.tile[i1, index1].type == (ushort) 80)
        {
          ++index1;
          if (!Main.tile[i1, index1].active() || Main.tile[i1, index1].type != (ushort) 80)
          {
            if (Main.tile[i1 - 1, index1].active() && Main.tile[i1 - 1, index1].type == (ushort) 80 && Main.tile[i1 - 1, index1 - 1].active() && Main.tile[i1 - 1, index1 - 1].type == (ushort) 80 && i1 >= i)
              --i1;
            if (Main.tile[i1 + 1, index1].active() && Main.tile[i1 + 1, index1].type == (ushort) 80 && Main.tile[i1 + 1, index1 - 1].active() && Main.tile[i1 + 1, index1 - 1].type == (ushort) 80 && i1 <= i)
              ++i1;
          }
        }
        int num4 = index1 - 1 - j;
        int num5 = i - i1;
        int num6 = i - num5;
        int num7 = j;
        int num8 = 11 - num4;
        int num9 = 0;
        for (int index6 = num6 - 2; index6 <= num6 + 2; ++index6)
        {
          for (int index7 = num7 - num8; index7 <= num7 + num4; ++index7)
          {
            if (Main.tile[index6, index7].active() && Main.tile[index6, index7].type == (ushort) 80)
              ++num9;
          }
        }
        if (Main.drunkWorld)
        {
          if (num9 >= WorldGen.genRand.Next(11, 20))
            return;
        }
        else if (num9 >= WorldGen.genRand.Next(11, 13))
          return;
        int index8 = i;
        int index9 = j;
        if (num5 == 0)
        {
          if (num4 == 0)
          {
            if (Main.tile[index8, index9 - 1].active())
              return;
            Main.tile[index8, index9 - 1].active(true);
            Main.tile[index8, index9 - 1].type = (ushort) 80;
            WorldGen.SquareTileFrame(index8, index9 - 1);
            if (Main.netMode != 2)
              return;
            NetMessage.SendTileSquare(-1, index8, index9 - 1);
          }
          else
          {
            bool flag1 = false;
            bool flag2 = false;
            if (Main.tile[index8, index9 - 1].active() && Main.tile[index8, index9 - 1].type == (ushort) 80)
            {
              if (!Main.tile[index8 - 1, index9].active() && !Main.tile[index8 - 2, index9 + 1].active() && !Main.tile[index8 - 1, index9 - 1].active() && !Main.tile[index8 - 1, index9 + 1].active() && !Main.tile[index8 - 2, index9].active())
                flag1 = true;
              if (!Main.tile[index8 + 1, index9].active() && !Main.tile[index8 + 2, index9 + 1].active() && !Main.tile[index8 + 1, index9 - 1].active() && !Main.tile[index8 + 1, index9 + 1].active() && !Main.tile[index8 + 2, index9].active())
                flag2 = true;
            }
            int num10 = WorldGen.genRand.Next(3);
            if (num10 == 0 & flag1)
            {
              Main.tile[index8 - 1, index9].active(true);
              Main.tile[index8 - 1, index9].type = (ushort) 80;
              WorldGen.SquareTileFrame(index8 - 1, index9);
              if (Main.netMode != 2)
                return;
              NetMessage.SendTileSquare(-1, index8 - 1, index9);
            }
            else if (num10 == 1 & flag2)
            {
              Main.tile[index8 + 1, index9].active(true);
              Main.tile[index8 + 1, index9].type = (ushort) 80;
              WorldGen.SquareTileFrame(index8 + 1, index9);
              if (Main.netMode != 2)
                return;
              NetMessage.SendTileSquare(-1, index8 + 1, index9);
            }
            else
            {
              if (num4 >= WorldGen.genRand.Next(2, 8))
                return;
              if (Main.tile[index8 - 1, index9 - 1].active())
              {
                int type = (int) Main.tile[index8 - 1, index9 - 1].type;
              }
              if (Main.tile[index8 + 1, index9 - 1].active() && Main.tile[index8 + 1, index9 - 1].type == (ushort) 80 || Main.tile[index8, index9 - 1].active())
                return;
              Main.tile[index8, index9 - 1].active(true);
              Main.tile[index8, index9 - 1].type = (ushort) 80;
              WorldGen.SquareTileFrame(index8, index9 - 1);
              if (Main.netMode != 2)
                return;
              NetMessage.SendTileSquare(-1, index8, index9 - 1);
            }
          }
        }
        else
        {
          if (Main.tile[index8, index9 - 1].active() || Main.tile[index8, index9 - 2].active() || Main.tile[index8 + num5, index9 - 1].active() || !Main.tile[index8 - num5, index9 - 1].active() || Main.tile[index8 - num5, index9 - 1].type != (ushort) 80)
            return;
          Main.tile[index8, index9 - 1].active(true);
          Main.tile[index8, index9 - 1].type = (ushort) 80;
          WorldGen.SquareTileFrame(index8, index9 - 1);
          if (Main.netMode != 2)
            return;
          NetMessage.SendTileSquare(-1, index8, index9 - 1);
        }
      }
    }

    public static void CheckPot(int i, int j, int type = 28)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = 0;
      int num2 = j;
      int num3 = num1 + (int) Main.tile[i, j].frameX / 18;
      while (num3 > 1)
        num3 -= 2;
      int x2 = num3 * -1 + i;
      int num4 = (int) Main.tile[i, j].frameY / 18;
      int style = 0;
      while (num4 > 1)
      {
        num4 -= 2;
        ++style;
      }
      int y2 = num2 - num4;
      for (int i1 = x2; i1 < x2 + 2; ++i1)
      {
        for (int index = y2; index < y2 + 2; ++index)
        {
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          int num5 = (int) Main.tile[i1, index].frameX / 18;
          while (num5 > 1)
            num5 -= 2;
          if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || num5 != i1 - x2 || (int) Main.tile[i1, index].frameY != (index - y2) * 18 + style * 36)
            flag = true;
        }
        if (Main.tile[i1, y2 + 2] == null)
          Main.tile[i1, y2 + 2] = new Tile();
        if (!WorldGen.SolidTile2(i1, y2 + 2))
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      if (style >= 7 && style <= 9)
        SoundEngine.PlaySound(6, i * 16, j * 16);
      else if (style >= 16 && style <= 24)
        SoundEngine.PlaySound(4, i * 16, j * 16);
      else
        SoundEngine.PlaySound(13, i * 16, j * 16);
      for (int i2 = x2; i2 < x2 + 2; ++i2)
      {
        for (int j1 = y2; j1 < y2 + 2; ++j1)
        {
          if ((int) Main.tile[i2, j1].type == type && Main.tile[i2, j1].active())
            WorldGen.KillTile(i2, j1);
        }
      }
      switch (style)
      {
        case 0:
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 51);
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 52);
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 53);
          break;
        case 1:
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 166);
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 167);
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 168);
          break;
        case 2:
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 169);
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 170);
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 171);
          break;
        case 3:
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 172);
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 173);
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 174);
          break;
        default:
          if (style >= 4 && style <= 6)
          {
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 197);
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 198);
            break;
          }
          if (style >= 7 && style <= 9)
          {
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 199);
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 200);
            break;
          }
          if (style >= 10 && style <= 12)
          {
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 201);
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 202);
            break;
          }
          if (style >= 13 && style <= 15)
          {
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 203);
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 204);
            break;
          }
          if ((style < 16 || style > 18) && (style < 19 || style > 21) && (style < 22 || style > 24))
          {
            if (style >= 25 && style <= 27)
            {
              Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), WorldGen.genRand.Next(217, 220));
              Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), WorldGen.genRand.Next(217, 220));
              break;
            }
            if (style >= 28 && style <= 30)
            {
              Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), WorldGen.genRand.Next(315, 317));
              Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), WorldGen.genRand.Next(315, 317));
              break;
            }
            if (style >= 31 && style <= 33)
            {
              int num6 = WorldGen.genRand.Next(2, 5);
              for (int index = 0; index < num6; ++index)
                Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 698 + WorldGen.genRand.Next(6));
              break;
            }
            if (style >= 34 && style <= 36)
            {
              Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 1122);
              Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 1123);
              Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 1124);
              break;
            }
            break;
          }
          break;
      }
      if (Main.netMode != 1 && type != 653)
        WorldGen.SpawnThingsFromPot(i, j, x2, y2, style);
      WorldGen.destroyObject = false;
    }

    private static void SpawnThingsFromPot(int i, int j, int x2, int y2, int style)
    {
      bool flag1 = (double) j < Main.rockLayer;
      bool flag2 = j < Main.UnderworldLayer;
      if (Main.remixWorld)
      {
        flag1 = (double) j > Main.rockLayer && j < Main.UnderworldLayer;
        flag2 = (double) j > Main.worldSurface && (double) j < Main.rockLayer;
      }
      float num1 = 1f;
      bool flag3 = style >= 34 && style <= 36;
      if (style != 0 && style != 1 && style != 2 && style != 3)
      {
        if (style >= 4 && style <= 6)
          num1 = 1.25f;
        else if (style >= 7 && style <= 9)
          num1 = 1.75f;
        else if (style >= 10 && style <= 12)
          num1 = 1.9f;
        else if (style >= 13 && style <= 15)
          num1 = 2.1f;
        else if (style >= 16 && style <= 18)
          num1 = 1.6f;
        else if (style >= 19 && style <= 21)
          num1 = 3.5f;
        else if (style >= 22 && style <= 24)
          num1 = 1.6f;
        else if (style >= 25 && style <= 27)
          num1 = 10f;
        else if (style >= 28 && style <= 30)
        {
          if (Main.hardMode)
            num1 = 4f;
        }
        else if (style >= 31 && style <= 33)
          num1 = 2f;
        else if (style >= 34 && style <= 36)
          num1 = 1.25f;
      }
      float num2 = (float) (((double) num1 * 2.0 + 1.0) / 3.0);
      int range = (int) (500.0 / (((double) num2 + 1.0) / 2.0));
      if (WorldGen.gen)
        return;
      if ((double) Player.GetClosestRollLuck(i, j, range) == 0.0)
      {
        if (Main.netMode == 1)
          return;
        Projectile.NewProjectile((IEntitySource) WorldGen.GetProjectileSource_TileBreak(i, j), (float) (i * 16 + 16), (float) (j * 16 + 16), 0.0f, -12f, 518, 0, 0.0f, Main.myPlayer);
      }
      else if (WorldGen.genRand.Next(35) == 0 && Main.wallDungeon[(int) Main.tile[i, j].wall] && (double) j > Main.worldSurface)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 327);
      else if (Main.getGoodWorld && WorldGen.genRand.Next(6) == 0)
        Projectile.NewProjectile((IEntitySource) WorldGen.GetProjectileSource_TileBreak(i, j), (float) (i * 16 + 16), (float) (j * 16 + 8), (float) Main.rand.Next(-100, 101) * (1f / 500f), 0.0f, 28, 0, 0.0f, Main.myPlayer, 16f, 16f);
      else if (Main.remixWorld && Main.netMode != 1 && WorldGen.genRand.Next(5) == 0)
      {
        Player player = Main.player[(int) Player.FindClosest(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16)];
        if (Main.rand.Next(2) == 0)
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 75);
        else if (player.ZoneJungle)
        {
          int index = NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -10);
          if (index <= -1)
            return;
          Main.npc[index].ai[1] = 75f;
          Main.npc[index].netUpdate = true;
        }
        else if ((double) j > Main.rockLayer && j < Main.maxTilesY - 350)
        {
          int index = Main.rand.Next(9) != 0 ? (Main.rand.Next(7) != 0 ? (Main.rand.Next(6) != 0 ? (Main.rand.Next(3) != 0 ? NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, 1) : NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -3)) : NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -9)) : NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -8)) : NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -7);
          if (index <= -1)
            return;
          Main.npc[index].ai[1] = 75f;
          Main.npc[index].netUpdate = true;
        }
        else if ((double) j > Main.worldSurface && (double) j <= Main.rockLayer)
        {
          int index = NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -6);
          if (index <= -1)
            return;
          Main.npc[index].ai[1] = 75f;
          Main.npc[index].netUpdate = true;
        }
        else
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 75);
      }
      else if (Main.remixWorld && (double) i > (double) Main.maxTilesX * 0.37 && (double) i < (double) Main.maxTilesX * 0.63 && j > Main.maxTilesY - 220)
      {
        int Stack = Main.rand.Next(20, 41);
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 965, Stack);
      }
      else if (WorldGen.genRand.Next(45) == 0 || Main.rand.Next(45) == 0 && Main.expertMode)
      {
        if ((double) j < Main.worldSurface)
        {
          int num3 = WorldGen.genRand.Next(10);
          if (num3 == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 292);
          if (num3 == 1)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 298);
          if (num3 == 2)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 299);
          if (num3 == 3)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 290);
          if (num3 == 4)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2322);
          if (num3 == 5)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2324);
          if (num3 == 6)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2325);
          if (num3 < 7)
            return;
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2350, WorldGen.genRand.Next(1, 3));
        }
        else if (flag1)
        {
          int num4 = WorldGen.genRand.Next(11);
          if (num4 == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 289);
          if (num4 == 1)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 298);
          if (num4 == 2)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 299);
          if (num4 == 3)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 290);
          if (num4 == 4)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 303);
          if (num4 == 5)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 291);
          if (num4 == 6)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 304);
          if (num4 == 7)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2322);
          if (num4 == 8)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2329);
          if (num4 < 7)
            return;
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2350, WorldGen.genRand.Next(1, 3));
        }
        else if (flag2)
        {
          int num5 = WorldGen.genRand.Next(15);
          if (num5 == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 296);
          if (num5 == 1)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 295);
          if (num5 == 2)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 299);
          if (num5 == 3)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 302);
          if (num5 == 4)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 303);
          if (num5 == 5)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 305);
          if (num5 == 6)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 301);
          if (num5 == 7)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 302);
          if (num5 == 8)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 297);
          if (num5 == 9)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 304);
          if (num5 == 10)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2322);
          if (num5 == 11)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2323);
          if (num5 == 12)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2327);
          if (num5 == 13)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2329);
          if (num5 < 7)
            return;
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2350, WorldGen.genRand.Next(1, 3));
        }
        else
        {
          int num6 = WorldGen.genRand.Next(14);
          if (num6 == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 296);
          if (num6 == 1)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 295);
          if (num6 == 2)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 293);
          if (num6 == 3)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 288);
          if (num6 == 4)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 294);
          if (num6 == 5)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 297);
          if (num6 == 6)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 304);
          if (num6 == 7)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 305);
          if (num6 == 8)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 301);
          if (num6 == 9)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 302);
          if (num6 == 10)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 288);
          if (num6 == 11)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 300);
          if (num6 == 12)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2323);
          if (num6 == 13)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2326);
          if (WorldGen.genRand.Next(5) != 0)
            return;
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 4870);
        }
      }
      else if (Main.netMode == 2 && Main.rand.Next(30) == 0)
      {
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2997);
      }
      else
      {
        int num7 = Main.rand.Next(7);
        if (Main.expertMode)
          --num7;
        Player player = Main.player[(int) Player.FindClosest(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16)];
        int num8 = 0;
        int num9 = 20;
        for (int index = 0; index < 50; ++index)
        {
          Item obj = player.inventory[index];
          if (!obj.IsAir && obj.createTile == 4)
          {
            num8 += obj.stack;
            if (num8 >= num9)
              break;
          }
        }
        bool flag4 = num8 < num9;
        if (num7 == 0 && player.statLife < player.statLifeMax2)
        {
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 58);
          if (Main.rand.Next(2) == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 58);
          if (!Main.expertMode)
            return;
          if (Main.rand.Next(2) == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 58);
          if (Main.rand.Next(2) != 0)
            return;
          Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 58);
        }
        else if (num7 == 1 || num7 == 0 & flag4)
        {
          int Stack = Main.rand.Next(2, 7);
          if (Main.expertMode)
            Stack += Main.rand.Next(1, 7);
          int Type1 = 8;
          int Type2 = 282;
          if (player.ZoneHallow)
          {
            Stack += Main.rand.Next(2, 7);
            Type1 = 4387;
          }
          else if (style >= 22 && style <= 24 || player.ZoneCrimson)
          {
            Stack += Main.rand.Next(2, 7);
            Type1 = 4386;
          }
          else if (style >= 16 && style <= 18 || player.ZoneCorrupt)
          {
            Stack += Main.rand.Next(2, 7);
            Type1 = 4385;
          }
          else if (style >= 7 && style <= 9)
          {
            Stack = (int) ((double) (Stack + Main.rand.Next(2, 7)) * 1.5);
            Type1 = 4388;
          }
          else if (style >= 4 && style <= 6)
          {
            Type1 = 974;
            Type2 = 286;
          }
          else if (style >= 34 && style <= 36)
          {
            Stack += Main.rand.Next(2, 7);
            Type1 = 4383;
          }
          else if (player.ZoneGlowshroom)
          {
            Stack += Main.rand.Next(2, 7);
            Type1 = 5293;
          }
          if (Main.tile[i, j].liquid > (byte) 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Type2, Stack);
          else
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Type1, Stack);
        }
        else
        {
          switch (num7)
          {
            case 2:
              int Stack1 = Main.rand.Next(10, 21);
              int Type3 = 40;
              if (flag1 && WorldGen.genRand.Next(2) == 0)
                Type3 = !Main.hardMode ? 42 : 168;
              if (j > Main.UnderworldLayer)
                Type3 = 265;
              else if (Main.hardMode)
                Type3 = Main.rand.Next(2) != 0 ? 47 : (WorldGen.SavedOreTiers.Silver != 168 ? 278 : 4915);
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Type3, Stack1);
              break;
            case 3:
              int Type4 = 28;
              if (j > Main.UnderworldLayer || Main.hardMode)
                Type4 = 188;
              int Stack2 = 1;
              if (Main.expertMode && Main.rand.Next(3) != 0)
                ++Stack2;
              Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Type4, Stack2);
              break;
            default:
              if (num7 == 4 && flag3 | flag2)
              {
                int Type5 = 166;
                if (flag3)
                  Type5 = 4423;
                int Stack3 = Main.rand.Next(4) + 1;
                if (Main.expertMode)
                  Stack3 += Main.rand.Next(4);
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Type5, Stack3);
                break;
              }
              if ((num7 == 4 || num7 == 5) && j < Main.UnderworldLayer && !Main.hardMode)
              {
                int Stack4 = Main.rand.Next(20, 41);
                Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 965, Stack4);
                break;
              }
              float num10 = (float) (200 + WorldGen.genRand.Next(-100, 101));
              if ((double) j < Main.worldSurface)
                num10 *= 0.5f;
              else if (flag1)
                num10 *= 0.75f;
              else if (j > Main.maxTilesY - 250)
                num10 *= 1.25f;
              float num11 = num10 * (float) (1.0 + (double) Main.rand.Next(-20, 21) * 0.0099999997764825821);
              if (Main.rand.Next(4) == 0)
                num11 *= (float) (1.0 + (double) Main.rand.Next(5, 11) * 0.0099999997764825821);
              if (Main.rand.Next(8) == 0)
                num11 *= (float) (1.0 + (double) Main.rand.Next(10, 21) * 0.0099999997764825821);
              if (Main.rand.Next(12) == 0)
                num11 *= (float) (1.0 + (double) Main.rand.Next(20, 41) * 0.0099999997764825821);
              if (Main.rand.Next(16) == 0)
                num11 *= (float) (1.0 + (double) Main.rand.Next(40, 81) * 0.0099999997764825821);
              if (Main.rand.Next(20) == 0)
                num11 *= (float) (1.0 + (double) Main.rand.Next(50, 101) * 0.0099999997764825821);
              if (Main.expertMode)
                num11 *= 2.5f;
              if (Main.expertMode && Main.rand.Next(2) == 0)
                num11 *= 1.25f;
              if (Main.expertMode && Main.rand.Next(3) == 0)
                num11 *= 1.5f;
              if (Main.expertMode && Main.rand.Next(4) == 0)
                num11 *= 1.75f;
              float num12 = num11 * num2;
              if (NPC.downedBoss1)
                num12 *= 1.1f;
              if (NPC.downedBoss2)
                num12 *= 1.1f;
              if (NPC.downedBoss3)
                num12 *= 1.1f;
              if (NPC.downedMechBoss1)
                num12 *= 1.1f;
              if (NPC.downedMechBoss2)
                num12 *= 1.1f;
              if (NPC.downedMechBoss3)
                num12 *= 1.1f;
              if (NPC.downedPlantBoss)
                num12 *= 1.1f;
              if (NPC.downedQueenBee)
                num12 *= 1.1f;
              if (NPC.downedGolemBoss)
                num12 *= 1.1f;
              if (NPC.downedPirates)
                num12 *= 1.1f;
              if (NPC.downedGoblins)
                num12 *= 1.1f;
              if (NPC.downedFrost)
                num12 *= 1.1f;
              while ((int) num12 > 0)
              {
                if ((double) num12 > 1000000.0)
                {
                  int Stack5 = (int) ((double) num12 / 1000000.0);
                  if (Stack5 > 50 && Main.rand.Next(2) == 0)
                    Stack5 /= Main.rand.Next(3) + 1;
                  if (Main.rand.Next(2) == 0)
                    Stack5 /= Main.rand.Next(3) + 1;
                  num12 -= (float) (1000000 * Stack5);
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 74, Stack5);
                }
                else if ((double) num12 > 10000.0)
                {
                  int Stack6 = (int) ((double) num12 / 10000.0);
                  if (Stack6 > 50 && Main.rand.Next(2) == 0)
                    Stack6 /= Main.rand.Next(3) + 1;
                  if (Main.rand.Next(2) == 0)
                    Stack6 /= Main.rand.Next(3) + 1;
                  num12 -= (float) (10000 * Stack6);
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 73, Stack6);
                }
                else if ((double) num12 > 100.0)
                {
                  int Stack7 = (int) ((double) num12 / 100.0);
                  if (Stack7 > 50 && Main.rand.Next(2) == 0)
                    Stack7 /= Main.rand.Next(3) + 1;
                  if (Main.rand.Next(2) == 0)
                    Stack7 /= Main.rand.Next(3) + 1;
                  num12 -= (float) (100 * Stack7);
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 72, Stack7);
                }
                else
                {
                  int Stack8 = (int) num12;
                  if (Stack8 > 50 && Main.rand.Next(2) == 0)
                    Stack8 /= Main.rand.Next(3) + 1;
                  if (Main.rand.Next(2) == 0)
                    Stack8 /= Main.rand.Next(4) + 1;
                  if (Stack8 < 1)
                    Stack8 = 1;
                  num12 -= (float) Stack8;
                  Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 71, Stack8);
                }
              }
              break;
          }
        }
      }
    }

    public static int PlaceChest(int x, int y, ushort type = 21, bool notNearOtherChests = false, int style = 0)
    {
      int num = -1;
      if (TileID.Sets.Boulders[(int) Main.tile[x, y + 1].type] || TileID.Sets.Boulders[(int) Main.tile[x + 1, y + 1].type])
        return -1;
      TileObject objectData;
      if (TileObject.CanPlace(x, y, (int) type, style, 1, out objectData))
      {
        bool flag = true;
        if (notNearOtherChests && Chest.NearOtherChests(x - 1, y - 1))
          flag = false;
        if (flag)
        {
          TileObject.Place(objectData);
          num = Chest.CreateChest(objectData.xCoord, objectData.yCoord);
        }
      }
      else
        num = -1;
      if (num != -1 && Main.netMode == 1 && type == (ushort) 21)
        NetMessage.SendData(34, number2: ((float) x), number3: ((float) y), number4: ((float) style));
      if (num != -1 && Main.netMode == 1 && type == (ushort) 467)
        NetMessage.SendData(34, number: 4, number2: ((float) x), number3: ((float) y), number4: ((float) style));
      return num;
    }

    public static void PlaceChestDirect(int x, int y, ushort type, int style, int id)
    {
      Chest.CreateChest(x, y - 1, id);
      for (int index1 = 0; index1 <= 1; ++index1)
      {
        for (int index2 = -1; index2 <= 0; ++index2)
        {
          if (Main.tile[x + index1, y + index2] == null)
            Main.tile[x + index1, y + index2] = new Tile();
        }
      }
      Main.tile[x, y - 1].active(true);
      Main.tile[x, y - 1].frameY = (short) 0;
      Main.tile[x, y - 1].frameX = (short) (36 * style);
      Main.tile[x, y - 1].type = type;
      Main.tile[x, y - 1].halfBrick(false);
      Main.tile[x + 1, y - 1].active(true);
      Main.tile[x + 1, y - 1].frameY = (short) 0;
      Main.tile[x + 1, y - 1].frameX = (short) (18 + 36 * style);
      Main.tile[x + 1, y - 1].type = type;
      Main.tile[x + 1, y - 1].halfBrick(false);
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) 18;
      Main.tile[x, y].frameX = (short) (36 * style);
      Main.tile[x, y].type = type;
      Main.tile[x, y].halfBrick(false);
      Main.tile[x + 1, y].active(true);
      Main.tile[x + 1, y].frameY = (short) 18;
      Main.tile[x + 1, y].frameX = (short) (18 + 36 * style);
      Main.tile[x + 1, y].type = type;
      Main.tile[x + 1, y].halfBrick(false);
    }

    public static void PlaceDresserDirect(int x, int y, ushort type, int style, int id)
    {
      Chest.CreateChest(x - 1, y - 1, id);
      for (int index1 = -1; index1 <= 1; ++index1)
      {
        for (int index2 = -1; index2 <= 0; ++index2)
        {
          if (Main.tile[x + index1, y + index2] == null)
            Main.tile[x + index1, y + index2] = new Tile();
        }
      }
      short num = (short) (style * 54);
      Main.tile[x - 1, y - 1].active(true);
      Main.tile[x - 1, y - 1].frameY = (short) 0;
      Main.tile[x - 1, y - 1].frameX = num;
      Main.tile[x - 1, y - 1].type = type;
      Main.tile[x, y - 1].active(true);
      Main.tile[x, y - 1].frameY = (short) 0;
      Main.tile[x, y - 1].frameX = (short) ((int) num + 18);
      Main.tile[x, y - 1].type = type;
      Main.tile[x + 1, y - 1].active(true);
      Main.tile[x + 1, y - 1].frameY = (short) 0;
      Main.tile[x + 1, y - 1].frameX = (short) ((int) num + 36);
      Main.tile[x + 1, y - 1].type = type;
      Main.tile[x - 1, y].active(true);
      Main.tile[x - 1, y].frameY = (short) 18;
      Main.tile[x - 1, y].frameX = num;
      Main.tile[x - 1, y].type = type;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) 18;
      Main.tile[x, y].frameX = (short) ((int) num + 18);
      Main.tile[x, y].type = type;
      Main.tile[x + 1, y].active(true);
      Main.tile[x + 1, y].frameY = (short) 18;
      Main.tile[x + 1, y].frameX = (short) ((int) num + 36);
      Main.tile[x + 1, y].type = type;
    }

    public static void CheckChest(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = 0;
      int num2 = j;
      int num3 = num1 + (int) Main.tile[i, j].frameX / 18;
      int Y = num2 + (int) Main.tile[i, j].frameY / 18 * -1;
      while (num3 > 1)
        num3 -= 2;
      int X = num3 * -1 + i;
      for (int index1 = X; index1 < X + 2; ++index1)
      {
        for (int index2 = Y; index2 < Y + 2; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          int num4 = (int) Main.tile[index1, index2].frameX / 18;
          while (num4 > 1)
            num4 -= 2;
          if (!Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != type || num4 != index1 - X || (int) Main.tile[index1, index2].frameY != (index2 - Y) * 18)
            flag = true;
        }
        if (Main.tile[index1, Y + 2] == null)
          Main.tile[index1, Y + 2] = new Tile();
        if ((!Main.tile[index1, Y + 2].active() || !Main.tileSolid[(int) Main.tile[index1, Y + 2].type]) && Chest.CanDestroyChest(X, Y))
          flag = true;
      }
      if (!flag)
        return;
      int chestItemDrop = WorldGen.GetChestItemDrop(i, j, type);
      WorldGen.destroyObject = true;
      for (int index3 = X; index3 < X + 2; ++index3)
      {
        for (int index4 = Y; index4 < Y + 3; ++index4)
        {
          if ((int) Main.tile[index3, index4].type == type && Main.tile[index3, index4].active())
          {
            Chest.DestroyChest(index3, index4);
            WorldGen.KillTile(index3, index4);
          }
        }
      }
      Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, chestItemDrop);
      WorldGen.destroyObject = false;
    }

    private static int GetChestItemDrop(int x, int y, int type)
    {
      int index = (int) Main.tile[x, y].frameX / 36;
      return type != 467 ? Chest.chestItemSpawn[index] : Chest.chestItemSpawn2[index];
    }

    public static bool PlaceActuator(int i, int j)
    {
      if (Main.tile[i, j].actuator())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16);
      Main.tile[i, j].actuator(true);
      return true;
    }

    public static bool KillActuator(int i, int j)
    {
      if (!Main.tile[i, j].actuator())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16);
      Main.tile[i, j].actuator(false);
      if (Main.netMode != 1)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 849);
      for (int index = 0; index < 5; ++index)
        Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 50);
      return true;
    }

    public static bool PlaceWire(int i, int j)
    {
      if (Main.tile[i, j].wire())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16);
      Main.tile[i, j].wire(true);
      return true;
    }

    public static bool KillWire(int i, int j)
    {
      if (!Main.tile[i, j].wire())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16);
      Main.tile[i, j].wire(false);
      if (Main.netMode != 1)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 530);
      for (int index = 0; index < 5; ++index)
        Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 50);
      return true;
    }

    public static bool PlaceWire2(int i, int j)
    {
      if (Main.tile[i, j].wire2())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16);
      Main.tile[i, j].wire2(true);
      return true;
    }

    public static bool KillWire2(int i, int j)
    {
      if (!Main.tile[i, j].wire2())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16);
      Main.tile[i, j].wire2(false);
      if (Main.netMode != 1)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 530);
      for (int index = 0; index < 5; ++index)
        Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 50);
      return true;
    }

    public static bool PlaceWire3(int i, int j)
    {
      if (Main.tile[i, j].wire3())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16);
      Main.tile[i, j].wire3(true);
      return true;
    }

    public static bool KillWire3(int i, int j)
    {
      if (!Main.tile[i, j].wire3())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16);
      Main.tile[i, j].wire3(false);
      if (Main.netMode != 1)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 530);
      for (int index = 0; index < 5; ++index)
        Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 50);
      return true;
    }

    public static bool PlaceWire4(int i, int j)
    {
      if (Main.tile[i, j].wire4())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16);
      Main.tile[i, j].wire4(true);
      return true;
    }

    public static bool KillWire4(int i, int j)
    {
      if (!Main.tile[i, j].wire4())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16);
      Main.tile[i, j].wire4(false);
      if (Main.netMode != 1)
        Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 530);
      for (int index = 0; index < 5; ++index)
        Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 50);
      return true;
    }

    public static bool IsFitToPlaceFlowerIn(int x, int y, int typeAttemptedToPlace)
    {
      if (y < 1 || y > Main.maxTilesY - 1)
        return false;
      Tile tile = Main.tile[x, y + 1];
      if (!tile.active() || tile.slope() != (byte) 0 || tile.halfBrick())
        return false;
      if ((tile.type == (ushort) 2 || tile.type == (ushort) 78 || tile.type == (ushort) 380 || tile.type == (ushort) 477 || tile.type == (ushort) 579) && typeAttemptedToPlace == 3 || (tile.type == (ushort) 23 || tile.type == (ushort) 661) && typeAttemptedToPlace == 24 || (tile.type == (ushort) 109 || tile.type == (ushort) 492) && typeAttemptedToPlace == 110 || (tile.type == (ushort) 199 || tile.type == (ushort) 662) && typeAttemptedToPlace == 201)
        return true;
      return tile.type == (ushort) 633 && typeAttemptedToPlace == 637;
    }

    private static bool SeaOatWaterCheck(int x, int y)
    {
      int num1 = 45;
      int num2 = 20;
      int num3 = 20;
      int num4 = -1;
      int num5 = num1 + 1;
      int num6 = 0;
      bool flag = false;
      if (x <= WorldGen.beachDistance || x >= Main.maxTilesX - WorldGen.beachDistance)
      {
        flag = true;
        num4 = 40;
        num1 = 65;
        num2 += 5;
      }
      for (int index1 = x - num1; index1 <= x + num1; ++index1)
      {
        for (int index2 = y - num2; index2 <= y + num2; ++index2)
        {
          if (WorldGen.InWorld(index1, index2) && !WorldGen.SolidTile(index1, index2) && Main.tile[index1, index2].liquid > (byte) 0)
          {
            num6 += (int) Main.tile[index1, index2].liquid;
            int num7 = Math.Abs(index1 - x);
            if (num7 < num5)
              num5 = num7;
          }
        }
      }
      if (num6 / (int) byte.MaxValue >= num3)
      {
        if (!flag)
          return true;
        return false;
      }
      return flag;
    }

    private static bool PlantSeaOat(int x, int y)
    {
      if (Main.tile[x, y].wall > (ushort) 0 || Main.tile[x, y].active() || Main.tile[x, y].liquid > (byte) 0 || !WorldGen.SolidTileAllowBottomSlope(x, y + 1) || !TileID.Sets.Conversion.Sand[(int) Main.tile[x, y + 1].type] || !WorldGen.SeaOatWaterCheck(x, y))
        return false;
      Main.tile[x, y].active(true);
      Main.tile[x, y].slope((byte) 0);
      Main.tile[x, y].halfBrick(false);
      Main.tile[x, y].type = (ushort) 529;
      Main.tile[x, y].frameX = (short) (WorldGen.genRand.Next(5) * 18);
      int num = 0;
      Main.tile[x, y].frameY = (short) (num * 34);
      if (Main.netMode == 2)
        NetMessage.SendTileSquare(-1, x, y);
      return true;
    }

    private static bool CheckSeaOat(int x, int y)
    {
      if (WorldGen.SeaOatWaterCheck(x, y))
        return true;
      WorldGen.KillTile(x, y);
      if (Main.netMode == 2)
        NetMessage.SendData(17, number2: ((float) x), number3: ((float) y));
      return false;
    }

    private static bool GrowSeaOat(int x, int y)
    {
      if (Main.tile[x, y].frameX < (short) 180)
        Main.tile[x, y].frameX += (short) 90;
      if (Main.netMode == 2)
        NetMessage.SendTileSquare(-1, x, y);
      return false;
    }

    private static int GetWaterDepth(int x, int y)
    {
      int j1 = y;
      while (!WorldGen.SolidTile(x, j1))
      {
        ++j1;
        if (j1 > Main.maxTilesY - 1)
          return 0;
      }
      int num = j1 - 1;
      int j2 = num;
      while (Main.tile[x, j2].liquid > (byte) 0 && !WorldGen.SolidTile(x, j2))
        --j2;
      return num - j2;
    }

    private static int CountGrowingPlantTiles(int x, int y, int range, int type)
    {
      int num = 0;
      for (int index1 = x - range; index1 <= x + range; ++index1)
      {
        for (int index2 = y - range * 3; index2 <= y + range * 3; ++index2)
        {
          if (Main.tile[index1, index2].active() && (int) Main.tile[index1, index2].type == type)
            ++num;
        }
      }
      return num;
    }

    private static bool PlaceBamboo(int x, int y)
    {
      int num1 = 2;
      int num2 = 5;
      int num3 = WorldGen.genRand.Next(1, 21);
      Tile tile1 = Main.tile[x, y];
      if (tile1.wall > (ushort) 0 && (double) y <= Main.worldSurface || tile1.active() && tile1.type == (ushort) 314)
        return false;
      Tile tile2 = Main.tile[x, y + 1];
      if (tile2.type != (ushort) 571 && tile2.type != (ushort) 60)
        return false;
      int waterDepth = WorldGen.GetWaterDepth(x, y);
      if (waterDepth < num1 || waterDepth > num2)
        return false;
      int num4 = WorldGen.CountGrowingPlantTiles(x, y, 5, 571);
      int num5 = 1;
      if (tile2.type == (ushort) 571)
      {
        while (!WorldGen.SolidTile(x, y + num5))
          ++num5;
        if (num5 + num4 / WorldGen.genRand.Next(1, 21) > num3)
          return false;
      }
      else
        num4 += 25;
      if (num4 + num5 * 2 > WorldGen.genRand.Next(40, 61))
        return false;
      Tile tile3 = Main.tile[x, y];
      tile3.active(true);
      tile3.type = (ushort) 571;
      tile3.frameX = (short) 0;
      tile3.frameY = (short) 0;
      tile3.slope((byte) 0);
      tile3.halfBrick(false);
      WorldGen.SquareTileFrame(x, y);
      return true;
    }

    public static void CheckBamboo(int x, int y)
    {
      Tile tile1 = Main.tile[x, y + 1];
      if (tile1 == null)
        return;
      if (!tile1.active() || tile1.type != (ushort) 60 && tile1.type != (ushort) 571)
      {
        WorldGen.KillTile(x, y);
        if (Main.netMode == 2)
          NetMessage.SendData(17, number2: ((float) x), number3: ((float) y));
        WorldGen.SquareTileFrame(x, y);
      }
      else
      {
        Tile tile2 = Main.tile[x, y - 1];
        if (tile2 == null)
          return;
        Tile tile3 = Main.tile[x, y];
        if (tile3 == null)
          return;
        int num1 = !tile2.active() ? 0 : (tile2.type == (ushort) 571 ? 1 : 0);
        bool flag = tile1.active() && tile1.type == (ushort) 571;
        int num2 = (int) tile3.frameX / 18;
        tile3.frameY = (short) 0;
        if (num1 != 0)
        {
          if (flag)
          {
            if ((num2 < 5 ? 0 : (num2 <= 14 ? 1 : 0)) != 0)
              return;
            tile3.frameX = (short) (WorldGen.genRand.Next(5, 15) * 18);
            if (Main.netMode != 2)
              return;
            NetMessage.SendTileSquare(-1, x, y);
          }
          else
          {
            if ((num2 < 1 ? 0 : (num2 <= 4 ? 1 : 0)) != 0)
              return;
            tile3.frameX = (short) (WorldGen.genRand.Next(1, 5) * 18);
            if (Main.netMode != 2)
              return;
            NetMessage.SendTileSquare(-1, x, y);
          }
        }
        else if (flag)
        {
          if ((num2 < 15 ? 0 : (num2 <= 19 ? 1 : 0)) != 0)
            return;
          tile3.frameX = (short) (WorldGen.genRand.Next(15, 20) * 18);
          if (Main.netMode != 2)
            return;
          NetMessage.SendTileSquare(-1, x, y);
        }
        else
        {
          if (num2 == 0)
            return;
          tile3.frameX = (short) 0;
          if (Main.netMode != 2)
            return;
          NetMessage.SendTileSquare(-1, x, y);
        }
      }
    }

    public static void PlaceUnderwaterPlant(ushort type, int x, int y)
    {
      if (!WorldGen.CanUnderwaterPlantGrowHere(type, x, y, false))
        return;
      Tile tileSafely1 = Framing.GetTileSafely(x, y + 1);
      tileSafely1.slope((byte) 0);
      tileSafely1.halfBrick(false);
      Tile tileSafely2 = Framing.GetTileSafely(x, y);
      tileSafely2.active(true);
      tileSafely2.type = type;
      tileSafely2.frameX = (short) 0;
      tileSafely2.frameY = (short) 0;
      tileSafely2.slope((byte) 0);
      tileSafely2.halfBrick(false);
      WorldGen.SquareTileFrame(x, y);
    }

    public static bool CanUnderwaterPlantGrowHere(ushort type, int x, int y, bool ignoreSelf)
    {
      if (!WorldGen.InWorld(x, y, 50))
        return false;
      Tile tileSafely1 = Framing.GetTileSafely(x, y);
      if (!ignoreSelf && tileSafely1.active())
        return false;
      for (int index = 0; index < 3; ++index)
      {
        Tile tileSafely2 = Framing.GetTileSafely(x, y - index);
        if (tileSafely2.liquid == (byte) 0 || tileSafely2.liquidType() != (byte) 0)
          return false;
      }
      Tile tileSafely3 = Framing.GetTileSafely(x, y + 1);
      if (!tileSafely3.nactive() || (TileID.Sets.Conversion.Sand[(int) tileSafely3.type] ? 1 : ((int) type == (int) tileSafely3.type ? 1 : 0)) == 0)
        return false;
      switch (Framing.GetTileSafely(x, y).wall)
      {
        case 0:
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 80:
        case 81:
          return true;
        default:
          return false;
      }
    }

    public static void CheckUnderwaterPlant(ushort type, int x, int y)
    {
      if (!WorldGen.CanUnderwaterPlantGrowHere(type, x, y, true))
      {
        WorldGen.KillTile(x, y);
        if (Main.netMode == 2)
          NetMessage.SendData(17, number2: ((float) x), number3: ((float) y));
        WorldGen.SquareTileFrame(x, y);
      }
      else
      {
        Tile tileSafely1 = Framing.GetTileSafely(x, y - 1);
        Tile tileSafely2 = Framing.GetTileSafely(x, y);
        Tile tileSafely3 = Framing.GetTileSafely(x, y + 1);
        int num1 = !tileSafely1.active() ? 0 : ((int) tileSafely1.type == (int) type ? 1 : 0);
        bool flag = tileSafely3.active() && (int) tileSafely3.type == (int) type;
        int num2 = (int) tileSafely2.frameX / 18;
        tileSafely2.frameY = (short) 0;
        if (num1 != 0)
        {
          if ((1 > num2 ? 0 : (num2 <= 7 ? 1 : 0)) != 0)
            return;
          tileSafely2.frameX = (short) (WorldGen.genRand.Next(1, 8) * 18);
          if (Main.netMode != 2)
            return;
          NetMessage.SendTileSquare(-1, x, y);
        }
        else if (flag)
        {
          if ((7 > num2 ? 0 : (num2 <= 12 ? 1 : 0)) != 0)
            return;
          tileSafely2.frameX = (short) (WorldGen.genRand.Next(7, 13) * 18);
          if (Main.netMode != 2)
            return;
          NetMessage.SendTileSquare(-1, x, y);
        }
        else
        {
          if (num2 == 0)
            return;
          tileSafely2.frameX = (short) 0;
          if (Main.netMode != 2)
            return;
          NetMessage.SendTileSquare(-1, x, y);
        }
      }
    }

    public static Point PlaceCatTail(int x, int j)
    {
      int index1 = j;
      Point point = new Point(-1, -1);
      if (x < 50 || x > Main.maxTilesX - 50 || index1 < 50 || index1 > Main.maxTilesY - 50 || Main.tile[x, index1].active() && Main.tile[x, index1].type != (ushort) 71 || Main.tile[x, index1].liquid == (byte) 0 || Main.tile[x, index1].liquidType() != (byte) 0)
        return point;
      while (Main.tile[x, index1].liquid > (byte) 0 && index1 > 50)
        --index1;
      int index2 = index1 + 1;
      if (Main.tile[x, index2].active() || Main.tile[x, index2 - 1].active() || Main.tile[x, index2].liquid == (byte) 0 || Main.tile[x, index2].liquidType() != (byte) 0 || Main.tile[x, index2].wall != (ushort) 0 && Main.tile[x, index2].wall != (ushort) 80 && Main.tile[x, index2].wall != (ushort) 81 && Main.tile[x, index2].wall != (ushort) 69 && (Main.tile[x, index2].wall < (ushort) 63 || Main.tile[x, index2].wall > (ushort) 68))
        return point;
      int num1 = 7;
      int num2 = 0;
      for (int index3 = x - num1; index3 <= x + num1; ++index3)
      {
        for (int index4 = index2 - num1; index4 <= index2 + num1; ++index4)
        {
          if (Main.tile[index3, index4].active() && Main.tile[index3, index4].type == (ushort) 519)
          {
            ++num2;
            break;
          }
        }
      }
      if (num2 > 3)
        return point;
      int index5;
      for (index5 = index2; (!Main.tile[x, index5].active() || !Main.tileSolid[(int) Main.tile[x, index5].type] || Main.tileSolidTop[(int) Main.tile[x, index5].type]) && index5 < Main.maxTilesY - 50; ++index5)
      {
        if (Main.tile[x, index5].active() && Main.tile[x, index5].type != (ushort) 71)
          return point;
      }
      int num3 = WorldGen.catTailDistance - 1;
      if (index5 - index2 > num3 || index5 - index2 < 2)
        return point;
      int type = (int) Main.tile[x, index5].type;
      if (!Main.tile[x, index5].nactive())
        return point;
      int num4 = -1;
      switch (type)
      {
        case 2:
        case 477:
          num4 = 0;
          break;
        case 23:
        case 112:
        case 661:
          num4 = 72;
          break;
        case 53:
          if (x < WorldGen.beachDistance || x > Main.maxTilesX - WorldGen.beachDistance)
            return point;
          num4 = 18;
          break;
        case 70:
          num4 = 90;
          break;
        case 199:
        case 234:
        case 662:
          num4 = 54;
          break;
      }
      if (num4 < 0)
        return point;
      if (Main.tile[x, index5].topSlope() && WorldGen.gen && WorldGen.genRand.Next(3) != 0)
        Main.tile[x, index5].slope((byte) 0);
      else if (Main.tile[x, index5].topSlope() || Main.tile[x, index5].halfBrick())
        return point;
      int index6 = index5 - 1;
      Main.tile[x, index6].active(true);
      Main.tile[x, index6].type = (ushort) 519;
      Main.tile[x, index6].frameX = (short) 0;
      Main.tile[x, index6].frameY = (short) num4;
      Main.tile[x, index6].halfBrick(false);
      Main.tile[x, index6].slope((byte) 0);
      Main.tile[x, index6].CopyPaintAndCoating(Main.tile[x, index6 + 1]);
      WorldGen.SquareTileFrame(x, index6);
      point = new Point(x, index6);
      return point;
    }

    public static void CheckCatTail(int x, int j)
    {
      if (Main.tile[x, j] == null)
        return;
      int num1 = j;
      bool flag = false;
      int index1 = num1;
      while ((!Main.tile[x, index1].active() || !Main.tileSolid[(int) Main.tile[x, index1].type] || Main.tileSolidTop[(int) Main.tile[x, index1].type]) && index1 < Main.maxTilesY - 50)
      {
        if (Main.tile[x, index1].active() && Main.tile[x, index1].type != (ushort) 519)
          flag = true;
        if (Main.tile[x, index1].active())
        {
          ++index1;
          if (Main.tile[x, index1] == null)
            return;
        }
        else
          break;
      }
      int index2 = index1 - 1;
      if (Main.tile[x, index2] == null)
        return;
      while (Main.tile[x, index2] != null && Main.tile[x, index2].liquid > (byte) 0 && index2 > 50)
      {
        if (Main.tile[x, index2].active() && Main.tile[x, index2].type != (ushort) 519 || Main.tile[x, index2].liquidType() != (byte) 0)
          flag = true;
        --index2;
        if (Main.tile[x, index2] == null)
          return;
      }
      int index3 = index2 + 1;
      if (Main.tile[x, index3] == null)
        return;
      int num2 = index3;
      int catTailDistance = WorldGen.catTailDistance;
      if (index1 - num2 > catTailDistance)
        flag = true;
      int type = (int) Main.tile[x, index1].type;
      int num3 = -1;
      switch (type)
      {
        case 2:
        case 477:
          num3 = 0;
          break;
        case 23:
        case 112:
        case 661:
          num3 = 72;
          break;
        case 53:
          num3 = 18;
          break;
        case 70:
          num3 = 90;
          break;
        case 199:
        case 234:
        case 662:
          num3 = 54;
          break;
      }
      if (!Main.tile[x, index1].nactive())
        flag = true;
      if (num3 < 0)
        flag = true;
      int index4 = index1 - 1;
      if (Main.tile[x, index4] != null && !Main.tile[x, index4].active())
      {
        for (int index5 = index4; index5 >= num2; --index5)
        {
          if (Main.tile[x, index5] == null)
            return;
          if (Main.tile[x, index5].active() && Main.tile[x, index5].type == (ushort) 519)
          {
            index4 = index5;
            break;
          }
        }
      }
      while (Main.tile[x, index4] != null && Main.tile[x, index4].active() && Main.tile[x, index4].type == (ushort) 519)
        --index4;
      int tileY = index4 + 1;
      if (Main.tile[x, index1 - 1] != null && Main.tile[x, index1 - 1].liquid < (byte) 127 && WorldGen.genRand.Next(4) == 0)
        flag = true;
      if (Main.tile[x, tileY] != null && Main.tile[x, tileY].frameX >= (short) 180 && Main.tile[x, tileY].liquid > (byte) 127 && WorldGen.genRand.Next(4) == 0)
        flag = true;
      if (Main.tile[x, tileY] != null && Main.tile[x, index1 - 1] != null && Main.tile[x, tileY].frameX > (short) 18)
      {
        if (Main.tile[x, index1 - 1].frameX < (short) 36 || Main.tile[x, index1 - 1].frameX > (short) 72)
          flag = true;
        else if (Main.tile[x, tileY].frameX < (short) 90)
          flag = true;
        else if (Main.tile[x, tileY].frameX >= (short) 108 && Main.tile[x, tileY].frameX <= (short) 162)
          Main.tile[x, tileY].frameX = (short) 90;
      }
      if (index1 > tileY + 4 && Main.tile[x, tileY + 4] != null && Main.tile[x, tileY + 3] != null && Main.tile[x, tileY + 4].liquid == (byte) 0 && Main.tile[x, tileY + 3].type == (ushort) 519)
        flag = true;
      if (flag)
      {
        int num4 = num2;
        if (tileY < num2)
          num4 = tileY;
        for (int index6 = num4 - 4; index6 <= index1; ++index6)
        {
          if (Main.tile[x, index6] != null && Main.tile[x, index6].active() && Main.tile[x, index6].type == (ushort) 519)
          {
            WorldGen.KillTile(x, index6);
            if (Main.netMode == 2)
              NetMessage.SendData(17, number2: ((float) x), number3: ((float) index6));
            WorldGen.SquareTileFrame(x, index6);
          }
        }
      }
      else
      {
        if (num3 == (int) Main.tile[x, tileY].frameY)
          return;
        for (int index7 = tileY; index7 < index1; ++index7)
        {
          if (Main.tile[x, index7] != null && Main.tile[x, index7].active() && Main.tile[x, index7].type == (ushort) 519)
          {
            Main.tile[x, index7].frameY = (short) num3;
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, x, tileY);
          }
        }
      }
    }

    public static void GrowCheckSeaweed(int x, int y)
    {
      int maxValue = 1;
      if (Main.netMode == 1)
        return;
      if (Main.tile[x, y].type == (ushort) 549 && Main.tile[x, y].liquid < (byte) 200 || Main.tile[x, y - 1].liquid < (byte) 200)
      {
        if (!Main.tile[x, y].active() || Main.tile[x, y].type != (ushort) 549 || WorldGen.genRand.Next(2) != 0)
          return;
        WorldGen.KillTile(x, y);
        if (Main.netMode != 2)
          return;
        NetMessage.SendData(17, number2: ((float) x), number3: ((float) y));
      }
      else
      {
        if (Main.tile[x, y - 1].active() || Main.tile[x, y - 2].active() || WorldGen.genRand.Next(maxValue) != 0 || Main.tile[x, y - 2].liquid != byte.MaxValue || Main.tile[x, y - 3].liquid != byte.MaxValue)
          return;
        int num1 = 17;
        int num2 = 4;
        int num3 = 30;
        int num4 = 0;
        for (int index1 = x - num2; index1 <= x + num2; ++index1)
        {
          for (int index2 = y; index2 <= y + num2 * 3; ++index2)
          {
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 549)
            {
              ++num4;
              if (num4 > num3)
                return;
            }
          }
        }
        int j = y;
        while (!WorldGen.SolidTile(x, j) && j < Main.maxTilesY - 50)
          ++j;
        if (j - y >= num1 - WorldGen.genRand.Next(20))
          return;
        WorldGen.PlaceTile(x, y - 1, 549, true);
        if (Main.netMode != 2)
          return;
        NetMessage.SendTileSquare(-1, x, y - 1);
      }
    }

    public static void GrowCatTail(int x, int j)
    {
      if (Main.netMode == 1)
        return;
      int index1 = j;
      while (Main.tile[x, index1].liquid > (byte) 0 && index1 > 50)
        --index1;
      int index2 = index1 + 1;
      while ((!Main.tile[x, index2].active() || !Main.tileSolid[(int) Main.tile[x, index2].type] || Main.tileSolidTop[(int) Main.tile[x, index2].type]) && index2 < Main.maxTilesY - 50)
        ++index2;
      int index3 = index2 - 1;
      while (Main.tile[x, index3].active() && Main.tile[x, index3].type == (ushort) 519)
        --index3;
      int index4 = index3 + 1;
      if (Main.tile[x, index4].frameX == (short) 90 && Main.tile[x, index4 - 1].active() && Main.tileCut[(int) Main.tile[x, index4 - 1].type])
      {
        WorldGen.KillTile(x, index4 - 1);
        if (Main.netMode == 2)
          NetMessage.SendData(17, number2: ((float) x), number3: ((float) (index4 - 1)));
      }
      if (Main.tile[x, index4 - 1].active())
        return;
      if (Main.tile[x, index4].frameX == (short) 0)
      {
        Main.tile[x, index4].frameX = (short) 18;
        WorldGen.SquareTileFrame(x, index4);
        if (Main.netMode == 2)
          NetMessage.SendTileSquare(-1, x, index4);
      }
      else if (Main.tile[x, index4].frameX == (short) 18)
      {
        Main.tile[x, index4].frameX = (short) (18 * WorldGen.genRand.Next(2, 5));
        Main.tile[x, index4 - 1].active(true);
        Main.tile[x, index4 - 1].type = (ushort) 519;
        Main.tile[x, index4 - 1].frameX = (short) 90;
        Main.tile[x, index4 - 1].frameY = Main.tile[x, index4].frameY;
        Main.tile[x, index4 - 1].halfBrick(false);
        Main.tile[x, index4 - 1].slope((byte) 0);
        Main.tile[x, index4 - 1].CopyPaintAndCoating(Main.tile[x, index4]);
        WorldGen.SquareTileFrame(x, index4);
        if (Main.netMode == 2)
          NetMessage.SendTileSquare(-1, x, index4);
      }
      else if (Main.tile[x, index4].frameX == (short) 90)
      {
        if (Main.tile[x, index4 - 1].liquid == (byte) 0)
        {
          if (!Main.tile[x, index4 - 2].active() && (Main.tile[x, index4].liquid > (byte) 0 || Main.tile[x, index4 + 1].liquid > (byte) 0 || Main.tile[x, index4 + 2].liquid > (byte) 0) && WorldGen.genRand.Next(3) == 0)
          {
            Main.tile[x, index4].frameX = (short) 108;
            Main.tile[x, index4 - 1].active(true);
            Main.tile[x, index4 - 1].type = (ushort) 519;
            Main.tile[x, index4 - 1].frameX = (short) 90;
            Main.tile[x, index4 - 1].frameY = Main.tile[x, index4].frameY;
            Main.tile[x, index4 - 1].halfBrick(false);
            Main.tile[x, index4 - 1].slope((byte) 0);
            Main.tile[x, index4 - 1].CopyPaintAndCoating(Main.tile[x, index4]);
            WorldGen.SquareTileFrame(x, index4);
          }
          else
          {
            int num = WorldGen.genRand.Next(3);
            Main.tile[x, index4].frameX = (short) (126 + num * 18);
            Main.tile[x, index4 - 1].active(true);
            Main.tile[x, index4 - 1].type = (ushort) 519;
            Main.tile[x, index4 - 1].frameX = (short) (180 + num * 18);
            Main.tile[x, index4 - 1].frameY = Main.tile[x, index4].frameY;
            Main.tile[x, index4 - 1].halfBrick(false);
            Main.tile[x, index4 - 1].slope((byte) 0);
            Main.tile[x, index4 - 1].CopyPaintAndCoating(Main.tile[x, index4]);
            WorldGen.SquareTileFrame(x, index4);
          }
        }
        else
        {
          Main.tile[x, index4].frameX = (short) 108;
          Main.tile[x, index4 - 1].active(true);
          Main.tile[x, index4 - 1].type = (ushort) 519;
          Main.tile[x, index4 - 1].frameX = (short) 90;
          Main.tile[x, index4 - 1].frameY = Main.tile[x, index4].frameY;
          Main.tile[x, index4 - 1].halfBrick(false);
          Main.tile[x, index4 - 1].slope((byte) 0);
          Main.tile[x, index4 - 1].CopyPaintAndCoating(Main.tile[x, index4]);
          WorldGen.SquareTileFrame(x, index4);
        }
      }
      WorldGen.SquareTileFrame(x, index4 - 1, false);
      if (Main.netMode != 2)
        return;
      NetMessage.SendTileSquare(-1, x, index4 - 1, 1, 2);
    }

    public static bool PlaceLilyPad(int x, int j)
    {
      int index1 = j;
      if (x < 50 || x > Main.maxTilesX - 50 || index1 < 50 || index1 > Main.maxTilesY - 50 || Main.tile[x, index1].active() || Main.tile[x, index1].liquid == (byte) 0 || Main.tile[x, index1].liquidType() != (byte) 0)
        return false;
      while (Main.tile[x, index1].liquid > (byte) 0 && index1 > 50)
        --index1;
      int j1 = index1 + 1;
      if (Main.tile[x, j1].active() || Main.tile[x, j1 - 1].active() || Main.tile[x, j1].liquid == (byte) 0 || Main.tile[x, j1].liquidType() != (byte) 0 || Main.tile[x, j1].wall != (ushort) 0 && Main.tile[x, j1].wall != (ushort) 15 && Main.tile[x, j1].wall != (ushort) 70 && (Main.tile[x, j1].wall < (ushort) 63 || Main.tile[x, j1].wall > (ushort) 68))
        return false;
      int num1 = 5;
      int num2 = 0;
      for (int index2 = x - num1; index2 <= x + num1; ++index2)
      {
        for (int index3 = j1 - num1; index3 <= j1 + num1; ++index3)
        {
          if (Main.tile[index2, index3].active() && Main.tile[index2, index3].type == (ushort) 518)
            ++num2;
        }
      }
      if (num2 > 3)
        return false;
      int index4;
      for (index4 = j1; (!Main.tile[x, index4].active() || !Main.tileSolid[(int) Main.tile[x, index4].type] || Main.tileSolidTop[(int) Main.tile[x, index4].type]) && index4 < Main.maxTilesY - 50; ++index4)
      {
        if (Main.tile[x, index4].active() && Main.tile[x, index4].type == (ushort) 519)
          return false;
      }
      int num3 = 12;
      if (index4 - j1 > num3 || index4 - j1 < 3)
        return false;
      int type = (int) Main.tile[x, index4].type;
      int num4 = -1;
      if (type == 2 || type == 477)
        num4 = 0;
      if (type == 109 || type == 109 || type == 116)
        num4 = 18;
      if (type == 60)
        num4 = 36;
      if (num4 < 0)
        return false;
      Main.tile[x, j1].active(true);
      Main.tile[x, j1].type = (ushort) 518;
      if (WorldGen.genRand.Next(2) == 0)
        Main.tile[x, j1].frameX = (short) (18 * WorldGen.genRand.Next(3));
      else if (WorldGen.genRand.Next(15) == 0)
      {
        Main.tile[x, j1].frameX = (short) (18 * WorldGen.genRand.Next(18));
      }
      else
      {
        int num5 = Main.maxTilesX / 5;
        Main.tile[x, j1].frameX = x >= num5 ? (x >= num5 * 2 ? (x >= num5 * 3 ? (x >= num5 * 4 ? (short) (18 * WorldGen.genRand.Next(12, 15)) : (short) (18 * WorldGen.genRand.Next(15, 18))) : (short) (18 * WorldGen.genRand.Next(3, 6))) : (short) (18 * WorldGen.genRand.Next(9, 12))) : (short) (18 * WorldGen.genRand.Next(6, 9));
      }
      Main.tile[x, j1].frameY = (short) num4;
      Main.tile[x, j1].halfBrick(false);
      Main.tile[x, j1].slope((byte) 0);
      WorldGen.SquareTileFrame(x, j1);
      return true;
    }

    public static void CheckLilyPad(int x, int y)
    {
      if (Main.netMode == 1)
        return;
      if (Main.tile[x, y].liquidType() != (byte) 0)
      {
        WorldGen.KillTile(x, y);
        if (Main.netMode != 2)
          return;
        NetMessage.SendData(17, number2: ((float) x), number3: ((float) y));
      }
      else
      {
        int index = y;
        while ((!Main.tile[x, index].active() || !Main.tileSolid[(int) Main.tile[x, index].type] || Main.tileSolidTop[(int) Main.tile[x, index].type]) && index < Main.maxTilesY - 50)
        {
          ++index;
          if (Main.tile[x, index] == null)
            return;
        }
        int type = (int) Main.tile[x, index].type;
        int num = -1;
        if (type == 2 || type == 477)
          num = 0;
        if (type == 109 || type == 109 || type == 116)
          num = 18;
        if (type == 60)
          num = 36;
        if (num >= 0)
        {
          if (num != (int) Main.tile[x, y].frameY)
          {
            Main.tile[x, y].frameY = (short) num;
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, x, y);
          }
          if (Main.tile[x, y - 1].liquid > (byte) 0 && !Main.tile[x, y - 1].active())
          {
            Main.tile[x, y - 1].active(true);
            Main.tile[x, y - 1].type = (ushort) 518;
            Main.tile[x, y - 1].frameX = Main.tile[x, y].frameX;
            Main.tile[x, y - 1].frameY = Main.tile[x, y].frameY;
            Main.tile[x, y - 1].halfBrick(false);
            Main.tile[x, y - 1].slope((byte) 0);
            Main.tile[x, y].active(false);
            Main.tile[x, y].type = (ushort) 0;
            WorldGen.SquareTileFrame(x, y - 1, false);
            if (Main.netMode != 2)
              return;
            NetMessage.SendTileSquare(-1, x, y - 1, 1, 2);
          }
          else
          {
            if (Main.tile[x, y].liquid != (byte) 0)
              return;
            Tile tileSafely = Framing.GetTileSafely(x, y + 1);
            if (!tileSafely.active())
            {
              Main.tile[x, y + 1].active(true);
              Main.tile[x, y + 1].type = (ushort) 518;
              Main.tile[x, y + 1].frameX = Main.tile[x, y].frameX;
              Main.tile[x, y + 1].frameY = Main.tile[x, y].frameY;
              Main.tile[x, y + 1].halfBrick(false);
              Main.tile[x, y + 1].slope((byte) 0);
              Main.tile[x, y].active(false);
              Main.tile[x, y].type = (ushort) 0;
              WorldGen.SquareTileFrame(x, y + 1, false);
              if (Main.netMode != 2)
                return;
              NetMessage.SendTileSquare(-1, x, y, 1, 2);
            }
            else
            {
              if (!tileSafely.active() || TileID.Sets.Platforms[(int) tileSafely.type] || Main.tileSolid[(int) tileSafely.type] && !Main.tileSolidTop[(int) tileSafely.type])
                return;
              WorldGen.KillTile(x, y);
              if (Main.netMode != 2)
                return;
              NetMessage.SendData(17, number2: ((float) x), number3: ((float) y));
            }
          }
        }
        else
        {
          WorldGen.KillTile(x, y);
          if (Main.netMode != 2)
            return;
          NetMessage.SendData(17, number2: ((float) x), number3: ((float) y));
        }
      }
    }

    public static bool TryKillingReplaceableTile(int x, int y, int tileType)
    {
      if (!WorldGen.InWorld(x, y, 2) || !Main.tile[x, y].active() || !Main.tileCut[(int) Main.tile[x, y].type] && !TileID.Sets.BreakableWhenPlacing[(int) Main.tile[x, y].type] && (Main.tile[x, y].type < (ushort) 373 || Main.tile[x, y].type > (ushort) 375) && Main.tile[x, y].type != (ushort) 461 || (int) Main.tile[x, y].type == tileType)
        return false;
      int num = Main.tile[x, y + 1].type == (ushort) 78 || Main.tile[x, y + 1].type == (ushort) 380 ? 0 : (Main.tile[x, y + 1].type != (ushort) 579 ? 1 : 0);
      bool flag1 = Main.tile[x, y].type == (ushort) 3 || Main.tile[x, y].type == (ushort) 73;
      bool flag2 = Main.tileAlch[(int) Main.tile[x, y].type] && WorldGen.IsHarvestableHerbWithSeed((int) Main.tile[x, y].type, (int) Main.tile[x, y].frameX / 18);
      bool flag3 = Main.tileAlch[tileType];
      if (num == 0 && !((flag1 | flag2) & flag3))
        return false;
      WorldGen.KillTile(x, y);
      if (!Main.tile[x, y].active() && Main.netMode != 0)
        NetMessage.SendData(17, number2: ((float) x), number3: ((float) y));
      return true;
    }

    public static bool PlaceTile(
      int i,
      int j,
      int Type,
      bool mute = false,
      bool forced = false,
      int plr = -1,
      int style = 0)
    {
      int index1 = Type;
      if (WorldGen.gen && Main.tile[i, j].active() && Main.tile[i, j].type == (ushort) 488 || index1 >= (int) TileID.Count)
        return false;
      bool flag1 = false;
      if (i >= 0 && j >= 0 && i < Main.maxTilesX && j < Main.maxTilesY)
      {
        Tile trackCache = Main.tile[i, j];
        if (trackCache == null)
        {
          trackCache = new Tile();
          Main.tile[i, j] = trackCache;
        }
        if (trackCache.active())
        {
          if (index1 == 23 && trackCache.type == (ushort) 59)
            index1 = 661;
          if (index1 == 199 && trackCache.type == (ushort) 59)
            index1 = 662;
        }
        if (forced || Collision.EmptyTile(i, j) || !Main.tileSolid[index1] || index1 == 23 && trackCache.type == (ushort) 0 && trackCache.active() || index1 == 199 && trackCache.type == (ushort) 0 && trackCache.active() || index1 == 2 && trackCache.type == (ushort) 0 && trackCache.active() || index1 == 109 && trackCache.type == (ushort) 0 && trackCache.active() || index1 == 60 && trackCache.type == (ushort) 59 && trackCache.active() || index1 == 661 && trackCache.type == (ushort) 59 && trackCache.active() || index1 == 662 && trackCache.type == (ushort) 59 && trackCache.active() || index1 == 70 && trackCache.type == (ushort) 59 && trackCache.active() || index1 == 633 && trackCache.type == (ushort) 57 && trackCache.active() || Main.tileMoss[index1] && (trackCache.type == (ushort) 1 || trackCache.type == (ushort) 38) && trackCache.active())
        {
          if (index1 == 23 && (trackCache.type != (ushort) 0 || !trackCache.active()) || index1 == 199 && (trackCache.type != (ushort) 0 || !trackCache.active()) || index1 == 2 && (trackCache.type != (ushort) 0 || !trackCache.active()) || index1 == 109 && (trackCache.type != (ushort) 0 || !trackCache.active()) || index1 == 60 && (trackCache.type != (ushort) 59 || !trackCache.active()) || index1 == 661 && (trackCache.type != (ushort) 59 || !trackCache.active()) || index1 == 662 && (trackCache.type != (ushort) 59 || !trackCache.active()) || index1 == 70 && (trackCache.type != (ushort) 59 || !trackCache.active()) || index1 == 633 && (trackCache.type != (ushort) 57 || !trackCache.active()))
            return false;
          if (Main.tileMoss[index1])
          {
            if (trackCache.type != (ushort) 1 && trackCache.type != (ushort) 38 || !trackCache.active())
              return false;
            if (trackCache.type == (ushort) 38)
            {
              switch (index1)
              {
                case 381:
                  index1 = 517;
                  break;
                case 534:
                  index1 = 535;
                  break;
                case 536:
                  index1 = 537;
                  break;
                case 539:
                  index1 = 540;
                  break;
                case 625:
                  index1 = 626;
                  break;
                case 627:
                  index1 = 628;
                  break;
                default:
                  index1 = 512 + index1 - 179;
                  break;
              }
            }
          }
          if (index1 == 81)
          {
            if (Main.tile[i, j - 1] == null)
              Main.tile[i, j - 1] = new Tile();
            if (Main.tile[i, j + 1] == null)
              Main.tile[i, j + 1] = new Tile();
            if (Main.tile[i, j - 1].active() || !Main.tile[i, j + 1].active() || !Main.tileSolid[(int) Main.tile[i, j + 1].type] || Main.tile[i, j + 1].halfBrick() || Main.tile[i, j + 1].slope() != (byte) 0)
              return false;
          }
          if ((index1 == 373 || index1 == 375 || index1 == 374 || index1 == 461) && (Main.tile[i, j - 1] == null || Main.tile[i, j - 1].bottomSlope()))
            return false;
          if (trackCache.liquid > (byte) 0 || trackCache.checkingLiquid())
          {
            switch (index1)
            {
              case 3:
              case 20:
              case 24:
              case 27:
              case 32:
              case 51:
              case 69:
              case 72:
              case 201:
              case 352:
              case 529:
              case 624:
              case 637:
              case 656:
                return false;
              case 4:
                if (style != 8 && style != 11 && style != 17)
                  return false;
                break;
            }
          }
          if (TileID.Sets.ResetsHalfBrickPlacementAttempt[index1] && (!trackCache.active() || !Main.tileFrameImportant[(int) trackCache.type]))
          {
            trackCache.halfBrick(false);
            trackCache.frameY = (short) 0;
            trackCache.frameX = (short) 0;
          }
          switch (index1)
          {
            case 624:
              if ((!trackCache.active() || Main.tileCut[(int) trackCache.type] || TileID.Sets.BreakableWhenPlacing[(int) trackCache.type]) && WorldGen.HasValidGroundForAbigailsFlowerBelowSpot(i, j))
              {
                trackCache.active(true);
                trackCache.type = (ushort) 624;
                trackCache.halfBrick(false);
                trackCache.slope((byte) 0);
                trackCache.frameX = (short) 0;
                trackCache.frameY = (short) 0;
                break;
              }
              break;
            case 656:
              if ((!trackCache.active() || Main.tileCut[(int) trackCache.type] || TileID.Sets.BreakableWhenPlacing[(int) trackCache.type]) && WorldGen.HasValidGroundForGlowTulipBelowSpot(i, j))
              {
                trackCache.active(true);
                trackCache.type = (ushort) 656;
                trackCache.halfBrick(false);
                trackCache.slope((byte) 0);
                trackCache.frameX = (short) 0;
                trackCache.frameY = (short) 0;
                break;
              }
              break;
            default:
              if (index1 == 3 || index1 == 24 || index1 == 110 || index1 == 201 || index1 == 637)
              {
                if (WorldGen.IsFitToPlaceFlowerIn(i, j, index1))
                {
                  if (index1 == 24 && WorldGen.genRand.Next(13) == 0)
                  {
                    trackCache.active(true);
                    trackCache.type = (ushort) 32;
                    WorldGen.SquareTileFrame(i, j);
                    break;
                  }
                  if (index1 == 201 && WorldGen.genRand.Next(13) == 0)
                  {
                    trackCache.active(true);
                    trackCache.type = (ushort) 352;
                    WorldGen.SquareTileFrame(i, j);
                    break;
                  }
                  if (Main.tile[i, j + 1].type == (ushort) 78 || Main.tile[i, j + 1].type == (ushort) 380 || Main.tile[i, j + 1].type == (ushort) 579)
                  {
                    trackCache.active(true);
                    trackCache.type = (ushort) index1;
                    int num = WorldGen.genRand.NextFromList<int>(6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 27, 30, 33, 36, 39, 42);
                    switch (num)
                    {
                      case 21:
                      case 24:
                      case 27:
                      case 30:
                      case 33:
                      case 36:
                      case 39:
                      case 42:
                        num += WorldGen.genRand.Next(3);
                        break;
                    }
                    trackCache.frameX = (short) (num * 18);
                    break;
                  }
                  if (trackCache.wall >= (ushort) 0 && (int) trackCache.wall < (int) WallID.Count && WallID.Sets.AllowsPlantsToGrow[(int) trackCache.wall] && Main.tile[i, j + 1].wall >= (ushort) 0 && (int) Main.tile[i, j + 1].wall < (int) WallID.Count && WallID.Sets.AllowsPlantsToGrow[(int) Main.tile[i, j + 1].wall])
                  {
                    if (WorldGen.genRand.Next(50) == 0 || (index1 == 24 || index1 == 201) && WorldGen.genRand.Next(40) == 0)
                    {
                      trackCache.active(true);
                      trackCache.type = (ushort) index1;
                      trackCache.frameX = index1 != 201 ? (short) 144 : (short) 270;
                      break;
                    }
                    if (WorldGen.genRand.Next(35) == 0 || Main.tile[i, j].wall >= (ushort) 63 && Main.tile[i, j].wall <= (ushort) 70)
                    {
                      trackCache.active(true);
                      trackCache.type = (ushort) index1;
                      int num = WorldGen.genRand.NextFromList<int>(6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20);
                      if (index1 == 201)
                        num = WorldGen.genRand.NextFromList<int>(6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19, 20, 21, 22);
                      if (index1 == 637)
                        num = WorldGen.genRand.NextFromList<int>(6, 7, 8, 9, 10);
                      trackCache.frameX = (short) (num * 18);
                      break;
                    }
                    trackCache.active(true);
                    trackCache.type = (ushort) index1;
                    trackCache.frameX = (short) (WorldGen.genRand.Next(6) * 18);
                    break;
                  }
                  break;
                }
                break;
              }
              switch (index1)
              {
                case 61:
                  if (j + 1 < Main.maxTilesY && Main.tile[i, j + 1].active() && Main.tile[i, j + 1].slope() == (byte) 0 && !Main.tile[i, j + 1].halfBrick() && Main.tile[i, j + 1].type == (ushort) 60)
                  {
                    bool flag2 = (double) j > Main.rockLayer || Main.remixWorld || WorldGen.remixWorldGen;
                    if (WorldGen.genRand.Next(16) == 0 && (double) j > Main.worldSurface)
                    {
                      trackCache.active(true);
                      trackCache.type = (ushort) 69;
                      WorldGen.SquareTileFrame(i, j);
                      break;
                    }
                    if (WorldGen.genRand.Next(60) == 0 & flag2)
                    {
                      trackCache.active(true);
                      trackCache.type = (ushort) index1;
                      trackCache.frameX = (short) 144;
                      break;
                    }
                    if (WorldGen.genRand.Next(230) == 0 & flag2)
                    {
                      trackCache.active(true);
                      trackCache.type = (ushort) index1;
                      trackCache.frameX = (short) 162;
                      break;
                    }
                    if (WorldGen.genRand.Next(15) == 0)
                    {
                      trackCache.active(true);
                      trackCache.type = (ushort) index1;
                      trackCache.frameX = WorldGen.genRand.Next(3) == 0 ? (short) (WorldGen.genRand.Next(13) * 18 + 180) : (short) (WorldGen.genRand.Next(2) * 18 + 108);
                      break;
                    }
                    trackCache.active(true);
                    trackCache.type = (ushort) index1;
                    trackCache.frameX = (short) (WorldGen.genRand.Next(6) * 18);
                    break;
                  }
                  break;
                case 71:
                  if (j + 1 < Main.maxTilesY && Main.tile[i, j + 1].active() && Main.tile[i, j + 1].slope() == (byte) 0 && !Main.tile[i, j + 1].halfBrick() && Main.tile[i, j + 1].type == (ushort) 70)
                  {
                    Point point = new Point(-1, -1);
                    if ((double) j > Main.worldSurface)
                      point = WorldGen.PlaceCatTail(i, j);
                    if (WorldGen.InWorld(point.X, point.Y))
                    {
                      if (WorldGen.gen)
                      {
                        int num = WorldGen.genRand.Next(14);
                        for (int index2 = 0; index2 < num; ++index2)
                          WorldGen.GrowCatTail(point.X, point.Y);
                        WorldGen.SquareTileFrame(point.X, point.Y);
                        break;
                      }
                      break;
                    }
                    trackCache.active(true);
                    trackCache.type = (ushort) index1;
                    trackCache.frameX = (short) (WorldGen.genRand.Next(5) * 18);
                    break;
                  }
                  break;
                case 129:
                  if (WorldGen.SolidTile(i - 1, j) || WorldGen.SolidTile(i + 1, j) || WorldGen.SolidTile(i, j - 1) || WorldGen.SolidTile(i, j + 1))
                  {
                    trackCache.active(true);
                    trackCache.type = (ushort) index1;
                    trackCache.frameX = (short) (style * 18);
                    WorldGen.SquareTileFrame(i, j);
                    break;
                  }
                  break;
                case 171:
                  WorldGen.PlaceXmasTree(i, j);
                  break;
                case 178:
                  if (WorldGen.SolidTile(i - 1, j, true) || WorldGen.SolidTile(i + 1, j, true) || WorldGen.SolidTile(i, j - 1) || WorldGen.SolidTile(i, j + 1))
                  {
                    trackCache.active(true);
                    trackCache.type = (ushort) index1;
                    trackCache.frameX = (short) (style * 18);
                    trackCache.frameY = (short) (WorldGen.genRand.Next(3) * 18);
                    WorldGen.SquareTileFrame(i, j);
                    break;
                  }
                  break;
                case 184:
                  if (Main.tileMoss[(int) Main.tile[i - 1, j].type] && WorldGen.SolidTile(i - 1, j) || Main.tileMoss[(int) Main.tile[i + 1, j].type] && WorldGen.SolidTile(i + 1, j) || Main.tileMoss[(int) Main.tile[i, j - 1].type] && WorldGen.SolidTile(i, j - 1) || Main.tileMoss[(int) Main.tile[i, j + 1].type] && WorldGen.SolidTile(i, j + 1))
                  {
                    trackCache.active(true);
                    trackCache.type = (ushort) index1;
                    trackCache.frameX = (short) (style * 18);
                    trackCache.frameY = (short) (WorldGen.genRand.Next(3) * 18);
                    WorldGen.SquareTileFrame(i, j);
                  }
                  if (TileID.Sets.tileMossBrick[(int) Main.tile[i - 1, j].type] && WorldGen.SolidTile(i - 1, j) || TileID.Sets.tileMossBrick[(int) Main.tile[i + 1, j].type] && WorldGen.SolidTile(i + 1, j) || TileID.Sets.tileMossBrick[(int) Main.tile[i, j - 1].type] && WorldGen.SolidTile(i, j - 1) || TileID.Sets.tileMossBrick[(int) Main.tile[i, j + 1].type] && WorldGen.SolidTile(i, j + 1))
                  {
                    trackCache.active(true);
                    trackCache.type = (ushort) index1;
                    trackCache.frameX = (short) (style * 18);
                    trackCache.frameY = (short) (WorldGen.genRand.Next(3) * 18);
                    WorldGen.SquareTileFrame(i, j);
                    break;
                  }
                  break;
                case 254:
                  WorldGen.Place2x2Style(i, j, (ushort) index1, style);
                  break;
                case 485:
                  WorldGen.PlaceObject(i, j, index1, mute, style);
                  break;
                case 518:
                  WorldGen.PlaceLilyPad(i, j);
                  break;
                case 519:
                  WorldGen.PlaceCatTail(i, j);
                  break;
                case 529:
                  WorldGen.PlantSeaOat(i, j);
                  break;
                case 549:
                  WorldGen.PlaceUnderwaterPlant((ushort) 549, i, j);
                  break;
                case 571:
                  WorldGen.PlaceBamboo(i, j);
                  break;
                default:
                  if (index1 == 335 || index1 == 564 || index1 == 594)
                  {
                    WorldGen.Place2x2(i, j, (ushort) index1, 0);
                    break;
                  }
                  if (index1 == 654 || index1 == 319 || index1 == 132 || index1 == 484 || index1 == 138 || index1 == 664 || index1 == 142 || index1 == 143 || index1 == 282 || index1 >= 288 && index1 <= 295 || index1 >= 316 && index1 <= 318)
                  {
                    WorldGen.Place2x2(i, j, (ushort) index1, 0);
                    break;
                  }
                  switch (index1)
                  {
                    case 4:
                      if (Main.tile[i - 1, j] == null)
                        Main.tile[i - 1, j] = new Tile();
                      if (Main.tile[i + 1, j] == null)
                        Main.tile[i + 1, j] = new Tile();
                      if (Main.tile[i, j + 1] == null)
                        Main.tile[i, j + 1] = new Tile();
                      Tile tile1 = Main.tile[i - 1, j];
                      Tile tile2 = Main.tile[i + 1, j];
                      Tile tile3 = Main.tile[i, j + 1];
                      if (trackCache.wall > (ushort) 0 || tile1.active() && (tile1.slope() == (byte) 0 || (int) tile1.slope() % 2 != 1) && (Main.tileSolid[(int) tile1.type] && !Main.tileSolidTop[(int) tile1.type] && !TileID.Sets.NotReallySolid[(int) tile1.type] || TileID.Sets.IsBeam[(int) tile1.type] || WorldGen.IsTreeType((int) tile1.type) && WorldGen.IsTreeType((int) Main.tile[i - 1, j - 1].type) && WorldGen.IsTreeType((int) Main.tile[i - 1, j + 1].type)) || tile2.active() && (tile2.slope() == (byte) 0 || (int) tile2.slope() % 2 != 0) && (Main.tileSolid[(int) tile2.type] && !Main.tileSolidTop[(int) tile2.type] && !TileID.Sets.NotReallySolid[(int) tile2.type] || TileID.Sets.IsBeam[(int) tile2.type] || WorldGen.IsTreeType((int) tile2.type) && WorldGen.IsTreeType((int) Main.tile[i + 1, j - 1].type) && WorldGen.IsTreeType((int) Main.tile[i + 1, j + 1].type)) || tile3.active() && Main.tileSolid[(int) tile3.type] && (TileID.Sets.Platforms[(int) tile3.type] && WorldGen.TopEdgeCanBeAttachedTo(i, j + 1) || (!Main.tileSolidTop[(int) tile3.type] || tile3.type == (ushort) 380 && tile3.slope() == (byte) 0) && !TileID.Sets.NotReallySolid[(int) tile3.type] && !tile3.halfBrick() && tile3.slope() == (byte) 0))
                      {
                        trackCache.active(true);
                        trackCache.type = (ushort) index1;
                        trackCache.frameY = (short) (22 * style);
                        WorldGen.SquareTileFrame(i, j);
                        break;
                      }
                      break;
                    case 10:
                      if (Main.tile[i, j - 1] == null)
                        Main.tile[i, j - 1] = new Tile();
                      if (Main.tile[i, j - 2] == null)
                        Main.tile[i, j - 2] = new Tile();
                      if (Main.tile[i, j - 3] == null)
                        Main.tile[i, j - 3] = new Tile();
                      if (Main.tile[i, j + 1] == null)
                        Main.tile[i, j + 1] = new Tile();
                      if (Main.tile[i, j + 2] == null)
                        Main.tile[i, j + 2] = new Tile();
                      if (Main.tile[i, j + 3] == null)
                        Main.tile[i, j + 3] = new Tile();
                      if (!Main.tile[i, j - 1].active() && !Main.tile[i, j - 2].active() && Main.tile[i, j - 3].active() && Main.tileSolid[(int) Main.tile[i, j - 3].type])
                      {
                        WorldGen.PlaceDoor(i, j - 1, index1, style);
                        WorldGen.SquareTileFrame(i, j);
                        break;
                      }
                      if (Main.tile[i, j + 1].active() || Main.tile[i, j + 2].active() || !Main.tile[i, j + 3].active() || !Main.tileSolid[(int) Main.tile[i, j + 3].type])
                        return false;
                      WorldGen.PlaceDoor(i, j + 1, index1, style);
                      WorldGen.SquareTileFrame(i, j);
                      break;
                    case 136:
                      if (Main.tile[i - 1, j] == null)
                        Main.tile[i - 1, j] = new Tile();
                      if (Main.tile[i + 1, j] == null)
                        Main.tile[i + 1, j] = new Tile();
                      if (Main.tile[i, j + 1] == null)
                        Main.tile[i, j + 1] = new Tile();
                      if (Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && !TileID.Sets.NotReallySolid[(int) Main.tile[i - 1, j].type] && Main.tile[i - 1, j].slope() == (byte) 0 && (WorldGen.SolidTile(i - 1, j) || TileID.Sets.IsBeam[(int) Main.tile[i - 1, j].type] || Main.tile[i - 1, j].type == (ushort) 5 && Main.tile[i - 1, j - 1].type == (ushort) 5 && Main.tile[i - 1, j + 1].type == (ushort) 5) || Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && !TileID.Sets.NotReallySolid[(int) Main.tile[i + 1, j].type] && Main.tile[i + 1, j].slope() == (byte) 0 && (WorldGen.SolidTile(i + 1, j) || TileID.Sets.IsBeam[(int) Main.tile[i + 1, j].type] || Main.tile[i + 1, j].type == (ushort) 5 && Main.tile[i + 1, j - 1].type == (ushort) 5 && Main.tile[i + 1, j + 1].type == (ushort) 5) || Main.tile[i, j + 1].nactive() && !Main.tile[i, j + 1].halfBrick() && WorldGen.SolidTile(i, j + 1) && Main.tile[i, j + 1].slope() == (byte) 0 || trackCache.wall > (ushort) 0)
                      {
                        trackCache.active(true);
                        trackCache.type = (ushort) index1;
                        WorldGen.SquareTileFrame(i, j);
                        break;
                      }
                      break;
                    case 137:
                      trackCache.active(true);
                      trackCache.type = (ushort) index1;
                      trackCache.frameY = (short) (18 * style);
                      break;
                    case 411:
                      WorldGen.Place2x2(i, j, (ushort) index1, 0);
                      break;
                    case 442:
                      if (Main.tile[i - 1, j] == null)
                        Main.tile[i - 1, j] = new Tile();
                      if (Main.tile[i + 1, j] == null)
                        Main.tile[i + 1, j] = new Tile();
                      if (Main.tile[i, j + 1] == null)
                        Main.tile[i, j + 1] = new Tile();
                      if (Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && !TileID.Sets.NotReallySolid[(int) Main.tile[i - 1, j].type] && Main.tile[i - 1, j].slope() == (byte) 0 && (WorldGen.SolidTile(i - 1, j) || TileID.Sets.IsBeam[(int) Main.tile[i - 1, j].type] || Main.tile[i - 1, j].type == (ushort) 5 && Main.tile[i - 1, j - 1].type == (ushort) 5 && Main.tile[i - 1, j + 1].type == (ushort) 5) || Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && !TileID.Sets.NotReallySolid[(int) Main.tile[i + 1, j].type] && Main.tile[i + 1, j].slope() == (byte) 0 && (WorldGen.SolidTile(i + 1, j) || TileID.Sets.IsBeam[(int) Main.tile[i + 1, j].type] || Main.tile[i + 1, j].type == (ushort) 5 && Main.tile[i + 1, j - 1].type == (ushort) 5 && Main.tile[i + 1, j + 1].type == (ushort) 5) || Main.tile[i, j + 1].nactive() && !Main.tile[i, j + 1].halfBrick() && WorldGen.SolidTile(i, j + 1) && Main.tile[i, j + 1].slope() == (byte) 0)
                      {
                        trackCache.active(true);
                        trackCache.type = (ushort) index1;
                        WorldGen.SquareTileFrame(i, j);
                        break;
                      }
                      break;
                    case 457:
                      WorldGen.Place2x2Horizontal(i, j, (ushort) 457, style);
                      break;
                    default:
                      if (index1 >= 275 && index1 <= 281 || index1 == 296 || index1 == 297 || index1 == 309 || index1 == 358 || index1 == 359 || index1 == 413 || index1 == 414 || index1 == 542)
                      {
                        WorldGen.Place6x3(i, j, (ushort) index1);
                        break;
                      }
                      if (index1 == 237 || index1 == 244 || index1 == 285 || index1 == 286 || index1 == 298 || index1 == 299 || index1 == 310 || index1 == 339 || index1 == 538 || index1 >= 361 && index1 <= 364 || index1 == 532 || index1 == 533 || index1 == 486 || index1 == 488 || index1 == 544 || index1 == 582 || index1 == 619 || index1 == 629)
                      {
                        WorldGen.Place3x2(i, j, (ushort) index1);
                        break;
                      }
                      switch (index1)
                      {
                        case 128:
                          WorldGen.PlaceMan(i, j, style);
                          WorldGen.SquareTileFrame(i, j);
                          break;
                        case 149:
                          if (WorldGen.SolidTile(i - 1, j) || WorldGen.SolidTile(i + 1, j) || WorldGen.SolidTile(i, j - 1) || WorldGen.SolidTile(i, j + 1))
                          {
                            trackCache.frameX = (short) (18 * style);
                            trackCache.active(true);
                            trackCache.type = (ushort) index1;
                            WorldGen.SquareTileFrame(i, j);
                            break;
                          }
                          break;
                        case 269:
                          WorldGen.PlaceWoman(i, j, style);
                          WorldGen.SquareTileFrame(i, j);
                          break;
                        case 334:
                          int style1 = 0;
                          if (style == -1)
                            style1 = 1;
                          WorldGen.Place3x3Wall(i, j, (ushort) 334, style1);
                          WorldGen.SquareTileFrame(i, j);
                          break;
                        default:
                          if (index1 == 139 || index1 == 35)
                          {
                            WorldGen.PlaceMB(i, j, (ushort) index1, style);
                            WorldGen.SquareTileFrame(i, j);
                            break;
                          }
                          switch (index1)
                          {
                            case 34:
                              WorldGen.PlaceChand(i, j, (ushort) index1, style);
                              WorldGen.SquareTileFrame(i, j);
                              break;
                            case 165:
                              WorldGen.PlaceTight(i, j);
                              WorldGen.SquareTileFrame(i, j);
                              break;
                            case 235:
                              WorldGen.Place3x1(i, j, (ushort) index1);
                              WorldGen.SquareTileFrame(i, j);
                              break;
                            case 240:
                              WorldGen.Place3x3Wall(i, j, (ushort) index1, style);
                              break;
                            case 241:
                              WorldGen.Place4x3Wall(i, j, (ushort) index1, style);
                              break;
                            case 242:
                              WorldGen.Place6x4Wall(i, j, (ushort) index1, style);
                              break;
                            case 245:
                              WorldGen.Place2x3Wall(i, j, (ushort) index1, style);
                              break;
                            case 246:
                              WorldGen.Place3x2Wall(i, j, (ushort) index1, style);
                              break;
                            case 440:
                              WorldGen.Place3x3Wall(i, j, (ushort) index1, style);
                              break;
                            default:
                              if (index1 == 106 || index1 == 212 || index1 == 219 || index1 == 220 || index1 == 228 || index1 == 231 || index1 == 243 || index1 == 247 || index1 == 283 || index1 >= 300 && index1 <= 308 || index1 == 354 || index1 == 355 || index1 == 491 || index1 == 642)
                              {
                                WorldGen.Place3x3(i, j, (ushort) index1, style);
                                WorldGen.SquareTileFrame(i, j);
                                break;
                              }
                              if (index1 == 13 || index1 == 33 || index1 == 49 || index1 == 50 || index1 == 78 || index1 == 174 || index1 == 372 || index1 == 646)
                              {
                                WorldGen.PlaceOnTable1x1(i, j, index1, style);
                                WorldGen.SquareTileFrame(i, j);
                                break;
                              }
                              if (index1 == 14 || index1 == 469 || index1 == 26 || index1 == 86 || index1 == 87 || index1 == 88 || index1 == 89 || index1 == 114 || index1 == 186 || index1 == 187 || index1 == 215 || index1 == 217 || index1 == 218 || index1 == 377)
                              {
                                WorldGen.Place3x2(i, j, (ushort) index1, style);
                                WorldGen.SquareTileFrame(i, j);
                                break;
                              }
                              switch (index1)
                              {
                                case 20:
                                  if (Main.tile[i, j + 1] == null)
                                    Main.tile[i, j + 1] = new Tile();
                                  int type = (int) Main.tile[i, j + 1].type;
                                  if (Main.tile[i, j + 1].active() && (type == 2 || type == 109 || type == 147 || type == 60 || type == 23 || type == 199 || type == 661 || type == 662 || type == 53 || type == 234 || type == 116 || type == 112))
                                  {
                                    WorldGen.Place1x2(i, j, (ushort) index1, style);
                                    WorldGen.SquareTileFrame(i, j);
                                    break;
                                  }
                                  break;
                                case 236:
                                  WorldGen.PlaceJunglePlant(i, j, (ushort) index1, WorldGen.genRand.Next(3), 0);
                                  WorldGen.SquareTileFrame(i, j);
                                  break;
                                case 238:
                                  WorldGen.PlaceJunglePlant(i, j, (ushort) index1, 0, 0);
                                  WorldGen.SquareTileFrame(i, j);
                                  break;
                                default:
                                  if (index1 == 15 || index1 == 216 || index1 == 338 || index1 == 390)
                                  {
                                    if (Main.tile[i, j - 1] == null)
                                      Main.tile[i, j - 1] = new Tile();
                                    if (Main.tile[i, j] == null)
                                      Main.tile[i, j] = new Tile();
                                    WorldGen.Place1x2(i, j, (ushort) index1, style);
                                    WorldGen.SquareTileFrame(i, j);
                                    break;
                                  }
                                  switch (index1)
                                  {
                                    case 227:
                                      WorldGen.PlaceDye(i, j, style);
                                      WorldGen.SquareTileFrame(i, j);
                                      break;
                                    case 567:
                                      WorldGen.PlaceGnome(i, j, style);
                                      WorldGen.SquareTileFrame(i, j);
                                      break;
                                    default:
                                      if (index1 == 16 || index1 == 18 || index1 == 29 || index1 == 103 || index1 == 134 || index1 == 462)
                                      {
                                        WorldGen.Place2x1(i, j, (ushort) index1, style);
                                        WorldGen.SquareTileFrame(i, j);
                                        break;
                                      }
                                      if (index1 == 92 || index1 == 93 || index1 == 453)
                                      {
                                        WorldGen.Place1xX(i, j, (ushort) index1, style);
                                        WorldGen.SquareTileFrame(i, j);
                                        break;
                                      }
                                      if (index1 == 104 || index1 == 105 || index1 == 320 || index1 == 337 || index1 == 349 || index1 == 356 || index1 == 663 || index1 == 378 || index1 == 456 || index1 == 506 || index1 == 545)
                                      {
                                        WorldGen.Place2xX(i, j, (ushort) index1, style);
                                        WorldGen.SquareTileFrame(i, j);
                                        break;
                                      }
                                      if (index1 == 17 || index1 == 77 || index1 == 133)
                                      {
                                        WorldGen.Place3x2(i, j, (ushort) index1, style);
                                        WorldGen.SquareTileFrame(i, j);
                                        break;
                                      }
                                      if (index1 == 207)
                                      {
                                        WorldGen.Place2xX(i, j, (ushort) index1, style);
                                        WorldGen.SquareTileFrame(i, j);
                                        break;
                                      }
                                      if (index1 == 410 || index1 == 480 || index1 == 509 || index1 == 657 || index1 == 658)
                                      {
                                        WorldGen.Place2xX(i, j, (ushort) index1, style);
                                        WorldGen.SquareTileFrame(i, j);
                                        break;
                                      }
                                      if (index1 == 465 || index1 == 531 || index1 == 591 || index1 == 592)
                                      {
                                        WorldGen.Place2xX(i, j, (ushort) index1, style);
                                        WorldGen.SquareTileFrame(i, j);
                                        break;
                                      }
                                      if (TileID.Sets.BasicChest[index1])
                                      {
                                        WorldGen.PlaceChest(i, j, (ushort) index1, style: style);
                                        WorldGen.SquareTileFrame(i, j);
                                        break;
                                      }
                                      switch (index1)
                                      {
                                        case 27:
                                          WorldGen.PlaceSunflower(i, j);
                                          WorldGen.SquareTileFrame(i, j);
                                          break;
                                        case 28:
                                          WorldGen.PlacePot(i, j, style: WorldGen.genRand.Next(4));
                                          WorldGen.SquareTileFrame(i, j);
                                          break;
                                        case 36:
                                        case 135:
                                        case 141:
                                        case 144:
                                        case 210:
                                        case 239:
                                        case 324:
                                        case 476:
                                        case 494:
                                          WorldGen.Place1x1(i, j, index1, style);
                                          WorldGen.SquareTileFrame(i, j);
                                          break;
                                        case 42:
                                        case 270:
                                        case 271:
                                          WorldGen.Place1x2Top(i, j, (ushort) index1, style);
                                          WorldGen.SquareTileFrame(i, j);
                                          break;
                                        case 55:
                                        case 425:
                                        case 510:
                                        case 511:
                                          WorldGen.PlaceSign(i, j, (ushort) index1, style);
                                          break;
                                        case 85:
                                        case 376:
                                          WorldGen.Place2x2Horizontal(i, j, (ushort) index1, style);
                                          break;
                                        case 91:
                                          WorldGen.PlaceBanner(i, j, (ushort) index1, style);
                                          WorldGen.SquareTileFrame(i, j);
                                          break;
                                        case 101:
                                        case 102:
                                        case 463:
                                          WorldGen.Place3x4(i, j, (ushort) index1, style);
                                          WorldGen.SquareTileFrame(i, j);
                                          break;
                                        case 419:
                                        case 420:
                                        case 423:
                                        case 424:
                                        case 429:
                                        case 445:
                                          WorldGen.PlaceLogicTiles(i, j, index1, style);
                                          WorldGen.SquareTileFrame(i, j);
                                          break;
                                        case 464:
                                        case 466:
                                          WorldGen.Place5x4(i, j, (ushort) index1, style);
                                          WorldGen.SquareTileFrame(i, j);
                                          break;
                                        default:
                                          if (Main.tileAlch[index1])
                                          {
                                            WorldGen.PlaceAlch(i, j, style);
                                            break;
                                          }
                                          switch (index1)
                                          {
                                            case 19:
                                              trackCache.frameY = (short) (18 * style);
                                              trackCache.active(true);
                                              trackCache.type = (ushort) index1;
                                              break;
                                            case 79:
                                            case 90:
                                              int direction = 1;
                                              if (plr > -1)
                                                direction = Main.player[plr].direction;
                                              WorldGen.Place4x2(i, j, (ushort) index1, direction, style);
                                              break;
                                            case 81:
                                              trackCache.frameX = (short) (26 * WorldGen.genRand.Next(6));
                                              trackCache.active(true);
                                              trackCache.type = (ushort) index1;
                                              break;
                                            case 94:
                                            case 95:
                                            case 97:
                                            case 98:
                                            case 99:
                                            case 100:
                                            case 125:
                                            case 126:
                                            case 172:
                                            case 173:
                                            case 287:
                                              WorldGen.Place2x2(i, j, (ushort) index1, style);
                                              break;
                                            case 96:
                                              WorldGen.Place2x2Style(i, j, (ushort) index1, style);
                                              break;
                                            case 209:
                                              WorldGen.PlaceCannon(i, j, (ushort) index1, style);
                                              break;
                                            case 314:
                                              Minecart.PlaceTrack(trackCache, style);
                                              break;
                                            case 380:
                                              trackCache.frameY = (short) (18 * style);
                                              trackCache.active(true);
                                              trackCache.type = (ushort) index1;
                                              break;
                                            default:
                                              trackCache.active(true);
                                              trackCache.type = (ushort) index1;
                                              if (Main.tenthAnniversaryWorld && !Main.remixWorld && (index1 == 53 || index1 == 396 || index1 == 397))
                                              {
                                                trackCache.color((byte) 7);
                                                break;
                                              }
                                              break;
                                          }
                                          break;
                                      }
                                      break;
                                  }
                                  break;
                              }
                              break;
                          }
                          break;
                      }
                      break;
                  }
                  break;
              }
              break;
          }
          if (trackCache.active())
          {
            if (TileID.Sets.BlocksWaterDrawingBehindSelf[(int) trackCache.type])
              WorldGen.SquareWallFrame(i, j);
            WorldGen.SquareTileFrame(i, j);
            flag1 = true;
            if (!mute)
            {
              switch (index1)
              {
                case (int) sbyte.MaxValue:
                  SoundEngine.PlaySound(SoundID.Item30, i * 16, j * 16);
                  break;
                case 314:
                  SoundEngine.PlaySound(SoundID.Item52, i * 16, j * 16);
                  break;
                case 330:
                case 331:
                case 332:
                case 333:
                  SoundEngine.PlaySound(18, i * 16, j * 16);
                  break;
                default:
                  SoundEngine.PlaySound(0, i * 16, j * 16);
                  break;
              }
              if (index1 == 22 || index1 == 140)
              {
                for (int index3 = 0; index3 < 3; ++index3)
                  Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 14);
              }
            }
          }
        }
      }
      return flag1;
    }

    public static void KillWall(int i, int j, bool fail = false)
    {
      if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
        return;
      Tile tileCache = Main.tile[i, j];
      if (tileCache == null)
      {
        tileCache = new Tile();
        Main.tile[i, j] = tileCache;
      }
      if (tileCache.wall <= (ushort) 0)
        return;
      fail = WorldGen.KillWall_CheckFailure(fail, tileCache);
      WorldGen.KillWall_PlaySounds(i, j, tileCache);
      int num = 10;
      if (fail)
        num = 3;
      for (int index = 0; index < num; ++index)
        WorldGen.KillWall_MakeWallDust(i, j, tileCache);
      if (fail)
      {
        WorldGen.SquareWallFrame(i, j);
      }
      else
      {
        WorldGen.KillWall_DropItems(i, j, tileCache);
        tileCache.wall = (ushort) 0;
        tileCache.ClearWallPaintAndCoating();
        WorldGen.SquareWallFrame(i, j);
        if (tileCache.type < (ushort) 0 || (int) tileCache.type >= (int) TileID.Count || !TileID.Sets.FramesOnKillWall[(int) tileCache.type])
          return;
        WorldGen.TileFrame(i, j);
      }
    }

    private static bool KillWall_CheckFailure(bool fail, Tile tileCache)
    {
      if (Main.wallDungeon[(int) tileCache.wall] && !NPC.downedBoss3)
        fail = true;
      if (tileCache.wall == (ushort) 87 && !NPC.downedGolemBoss)
        fail = true;
      return fail;
    }

    private static void KillWall_PlaySounds(int i, int j, Tile tileCache)
    {
      if (tileCache.wall == (ushort) 241 || tileCache.wall >= (ushort) 88 && tileCache.wall <= (ushort) 93 || tileCache.wall == (ushort) 21 || tileCache.wall == (ushort) 186 || tileCache.wall == (ushort) 136 || tileCache.wall == (ushort) 137 || tileCache.wall == (ushort) 168 || tileCache.wall == (ushort) 169 || tileCache.wall == (ushort) 172 || tileCache.wall == (ushort) 226 || tileCache.wall == (ushort) 227 || tileCache.wall == (ushort) 242 || tileCache.wall == (ushort) 243)
        SoundEngine.PlaySound(13, i * 16, j * 16);
      else if (tileCache.wall >= (ushort) 63 && tileCache.wall <= (ushort) 70 || tileCache.wall == (ushort) 264 || tileCache.wall == (ushort) 268 || tileCache.wall == (ushort) 265)
        SoundEngine.PlaySound(6, i * 16, j * 16);
      else
        SoundEngine.PlaySound(0, i * 16, j * 16);
    }

    private static void KillWall_DropItems(int i, int j, Tile tileCache)
    {
      int itemDrops = WorldGen.KillWall_GetItemDrops(tileCache);
      if (itemDrops <= 0)
        return;
      Item.NewItem(WorldGen.GetItemSource_FromWallBreak(i, j), i * 16, j * 16, 16, 16, itemDrops);
    }

    private static int KillWall_GetItemDrops(Tile tileCache)
    {
      switch (tileCache.wall)
      {
        case 237:
          return 4233;
        case 238:
          return 4234;
        case 239:
          return 4235;
        case 240:
          return 4236;
        case 246:
          return 4486;
        case 247:
          return 4487;
        case 248:
          return 4488;
        case 249:
          return 4489;
        case 250:
          return 4490;
        case 251:
          return 4491;
        case 252:
          return 4492;
        case 253:
          return 4493;
        case 254:
          return 4494;
        case (ushort) byte.MaxValue:
          return 4495;
        case 256:
          return 4496;
        case 257:
          return 4497;
        case 258:
          return 4498;
        case 259:
          return 4499;
        case 260:
          return 4500;
        case 261:
          return 4501;
        case 262:
          return 4502;
        case 263:
          return 4503;
        case 264:
          return 4504;
        case 265:
          return 4505;
        case 266:
          return 4506;
        case 267:
          return 4507;
        case 268:
          return 4508;
        case 269:
          return 4509;
        case 270:
          return 4510;
        case 271:
          return 4511;
        case 274:
          return 4512;
        case 275:
          return 3273;
        case 276:
          return 4513;
        case 277:
          return 4514;
        case 278:
          return 4515;
        case 279:
          return 4516;
        case 280:
          return 4517;
        case 281:
          return 4518;
        case 282:
          return 4519;
        case 283:
          return 4520;
        case 284:
          return 4521;
        case 285:
          return 4522;
        case 286:
          return 4523;
        case 287:
          return 4524;
        case 288:
          return 4525;
        case 289:
          return 4526;
        case 290:
          return 4527;
        case 291:
          return 4528;
        case 292:
          return 4529;
        case 293:
          return 4530;
        case 294:
          return 4531;
        case 295:
          return 4532;
        case 296:
          return 4533;
        case 297:
          return 4534;
        case 298:
          return 4535;
        case 299:
          return 4536;
        case 300:
          return 4537;
        case 301:
          return 4538;
        case 302:
          return 4539;
        case 303:
          return 4540;
        case 304:
          return 3340;
        case 305:
          return 3341;
        case 306:
          return 3342;
        case 307:
          return 3343;
        case 308:
          return 3344;
        case 309:
          return 3345;
        case 310:
          return 3346;
        case 311:
          return 3348;
        case 314:
          return 4647;
        default:
          int itemDrops = 0;
          if (tileCache.wall == (ushort) 168)
            itemDrops = 2696;
          if (tileCache.wall == (ushort) 169)
            itemDrops = 2698;
          if (tileCache.wall == (ushort) 226)
            itemDrops = 3752;
          if (tileCache.wall == (ushort) 227)
            itemDrops = 3753;
          if (tileCache.wall == (ushort) 228)
            itemDrops = 3760;
          if (tileCache.wall == (ushort) 229)
            itemDrops = 3761;
          if (tileCache.wall == (ushort) 230)
            itemDrops = 3762;
          if (tileCache.wall == (ushort) 142)
            itemDrops = 2263;
          if (tileCache.wall == (ushort) 143)
            itemDrops = 2264;
          if (tileCache.wall == (ushort) 144)
            itemDrops = 2271;
          if (tileCache.wall == (ushort) 149)
            itemDrops = 2505;
          if (tileCache.wall == (ushort) 150)
            itemDrops = 2507;
          if (tileCache.wall == (ushort) 151)
            itemDrops = 2506;
          if (tileCache.wall == (ushort) 152)
            itemDrops = 2508;
          if (tileCache.wall == (ushort) 316)
            itemDrops = 5216;
          if (tileCache.wall == (ushort) 317)
            itemDrops = 5217;
          if (tileCache.wall == (ushort) 245)
            itemDrops = 4424;
          if (tileCache.wall == (ushort) 315)
            itemDrops = 4667;
          if (tileCache.wall == (ushort) 1)
            itemDrops = 26;
          if (tileCache.wall == (ushort) 4)
            itemDrops = 93;
          if (tileCache.wall == (ushort) 5)
            itemDrops = 130;
          if (tileCache.wall == (ushort) 6)
            itemDrops = 132;
          if (tileCache.wall == (ushort) 7)
            itemDrops = 135;
          if (tileCache.wall == (ushort) 8)
            itemDrops = 138;
          if (tileCache.wall == (ushort) 9)
            itemDrops = 140;
          if (tileCache.wall == (ushort) 10)
            itemDrops = 142;
          if (tileCache.wall == (ushort) 11)
            itemDrops = 144;
          if (tileCache.wall == (ushort) 12)
            itemDrops = 146;
          if (tileCache.wall == (ushort) 14)
            itemDrops = 330;
          if (tileCache.wall == (ushort) 224)
            itemDrops = 3472;
          if (tileCache.wall == (ushort) 323)
            itemDrops = 5409;
          if (tileCache.wall == (ushort) 324)
            itemDrops = 5410;
          if (tileCache.wall == (ushort) 325)
            itemDrops = 5411;
          if (tileCache.wall == (ushort) 326)
            itemDrops = 5412;
          if (tileCache.wall == (ushort) 327)
            itemDrops = 5413;
          if (tileCache.wall == (ushort) 328)
            itemDrops = 5414;
          if (tileCache.wall == (ushort) 329)
            itemDrops = 5415;
          if (tileCache.wall == (ushort) 330)
            itemDrops = 5416;
          if (tileCache.wall == (ushort) 331)
            itemDrops = 5418;
          if (tileCache.wall == (ushort) 332)
            itemDrops = 5420;
          if (tileCache.wall == (ushort) 333)
            itemDrops = 5422;
          if (tileCache.wall == (ushort) 334)
            itemDrops = 5424;
          if (tileCache.wall == (ushort) 335)
            itemDrops = 5426;
          if (tileCache.wall == (ushort) 336)
            itemDrops = 5428;
          if (tileCache.wall == (ushort) 337)
            itemDrops = 5434;
          if (tileCache.wall == (ushort) 338)
            itemDrops = 5436;
          if (tileCache.wall == (ushort) 339)
            itemDrops = 5430;
          if (tileCache.wall == (ushort) 340)
            itemDrops = 5432;
          if (tileCache.wall == (ushort) 341)
            itemDrops = 5445;
          if (tileCache.wall == (ushort) 342)
            itemDrops = 5446;
          if (tileCache.wall == (ushort) 343)
            itemDrops = 5447;
          if (tileCache.wall == (ushort) 344)
            itemDrops = 5448;
          if (tileCache.wall == (ushort) 345)
            itemDrops = 5449;
          if (tileCache.wall == (ushort) 346)
            itemDrops = 5450;
          if (tileCache.wall == (ushort) 177)
            itemDrops = 3067;
          if (tileCache.wall == (ushort) 167)
            itemDrops = 2691;
          if (tileCache.wall == (ushort) 60)
            itemDrops = 3584;
          if (tileCache.wall == (ushort) 231)
            itemDrops = 3952;
          if (tileCache.wall == (ushort) 232)
            itemDrops = 3954;
          if (tileCache.wall == (ushort) 225)
            itemDrops = 3751;
          if (tileCache.wall == (ushort) 233)
            itemDrops = 3956;
          if (tileCache.wall == (ushort) 234)
            itemDrops = 4052;
          if (tileCache.wall == (ushort) 235)
            itemDrops = 4053;
          if (tileCache.wall == (ushort) 236)
            itemDrops = 4140;
          if (tileCache.wall == (ushort) 312)
            itemDrops = 4565;
          if (tileCache.wall == (ushort) 313)
            itemDrops = 4548;
          if (tileCache.wall == (ushort) 319)
            itemDrops = 5307;
          if (tileCache.wall == (ushort) 318)
            itemDrops = 5291;
          if (tileCache.wall == (ushort) 179)
            itemDrops = 3083;
          if (tileCache.wall == (ushort) 183)
            itemDrops = 3082;
          if (tileCache.wall == (ushort) 321)
            itemDrops = 5397;
          if (tileCache.wall == (ushort) 322)
            itemDrops = 5399;
          if (tileCache.wall == (ushort) 181)
            itemDrops = 3089;
          if (tileCache.wall == (ushort) 184)
            itemDrops = 3088;
          if (tileCache.wall == (ushort) 186)
            itemDrops = 3238;
          if (tileCache.wall == (ushort) 320)
            itemDrops = 5396;
          if (tileCache.wall >= (ushort) 153 && tileCache.wall <= (ushort) 166)
          {
            switch (tileCache.wall)
            {
              case 153:
                itemDrops = 2677;
                break;
              case 154:
                itemDrops = 2679;
                break;
              case 155:
                itemDrops = 2681;
                break;
              case 156:
                itemDrops = 2683;
                break;
              case 157:
                itemDrops = 2678;
                break;
              case 158:
                itemDrops = 2680;
                break;
              case 159:
                itemDrops = 2682;
                break;
              case 160:
                itemDrops = 2684;
                break;
              case 161:
                itemDrops = 2686;
                break;
              case 162:
                itemDrops = 2688;
                break;
              case 163:
                itemDrops = 2690;
                break;
              case 164:
                itemDrops = 2685;
                break;
              case 165:
                itemDrops = 2687;
                break;
              case 166:
                itemDrops = 2689;
                break;
            }
          }
          if (tileCache.wall == (ushort) 136)
            itemDrops = 2169;
          if (tileCache.wall == (ushort) 137)
            itemDrops = 2170;
          if (tileCache.wall == (ushort) 172)
            itemDrops = 2788;
          if (tileCache.wall == (ushort) 242)
            itemDrops = 4279;
          if (tileCache.wall == (ushort) 243)
            itemDrops = 4280;
          if (tileCache.wall == (ushort) 145)
            itemDrops = 2333;
          if (tileCache.wall == (ushort) 16)
            itemDrops = 30;
          if (tileCache.wall == (ushort) 17)
            itemDrops = 135;
          if (tileCache.wall == (ushort) 18)
            itemDrops = 138;
          if (tileCache.wall == (ushort) 19)
            itemDrops = 140;
          if (tileCache.wall == (ushort) 20)
            itemDrops = 330;
          if (tileCache.wall == (ushort) 21)
            itemDrops = 392;
          if (tileCache.wall == (ushort) 86 || tileCache.wall == (ushort) 108)
            itemDrops = 1126;
          if (tileCache.wall == (ushort) 173)
            itemDrops = 2789;
          if (tileCache.wall == (ushort) 174)
            itemDrops = 2790;
          if (tileCache.wall == (ushort) 175)
            itemDrops = 2791;
          if (tileCache.wall == (ushort) 176)
            itemDrops = 2861;
          if (tileCache.wall == (ushort) 182)
            itemDrops = 3101;
          if (tileCache.wall == (ushort) 133)
            itemDrops = 2158;
          if (tileCache.wall == (ushort) 134)
            itemDrops = 2159;
          if (tileCache.wall == (ushort) 135)
            itemDrops = 2160;
          else if (tileCache.wall == (ushort) 113)
            itemDrops = 1726;
          else if (tileCache.wall == (ushort) 114)
            itemDrops = 1728;
          else if (tileCache.wall == (ushort) 115)
            itemDrops = 1730;
          else if (tileCache.wall == (ushort) 146)
            itemDrops = 2432;
          else if (tileCache.wall == (ushort) 147)
            itemDrops = 2433;
          else if (tileCache.wall == (ushort) 148)
            itemDrops = 2434;
          if (tileCache.wall >= (ushort) 116 && tileCache.wall <= (ushort) 125)
            itemDrops = 1948 + (int) tileCache.wall - 116;
          if (tileCache.wall >= (ushort) 126 && tileCache.wall <= (ushort) 132)
            itemDrops = 2008 + (int) tileCache.wall - 126;
          if (tileCache.wall == (ushort) 22)
            itemDrops = 417;
          if (tileCache.wall == (ushort) 23)
            itemDrops = 418;
          if (tileCache.wall == (ushort) 24)
            itemDrops = 419;
          if (tileCache.wall == (ushort) 25)
            itemDrops = 420;
          if (tileCache.wall == (ushort) 26)
            itemDrops = 421;
          if (tileCache.wall == (ushort) 29)
            itemDrops = 587;
          if (tileCache.wall == (ushort) 30)
            itemDrops = 592;
          if (tileCache.wall == (ushort) 31)
            itemDrops = 595;
          if (tileCache.wall == (ushort) 32)
            itemDrops = 605;
          if (tileCache.wall == (ushort) 33)
            itemDrops = 606;
          if (tileCache.wall == (ushort) 34)
            itemDrops = 608;
          if (tileCache.wall == (ushort) 35)
            itemDrops = 610;
          if (tileCache.wall == (ushort) 36)
            itemDrops = 615;
          if (tileCache.wall == (ushort) 37)
            itemDrops = 616;
          if (tileCache.wall == (ushort) 38)
            itemDrops = 617;
          if (tileCache.wall == (ushort) 39)
            itemDrops = 618;
          if (tileCache.wall == (ushort) 41)
            itemDrops = 622;
          if (tileCache.wall == (ushort) 42)
            itemDrops = 623;
          if (tileCache.wall == (ushort) 43)
            itemDrops = 624;
          if (tileCache.wall == (ushort) 44)
            itemDrops = 663;
          if (tileCache.wall == (ushort) 45)
            itemDrops = 720;
          if (tileCache.wall == (ushort) 46)
            itemDrops = 721;
          if (tileCache.wall == (ushort) 47)
            itemDrops = 722;
          if (tileCache.wall == (ushort) 66)
            itemDrops = 745;
          if (tileCache.wall == (ushort) 67)
            itemDrops = 746;
          if (tileCache.wall == (ushort) 68)
            itemDrops = 747;
          if (tileCache.wall == (ushort) 84)
            itemDrops = 884;
          if (tileCache.wall == (ushort) 72)
            itemDrops = 750;
          if (tileCache.wall == (ushort) 73)
            itemDrops = 752;
          if (tileCache.wall == (ushort) 74)
            itemDrops = 764;
          if (tileCache.wall == (ushort) 85)
            itemDrops = 927;
          if (tileCache.wall == (ushort) 75)
            itemDrops = 768;
          if (tileCache.wall == (ushort) 76)
            itemDrops = 769;
          if (tileCache.wall == (ushort) 77)
            itemDrops = 770;
          if (tileCache.wall == (ushort) 82)
            itemDrops = 825;
          if (tileCache.wall == (ushort) 27)
            itemDrops = 479;
          if (tileCache.wall == (ushort) 106)
            itemDrops = 1447;
          if (tileCache.wall == (ushort) 107)
            itemDrops = 1448;
          if (tileCache.wall == (ushort) 109)
            itemDrops = 1590;
          if (tileCache.wall == (ushort) 110)
            itemDrops = 1592;
          if (tileCache.wall == (ushort) 111)
            itemDrops = 1594;
          if (tileCache.wall == (ushort) 78)
            itemDrops = 1723;
          if (tileCache.wall == (ushort) 87 || tileCache.wall == (ushort) 112)
            itemDrops = 1102;
          if (tileCache.wall == (ushort) 94 || tileCache.wall == (ushort) 100)
            itemDrops = 1378;
          if (tileCache.wall == (ushort) 95 || tileCache.wall == (ushort) 101)
            itemDrops = 1379;
          if (tileCache.wall == (ushort) 96 || tileCache.wall == (ushort) 102)
            itemDrops = 1380;
          if (tileCache.wall == (ushort) 97 || tileCache.wall == (ushort) 103)
            itemDrops = 1381;
          if (tileCache.wall == (ushort) 98 || tileCache.wall == (ushort) 104)
            itemDrops = 1382;
          if (tileCache.wall == (ushort) 99 || tileCache.wall == (ushort) 105)
            itemDrops = 1383;
          if (tileCache.wall == (ushort) 241)
            itemDrops = 4260;
          if (tileCache.wall >= (ushort) 88 && tileCache.wall <= (ushort) 93)
            itemDrops = 1267 + (int) tileCache.wall - 88;
          if (tileCache.wall >= (ushort) 138 && tileCache.wall <= (ushort) 141)
            itemDrops = 2210 + (int) tileCache.wall - 138;
          return itemDrops;
      }
    }

    private static void KillWall_MakeWallDust(int i, int j, Tile tileCache)
    {
      int Type = 0;
      switch (tileCache.wall)
      {
        case 3:
        case 246:
          Type = WorldGen.genRand.Next(2) != 0 ? 1 : 14;
          break;
        case 7:
        case 17:
        case 94:
        case 95:
        case 100:
        case 101:
        case 331:
          Type = 275;
          break;
        case 8:
        case 18:
        case 98:
        case 99:
        case 104:
        case 105:
        case 332:
          Type = 276;
          break;
        case 9:
        case 19:
        case 96:
        case 97:
        case 102:
        case 103:
        case 333:
          Type = 277;
          break;
        case 15:
        case 247:
          Type = 38;
          break;
        case 22:
        case 28:
        case 248:
          Type = 51;
          break;
        case 40:
        case 249:
          Type = 51;
          break;
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 185:
        case 250:
        case 251:
        case 252:
        case 253:
        case 254:
        case (ushort) byte.MaxValue:
        case 256:
        case 257:
        case 258:
        case 259:
        case 260:
        case 274:
        case 314:
          Type = 1;
          break;
        case 59:
        case 61:
        case 261:
        case 262:
          Type = 0;
          break;
        case 62:
        case 263:
          Type = 0;
          break;
        case 69:
        case 264:
          Type = WorldGen.genRand.Next(2) != 0 ? 17 : 14;
          break;
        case 70:
        case 265:
          Type = 47;
          break;
        case 71:
        case 266:
          Type = 80;
          break;
        case 79:
        case 267:
          Type = 37;
          break;
        case 81:
        case 268:
          Type = 123;
          break;
        case 83:
        case 234:
        case 269:
          Type = WorldGen.genRand.Next(2) != 0 ? 117 : 1;
          break;
        case 170:
        case 171:
        case 270:
        case 271:
          Type = 0;
          break;
        case 187:
        case 275:
          Type = 0;
          break;
        case 188:
        case 189:
        case 190:
        case 191:
        case 276:
        case 277:
        case 278:
        case 279:
          Type = 37;
          break;
        case 192:
        case 193:
        case 194:
        case 195:
        case 280:
        case 281:
        case 282:
        case 283:
          Type = 117;
          break;
        case 196:
        case 197:
        case 198:
        case 199:
        case 284:
        case 285:
        case 286:
        case 287:
          Type = 0;
          break;
        case 200:
        case 202:
        case 288:
        case 290:
          Type = WorldGen.genRand.Next(2) != 0 ? 70 : 69;
          break;
        case 201:
        case 289:
          Type = 17;
          break;
        case 203:
        case 291:
          Type = WorldGen.genRand.Next(2) != 0 ? 68 : 69;
          break;
        case 204:
        case 205:
        case 207:
        case 292:
        case 293:
        case 295:
          Type = 0;
          break;
        case 206:
        case 294:
          Type = 1;
          break;
        case 208:
        case 209:
        case 210:
        case 211:
        case 296:
        case 297:
        case 298:
        case 299:
          Type = WorldGen.genRand.Next(2) != 0 ? 125 : 155;
          break;
        case 212:
        case 213:
        case 214:
        case 215:
        case 300:
        case 301:
        case 302:
        case 303:
          Type = 1;
          break;
        case 216:
        case 304:
          Type = 0;
          break;
        case 217:
        case 305:
          Type = 37;
          break;
        case 218:
        case 306:
          Type = 155;
          break;
        case 219:
        case 307:
          Type = 17;
          break;
        case 220:
        case 308:
          Type = 37;
          break;
        case 221:
        case 309:
          Type = 155;
          break;
        case 222:
        case 310:
          Type = 37;
          break;
        case 223:
        case 311:
          Type = 0;
          break;
        case 231:
          Type = 8;
          break;
        case 232:
          Type = 82;
          break;
        case 233:
          Type = 18;
          break;
        case 237:
          Type = 6;
          break;
        case 238:
          Type = 61;
          break;
        case 239:
          Type = 242;
          break;
        case 240:
          Type = 135;
          break;
        case 312:
        case 313:
        case 315:
          Type = -1;
          break;
        case 316:
        case 317:
          Type = 36;
          break;
      }
      if (tileCache.wall == (ushort) 148)
        Type = -1;
      if (tileCache.wall == (ushort) 1 || tileCache.wall == (ushort) 5 || tileCache.wall == (ushort) 6 || tileCache.wall == (ushort) 107)
        Type = 1;
      if (tileCache.wall == (ushort) 35)
        Type = 37;
      if (tileCache.wall == (ushort) 4 || tileCache.wall == (ushort) 106)
        Type = 7;
      if (tileCache.wall == (ushort) 12)
        Type = 9;
      if (tileCache.wall == (ushort) 336)
        Type = 9;
      if (tileCache.wall == (ushort) 10)
        Type = 10;
      if (tileCache.wall == (ushort) 334)
        Type = 10;
      if (tileCache.wall == (ushort) 11)
        Type = 11;
      if (tileCache.wall == (ushort) 335)
        Type = 11;
      if (tileCache.wall == (ushort) 21)
        Type = 13;
      if (tileCache.wall == (ushort) 34)
        Type = 32;
      if (tileCache.wall == (ushort) 225)
        Type = 1;
      if (tileCache.wall == (ushort) 145)
        Type = 8;
      if (tileCache.wall == (ushort) 23)
        Type = 38;
      if (tileCache.wall == (ushort) 24)
        Type = 36;
      if (tileCache.wall == (ushort) 25 || tileCache.wall == (ushort) 339)
        Type = 48;
      if (tileCache.wall == (ushort) 179 || tileCache.wall == (ushort) 178 || tileCache.wall == (ushort) 183)
        Type = 236;
      if (tileCache.wall == (ushort) 181 || tileCache.wall == (ushort) 180 || tileCache.wall == (ushort) 184)
        Type = 240;
      if (tileCache.wall == (ushort) 113)
        Type = 189;
      if (tileCache.wall == (ushort) 114)
        Type = 190;
      if (tileCache.wall == (ushort) 115)
        Type = 191;
      if (tileCache.wall == (ushort) 177 || tileCache.wall == (ushort) 13 || tileCache.wall == (ushort) 338)
        Type = 25;
      if (tileCache.wall == (ushort) 186)
        Type = WorldGen.genRand.Next(68, 71);
      if (tileCache.wall == (ushort) 319)
        Type = 171;
      if (tileCache.wall == (ushort) 321)
        Type = 308;
      if (tileCache.wall == (ushort) 322)
        Type = 308;
      if (tileCache.wall == (ushort) 318)
        Type = 226;
      if (tileCache.wall == (ushort) 142)
        Type = 210;
      if (tileCache.wall == (ushort) 143)
        Type = 210;
      if (tileCache.wall == (ushort) 224)
        Type = 265;
      if (tileCache.wall == (ushort) 323)
        Type = 314;
      if (tileCache.wall == (ushort) 324)
        Type = 315;
      if (tileCache.wall == (ushort) 325)
        Type = 316;
      if (tileCache.wall == (ushort) 326)
        Type = 317;
      if (tileCache.wall == (ushort) 327)
        Type = 318;
      if (tileCache.wall == (ushort) 328)
        Type = 319;
      if (tileCache.wall == (ushort) 329)
        Type = 320;
      if (tileCache.wall == (ushort) 330)
        Type = 321;
      if (tileCache.wall == (ushort) 320)
        Type = 0;
      if (tileCache.wall == (ushort) 341)
        Type = 258;
      if (tileCache.wall == (ushort) 342)
        Type = 301;
      if (tileCache.wall == (ushort) 343)
        Type = 299;
      if (tileCache.wall == (ushort) 344)
        Type = 300;
      if (tileCache.wall == (ushort) 345)
        Type = 305;
      if (tileCache.wall == (ushort) 173)
        Type = 128;
      if (tileCache.wall == (ushort) 174)
        Type = 117;
      if (tileCache.wall == (ushort) 175)
        Type = 42;
      if (tileCache.wall == (ushort) 176)
        Type = 226;
      if (tileCache.wall == (ushort) 182)
        Type = WorldGen.genRand.Next(2) != 0 ? 23 : 6;
      if (tileCache.wall >= (ushort) 153 && tileCache.wall <= (ushort) 166)
      {
        switch (tileCache.wall)
        {
          case 153:
          case 157:
            Type = 138;
            break;
          case 154:
          case 158:
            Type = 86;
            break;
          case 155:
          case 159:
            Type = 91;
            break;
          case 156:
          case 160:
            Type = 89;
            break;
          case 161:
          case 164:
            Type = 90;
            break;
          case 162:
          case 165:
            Type = 88;
            break;
          case 163:
          case 166:
            Type = 87;
            break;
        }
      }
      if (tileCache.wall == (ushort) 26 || tileCache.wall == (ushort) 30 || tileCache.wall == (ushort) 340)
        Type = 49;
      if (tileCache.wall == (ushort) 29 || tileCache.wall == (ushort) 32)
        Type = 50;
      if (tileCache.wall == (ushort) 31)
        Type = 51;
      if (tileCache.wall == (ushort) 14 || tileCache.wall == (ushort) 20 || tileCache.wall == (ushort) 337)
        Type = 109;
      if (tileCache.wall == (ushort) 241)
        Type = 286;
      if (tileCache.wall >= (ushort) 88 && tileCache.wall <= (ushort) 93)
      {
        Type = 86 + (int) tileCache.wall - 88;
        if (tileCache.wall == (ushort) 93)
          Type = WorldGen.genRand.Next(88, 94);
      }
      if (tileCache.wall == (ushort) 33)
        Type = 14;
      if (tileCache.wall == (ushort) 41)
        Type = 77;
      if (tileCache.wall == (ushort) 42)
        Type = 78;
      if (tileCache.wall == (ushort) 43)
        Type = 78;
      if (tileCache.wall == (ushort) 36)
        Type = 26;
      if (tileCache.wall == (ushort) 37)
        Type = 32;
      if (tileCache.wall == (ushort) 38)
        Type = 2;
      if (tileCache.wall == (ushort) 39)
        Type = 1;
      if (tileCache.wall == (ushort) 45)
        Type = 81;
      if (tileCache.wall == (ushort) 46)
        Type = 83;
      if (tileCache.wall == (ushort) 47)
        Type = 84;
      if (tileCache.wall == (ushort) 85)
        Type = 126;
      if (tileCache.wall == (ushort) 63)
        Type = 3;
      if (tileCache.wall == (ushort) 65)
        Type = 3;
      if (tileCache.wall == (ushort) 66)
        Type = 3;
      if (tileCache.wall == (ushort) 68)
        Type = 3;
      if (tileCache.wall == (ushort) 64)
        Type = 40;
      if (tileCache.wall == (ushort) 67)
        Type = 40;
      if (tileCache.wall == (ushort) 84)
        Type = 80;
      if (tileCache.wall == (ushort) 60)
        Type = 3;
      if (tileCache.wall == (ushort) 167)
        Type = 81;
      if (tileCache.wall == (ushort) 147)
        Type = 51;
      if (tileCache.wall == (ushort) 146)
        Type = 9;
      if (tileCache.wall == (ushort) 109)
        Type = 144;
      if (tileCache.wall == (ushort) 110)
        Type = 145;
      if (tileCache.wall == (ushort) 111)
        Type = 146;
      if (tileCache.wall == (ushort) 86 || tileCache.wall == (ushort) 108)
        Type = 147;
      if (tileCache.wall == (ushort) 87)
        Type = 148;
      if (tileCache.wall == (ushort) 136)
        Type = 13;
      if (tileCache.wall == (ushort) 137)
        Type = 13;
      if (tileCache.wall == (ushort) 168)
        Type = 13;
      if (tileCache.wall == (ushort) 169)
        Type = 13;
      if (tileCache.wall == (ushort) 172)
        Type = 13;
      if (tileCache.wall == (ushort) 226)
        Type = 13;
      if (tileCache.wall == (ushort) 227)
        Type = 13;
      if (tileCache.wall == (ushort) 242)
        Type = 13;
      if (tileCache.wall == (ushort) 243)
        Type = 13;
      if (tileCache.wall == (ushort) 72)
        Type = 40;
      if (tileCache.wall == (ushort) 73)
        Type = 16;
      if (tileCache.wall == (ushort) 74 || tileCache.wall == (ushort) 80)
        Type = 26;
      if (tileCache.wall == (ushort) 144)
        Type = WorldGen.genRand.Next(2) != 0 ? 118 : 10;
      if (tileCache.wall == (ushort) 75)
        Type = 26;
      if (tileCache.wall == (ushort) 76)
        Type = 4;
      if (tileCache.wall == (ushort) 77 || tileCache.wall == (ushort) 81)
        Type = 5;
      if (tileCache.wall == (ushort) 78 || tileCache.wall == (ushort) 244)
        Type = 7;
      if (tileCache.wall == (ushort) 82)
        Type = 36;
      if (tileCache.wall == (ushort) 27)
        Type = WorldGen.genRand.Next(2) != 0 ? 1 : 7;
      if (tileCache.wall == (ushort) 138)
        Type = 77;
      if (tileCache.wall == (ushort) 139)
        Type = 78;
      if (tileCache.wall == (ushort) 140)
        Type = 79;
      if (tileCache.wall == (ushort) 141)
        Type = 126;
      if (tileCache.wall == (ushort) 149 || tileCache.wall == (ushort) 150)
        Type = 214;
      if (tileCache.wall == (ushort) 151 || tileCache.wall == (ushort) 152)
        Type = 215;
      if (tileCache.wall == (ushort) 245)
        Type = 195;
      if (tileCache.wall == (ushort) 44 || tileCache.wall == (ushort) 346)
      {
        int index = Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 66, Alpha: 100, newColor: new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), Scale: 0.75f);
        Main.dust[index].noGravity = true;
      }
      else
      {
        if (tileCache.wall >= (ushort) 133 && tileCache.wall <= (ushort) 135 || tileCache.wall >= (ushort) 116 && tileCache.wall <= (ushort) 125 || tileCache.wall >= (ushort) 126 && tileCache.wall <= (ushort) 132)
          return;
        if (tileCache.wall == (ushort) 76)
        {
          Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type, Alpha: 75, newColor: new Color(0, 80, (int) byte.MaxValue, 100), Scale: 0.75f);
        }
        else
        {
          if (Type < 0)
            return;
          Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type);
        }
      }
    }

    public static void LaunchRocket(int x, int y, bool fromWiring)
    {
      int frameY = (int) Main.tile[x, y].frameY;
      int num = 0;
      while (frameY >= 40)
      {
        frameY -= 40;
        ++num;
      }
      if (frameY == 18)
        --y;
      Vector2 vector2 = new Vector2((float) (x * 16 + 8), (float) (y * 16 + 4));
      int Type = 167 + num;
      int Damage = 150;
      int KnockBack = 7;
      int index = Projectile.NewProjectile(WorldGen.GetProjectileSource_PlayerOrWires(x, y, fromWiring, Main.LocalPlayer), vector2.X, vector2.Y + 2f, 0.0f, -8f, Type, Damage, (float) KnockBack, Main.myPlayer);
      Main.projectile[index].originatedFromActivableTile = true;
      Main.tile[x, y].active(false);
      Main.tile[x, y + 1].active(false);
      NetMessage.SendTileSquare(-1, x, y, 1, 2);
    }

    public static void LaunchRocketSmall(int x, int y, bool fromWiring)
    {
      if (Main.tile[x, y].frameX == (short) 18)
        --x;
      if (Main.tile[x, y].frameY == (short) 18)
        --y;
      Vector2 vector2 = new Vector2((float) (x * 16 + 16), (float) (y * 16));
      int Type = 415 + Main.rand.Next(4);
      int Damage = 0;
      int KnockBack = 0;
      int index = Projectile.NewProjectile(WorldGen.GetProjectileSource_PlayerOrWires(x, y, fromWiring, Main.LocalPlayer), vector2.X, vector2.Y + 2f, 0.0f, -8f, Type, Damage, (float) KnockBack, Main.myPlayer);
      Main.projectile[index].originatedFromActivableTile = true;
    }

    public static bool CanKillTile(int i, int j, WorldGen.SpecialKillTileContext context)
    {
      if (context == WorldGen.SpecialKillTileContext.MowingTheGrass)
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return false;
        if (tile.type == (ushort) 2 || tile.type == (ushort) 109)
          return true;
      }
      return WorldGen.CanKillTile(i, j);
    }

    public static bool CanKillTile(int i, int j) => WorldGen.CanKillTile(i, j, out bool _);

    public static bool CanKillTile(int i, int j, out bool blockDamaged)
    {
      blockDamaged = false;
      if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
        return false;
      Tile t1 = Main.tile[i, j];
      Tile tile = (Tile) null;
      if (t1 == null || !t1.active())
        return false;
      if (j >= 1)
        tile = Main.tile[i, j - 1];
      if (tile != null && tile.active())
      {
        int type = (int) tile.type;
        if (TileID.Sets.IsATreeTrunk[type] && (int) t1.type != type && (tile.frameX != (short) 66 || tile.frameY < (short) 0 || tile.frameY > (short) 44) && (tile.frameX != (short) 88 || tile.frameY < (short) 66 || tile.frameY > (short) 110) && tile.frameY < (short) 198)
          return false;
        switch (type)
        {
          case 21:
          case 26:
          case 72:
          case 77:
          case 88:
          case 467:
          case 488:
            if ((int) t1.type != type)
              return false;
            break;
          case 80:
            if ((int) t1.type != type)
            {
              switch ((int) tile.frameX / 18)
              {
                case 0:
                case 1:
                case 4:
                case 5:
                  return false;
              }
            }
            else
              break;
            break;
          case 323:
            if ((int) t1.type != type && (tile.frameX == (short) 66 || tile.frameX == (short) 220))
              return false;
            break;
        }
      }
      if (TileID.Sets.Boulders[(int) t1.type] && WorldGen.CheckBoulderChest(i, j))
      {
        blockDamaged = true;
        return false;
      }
      switch (t1.type)
      {
        case 10:
          if (WorldGen.IsLockedDoor(t1))
          {
            blockDamaged = true;
            return false;
          }
          break;
        case 21:
        case 467:
          if (!Chest.CanDestroyChest(i - (int) t1.frameX / 18 % 2, j - (int) t1.frameY / 18))
            return false;
          break;
        case 88:
          if (!Chest.CanDestroyChest(i - (int) t1.frameX / 18 % 3, j - (int) t1.frameY / 18))
            return false;
          break;
        case 235:
          int num = i - (int) t1.frameX % 54 / 18;
          for (int index = 0; index < 3; ++index)
          {
            Tile t2 = Main.tile[num + index, j - 1];
            if (t2.active() && WorldGen.IsAContainer(t2))
            {
              blockDamaged = true;
              return false;
            }
          }
          break;
      }
      return true;
    }

    public static bool IsTileReplacable(int x, int y)
    {
      Tile tile1 = Main.tile[x, y];
      if (y >= 1)
      {
        Tile tile2 = Main.tile[x, y - 1];
        if (tile1 == null || tile2 == null)
          return false;
        if (tile2.active())
        {
          if (tile2.type == (ushort) 80 || tile2.type == (ushort) 488)
            return false;
          if (TileID.Sets.PreventsTileReplaceIfOnTopOfIt[(int) tile2.type] && (int) tile1.type != (int) tile2.type)
            return TileID.Sets.IsATreeTrunk[(int) tile2.type] ? tile2.frameX == (short) 66 && tile2.frameY >= (short) 0 && tile2.frameY <= (short) 44 || tile2.frameX == (short) 88 && tile2.frameY >= (short) 66 && tile2.frameY <= (short) 110 || tile2.frameY >= (short) 198 : tile2.type == (ushort) 323 && tile2.frameX != (short) 66 && tile2.frameX != (short) 220;
        }
      }
      return true;
    }

    public static int CheckTileBreakability(int x, int y)
    {
      if (Main.tile[x, y] == null)
        Main.tile[x, y] = new Tile();
      Tile t1 = Main.tile[x, y];
      if (y >= 1 && y <= Main.maxTilesY - 1)
      {
        if (Main.tile[x, y - 1] == null)
          Main.tile[x, y - 1] = new Tile();
        if (Main.tile[x, y + 1] == null)
          Main.tile[x, y + 1] = new Tile();
        Tile t2 = Main.tile[x, y - 1];
        Tile tile = Main.tile[x, y + 1];
        if (tile != null && tile.active() && WorldGen.IsLockedDoor(x, y + 1))
          return 2;
        if (!Main.tileSolid[(int) t1.type] && !Main.tileSolidTop[(int) t1.type])
          return 0;
        if (t2.active())
        {
          if (((!TileID.Sets.PreventsTileRemovalIfOnTopOfIt[(int) t2.type] ? 0 : ((int) t1.type != (int) t2.type ? 1 : 0)) | (WorldGen.IsLockedDoor(x, y - 1) ? 1 : 0) | (t2.type != (ushort) 77 || t1.type == (ushort) 77 ? 0 : (!Main.hardMode ? 1 : 0)) | (!WorldGen.IsAContainer(t2) ? 0 : (!WorldGen.IsAContainer(t1) ? 1 : 0))) != 0)
            return TileID.Sets.IsATreeTrunk[(int) t2.type] ? (t2.frameX == (short) 66 && t2.frameY >= (short) 0 && t2.frameY <= (short) 44 || t2.frameX == (short) 88 && t2.frameY >= (short) 66 && t2.frameY <= (short) 110 || t2.frameY >= (short) 198 ? 0 : 2) : (t2.type == (ushort) 323 && t2.frameX != (short) 66 && t2.frameX != (short) 220 ? 0 : 2);
          if (t2.type == (ushort) 80 && (int) t2.type != (int) t1.type)
          {
            switch ((int) t2.frameX / 18)
            {
              case 0:
              case 1:
              case 4:
              case 5:
                return 2;
            }
          }
          if (t1.type == (ushort) 10 && WorldGen.IsLockedDoor(t1))
            return 1;
          if (TileID.Sets.Boulders[(int) t1.type])
            return WorldGen.CheckBoulderChest(x, y) ? 1 : 0;
        }
        if (t1.type == (ushort) 235)
        {
          int frameX = (int) t1.frameX;
          int num = x - frameX % 54 / 18;
          for (int index = 0; index < 3; ++index)
          {
            if (Main.tile[num + index, y - 1].active() && WorldGen.IsAContainer(Main.tile[num + index, y - 1]))
              return 2;
          }
        }
      }
      return 0;
    }

    public static bool CheckTileBreakability2_ShouldTileSurvive(int x, int y)
    {
      if (Main.netMode == 1)
        return false;
      if (Main.tile[x, y] == null)
        Main.tile[x, y] = new Tile();
      Tile tile = Main.tile[x, y];
      if (TileID.Sets.BasicChest[(int) tile.type])
      {
        int num = (int) tile.frameX / 18;
        int Y = y - (int) tile.frameY / 18;
        while (num > 1)
          num -= 2;
        if (!Chest.DestroyChest(x - num, Y))
          return true;
      }
      if (tile.type == (ushort) 88)
      {
        int num1 = (int) tile.frameX / 18;
        int Y = y - (int) tile.frameY / 18;
        int num2 = num1 % 3;
        if (!Chest.DestroyChest(x - num2, Y))
          return true;
      }
      if (tile.type == (ushort) 470)
        return !TEDisplayDoll.IsBreakable(x, y);
      return tile.type == (ushort) 475 && !TEHatRack.IsBreakable(x, y);
    }

    public static bool ReplaceWall(int x, int y, ushort targetWall)
    {
      if ((int) targetWall >= (int) WallID.Count)
        return false;
      Tile tileCache = Main.tile[x, y];
      if (tileCache.wall == (ushort) 0 || targetWall == (ushort) 0 || WorldGen.KillWall_CheckFailure(false, tileCache))
        return false;
      int num = 10;
      for (int index = 0; index < num; ++index)
        WorldGen.KillWall_MakeWallDust(x, y, tileCache);
      WorldGen.KillWall_PlaySounds(x, y, tileCache);
      WorldGen.KillWall_DropItems(x, y, tileCache);
      tileCache.wall = targetWall;
      tileCache.ClearWallPaintAndCoating();
      WorldGen.SquareWallFrame(x, y);
      return true;
    }

    public static bool ReplaceTile(int x, int y, ushort targetType, int targetStyle)
    {
      Tile tileSafely = Framing.GetTileSafely(x, y);
      if (!WorldGen.WouldTileReplacementWork(targetType, x, y) || !WorldGen.IsTileReplacable(x, y))
        return false;
      WorldGen.MoveReplaceTileAnchor(ref x, ref y, targetType, tileSafely);
      int tileDustAmount = WorldGen.KillTile_GetTileDustAmount(false, tileSafely);
      for (int index = 0; index < tileDustAmount; ++index)
        WorldGen.KillTile_MakeTileDust(x, y, tileSafely);
      WorldGen.KillTile_PlaySounds(x, y, false, tileSafely);
      WorldGen.KillTile_DropItems(x, y, tileSafely, true);
      WorldGen.AttemptFossilShattering(x, y, tileSafely, false);
      WorldGen.ReplaceTIle_DoActualReplacement(targetType, targetStyle, x, y, tileSafely);
      return true;
    }

    private static void ReplaceTIle_DoActualReplacement(
      ushort targetType,
      int targetStyle,
      int topLeftX,
      int topLeftY,
      Tile t)
    {
      if (TileID.Sets.BasicChest[(int) targetType])
      {
        if (WorldGen.IsChestRigged(topLeftX, topLeftY) && Main.netMode != 1)
        {
          Wiring.HitSwitch(topLeftX, topLeftY);
          NetMessage.SendData(59, number: topLeftX, number2: ((float) topLeftY));
        }
        WorldGen.ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 2, 2);
      }
      else if (TileID.Sets.BasicDresser[(int) targetType])
        WorldGen.ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 3, 2);
      else if (targetType == (ushort) 215)
        WorldGen.ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 3, 2);
      else
        WorldGen.ReplaceTile_DoActualReplacement_Single(targetType, targetStyle, topLeftX, topLeftY, t);
    }

    private static void ReplaceTile_DoActualReplacement_Single(
      ushort targetType,
      int targetStyle,
      int topLeftX,
      int topLeftY,
      Tile t)
    {
      WorldGen.ReplaceTile_EliminateNaturalExtras(topLeftX, topLeftY);
      int type = (int) t.type;
      t.type = targetType;
      if (TileID.Sets.Platforms[(int) t.type])
        t.frameY = (short) (targetStyle * 18);
      if (t.type == (ushort) 4)
        t.frameY = (short) (targetStyle * 22);
      t.ClearBlockPaintAndCoating();
      bool flag = !WorldGen.CanPoundTile(topLeftX, topLeftY);
      if (TileID.Sets.Platforms[type] && TileID.Sets.Platforms[(int) t.type])
        flag = false;
      if (flag)
      {
        t.slope((byte) 0);
        t.halfBrick(false);
      }
      if (Main.tenthAnniversaryWorld && !Main.remixWorld && (targetType == (ushort) 53 || targetType == (ushort) 396 || targetType == (ushort) 397))
        t.color((byte) 7);
      WorldGen.SquareTileFrame(topLeftX, topLeftY);
    }

    private static void ReplaceTile_EliminateNaturalExtras(int x, int y)
    {
      if (!WorldGen.InWorld(x, y, 2))
        return;
      if (Main.tile[x, y - 1] != null && Main.tile[x, y - 1].active() && (TileID.Sets.ReplaceTileBreakUp[(int) Main.tile[x, y - 1].type] || Main.tile[x, y - 1].type == (ushort) 165 && (Main.tile[x, y - 1].frameY == (short) 36 || Main.tile[x, y - 1].frameY == (short) 54 || Main.tile[x, y - 1].frameY == (short) 90)))
        WorldGen.KillTile(x, y - 1);
      if (Main.tile[x, y + 1] == null || !Main.tile[x, y + 1].active() || !TileID.Sets.ReplaceTileBreakDown[(int) Main.tile[x, y + 1].type] && (Main.tile[x, y + 1].type != (ushort) 165 || Main.tile[x, y + 1].frameY != (short) 0 && Main.tile[x, y + 1].frameY != (short) 18 && Main.tile[x, y + 1].frameY != (short) 72))
        return;
      WorldGen.KillTile(x, y + 1);
    }

    private static void ReplaceTile_DoActualReplacement_Area(
      ushort targetType,
      int targetStyle,
      int topLeftX,
      int topLeftY,
      int areaSizeX,
      int areaSizeY)
    {
      for (int index1 = 0; index1 < areaSizeX; ++index1)
      {
        for (int index2 = 0; index2 < areaSizeY; ++index2)
        {
          Tile tile = Main.tile[topLeftX + index1, topLeftY + index2];
          tile.type = targetType;
          tile.frameX = (short) (targetStyle * (areaSizeX * 18) + index1 * 18);
          tile.frameY = (short) (index2 * 18);
          tile.ClearBlockPaintAndCoating();
        }
      }
      for (int index3 = 0; index3 < areaSizeX; ++index3)
      {
        for (int index4 = 0; index4 < areaSizeY; ++index4)
          WorldGen.SquareTileFrame(topLeftX + index3, topLeftY + index4);
      }
    }

    private static void MoveReplaceTileAnchor(ref int x, ref int y, ushort targetType, Tile t)
    {
      if (TileID.Sets.BasicChest[(int) t.type])
      {
        x -= (int) t.frameX % 36 / 18;
        y -= (int) t.frameY % 36 / 18;
      }
      if (TileID.Sets.BasicDresser[(int) t.type])
      {
        x -= (int) t.frameX % 54 / 18;
        y -= (int) t.frameY % 36 / 18;
      }
      if (t.type != (ushort) 215)
        return;
      x -= (int) t.frameX % 54 / 18;
      y -= (int) t.frameY % 36 / 18;
    }

    public static bool WouldTileReplacementBeBlockedByLiquid(int x, int y, int liquidType)
    {
      if (Main.tile[x - 1, y].liquid > (byte) 0 && (int) Main.tile[x - 1, y].liquidType() == liquidType || Main.tile[x + 1, y].liquid > (byte) 0 && (int) Main.tile[x + 1, y].liquidType() == liquidType)
        return true;
      return Main.tile[x, y - 1].liquid > (byte) 0 && (int) Main.tile[x, y - 1].liquidType() == liquidType;
    }

    public static bool WouldTileReplacementWork(ushort attemptingToReplaceWith, int x, int y)
    {
      Tile t = Main.tile[x, y];
      if ((int) attemptingToReplaceWith >= (int) TileID.Count || TileID.Sets.Conversion.Grass[(int) attemptingToReplaceWith] || attemptingToReplaceWith == (ushort) 633)
        return false;
      if (Main.tileRope[(int) t.type] && WorldGen.InWorld(x, y, 2))
      {
        Tile tile1 = Main.tile[x - 1, y];
        Tile tile2 = Main.tile[x + 1, y];
        if (attemptingToReplaceWith == (ushort) 314 && tile1 != null && tile2 != null && (tile1.active() && tile1.type == (ushort) 314 || tile2.active() && tile2.type == (ushort) 314) || TileID.Sets.Platforms[(int) attemptingToReplaceWith] && tile1 != null && tile2 != null && (tile1.active() && TileID.Sets.Platforms[(int) tile1.type] || tile2.active() && TileID.Sets.Platforms[(int) tile2.type]))
          return true;
      }
      bool flag1 = !WorldGen.ReplaceTile_IsValidSolid((int) attemptingToReplaceWith) || !WorldGen.ReplaceTile_IsValidSolid((int) t.type);
      bool flag2 = !WorldGen.ReplaceTile_IsValidTorch((int) attemptingToReplaceWith) || !WorldGen.ReplaceTile_IsValidTorch((int) t.type);
      bool flag3 = !WorldGen.ReplaceTile_IsValidCampfire((int) attemptingToReplaceWith) || !WorldGen.ReplaceTile_IsValidCampfire((int) t.type);
      int num1 = !WorldGen.ReplaceTile_IsValidPlatform((int) attemptingToReplaceWith) ? 1 : (!WorldGen.ReplaceTile_IsValidPlatform((int) t.type) ? 1 : 0);
      bool flag4 = !WorldGen.ReplaceTile_IsValidSolid((int) attemptingToReplaceWith) && !WorldGen.ReplaceTile_IsValidPlatform((int) attemptingToReplaceWith) || !WorldGen.ReplaceTile_IsValidSolid((int) t.type) && !WorldGen.ReplaceTile_IsValidPlatform((int) t.type);
      bool flag5 = !WorldGen.ReplaceTile_IsValidChest((int) attemptingToReplaceWith) || !WorldGen.ReplaceTile_IsValidChest((int) t.type) || Chest.IsLocked(t);
      bool flag6 = !WorldGen.ReplaceTile_IsValidDresser((int) attemptingToReplaceWith) || !WorldGen.ReplaceTile_IsValidDresser((int) t.type);
      int num2 = flag2 ? 1 : 0;
      return (num1 & num2 & (flag3 ? 1 : 0) & (flag1 ? 1 : 0) & (flag4 ? 1 : 0) & (flag5 ? 1 : 0) & (flag6 ? 1 : 0)) == 0;
    }

    private static bool ReplaceTile_IsValidSolid(int type)
    {
      if (!Main.tileSolid[type] || Main.tileSolidTop[type])
        return false;
      return Main.tileRope[type] || !Main.tileFrameImportant[type];
    }

    private static bool ReplaceTile_IsValidTorch(int type) => type == 4;

    private static bool ReplaceTile_IsValidCampfire(int type) => type == 215;

    private static bool ReplaceTile_IsValidChest(int type) => TileID.Sets.BasicChest[type];

    private static bool ReplaceTile_IsValidDresser(int type) => TileID.Sets.BasicDresser[type];

    private static bool ReplaceTile_IsValidPlatform(int type) => TileID.Sets.Platforms[type];

    public static bool GetAshTreeFoliageData(
      int i,
      int j,
      int xoffset,
      ref int treeFrame,
      ref int treeStyle,
      out int floorY,
      out int topTextureFrameWidth,
      out int topTextureFrameHeight)
    {
      Tile tile1 = Main.tile[i, j];
      int index1 = i + xoffset;
      topTextureFrameWidth = 116;
      topTextureFrameHeight = 96;
      floorY = j;
      for (int index2 = 0; index2 < 100; ++index2)
      {
        floorY = j + index2;
        Tile tile2 = Main.tile[index1, floorY];
        if (tile2 == null)
          return false;
        if (tile2.type == (ushort) 633)
        {
          treeStyle = 31;
          return true;
        }
      }
      return false;
    }

    public static bool GetVanityTreeFoliageData(
      int i,
      int j,
      int xoffset,
      ref int treeFrame,
      ref int treeStyle,
      out int floorY,
      out int topTextureFrameWidth,
      out int topTextureFrameHeight)
    {
      Tile tile1 = Main.tile[i, j];
      int index1 = i + xoffset;
      topTextureFrameWidth = 118;
      topTextureFrameHeight = 96;
      floorY = j;
      for (int index2 = 0; index2 < 100; ++index2)
      {
        floorY = j + index2;
        Tile tile2 = Main.tile[index1, floorY];
        if (tile2 == null)
          return false;
        if (TileID.Sets.Conversion.Grass[(int) tile2.type])
        {
          switch (tile1.type)
          {
            case 596:
              treeStyle = 29;
              return true;
            case 616:
              treeStyle = 30;
              return true;
            default:
              continue;
          }
        }
      }
      return false;
    }

    public static bool GetGemTreeFoliageData(
      int i,
      int j,
      int xoffset,
      ref int treeFrame,
      ref int treeStyle,
      out int floorY,
      out int topTextureFrameWidth,
      out int topTextureFrameHeight)
    {
      Tile tile1 = Main.tile[i, j];
      int index1 = i + xoffset;
      topTextureFrameWidth = 116;
      topTextureFrameHeight = 96;
      floorY = j;
      WorldGen.GrowTreeSettings profile;
      if (!WorldGen.GrowTreeSettings.Profiles.TryGetFromTreeId((int) tile1.type, out profile))
        return false;
      for (int index2 = 0; index2 < 100; ++index2)
      {
        floorY = j + index2;
        Tile tile2 = Main.tile[index1, floorY];
        if (tile2 == null)
          return false;
        if (profile.GroundTest((int) tile2.type))
        {
          switch (tile1.type)
          {
            case 583:
              treeStyle = 22;
              return true;
            case 584:
              treeStyle = 23;
              return true;
            case 585:
              treeStyle = 24;
              return true;
            case 586:
              treeStyle = 25;
              return true;
            case 587:
              treeStyle = 26;
              return true;
            case 588:
              treeStyle = 27;
              return true;
            case 589:
              treeStyle = 28;
              return true;
            default:
              continue;
          }
        }
      }
      return false;
    }

    public static bool GetCommonTreeFoliageData(
      int i,
      int j,
      int xoffset,
      ref int treeFrame,
      ref int treeStyle,
      out int floorY,
      out int topTextureFrameWidth,
      out int topTextureFrameHeight)
    {
      Tile tile1 = Main.tile[i, j];
      int index1 = i + xoffset;
      topTextureFrameWidth = 80;
      topTextureFrameHeight = 80;
      floorY = j;
      for (int index2 = 0; index2 < 100; ++index2)
      {
        floorY = j + index2;
        Tile tile2 = Main.tile[index1, floorY];
        if (tile2 == null)
          return false;
        switch (tile2.type)
        {
          case 2:
          case 477:
            int num = index1 > Main.treeX[0] ? (index1 > Main.treeX[1] ? (index1 > Main.treeX[2] ? WorldGen.TreeTops.GetTreeStyle(3) : WorldGen.TreeTops.GetTreeStyle(2)) : WorldGen.TreeTops.GetTreeStyle(1)) : WorldGen.TreeTops.GetTreeStyle(0);
            switch (num)
            {
              case 0:
                treeStyle = 0;
                break;
              case 5:
                treeStyle = 10;
                break;
              default:
                treeStyle = 5 + num;
                break;
            }
            return true;
          case 23:
          case 661:
            treeStyle = 1;
            return true;
          case 60:
            topTextureFrameHeight = 96;
            topTextureFrameWidth = 114;
            treeStyle = 2;
            if (WorldGen.TreeTops.GetTreeStyle(5) == 1)
            {
              treeStyle = 11;
              topTextureFrameWidth = 116;
            }
            if ((double) floorY > Main.worldSurface)
            {
              treeStyle = 13;
              topTextureFrameWidth = 116;
            }
            return true;
          case 70:
            treeStyle = 14;
            return true;
          case 109:
          case 492:
            topTextureFrameHeight = 140;
            int treeFoliageStyle = WorldGen.GetHollowTreeFoliageStyle();
            treeStyle = treeFoliageStyle;
            if (treeFoliageStyle == 19)
              topTextureFrameWidth = 120;
            if (treeFoliageStyle == 20)
            {
              treeStyle = 20;
              if (i % 6 == 1)
                treeFrame += 3;
              else if (i % 6 == 2)
                treeFrame += 6;
              else if (i % 6 == 3)
                treeFrame += 9;
              else if (i % 6 == 4)
                treeFrame += 12;
              else if (i % 6 == 5)
                treeFrame += 15;
            }
            else if (i % 3 == 1)
              treeFrame += 3;
            else if (i % 3 == 2)
              treeFrame += 6;
            return true;
          case 147:
            treeStyle = 4;
            int treeStyle1 = WorldGen.TreeTops.GetTreeStyle(6);
            if (treeStyle1 == 0)
            {
              treeStyle = 12;
              if (i % 10 == 0)
                treeStyle = 18;
            }
            if (treeStyle1 == 2 || treeStyle1 == 3 || treeStyle1 == 32 || treeStyle1 == 4 || treeStyle1 == 42 || treeStyle1 == 5 || treeStyle1 == 7)
              treeStyle = treeStyle1 % 2 != 0 ? (i <= Main.maxTilesX / 2 ? 17 : 16) : (i >= Main.maxTilesX / 2 ? 17 : 16);
            return true;
          case 199:
          case 662:
            treeStyle = 5;
            return true;
          default:
            continue;
        }
      }
      return false;
    }

    public static int GetHollowTreeFoliageStyle()
    {
      WorldGen.TreeTops.GetTreeStyle(7);
      switch (WorldGen.hallowBG)
      {
        case 2:
        case 3:
          return 20;
        case 4:
          return 19;
        default:
          return 3;
      }
    }

    public static int GetTreeFrame(Tile t)
    {
      if (t.frameY == (short) 220)
        return 1;
      return t.frameY == (short) 242 ? 2 : 0;
    }

    public static TreeTypes GetTreeType(int tileType)
    {
      switch (tileType)
      {
        case 2:
        case 477:
          return TreeTypes.Forest;
        case 23:
          return TreeTypes.Corrupt;
        case 53:
          return TreeTypes.Palm;
        case 60:
          return TreeTypes.Jungle;
        case 70:
          return TreeTypes.Mushroom;
        case 109:
        case 492:
          return TreeTypes.Hallowed;
        case 112:
          return TreeTypes.PalmCorrupt;
        case 116:
          return TreeTypes.PalmHallowed;
        case 147:
          return TreeTypes.Snow;
        case 199:
          return TreeTypes.Crimson;
        case 234:
          return TreeTypes.PalmCrimson;
        case 633:
          return TreeTypes.Ash;
        default:
          return TreeTypes.None;
      }
    }

    public static bool IsThisAMushroomTree(int i, int j)
    {
      int x;
      int y;
      WorldGen.GetTreeBottom(i, j, out x, out y);
      return WorldGen.GetTreeType((int) Main.tile[x, y].type) == TreeTypes.Mushroom;
    }

    public static void ResetTreeShakes() => WorldGen.numTreeShakes = 0;

    private static void ShakeTree(int i, int j)
    {
      if (WorldGen.numTreeShakes == WorldGen.maxTreeShakes)
        return;
      int x;
      int y;
      WorldGen.GetTreeBottom(i, j, out x, out y);
      int index1 = y;
      TreeTypes treeType = WorldGen.GetTreeType((int) Main.tile[x, y].type);
      if (treeType == TreeTypes.None)
        return;
      for (int index2 = 0; index2 < WorldGen.numTreeShakes; ++index2)
      {
        if (WorldGen.treeShakeX[index2] == x && WorldGen.treeShakeY[index2] == y)
          return;
      }
      WorldGen.treeShakeX[WorldGen.numTreeShakes] = x;
      WorldGen.treeShakeY[WorldGen.numTreeShakes] = y;
      ++WorldGen.numTreeShakes;
      --y;
      while (y > 10 && Main.tile[x, y].active() && TileID.Sets.IsShakeable[(int) Main.tile[x, y].type])
        --y;
      ++y;
      if (!WorldGen.IsTileALeafyTreeTop(x, y) || Collision.SolidTiles(x - 2, x + 2, y - 2, y + 2))
        return;
      if (Main.getGoodWorld && WorldGen.genRand.Next(17) == 0)
        Projectile.NewProjectile((IEntitySource) WorldGen.GetProjectileSource_ShakeTree(x, y), (float) (x * 16), (float) (y * 16), (float) Main.rand.Next(-100, 101) * (1f / 500f), 0.0f, 28, 0, 0.0f, Main.myPlayer, 16f, 16f);
      else if (WorldGen.genRand.Next(300) == 0 && treeType == TreeTypes.Forest)
        Item.NewItem((IEntitySource) WorldGen.GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 832);
      else if (WorldGen.genRand.Next(300) == 0 && treeType == TreeTypes.Forest)
        Item.NewItem((IEntitySource) WorldGen.GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 933);
      else if (WorldGen.genRand.Next(200) == 0 && treeType == TreeTypes.Jungle)
        Item.NewItem((IEntitySource) WorldGen.GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 3360);
      else if (WorldGen.genRand.Next(200) == 0 && treeType == TreeTypes.Jungle)
        Item.NewItem((IEntitySource) WorldGen.GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 3361);
      else if (WorldGen.genRand.Next(1000) == 0 && treeType == TreeTypes.Forest)
        Item.NewItem((IEntitySource) WorldGen.GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 4366);
      else if (WorldGen.genRand.Next(7) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Snow || treeType == TreeTypes.Hallowed || treeType == TreeTypes.Ash))
        Item.NewItem((IEntitySource) WorldGen.GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 27, WorldGen.genRand.Next(1, 3));
      else if (WorldGen.genRand.Next(8) == 0 && treeType == TreeTypes.Mushroom)
        Item.NewItem((IEntitySource) WorldGen.GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 194, WorldGen.genRand.Next(1, 2));
      else if (WorldGen.genRand.Next(35) == 0 && Main.halloween)
        Item.NewItem((IEntitySource) WorldGen.GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 1809, WorldGen.genRand.Next(1, 3));
      else if (WorldGen.genRand.Next(12) == 0)
      {
        int dropItem = 0;
        WorldGen.KillTile_GetItemDrops(i, j, Main.tile[i, j], out dropItem, out int _, out int _, out int _);
        Item.NewItem(WorldGen.GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, dropItem, WorldGen.genRand.Next(1, 4));
      }
      else if (WorldGen.genRand.Next(20) == 0)
      {
        int Type = 71;
        int Stack = WorldGen.genRand.Next(50, 100);
        if (WorldGen.genRand.Next(30) == 0)
        {
          Type = 73;
          Stack = 1;
          if (WorldGen.genRand.Next(5) == 0)
            ++Stack;
          if (WorldGen.genRand.Next(10) == 0)
            ++Stack;
        }
        else if (WorldGen.genRand.Next(10) == 0)
        {
          Type = 72;
          Stack = WorldGen.genRand.Next(1, 21);
          if (WorldGen.genRand.Next(3) == 0)
            Stack += WorldGen.genRand.Next(1, 21);
          if (WorldGen.genRand.Next(4) == 0)
            Stack += WorldGen.genRand.Next(1, 21);
        }
        Item.NewItem(WorldGen.GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, Type, Stack);
      }
      else if (WorldGen.genRand.Next(15) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Hallowed))
      {
        int Type;
        switch (WorldGen.genRand.Next(5))
        {
          case 0:
            Type = 74;
            break;
          case 1:
            Type = 297;
            break;
          case 2:
            Type = 298;
            break;
          case 3:
            Type = 299;
            break;
          default:
            Type = 538;
            break;
        }
        if ((double) Player.GetClosestRollLuck(x, y, NPC.goldCritterChance) == 0.0)
          Type = WorldGen.genRand.Next(2) != 0 ? 539 : 442;
        NPC.NewNPC((IEntitySource) new EntitySource_ShakeTree(x, y), x * 16, y * 16, Type);
      }
      else if (WorldGen.genRand.Next(50) == 0 && treeType == TreeTypes.Hallowed && !Main.dayTime)
      {
        int Type = (int) Main.rand.NextFromList<short>((short) 583, (short) 584, (short) 585);
        if (Main.tenthAnniversaryWorld && Main.rand.Next(4) != 0)
          Type = 583;
        NPC.NewNPC((IEntitySource) new EntitySource_ShakeTree(x, y), x * 16, y * 16, Type);
      }
      else if (WorldGen.genRand.Next(50) == 0 && treeType == TreeTypes.Forest && !Main.dayTime)
      {
        NPC npc = Main.npc[NPC.NewNPC((IEntitySource) new EntitySource_ShakeTree(x, y), x * 16, y * 16, 611)];
        npc.velocity.Y = 1f;
        npc.netUpdate = true;
      }
      else if (WorldGen.genRand.Next(50) == 0 && treeType == TreeTypes.Jungle && Main.dayTime)
      {
        NPC npc = Main.npc[NPC.NewNPC((IEntitySource) new EntitySource_ShakeTree(x, y), x * 16, y * 16, (int) Main.rand.NextFromList<short>((short) 671, (short) 672, (short) 673, (short) 674, (short) 675))];
        npc.velocity.Y = 1f;
        npc.netUpdate = true;
      }
      else if (WorldGen.genRand.Next(40) == 0 && treeType == TreeTypes.Forest && !Main.dayTime && Main.halloween)
        NPC.NewNPC((IEntitySource) new EntitySource_ShakeTree(x, y), x * 16, y * 16, 301);
      else if (WorldGen.genRand.Next(50) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Hallowed))
      {
        for (int index3 = 0; index3 < 5; ++index3)
        {
          Point point = new Point(x + Main.rand.Next(-2, 2), y - 1 + Main.rand.Next(-2, 2));
          int Type;
          if ((double) Player.GetClosestRollLuck(x, y, NPC.goldCritterChance) == 0.0)
            Type = 442;
          else
            Type = (int) Main.rand.NextFromList<short>((short) 74, (short) 297, (short) 298);
          NPC npc = Main.npc[NPC.NewNPC((IEntitySource) new EntitySource_ShakeTree(x, y), point.X * 16, point.Y * 16, Type)];
          npc.velocity = Main.rand.NextVector2CircularEdge(3f, 3f);
          npc.netUpdate = true;
        }
      }
      else if (WorldGen.genRand.Next(40) == 0 && treeType == TreeTypes.Jungle)
      {
        for (int index4 = 0; index4 < 5; ++index4)
        {
          Point point = new Point(x + Main.rand.Next(-2, 2), y - 1 + Main.rand.Next(-2, 2));
          NPC npc = Main.npc[NPC.NewNPC((IEntitySource) new EntitySource_ShakeTree(x, y), point.X * 16, point.Y * 16, (int) Main.rand.NextFromList<short>((short) 210, (short) 211))];
          npc.ai[1] = 65f;
          npc.netUpdate = true;
        }
      }
      else if (WorldGen.genRand.Next(20) == 0 && (treeType == TreeTypes.Palm || treeType == TreeTypes.PalmCorrupt || treeType == TreeTypes.PalmCrimson || treeType == TreeTypes.PalmHallowed) && !WorldGen.IsPalmOasisTree(x))
        NPC.NewNPC((IEntitySource) new EntitySource_ShakeTree(x, y), x * 16, y * 16, 603);
      else if (WorldGen.genRand.Next(30) == 0 && (treeType == TreeTypes.Crimson || treeType == TreeTypes.PalmCrimson))
        NPC.NewNPC((IEntitySource) new EntitySource_ShakeTree(x, y), x * 16 + 8, (y - 1) * 16, -22);
      else if (WorldGen.genRand.Next(30) == 0 && (treeType == TreeTypes.Corrupt || treeType == TreeTypes.PalmCorrupt))
        NPC.NewNPC((IEntitySource) new EntitySource_ShakeTree(x, y), x * 16 + 8, (y - 1) * 16, -11);
      else if (WorldGen.genRand.Next(30) == 0 && treeType == TreeTypes.Jungle && !Main.dayTime)
        NPC.NewNPC((IEntitySource) new EntitySource_ShakeTree(x, y), x * 16, y * 16, 51);
      else if (WorldGen.genRand.Next(40) == 0 && treeType == TreeTypes.Jungle)
        Projectile.NewProjectile((IEntitySource) WorldGen.GetProjectileSource_ShakeTree(x, y), (float) (x * 16 + 8), (float) ((y - 1) * 16), 0.0f, 0.0f, 655, 0, 0.0f, Main.myPlayer);
      else if (WorldGen.genRand.Next(20) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Hallowed) && !Main.raining && !NPC.TooWindyForButterflies && Main.dayTime)
      {
        int Type = 356;
        if ((double) Player.GetClosestRollLuck(x, y, NPC.goldCritterChance) == 0.0)
          Type = 444;
        NPC.NewNPC((IEntitySource) new EntitySource_ShakeTree(x, y), x * 16, y * 16, Type);
      }
      else if (WorldGen.genRand.Next(20) == 0 && treeType == TreeTypes.Ash && y > Main.maxTilesY - 250)
      {
        int Type;
        switch (WorldGen.genRand.Next(3))
        {
          case 0:
            Type = 654;
            break;
          case 1:
            Type = 653;
            break;
          default:
            Type = 655;
            break;
        }
        NPC.NewNPC((IEntitySource) new EntitySource_ShakeTree(x, y), x * 16, y * 16, Type);
      }
      else if (Main.remixWorld && WorldGen.genRand.Next(20) == 0 && treeType == TreeTypes.Ash && y > Main.maxTilesY - 250)
        Item.NewItem(WorldGen.GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, 965, WorldGen.genRand.Next(20, 41));
      else if (WorldGen.genRand.Next(12) == 0 && treeType == TreeTypes.Forest)
      {
        int Type;
        switch (WorldGen.genRand.Next(5))
        {
          case 0:
            Type = 4009;
            break;
          case 1:
            Type = 4293;
            break;
          case 2:
            Type = 4282;
            break;
          case 3:
            Type = 4290;
            break;
          default:
            Type = 4291;
            break;
        }
        Item.NewItem(WorldGen.GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, Type);
      }
      else if (WorldGen.genRand.Next(12) == 0 && treeType == TreeTypes.Snow)
      {
        int Type = WorldGen.genRand.Next(2) != 0 ? 4295 : 4286;
        Item.NewItem(WorldGen.GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, Type);
      }
      else if (WorldGen.genRand.Next(12) == 0 && treeType == TreeTypes.Jungle)
      {
        int Type = WorldGen.genRand.Next(2) != 0 ? 4292 : 4294;
        Item.NewItem(WorldGen.GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, Type);
      }
      else if (WorldGen.genRand.Next(12) == 0 && (treeType == TreeTypes.Palm || treeType == TreeTypes.PalmCorrupt || treeType == TreeTypes.PalmCrimson || treeType == TreeTypes.PalmHallowed) && !WorldGen.IsPalmOasisTree(x))
      {
        int Type = WorldGen.genRand.Next(2) != 0 ? 4287 : 4283;
        Item.NewItem(WorldGen.GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, Type);
      }
      else if (WorldGen.genRand.Next(12) == 0 && (treeType == TreeTypes.Corrupt || treeType == TreeTypes.PalmCorrupt))
      {
        int Type = WorldGen.genRand.Next(2) != 0 ? 4289 : 4284;
        Item.NewItem(WorldGen.GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, Type);
      }
      else if (WorldGen.genRand.Next(12) == 0 && (treeType == TreeTypes.Hallowed || treeType == TreeTypes.PalmHallowed))
      {
        int Type = WorldGen.genRand.Next(2) != 0 ? 4288 : 4297;
        Item.NewItem(WorldGen.GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, Type);
      }
      else if (WorldGen.genRand.Next(12) == 0 && (treeType == TreeTypes.Crimson || treeType == TreeTypes.PalmCrimson))
      {
        int Type = WorldGen.genRand.Next(2) != 0 ? 4285 : 4296;
        Item.NewItem(WorldGen.GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, Type);
      }
      else if (WorldGen.genRand.Next(12) == 0 && treeType == TreeTypes.Ash)
      {
        int Type = WorldGen.genRand.Next(2) != 0 ? 5278 : 5277;
        Item.NewItem(WorldGen.GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, Type);
      }
      int treeHeight = 0;
      int treeFrame = 0;
      int passStyle = 0;
      WorldGen.GetTreeLeaf(x, Main.tile[x, y], Main.tile[x, index1], ref treeHeight, out treeFrame, out passStyle);
      if (passStyle == -1)
        return;
      if (Main.netMode == 2)
        NetMessage.SendData(112, number: 1, number2: ((float) x), number3: ((float) y), number4: 1f, number5: passStyle);
      if (Main.netMode != 0)
        return;
      WorldGen.TreeGrowFX(x, y, 1, passStyle, true);
    }

    private static void GetVineTop(int i, int j, out int x, out int y)
    {
      x = i;
      y = j;
      Tile tileSafely = Framing.GetTileSafely(x, y);
      if (!TileID.Sets.IsVine[(int) tileSafely.type])
        return;
      for (; y > 20 && tileSafely.active() && TileID.Sets.IsVine[(int) tileSafely.type]; tileSafely = Framing.GetTileSafely(x, y))
        --y;
    }

    public static void GetTreeBottom(int i, int j, out int x, out int y)
    {
      x = i;
      y = j;
      Tile tileSafely1 = Framing.GetTileSafely(x, y);
      if (tileSafely1.type == (ushort) 323)
      {
        for (; y < Main.maxTilesY - 50 && (!tileSafely1.active() || tileSafely1.type == (ushort) 323); tileSafely1 = Framing.GetTileSafely(x, y))
          ++y;
      }
      else
      {
        int num1 = (int) tileSafely1.frameX / 22;
        int num2 = (int) tileSafely1.frameY / 22;
        if (num1 == 3 && num2 <= 2)
          ++x;
        else if (num1 == 4 && num2 >= 3 && num2 <= 5)
          --x;
        else if (num1 == 1 && num2 >= 6 && num2 <= 8)
          --x;
        else if (num1 == 2 && num2 >= 6 && num2 <= 8)
          ++x;
        else if (num1 == 2 && num2 >= 9)
          ++x;
        else if (num1 == 3 && num2 >= 9)
          --x;
        for (Tile tileSafely2 = Framing.GetTileSafely(x, y); y < Main.maxTilesY - 50 && (!tileSafely2.active() || TileID.Sets.IsATreeTrunk[(int) tileSafely2.type] || tileSafely2.type == (ushort) 72); tileSafely2 = Framing.GetTileSafely(x, y))
          ++y;
      }
    }

    private static void AttemptFossilShattering(int i, int j, Tile tileCache, bool fail)
    {
      if (tileCache.type != (ushort) 404 || Main.netMode == 1 || WorldGen.fossilBreak)
        return;
      WorldGen.fossilBreak = true;
      for (int index1 = i - 1; index1 <= i + 1; ++index1)
      {
        for (int index2 = j - 1; index2 <= j + 1; ++index2)
        {
          int maxValue = 15;
          if (!WorldGen.SolidTile(index1, index2 + 1))
            maxValue = 4;
          else if (index1 == i && index2 == j - 1 && !fail)
            maxValue = 4;
          if ((index1 != i || index2 != j) && Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 404 && WorldGen.genRand.Next(maxValue) == 0)
          {
            WorldGen.KillTile(index1, index2, noItem: true);
            if (Main.netMode == 2)
              NetMessage.SendData(17, number2: ((float) index1), number3: ((float) index2));
          }
        }
      }
      WorldGen.fossilBreak = false;
    }

    public static void KillTile(int i, int j, bool fail = false, bool effectOnly = false, bool noItem = false)
    {
      if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
        return;
      Tile tileCache = Main.tile[i, j];
      if (tileCache == null)
      {
        tileCache = new Tile();
        Main.tile[i, j] = tileCache;
      }
      if (!tileCache.active())
        return;
      if (j >= 1 && Main.tile[i, j - 1] == null)
        Main.tile[i, j - 1] = new Tile();
      int num1 = WorldGen.CheckTileBreakability(i, j);
      if (num1 == 1)
        fail = true;
      if (num1 == 2)
        return;
      if (WorldGen.gen)
        noItem = true;
      if (!effectOnly && !WorldGen.stopDrops)
      {
        if (!noItem && FixExploitManEaters.SpotProtected(i, j))
          return;
        if (!Main.dedServ && !WorldGen.gen && !Main.gameMenu)
          WorldGen.KillTile_PlaySounds(i, j, fail, tileCache);
      }
      if (tileCache.type == (ushort) 128 || tileCache.type == (ushort) 269)
      {
        int index1 = i;
        int frameX1 = (int) tileCache.frameX;
        int frameX2 = (int) tileCache.frameX;
        while (frameX2 >= 100)
          frameX2 -= 100;
        while (frameX2 >= 36)
          frameX2 -= 36;
        if (frameX2 == 18)
        {
          frameX1 = (int) Main.tile[i - 1, j].frameX;
          --index1;
        }
        if (frameX1 >= 100)
        {
          int index2 = 0;
          while (frameX1 >= 100)
          {
            frameX1 -= 100;
            ++index2;
          }
          int num2 = (int) Main.tile[index1, j].frameY / 18;
          if (num2 == 0)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Item.headType[index2]);
          if (num2 == 1)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Item.bodyType[index2]);
          if (num2 == 2)
            Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Item.legType[index2]);
          int frameX3 = (int) Main.tile[index1, j].frameX;
          while (frameX3 >= 100)
            frameX3 -= 100;
          Main.tile[index1, j].frameX = (short) frameX3;
        }
      }
      if (tileCache.type == (ushort) 334)
      {
        int index = i;
        int frameX4 = (int) tileCache.frameX;
        int num3 = (int) tileCache.frameX;
        int num4 = 0;
        while (num3 >= 5000)
        {
          num3 -= 5000;
          ++num4;
        }
        if (num4 != 0)
          num3 = (num4 - 1) * 18;
        int num5 = num3 % 54;
        if (num5 == 18)
        {
          frameX4 = (int) Main.tile[i - 1, j].frameX;
          --index;
        }
        if (num5 == 36)
        {
          frameX4 = (int) Main.tile[i - 2, j].frameX;
          index -= 2;
        }
        if (frameX4 >= 5000)
        {
          int num6 = frameX4 % 5000 - 100;
          int frameX5 = (int) Main.tile[index + 1, j].frameX;
          int prefixWeWant = frameX5 < 25000 ? frameX5 - 10000 : frameX5 - 25000;
          if (Main.netMode != 1)
          {
            Item obj = new Item();
            obj.netDefaults(num6);
            obj.Prefix(prefixWeWant);
            int number = Item.NewItem(WorldGen.GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, num6, noBroadcast: true);
            obj.position = Main.item[number].position;
            Main.item[number] = obj;
            NetMessage.SendData(21, number: number);
          }
          int num7 = (int) Main.tile[index, j].frameX;
          int num8 = 0;
          while (num7 >= 5000)
          {
            num7 -= 5000;
            ++num8;
          }
          if (num8 != 0)
            num7 = (num8 - 1) * 18;
          Main.tile[index, j].frameX = (short) num7;
          Main.tile[index + 1, j].frameX = (short) (num7 + 18);
        }
      }
      if (tileCache.type == (ushort) 395)
      {
        int key = TEItemFrame.Find(i - (int) tileCache.frameX % 36 / 18, j - (int) tileCache.frameY % 36 / 18);
        if (key != -1 && ((TEItemFrame) TileEntity.ByID[key]).item.stack > 0)
        {
          ((TEItemFrame) TileEntity.ByID[key]).DropItem();
          if (Main.netMode == 2)
            return;
          Main.LocalPlayer.InterruptItemUsageIfOverTile(395);
          return;
        }
      }
      if (tileCache.type == (ushort) 471)
      {
        int key = TEWeaponsRack.Find(i - (int) tileCache.frameX % 54 / 18, j - (int) tileCache.frameY % 54 / 18);
        if (key != -1 && ((TEWeaponsRack) TileEntity.ByID[key]).item.stack > 0)
        {
          ((TEWeaponsRack) TileEntity.ByID[key]).DropItem();
          if (Main.netMode == 2)
            return;
          Main.LocalPlayer.InterruptItemUsageIfOverTile(471);
          return;
        }
      }
      if (tileCache.type == (ushort) 520)
      {
        int key = TEFoodPlatter.Find(i, j);
        if (key != -1 && ((TEFoodPlatter) TileEntity.ByID[key]).item.stack > 0)
        {
          ((TEFoodPlatter) TileEntity.ByID[key]).DropItem();
          if (Main.netMode == 2)
            return;
          Main.LocalPlayer.InterruptItemUsageIfOverTile(520);
          return;
        }
      }
      if (tileCache.type == (ushort) 470 && WorldGen.CheckTileBreakability2_ShouldTileSurvive(i, j) | fail || tileCache.type == (ushort) 475 && WorldGen.CheckTileBreakability2_ShouldTileSurvive(i, j) | fail)
        return;
      int tileDustAmount = WorldGen.KillTile_GetTileDustAmount(fail, tileCache);
      for (int index = 0; index < tileDustAmount; ++index)
        WorldGen.KillTile_MakeTileDust(i, j, tileCache);
      if (effectOnly)
        return;
      WorldGen.AttemptFossilShattering(i, j, tileCache, fail);
      if (fail)
      {
        if (Main.netMode != 1 && TileID.Sets.IsShakeable[(int) tileCache.type])
          WorldGen.ShakeTree(i, j);
        if (tileCache.type == (ushort) 2 || tileCache.type == (ushort) 23 || tileCache.type == (ushort) 109 || tileCache.type == (ushort) 199 || tileCache.type == (ushort) 477 || tileCache.type == (ushort) 492)
          tileCache.type = (ushort) 0;
        if (tileCache.type == (ushort) 633)
          tileCache.type = (ushort) 57;
        if (tileCache.type == (ushort) 60 || tileCache.type == (ushort) 661 || tileCache.type == (ushort) 662 || tileCache.type == (ushort) 70)
          tileCache.type = (ushort) 59;
        if (Main.tileMoss[(int) tileCache.type])
          tileCache.type = (ushort) 1;
        if (TileID.Sets.tileMossBrick[(int) tileCache.type])
          tileCache.type = (ushort) 38;
        WorldGen.SquareTileFrame(i, j);
      }
      else
      {
        if (Main.getGoodWorld && Main.netMode != 1 && tileCache.type == (ushort) 57)
        {
          for (int index3 = 0; index3 < 8; ++index3)
          {
            int maxValue = 2;
            int index4 = i;
            int index5 = j;
            if (index3 == 0)
              --index4;
            else if (index3 == 1)
              ++index4;
            else if (index3 == 2)
              --index5;
            else if (index3 == 3)
              ++index5;
            else if (index3 == 4)
            {
              --index4;
              --index5;
            }
            else if (index3 == 5)
            {
              ++index4;
              --index5;
            }
            else if (index3 == 6)
            {
              --index4;
              ++index5;
            }
            else if (index3 == 7)
            {
              ++index4;
              ++index5;
            }
            Tile tile = Main.tile[index4, index5];
            if (tile.active() && WorldGen.genRand.Next(maxValue) == 0 && tile.type == (ushort) 57 && !WorldGen.SolidTile(index4, index5 + 1))
            {
              WorldGen.KillTile(index4, index5, noItem: true);
              if (Main.netMode == 2)
                NetMessage.TrySendData(17, number: 20, number2: ((float) index4), number3: ((float) index5));
              int index6 = Projectile.NewProjectile((IEntitySource) WorldGen.GetProjectileSource_TileBreak(index4, index5), (float) (index4 * 16 + 8), (float) (index5 * 16 + 8), 0.0f, 0.41f, 40, 15, 0.0f, Main.myPlayer);
              Main.projectile[index6].netUpdate = true;
            }
          }
        }
        if (Main.netMode != 1 && tileCache.type >= (ushort) 481 && tileCache.type <= (ushort) 483)
        {
          for (int index7 = 0; index7 < 8; ++index7)
          {
            int maxValue = 6;
            int index8 = i;
            int index9 = j;
            if (index7 == 0)
              --index8;
            else if (index7 == 1)
              ++index8;
            else if (index7 == 2)
            {
              --index9;
              maxValue /= 2;
            }
            else if (index7 == 3)
              ++index9;
            else if (index7 == 4)
            {
              --index8;
              --index9;
            }
            else if (index7 == 5)
            {
              ++index8;
              --index9;
            }
            else if (index7 == 6)
            {
              --index8;
              ++index9;
            }
            else if (index7 == 7)
            {
              ++index8;
              ++index9;
            }
            Tile tile = Main.tile[index8, index9];
            if (tile.active() && WorldGen.genRand.Next(maxValue) == 0 && tile.type >= (ushort) 481 && tile.type <= (ushort) 483)
            {
              tileCache.active(false);
              WorldGen.KillTile(index8, index9, noItem: true);
              if (Main.netMode == 2)
                NetMessage.TrySendData(17, number: 20, number2: ((float) index8), number3: ((float) index9));
            }
          }
          int Type = (int) tileCache.type - 481 + 736;
          int Damage = 20;
          EntitySource_TileBreak projectileSourceTileBreak = WorldGen.GetProjectileSource_TileBreak(i, j);
          switch (Main.netMode)
          {
            case 0:
              Projectile.NewProjectile((IEntitySource) projectileSourceTileBreak, (float) (i * 16 + 8), (float) (j * 16 + 8), 0.0f, 0.41f, Type, Damage, 0.0f, Main.myPlayer);
              break;
            case 2:
              int index = Projectile.NewProjectile((IEntitySource) projectileSourceTileBreak, (float) (i * 16 + 8), (float) (j * 16 + 8), 0.0f, 0.41f, Type, Damage, 0.0f, Main.myPlayer);
              Main.projectile[index].netUpdate = true;
              break;
          }
        }
        if (WorldGen.CheckTileBreakability2_ShouldTileSurvive(i, j))
          return;
        if (tileCache.type == (ushort) 51 && tileCache.wall == (ushort) 62 && WorldGen.genRand.Next(4) != 0)
          noItem = true;
        if (!noItem && !WorldGen.stopDrops && Main.netMode != 1)
        {
          WorldGen.KillTile_DropBait(i, j, tileCache);
          WorldGen.KillTile_DropItems(i, j, tileCache);
        }
        if (tileCache.type == (ushort) 520)
          TEFoodPlatter.Kill(i, j);
        if (tileCache.type == (ushort) 423)
          TELogicSensor.Kill(i, j);
        if (Main.netMode != 2)
          AchievementsHelper.NotifyTileDestroyed(Main.player[Main.myPlayer], tileCache.type);
        tileCache.active(false);
        tileCache.halfBrick(false);
        tileCache.frameX = (short) -1;
        tileCache.frameY = (short) -1;
        tileCache.ClearBlockPaintAndCoating();
        tileCache.frameNumber((byte) 0);
        if (Main.netMode != 1)
        {
          if (tileCache.type == (ushort) 58 && j > Main.UnderworldLayer)
          {
            tileCache.lava(true);
            tileCache.liquid = (byte) 128;
          }
          else if (tileCache.type == (ushort) 230 && Main.getGoodWorld && WorldGen.genRand.Next(2) == 0)
          {
            tileCache.lava(true);
            tileCache.liquid = (byte) 128;
          }
        }
        if (tileCache.type == (ushort) 419)
          Wiring.PokeLogicGate(i, j + 1);
        else if (TileID.Sets.BlocksWaterDrawingBehindSelf[(int) tileCache.type])
          WorldGen.SquareWallFrame(i, j);
        tileCache.type = (ushort) 0;
        tileCache.inActive(false);
        WorldGen.SquareTileFrame(i, j);
        while (!WorldGen.destroyObject && WorldGen.ExploitDestroyQueue.Count > 0)
        {
          Point point = WorldGen.ExploitDestroyQueue.Dequeue();
          if (Framing.GetTileSafely(point.X, point.Y).active())
          {
            WorldGen.SquareTileFrame(point.X, point.Y);
            NetMessage.SendTileSquare(-1, point.X, point.Y);
          }
        }
      }
    }

    private static Player GetPlayerForTile(int x, int y) => Main.player[(int) Player.FindClosest(new Vector2((float) x, (float) y) * 16f, 16, 16)];

    private static void KillTile_DropItems(
      int x,
      int y,
      Tile tileCache,
      bool includeLargeObjectDrops = false)
    {
      int dropItem;
      int dropItemStack;
      int secondaryItem;
      int secondaryItemStack;
      WorldGen.KillTile_GetItemDrops(x, y, tileCache, out dropItem, out dropItemStack, out secondaryItem, out secondaryItemStack, includeLargeObjectDrops);
      if (Main.getGoodWorld && !tileCache.active())
        return;
      if (dropItem > 0)
      {
        int i = Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, dropItem, dropItemStack, pfix: -1);
        Main.item[i].TryCombiningIntoNearbyItems(i);
      }
      if (secondaryItem <= 0)
        return;
      int i1 = Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, secondaryItem, secondaryItemStack, pfix: -1);
      Main.item[i1].TryCombiningIntoNearbyItems(i1);
    }

    public static void KillTile_GetItemDrops(
      int x,
      int y,
      Tile tileCache,
      out int dropItem,
      out int dropItemStack,
      out int secondaryItem,
      out int secondaryItemStack,
      bool includeLargeObjectDrops = false)
    {
      dropItem = 0;
      dropItemStack = 1;
      secondaryItem = 0;
      secondaryItemStack = 1;
      if (includeLargeObjectDrops)
      {
        switch (tileCache.type)
        {
          case 21:
          case 467:
            dropItem = WorldGen.GetChestItemDrop(x, y, (int) tileCache.type);
            break;
          case 88:
            int style1 = (int) tileCache.frameX / 54;
            dropItem = WorldGen.GetDresserItemDrop(style1);
            break;
          case 215:
            int style2 = (int) tileCache.frameX / 54;
            dropItem = WorldGen.GetCampfireItemDrop(style2);
            break;
        }
      }
      switch (tileCache.type)
      {
        case 0:
        case 2:
        case 109:
        case 199:
        case 477:
        case 492:
          dropItem = 2;
          break;
        case 1:
          dropItem = 3;
          break;
        case 3:
          if (tileCache.frameX == (short) 144)
          {
            dropItem = 5;
            break;
          }
          if (!WorldGen.KillTile_ShouldDropSeeds(x, y))
            break;
          dropItem = 283;
          break;
        case 4:
          int num1 = (int) tileCache.frameY / 22;
          switch (num1)
          {
            case 0:
              dropItem = 8;
              return;
            case 8:
              dropItem = 523;
              return;
            case 9:
              dropItem = 974;
              return;
            case 10:
              dropItem = 1245;
              return;
            case 11:
              dropItem = 1333;
              return;
            case 12:
              dropItem = 2274;
              return;
            case 13:
              dropItem = 3004;
              return;
            case 14:
              dropItem = 3045;
              return;
            case 15:
              dropItem = 3114;
              return;
            case 16:
              dropItem = 4383;
              return;
            case 17:
              dropItem = 4384;
              return;
            case 18:
              dropItem = 4385;
              return;
            case 19:
              dropItem = 4386;
              return;
            case 20:
              dropItem = 4387;
              return;
            case 21:
              dropItem = 4388;
              return;
            case 22:
              dropItem = 5293;
              return;
            case 23:
              dropItem = 5353;
              return;
            default:
              dropItem = 426 + num1;
              return;
          }
        case 5:
        case 596:
        case 616:
        case 634:
          bool bonusWood = false;
          WorldGen.KillTile_GetTreeDrops(x, y, tileCache, ref bonusWood, ref dropItem, ref secondaryItem);
          if (!bonusWood)
            break;
          ++dropItemStack;
          break;
        case 6:
          dropItem = 11;
          break;
        case 7:
          dropItem = 12;
          break;
        case 8:
          dropItem = 13;
          break;
        case 9:
          dropItem = 14;
          break;
        case 13:
          switch ((int) tileCache.frameX / 18)
          {
            case 1:
              dropItem = 28;
              return;
            case 2:
              dropItem = 110;
              return;
            case 3:
              dropItem = 350;
              return;
            case 4:
              dropItem = 351;
              return;
            case 5:
              dropItem = 2234;
              return;
            case 6:
              dropItem = 2244;
              return;
            case 7:
              dropItem = 2257;
              return;
            case 8:
              dropItem = 2258;
              return;
            default:
              dropItem = 31;
              return;
          }
        case 19:
          int num2 = (int) tileCache.frameY / 18;
          switch (num2)
          {
            case 0:
              dropItem = 94;
              return;
            case 1:
              dropItem = 631;
              return;
            case 2:
              dropItem = 632;
              return;
            case 3:
              dropItem = 633;
              return;
            case 4:
              dropItem = 634;
              return;
            case 5:
              dropItem = 913;
              return;
            case 6:
              dropItem = 1384;
              return;
            case 7:
              dropItem = 1385;
              return;
            case 8:
              dropItem = 1386;
              return;
            case 9:
              dropItem = 1387;
              return;
            case 10:
              dropItem = 1388;
              return;
            case 11:
              dropItem = 1389;
              return;
            case 12:
              dropItem = 1418;
              return;
            case 13:
              dropItem = 1457;
              return;
            case 14:
              dropItem = 1702;
              return;
            case 15:
              dropItem = 1796;
              return;
            case 16:
              dropItem = 1818;
              return;
            case 17:
              dropItem = 2518;
              return;
            case 18:
              dropItem = 2549;
              return;
            case 19:
              dropItem = 2566;
              return;
            case 20:
              dropItem = 2581;
              return;
            case 21:
              dropItem = 2627;
              return;
            case 22:
              dropItem = 2628;
              return;
            case 23:
              dropItem = 2629;
              return;
            case 24:
              dropItem = 2630;
              return;
            case 25:
              dropItem = 2744;
              return;
            case 26:
              dropItem = 2822;
              return;
            case 27:
              dropItem = 3144;
              return;
            case 28:
              dropItem = 3146;
              return;
            case 29:
              dropItem = 3145;
              return;
            default:
              if (num2 >= 30 && num2 <= 35)
              {
                dropItem = 3903 + num2 - 30;
                return;
              }
              switch (num2)
              {
                case 36:
                  dropItem = 3945;
                  return;
                case 37:
                  dropItem = 3957;
                  return;
                case 38:
                  dropItem = 4159;
                  return;
                case 39:
                  dropItem = 4180;
                  return;
                case 40:
                  dropItem = 4201;
                  return;
                case 41:
                  dropItem = 4222;
                  return;
                case 42:
                  dropItem = 4311;
                  return;
                case 43:
                  dropItem = 4416;
                  return;
                case 44:
                  dropItem = 4580;
                  return;
                case 45:
                  dropItem = 5162;
                  return;
                case 46:
                  dropItem = 5183;
                  return;
                case 47:
                  dropItem = 5204;
                  return;
                case 48:
                  dropItem = 5292;
                  return;
                default:
                  return;
              }
          }
        case 22:
          dropItem = 56;
          break;
        case 23:
          dropItem = 2;
          break;
        case 24:
          if (tileCache.frameX != (short) 144)
            break;
          dropItem = 60;
          break;
        case 25:
          dropItem = 61;
          break;
        case 30:
          dropItem = 9;
          break;
        case 33:
          int num3 = (int) tileCache.frameY / 22;
          dropItem = 105;
          switch (num3)
          {
            case 1:
              dropItem = 1405;
              return;
            case 2:
              dropItem = 1406;
              return;
            case 3:
              dropItem = 1407;
              return;
            default:
              if (num3 >= 4 && num3 <= 13)
              {
                dropItem = 2045 + num3 - 4;
                return;
              }
              if (num3 >= 14 && num3 <= 16)
              {
                dropItem = 2153 + num3 - 14;
                return;
              }
              switch (num3)
              {
                case 17:
                  dropItem = 2236;
                  return;
                case 18:
                  dropItem = 2523;
                  return;
                case 19:
                  dropItem = 2542;
                  return;
                case 20:
                  dropItem = 2556;
                  return;
                case 21:
                  dropItem = 2571;
                  return;
                case 22:
                  dropItem = 2648;
                  return;
                case 23:
                  dropItem = 2649;
                  return;
                case 24:
                  dropItem = 2650;
                  return;
                case 25:
                  dropItem = 2651;
                  return;
                case 26:
                  dropItem = 2818;
                  return;
                case 27:
                  dropItem = 3171;
                  return;
                case 28:
                  dropItem = 3173;
                  return;
                case 29:
                  dropItem = 3172;
                  return;
                case 30:
                  dropItem = 3890;
                  return;
                case 31:
                  dropItem = 3936;
                  return;
                case 32:
                  dropItem = 3962;
                  return;
                case 33:
                  dropItem = 4150;
                  return;
                case 34:
                  dropItem = 4171;
                  return;
                case 35:
                  dropItem = 4192;
                  return;
                case 36:
                  dropItem = 4213;
                  return;
                case 37:
                  dropItem = 4303;
                  return;
                case 38:
                  dropItem = 4571;
                  return;
                case 39:
                  dropItem = 5153;
                  return;
                case 40:
                  dropItem = 5174;
                  return;
                case 41:
                  dropItem = 5195;
                  return;
                default:
                  return;
              }
          }
        case 36:
          dropItem = 1869;
          break;
        case 37:
          dropItem = 116;
          break;
        case 38:
          dropItem = 129;
          break;
        case 39:
          dropItem = 131;
          break;
        case 40:
          dropItem = 133;
          break;
        case 41:
          dropItem = 134;
          break;
        case 43:
          dropItem = 137;
          break;
        case 44:
          dropItem = 139;
          break;
        case 45:
          dropItem = 141;
          break;
        case 46:
          dropItem = 143;
          break;
        case 47:
          dropItem = 145;
          break;
        case 48:
          dropItem = 147;
          break;
        case 49:
          dropItem = 148;
          break;
        case 50:
          if (tileCache.frameX == (short) 90)
          {
            dropItem = 165;
            break;
          }
          dropItem = 149;
          break;
        case 51:
          dropItem = 150;
          break;
        case 52:
        case 62:
        case 382:
          if (Main.rand.Next(2) != 0 || !WorldGen.GetPlayerForTile(x, y).cordage)
            break;
          dropItem = 2996;
          break;
        case 53:
          dropItem = 169;
          break;
        case 54:
          dropItem = 170;
          break;
        case 56:
          dropItem = 173;
          break;
        case 57:
          dropItem = 172;
          break;
        case 58:
          dropItem = 174;
          break;
        case 59:
        case 60:
        case 661:
        case 662:
          dropItem = 176;
          break;
        case 61:
        case 74:
          if (tileCache.frameX == (short) 144 && tileCache.type == (ushort) 61)
          {
            dropItem = 331;
            dropItemStack = Main.rand.Next(2, 4);
            break;
          }
          if (tileCache.frameX == (short) 162 && tileCache.type == (ushort) 61)
          {
            dropItem = 223;
            break;
          }
          if (tileCache.frameX >= (short) 108 && tileCache.frameX <= (short) 126 && tileCache.type == (ushort) 61 && Main.rand.Next(20) == 0)
          {
            dropItem = 208;
            break;
          }
          if (Main.rand.Next(100) != 0)
            break;
          dropItem = 195;
          break;
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 68:
          dropItem = (int) tileCache.type - 63 + 177;
          break;
        case 70:
          dropItem = 176;
          break;
        case 71:
        case 72:
          if (Main.rand.Next(40) == 0)
          {
            dropItem = 194;
            break;
          }
          if (Main.rand.Next(2) != 0)
            break;
          dropItem = 183;
          break;
        case 73:
          if (!WorldGen.KillTile_ShouldDropSeeds(x, y))
            break;
          dropItem = 283;
          break;
        case 75:
          dropItem = 192;
          break;
        case 76:
          dropItem = 214;
          break;
        case 78:
          dropItem = 222;
          break;
        case 80:
          dropItem = 276;
          break;
        case 81:
          dropItem = 275;
          break;
        case 83:
        case 84:
          int style3 = (int) tileCache.frameX / 18;
          dropItem = 313 + style3;
          int num4 = 307 + style3;
          if (style3 == 6)
          {
            dropItem = 2358;
            num4 = 2357;
          }
          bool flag = WorldGen.IsHarvestableHerbWithSeed((int) tileCache.type, style3);
          Player playerForTile = WorldGen.GetPlayerForTile(x, y);
          if ((playerForTile.HeldItem.type == 213 ? 1 : (playerForTile.HeldItem.type == 5295 ? 1 : 0)) != 0)
          {
            dropItemStack = Main.rand.Next(1, 3);
            secondaryItem = num4;
            secondaryItemStack = Main.rand.Next(1, 6);
            break;
          }
          if (!flag)
            break;
          secondaryItem = num4;
          secondaryItemStack = Main.rand.Next(1, 4);
          break;
        case 107:
          dropItem = 364;
          break;
        case 108:
          dropItem = 365;
          break;
        case 110:
          if (tileCache.frameX != (short) 144)
            break;
          dropItem = 5;
          break;
        case 111:
          dropItem = 366;
          break;
        case 112:
          dropItem = 370;
          break;
        case 116:
          dropItem = 408;
          break;
        case 117:
          dropItem = 409;
          break;
        case 118:
          dropItem = 412;
          break;
        case 119:
          dropItem = 413;
          break;
        case 120:
          dropItem = 414;
          break;
        case 121:
          dropItem = 415;
          break;
        case 122:
          dropItem = 416;
          break;
        case 123:
          dropItem = 424;
          break;
        case 124:
          dropItem = 480;
          break;
        case 129:
          if (tileCache.frameX >= (short) 324)
          {
            dropItem = 4988;
            break;
          }
          dropItem = 502;
          break;
        case 130:
          dropItem = 511;
          break;
        case 131:
          dropItem = 512;
          break;
        case 135:
          int num5 = (int) tileCache.frameY / 18;
          if (num5 == 0)
            dropItem = 529;
          if (num5 == 1)
            dropItem = 541;
          if (num5 == 2)
            dropItem = 542;
          if (num5 == 3)
            dropItem = 543;
          if (num5 == 4)
            dropItem = 852;
          if (num5 == 5)
            dropItem = 853;
          if (num5 != 6)
            break;
          dropItem = 1151;
          break;
        case 136:
          dropItem = 538;
          break;
        case 137:
          int num6 = (int) tileCache.frameY / 18;
          if (num6 == 0)
            dropItem = 539;
          if (num6 == 1)
            dropItem = 1146;
          if (num6 == 2)
            dropItem = 1147;
          if (num6 == 3)
            dropItem = 1148;
          if (num6 == 4)
            dropItem = 1149;
          if (num6 != 5)
            break;
          dropItem = 5135;
          break;
        case 140:
          dropItem = 577;
          break;
        case 141:
          dropItem = 580;
          break;
        case 144:
          if (tileCache.frameX == (short) 0)
            dropItem = 583;
          if (tileCache.frameX == (short) 18)
            dropItem = 584;
          if (tileCache.frameX == (short) 36)
            dropItem = 585;
          if (tileCache.frameX == (short) 54)
            dropItem = 4484;
          if (tileCache.frameX != (short) 72)
            break;
          dropItem = 4485;
          break;
        case 145:
          dropItem = 586;
          break;
        case 146:
          dropItem = 591;
          break;
        case 147:
          dropItem = 593;
          break;
        case 148:
          dropItem = 594;
          break;
        case 149:
          if (tileCache.frameX == (short) 0 || tileCache.frameX == (short) 54)
          {
            dropItem = 596;
            break;
          }
          if (tileCache.frameX == (short) 18 || tileCache.frameX == (short) 72)
          {
            dropItem = 597;
            break;
          }
          if (tileCache.frameX != (short) 36 && tileCache.frameX != (short) 90)
            break;
          dropItem = 598;
          break;
        case 150:
          dropItem = 604;
          break;
        case 151:
          dropItem = 607;
          break;
        case 152:
          dropItem = 609;
          break;
        case 153:
          dropItem = 611;
          break;
        case 154:
          dropItem = 612;
          break;
        case 155:
          dropItem = 613;
          break;
        case 156:
          dropItem = 614;
          break;
        case 157:
          dropItem = 619;
          break;
        case 158:
          dropItem = 620;
          break;
        case 159:
          dropItem = 621;
          break;
        case 160:
          dropItem = 662;
          break;
        case 161:
          dropItem = 664;
          break;
        case 163:
          dropItem = 833;
          break;
        case 164:
          dropItem = 834;
          break;
        case 166:
          dropItem = 699;
          break;
        case 167:
          dropItem = 700;
          break;
        case 168:
          dropItem = 701;
          break;
        case 169:
          dropItem = 702;
          break;
        case 170:
          dropItem = 1872;
          break;
        case 171:
          if (tileCache.frameX < (short) 10)
            break;
          WorldGen.dropXmasTree(x, y, 0);
          WorldGen.dropXmasTree(x, y, 1);
          WorldGen.dropXmasTree(x, y, 2);
          WorldGen.dropXmasTree(x, y, 3);
          break;
        case 174:
          dropItem = 713;
          break;
        case 175:
          dropItem = 717;
          break;
        case 176:
          dropItem = 718;
          break;
        case 177:
          dropItem = 719;
          break;
        case 178:
          switch ((int) tileCache.frameX / 18)
          {
            case 0:
              dropItem = 181;
              return;
            case 1:
              dropItem = 180;
              return;
            case 2:
              dropItem = 177;
              return;
            case 3:
              dropItem = 179;
              return;
            case 4:
              dropItem = 178;
              return;
            case 5:
              dropItem = 182;
              return;
            case 6:
              dropItem = 999;
              return;
            default:
              return;
          }
        case 179:
        case 180:
        case 181:
        case 182:
        case 183:
        case 381:
        case 534:
        case 536:
        case 539:
        case 625:
        case 627:
          dropItem = 3;
          break;
        case 188:
          dropItem = 276;
          break;
        case 189:
          dropItem = 751;
          break;
        case 190:
          dropItem = 183;
          break;
        case 191:
          dropItem = 9;
          break;
        case 193:
          dropItem = 762;
          break;
        case 194:
          dropItem = 154;
          break;
        case 195:
          dropItem = 763;
          break;
        case 196:
          dropItem = 765;
          break;
        case 197:
          dropItem = 767;
          break;
        case 198:
          dropItem = 775;
          break;
        case 200:
          dropItem = 835;
          break;
        case 201:
          if (tileCache.frameX != (short) 270)
            break;
          dropItem = 2887;
          break;
        case 202:
          dropItem = 824;
          break;
        case 203:
          dropItem = 836;
          break;
        case 204:
          dropItem = 880;
          break;
        case 206:
          dropItem = 883;
          break;
        case 208:
          dropItem = 911;
          break;
        case 210:
          dropItem = 937;
          break;
        case 211:
          dropItem = 947;
          break;
        case 213:
          dropItem = 965;
          break;
        case 214:
          dropItem = 85;
          break;
        case 221:
          dropItem = 1104;
          break;
        case 222:
          dropItem = 1105;
          break;
        case 223:
          dropItem = 1106;
          break;
        case 224:
          dropItem = 1103;
          break;
        case 225:
          if (Main.rand.Next(3) == 0)
          {
            tileCache.honey(true);
            tileCache.liquid = byte.MaxValue;
            break;
          }
          dropItem = 1124;
          if (Main.netMode == 1 || Main.rand.Next(2) != 0)
            break;
          int num7 = 1;
          if (Main.rand.Next(3) == 0)
            num7 = 2;
          for (int index1 = 0; index1 < num7; ++index1)
          {
            int Type = Main.rand.Next(210, 212);
            int index2 = NPC.NewNPC((IEntitySource) WorldGen.GetNPCSource_TileBreak(x, y), x * 16 + 8, y * 16 + 15, Type, 1);
            Main.npc[index2].velocity.X = (float) Main.rand.Next(-200, 201) * (1f / 500f);
            Main.npc[index2].velocity.Y = (float) Main.rand.Next(-200, 201) * (1f / 500f);
            Main.npc[index2].netUpdate = true;
          }
          break;
        case 226:
          dropItem = 1101;
          break;
        case 227:
          int num8 = (int) tileCache.frameX / 34;
          dropItem = 1107 + num8;
          if (num8 < 8 || num8 > 11)
            break;
          dropItem = 3385 + num8 - 8;
          break;
        case 229:
          dropItem = 1125;
          break;
        case 230:
          dropItem = 1127;
          break;
        case 232:
          dropItem = 1150;
          break;
        case 234:
          dropItem = 1246;
          break;
        case 239:
          int num9 = (int) tileCache.frameX / 18;
          if (num9 == 0)
            dropItem = 20;
          if (num9 == 1)
            dropItem = 703;
          if (num9 == 2)
            dropItem = 22;
          if (num9 == 3)
            dropItem = 704;
          if (num9 == 4)
            dropItem = 21;
          if (num9 == 5)
            dropItem = 705;
          if (num9 == 6)
            dropItem = 19;
          if (num9 == 7)
            dropItem = 706;
          if (num9 == 8)
            dropItem = 57;
          if (num9 == 9)
            dropItem = 117;
          if (num9 == 10)
            dropItem = 175;
          if (num9 == 11)
            dropItem = 381;
          if (num9 == 12)
            dropItem = 1184;
          if (num9 == 13)
            dropItem = 382;
          if (num9 == 14)
            dropItem = 1191;
          if (num9 == 15)
            dropItem = 391;
          if (num9 == 16)
            dropItem = 1198;
          if (num9 == 17)
            dropItem = 1006;
          if (num9 == 18)
            dropItem = 1225;
          if (num9 == 19)
            dropItem = 1257;
          if (num9 == 20)
            dropItem = 1552;
          if (num9 == 21)
            dropItem = 3261;
          if (num9 != 22)
            break;
          dropItem = 3467;
          break;
        case 248:
          dropItem = 1589;
          break;
        case 249:
          dropItem = 1591;
          break;
        case 250:
          dropItem = 1593;
          break;
        case 251:
          dropItem = 1725;
          break;
        case 252:
          dropItem = 1727;
          break;
        case 253:
          dropItem = 1729;
          break;
        case (ushort) byte.MaxValue:
        case 256:
        case 257:
        case 258:
        case 259:
        case 260:
        case 261:
          dropItem = 1970 + (int) tileCache.type - (int) byte.MaxValue;
          break;
        case 262:
        case 263:
        case 264:
        case 265:
        case 266:
        case 267:
        case 268:
          dropItem = 1970 + (int) tileCache.type - 262;
          break;
        case 272:
          dropItem = 1344;
          break;
        case 273:
          dropItem = 2119;
          break;
        case 274:
          dropItem = 2120;
          break;
        case 284:
          dropItem = 2173;
          break;
        case 311:
          dropItem = 2260;
          break;
        case 312:
          dropItem = 2261;
          break;
        case 313:
          dropItem = 2262;
          break;
        case 314:
          dropItem = Minecart.GetTrackItem(tileCache);
          break;
        case 315:
          dropItem = 2435;
          break;
        case 321:
          dropItem = 2503;
          break;
        case 322:
          dropItem = 2504;
          break;
        case 323:
          dropItem = 2504;
          if (Main.tenthAnniversaryWorld)
            dropItemStack += WorldGen.genRand.Next(2, 5);
          if (tileCache.frameX <= (short) 132 && tileCache.frameX >= (short) 88)
            secondaryItem = 27;
          int index3 = x;
          int index4 = y;
          while (!Main.tile[index3, index4].active() || !Main.tileSolid[(int) Main.tile[index3, index4].type])
            ++index4;
          if (!Main.tile[index3, index4].active())
            break;
          switch (Main.tile[index3, index4].type)
          {
            case 112:
              dropItem = 619;
              return;
            case 116:
              dropItem = 621;
              return;
            case 234:
              dropItem = 911;
              return;
            default:
              return;
          }
        case 324:
          switch ((int) tileCache.frameY / 22)
          {
            case 0:
              dropItem = 2625;
              return;
            case 1:
              dropItem = 2626;
              return;
            case 2:
              dropItem = 4072;
              return;
            case 3:
              dropItem = 4073;
              return;
            case 4:
              dropItem = 4071;
              return;
            default:
              return;
          }
        case 325:
          dropItem = 2692;
          break;
        case 326:
          dropItem = 2693;
          break;
        case 327:
          dropItem = 2694;
          break;
        case 328:
          dropItem = 2695;
          break;
        case 329:
          dropItem = 2697;
          break;
        case 330:
          dropItem = 71;
          break;
        case 331:
          dropItem = 72;
          break;
        case 332:
          dropItem = 73;
          break;
        case 333:
          dropItem = 74;
          break;
        case 336:
          dropItem = 2701;
          break;
        case 340:
          dropItem = 2751;
          break;
        case 341:
          dropItem = 2752;
          break;
        case 342:
          dropItem = 2753;
          break;
        case 343:
          dropItem = 2754;
          break;
        case 344:
          dropItem = 2755;
          break;
        case 345:
          dropItem = 2787;
          break;
        case 346:
          dropItem = 2792;
          break;
        case 347:
          dropItem = 2793;
          break;
        case 348:
          dropItem = 2794;
          break;
        case 350:
          dropItem = 2860;
          break;
        case 351:
          dropItem = 2868;
          break;
        case 353:
          dropItem = 2996;
          break;
        case 357:
          dropItem = 3066;
          break;
        case 365:
          dropItem = 3077;
          break;
        case 366:
          dropItem = 3078;
          break;
        case 367:
          dropItem = 3081;
          break;
        case 368:
          dropItem = 3086;
          break;
        case 369:
          dropItem = 3087;
          break;
        case 370:
          dropItem = 3100;
          break;
        case 371:
          dropItem = 3113;
          break;
        case 372:
          dropItem = 3117;
          break;
        case 379:
          dropItem = 3214;
          break;
        case 380:
          int num10 = (int) tileCache.frameY / 18;
          dropItem = 3215 + num10;
          break;
        case 383:
          dropItem = 620;
          break;
        case 385:
          dropItem = 3234;
          break;
        case 396:
          dropItem = 3271;
          break;
        case 397:
          dropItem = 3272;
          break;
        case 398:
          dropItem = 3274;
          break;
        case 399:
          dropItem = 3275;
          break;
        case 400:
          dropItem = 3276;
          break;
        case 401:
          dropItem = 3277;
          break;
        case 402:
          dropItem = 3338;
          break;
        case 403:
          dropItem = 3339;
          break;
        case 404:
          dropItem = 3347;
          break;
        case 407:
          dropItem = 3380;
          break;
        case 408:
          dropItem = 3460;
          break;
        case 409:
          dropItem = 3461;
          break;
        case 415:
          dropItem = 3573;
          break;
        case 416:
          dropItem = 3574;
          break;
        case 417:
          dropItem = 3575;
          break;
        case 418:
          dropItem = 3576;
          break;
        case 419:
          switch ((int) tileCache.frameX / 18)
          {
            case 0:
              dropItem = 3602;
              return;
            case 1:
              dropItem = 3618;
              return;
            case 2:
              dropItem = 3663;
              return;
            default:
              return;
          }
        case 420:
          switch ((int) tileCache.frameY / 18)
          {
            case 0:
              dropItem = 3603;
              return;
            case 1:
              dropItem = 3604;
              return;
            case 2:
              dropItem = 3605;
              return;
            case 3:
              dropItem = 3606;
              return;
            case 4:
              dropItem = 3607;
              return;
            case 5:
              dropItem = 3608;
              return;
            default:
              return;
          }
        case 421:
          dropItem = 3609;
          break;
        case 422:
          dropItem = 3610;
          break;
        case 423:
          TELogicSensor.Kill(x, y);
          switch ((int) tileCache.frameY / 18)
          {
            case 0:
              dropItem = 3613;
              return;
            case 1:
              dropItem = 3614;
              return;
            case 2:
              dropItem = 3615;
              return;
            case 3:
              dropItem = 3726;
              return;
            case 4:
              dropItem = 3727;
              return;
            case 5:
              dropItem = 3728;
              return;
            case 6:
              dropItem = 3729;
              return;
            default:
              return;
          }
        case 424:
          dropItem = 3616;
          break;
        case 426:
          dropItem = 3621;
          break;
        case 427:
          dropItem = 3622;
          break;
        case 428:
          switch ((int) tileCache.frameY / 18)
          {
            case 0:
              dropItem = 3630;
              break;
            case 1:
              dropItem = 3632;
              break;
            case 2:
              dropItem = 3631;
              break;
            case 3:
              dropItem = 3626;
              break;
          }
          PressurePlateHelper.DestroyPlate(new Point(x, y));
          break;
        case 429:
          dropItem = 3629;
          break;
        case 430:
          dropItem = 3633;
          break;
        case 431:
          dropItem = 3634;
          break;
        case 432:
          dropItem = 3635;
          break;
        case 433:
          dropItem = 3636;
          break;
        case 434:
          dropItem = 3637;
          break;
        case 435:
          dropItem = 3638;
          break;
        case 436:
          dropItem = 3639;
          break;
        case 437:
          dropItem = 3640;
          break;
        case 438:
          dropItem = 3641;
          break;
        case 439:
          dropItem = 3642;
          break;
        case 442:
          dropItem = 3707;
          break;
        case 445:
          dropItem = 3725;
          break;
        case 446:
          dropItem = 3736;
          break;
        case 447:
          dropItem = 3737;
          break;
        case 448:
          dropItem = 3738;
          break;
        case 449:
          dropItem = 3739;
          break;
        case 450:
          dropItem = 3740;
          break;
        case 451:
          dropItem = 3741;
          break;
        case 458:
          dropItem = 3754;
          break;
        case 459:
          dropItem = 3755;
          break;
        case 460:
          dropItem = 3756;
          break;
        case 472:
          dropItem = 3951;
          break;
        case 473:
          dropItem = 3953;
          break;
        case 474:
          dropItem = 3955;
          break;
        case 476:
          dropItem = 4040;
          break;
        case 478:
          dropItem = 4050;
          break;
        case 479:
          dropItem = 4051;
          break;
        case 494:
          dropItem = 4089;
          break;
        case 495:
          dropItem = 4090;
          break;
        case 496:
          dropItem = 4091;
          break;
        case 498:
          dropItem = 4139;
          break;
        case 500:
          dropItem = 4229;
          break;
        case 501:
          dropItem = 4230;
          break;
        case 502:
          dropItem = 4231;
          break;
        case 503:
          dropItem = 4232;
          break;
        case 507:
          dropItem = 4277;
          break;
        case 508:
          dropItem = 4278;
          break;
        case 512:
        case 513:
        case 514:
        case 515:
        case 516:
        case 517:
        case 535:
        case 537:
        case 540:
        case 626:
        case 628:
          dropItem = 129;
          break;
        case 519:
          if (tileCache.frameY != (short) 90 || WorldGen.genRand.Next(2) != 0)
            break;
          dropItem = 183;
          break;
        case 520:
          dropItem = 4326;
          break;
        case 528:
          if (WorldGen.genRand.Next(2) != 0)
            break;
          dropItem = 183;
          break;
        case 541:
          dropItem = 4392;
          break;
        case 546:
        case 557:
          dropItem = 4422;
          break;
        case 561:
          dropItem = 4554;
          break;
        case 562:
          dropItem = 4564;
          break;
        case 563:
          dropItem = 4547;
          break;
        case 566:
          dropItem = 999;
          break;
        case 571:
          dropItem = 4564;
          dropItemStack = WorldGen.genRand.Next(1, 3);
          break;
        case 574:
          dropItem = 4717;
          break;
        case 575:
          dropItem = 4718;
          break;
        case 576:
          dropItem = 4719;
          break;
        case 577:
          dropItem = 4720;
          break;
        case 578:
          dropItem = 4721;
          break;
        case 579:
          dropItem = 4761;
          break;
        case 583:
          WorldGen.SetGemTreeDrops(180, 4851, tileCache, ref dropItem, ref secondaryItem);
          if (dropItem != 3)
            break;
          dropItemStack = Main.rand.Next(1, 3);
          break;
        case 584:
          WorldGen.SetGemTreeDrops(181, 4852, tileCache, ref dropItem, ref secondaryItem);
          if (dropItem != 3)
            break;
          dropItemStack = Main.rand.Next(1, 3);
          break;
        case 585:
          WorldGen.SetGemTreeDrops(177, 4853, tileCache, ref dropItem, ref secondaryItem);
          if (dropItem != 3)
            break;
          dropItemStack = Main.rand.Next(1, 3);
          break;
        case 586:
          WorldGen.SetGemTreeDrops(179, 4854, tileCache, ref dropItem, ref secondaryItem);
          if (dropItem != 3)
            break;
          dropItemStack = Main.rand.Next(1, 3);
          break;
        case 587:
          WorldGen.SetGemTreeDrops(178, 4855, tileCache, ref dropItem, ref secondaryItem);
          if (dropItem != 3)
            break;
          dropItemStack = Main.rand.Next(1, 3);
          break;
        case 588:
          WorldGen.SetGemTreeDrops(182, 4856, tileCache, ref dropItem, ref secondaryItem);
          if (dropItem != 3)
            break;
          dropItemStack = Main.rand.Next(1, 3);
          break;
        case 589:
          WorldGen.SetGemTreeDrops(999, 4857, tileCache, ref dropItem, ref secondaryItem);
          if (dropItem != 3)
            break;
          dropItemStack = Main.rand.Next(1, 3);
          break;
        case 593:
          dropItem = 4868;
          break;
        case 618:
          dropItem = 4962;
          break;
        case 624:
          dropItem = 5114;
          break;
        case 630:
          dropItem = 5137;
          break;
        case 631:
          dropItem = 5138;
          break;
        case 633:
          dropItem = 172;
          break;
        case 635:
          dropItem = 5215;
          break;
        case 637:
          if (Main.rand.Next(100) != 0)
            break;
          dropItem = 5214;
          break;
        case 641:
          dropItem = 5306;
          break;
        case 646:
          dropItem = 5322;
          break;
        case 650:
          int num11 = (int) tileCache.frameX / 18;
          if (num11 < 6)
          {
            dropItem = 3;
            break;
          }
          if (num11 < 12)
          {
            dropItem = 2;
            break;
          }
          if (num11 < 20)
          {
            dropItem = 154;
            break;
          }
          if (num11 < 28)
          {
            dropItem = 154;
            break;
          }
          if (num11 < 36)
          {
            dropItem = 9;
            break;
          }
          if (num11 < 42)
          {
            dropItem = 593;
            break;
          }
          if (num11 < 48)
          {
            dropItem = 664;
            break;
          }
          if (num11 < 54)
          {
            dropItem = 150;
            break;
          }
          if (num11 < 60)
          {
            dropItem = 3271;
            break;
          }
          if (num11 < 66)
          {
            dropItem = 3086;
            break;
          }
          if (num11 < 72)
          {
            dropItem = 3081;
            break;
          }
          if (num11 < 73)
          {
            dropItem = 62;
            break;
          }
          if (num11 >= 77)
            break;
          dropItem = 169;
          break;
        case 656:
          dropItem = 5333;
          break;
        case 659:
          dropItem = 5349;
          break;
        case 666:
          dropItem = 5395;
          break;
        case 667:
          dropItem = 5398;
          break;
        case 668:
          dropItem = 5400;
          break;
        case 669:
          dropItem = 5401;
          break;
        case 670:
          dropItem = 5402;
          break;
        case 671:
          dropItem = 5403;
          break;
        case 672:
          dropItem = 5404;
          break;
        case 673:
          dropItem = 5405;
          break;
        case 674:
          dropItem = 5406;
          break;
        case 675:
          dropItem = 5407;
          break;
        case 676:
          dropItem = 5408;
          break;
        case 677:
          dropItem = 5417;
          break;
        case 678:
          dropItem = 5419;
          break;
        case 679:
          dropItem = 5421;
          break;
        case 680:
          dropItem = 5423;
          break;
        case 681:
          dropItem = 5425;
          break;
        case 682:
          dropItem = 5427;
          break;
        case 683:
          dropItem = 5433;
          break;
        case 684:
          dropItem = 5435;
          break;
        case 685:
          dropItem = 5429;
          break;
        case 686:
          dropItem = 5431;
          break;
        case 687:
          dropItem = 5439;
          break;
        case 688:
          dropItem = 5440;
          break;
        case 689:
          dropItem = 5441;
          break;
        case 690:
          dropItem = 5442;
          break;
        case 691:
          dropItem = 5443;
          break;
        case 692:
          dropItem = 5444;
          break;
      }
    }

    private static void SetGemTreeDrops(
      int gemType,
      int seedType,
      Tile tileCache,
      ref int dropItem,
      ref int secondaryItem)
    {
      dropItem = Main.rand.Next(10) != 0 ? 3 : gemType;
      if (tileCache.frameX < (short) 22 || tileCache.frameY < (short) 198 || Main.rand.Next(2) != 0)
        return;
      secondaryItem = seedType;
    }

    private static void SetVanityTreeDrops(int dropType, Tile tileCache, ref int dropItem)
    {
      if (Main.rand.Next(2) != 0)
        return;
      dropItem = dropType;
    }

    public static bool IsHarvestableHerbWithSeed(int type, int style)
    {
      if (type == 82 || type != 84 && type != 83)
        return false;
      bool flag = false;
      if (type == 84)
        flag = true;
      if (style == 0 && Main.dayTime)
        flag = true;
      if (style == 1 && !Main.dayTime)
        flag = true;
      if (style == 3 && !Main.dayTime && (Main.bloodMoon || Main.moonPhase == 0))
        flag = true;
      if (style == 4 && (Main.raining || (double) Main.cloudAlpha > 0.0))
        flag = true;
      if (style == 5 && !Main.raining && Main.dayTime && Main.time > 40500.0)
        flag = true;
      return flag;
    }

    private static bool KillTile_ShouldDropSeeds(int x, int y)
    {
      if (Main.rand.Next(2) != 0)
        return false;
      return WorldGen.GetPlayerForTile(x, y).HasItem(281) || WorldGen.GetPlayerForTile(x, y).HasItem(986);
    }

    private static void KillTile_GetTreeDrops(
      int i,
      int j,
      Tile tileCache,
      ref bool bonusWood,
      ref int dropItem,
      ref int secondaryItem)
    {
      if (tileCache.frameX >= (short) 22 && tileCache.frameY >= (short) 198)
      {
        if (Main.netMode != 1)
        {
          if (WorldGen.genRand.Next(2) == 0)
          {
            int index = j;
            while (Main.tile[i, index] != null && (!Main.tile[i, index].active() || !Main.tileSolid[(int) Main.tile[i, index].type] || Main.tileSolidTop[(int) Main.tile[i, index].type]))
              ++index;
            if (Main.tile[i, index] != null)
            {
              Tile tile = Main.tile[i, index];
              if (tile.type == (ushort) 2 || tile.type == (ushort) 109 || tile.type == (ushort) 477 || tile.type == (ushort) 492 || tile.type == (ushort) 147 || tile.type == (ushort) 199 || tile.type == (ushort) 23 || tile.type == (ushort) 633)
              {
                dropItem = 9;
                secondaryItem = 27;
              }
              else
                dropItem = 9;
            }
          }
          else
            dropItem = 9;
        }
      }
      else
        dropItem = 9;
      if (dropItem != 9)
        return;
      int x;
      int y;
      WorldGen.GetTreeBottom(i, j, out x, out y);
      if (Main.tile[x, y].active())
      {
        switch (Main.tile[x, y].type)
        {
          case 23:
          case 661:
            dropItem = 619;
            break;
          case 60:
            dropItem = 620;
            break;
          case 70:
            dropItem = WorldGen.genRand.Next(2) != 0 ? 0 : 183;
            break;
          case 109:
          case 492:
            dropItem = 621;
            break;
          case 147:
            dropItem = 2503;
            break;
          case 199:
          case 662:
            dropItem = 911;
            break;
          case 633:
            dropItem = 5215;
            break;
        }
      }
      int closest = (int) Player.FindClosest(new Vector2((float) (x * 16), (float) (y * 16)), 16, 16);
      int axe = Main.player[closest].inventory[Main.player[closest].selectedItem].axe;
      if (WorldGen.genRand.Next(100) >= axe && Main.rand.Next(3) != 0)
        return;
      bonusWood = true;
    }

    private static void KillTile_DropBait(int i, int j, Tile tileCache)
    {
      int maxValue1 = -1;
      int maxValue2 = -1;
      int maxValue3 = -1;
      int maxValue4 = -1;
      int closest = (int) Player.FindClosest(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16);
      if (tileCache.type == (ushort) 3)
      {
        maxValue1 = 400;
        maxValue2 = 100;
        if (Main.player[closest].flowerBoots && tileCache.frameX >= (short) 108)
        {
          maxValue1 *= 10000;
          maxValue2 *= 10000;
        }
      }
      if (tileCache.type == (ushort) 73)
      {
        maxValue1 = 200;
        maxValue2 = 50;
        if (Main.player[closest].flowerBoots && tileCache.frameX >= (short) 108)
        {
          maxValue1 *= 10000;
          maxValue2 *= 10000;
        }
      }
      if (tileCache.type == (ushort) 637)
      {
        maxValue4 = 100;
        if (Main.player[closest].flowerBoots && tileCache.frameX >= (short) 108)
          maxValue4 *= 10000;
      }
      if (tileCache.type == (ushort) 61)
      {
        maxValue3 = 80;
        if (Main.player[closest].flowerBoots && tileCache.frameX >= (short) 108)
          maxValue3 *= 10000;
      }
      if (tileCache.type == (ushort) 74)
      {
        maxValue3 = 40;
        if (Main.player[closest].flowerBoots && tileCache.frameX >= (short) 108)
          maxValue3 *= 10000;
      }
      if (tileCache.type == (ushort) 62)
        maxValue3 = 250;
      if (tileCache.type == (ushort) 185)
      {
        if (tileCache.frameY == (short) 0 && tileCache.frameX < (short) 214)
          maxValue1 = 6;
        if (tileCache.frameY == (short) 18 && (tileCache.frameX < (short) 214 || tileCache.frameX >= (short) 1368))
          maxValue1 = 6;
      }
      else if (tileCache.type == (ushort) 186)
      {
        if (tileCache.frameX >= (short) 378 && tileCache.frameX <= (short) 700)
          maxValue1 = 6;
      }
      else if (tileCache.type == (ushort) 187)
      {
        if (tileCache.frameX >= (short) 756 && tileCache.frameX <= (short) 916)
          maxValue1 = 6;
        if (tileCache.frameX <= (short) 322)
          maxValue1 = 6;
      }
      else if (tileCache.type == (ushort) 233)
        maxValue3 = 10;
      int Type1 = 357;
      if (Main.player[closest].ZoneGraveyard)
        Type1 = 606;
      if (maxValue1 > 0 && NPC.CountNPCS(Type1) < 5 && WorldGen.genRand.Next(maxValue1) == 0)
      {
        int Type2 = Type1;
        if (Type1 == 357 && (double) Player.GetClosestRollLuck(i, j, NPC.goldCritterChance) == 0.0)
          Type2 = 448;
        int index = NPC.NewNPC((IEntitySource) WorldGen.GetNPCSource_TileBreak(i, j), i * 16 + 10, j * 16, Type2);
        Main.npc[index].TargetClosest();
        Main.npc[index].velocity.Y = (float) WorldGen.genRand.Next(-50, -21) * 0.1f;
        Main.npc[index].velocity.X = (float) WorldGen.genRand.Next(0, 26) * 0.1f * (float) -Main.npc[index].direction;
        Main.npc[index].direction *= -1;
        Main.npc[index].netUpdate = true;
      }
      if (maxValue2 > 0 && NPC.CountNPCS(377) < 5 && WorldGen.genRand.Next(maxValue2) == 0)
      {
        int Type3 = 377;
        if ((double) Player.GetClosestRollLuck(i, j, NPC.goldCritterChance) == 0.0)
          Type3 = 446;
        int index = NPC.NewNPC((IEntitySource) WorldGen.GetNPCSource_TileBreak(i, j), i * 16 + 10, j * 16, Type3);
        Main.npc[index].TargetClosest();
        Main.npc[index].velocity.Y = (float) WorldGen.genRand.Next(-50, -21) * 0.1f;
        Main.npc[index].velocity.X = (float) WorldGen.genRand.Next(0, 26) * 0.1f * (float) -Main.npc[index].direction;
        Main.npc[index].direction *= -1;
        Main.npc[index].netUpdate = true;
      }
      if (maxValue3 > 0 && NPC.CountNPCS(485) + NPC.CountNPCS(486) + NPC.CountNPCS(487) < 8 && WorldGen.genRand.Next(maxValue3) == 0)
      {
        int Type4 = 485;
        if (WorldGen.genRand.Next(4) == 0)
          Type4 = 486;
        if (WorldGen.genRand.Next(12) == 0)
          Type4 = 487;
        int index = NPC.NewNPC((IEntitySource) WorldGen.GetNPCSource_TileBreak(i, j), i * 16 + 10, j * 16, Type4);
        Main.npc[index].TargetClosest();
        Main.npc[index].velocity.Y = (float) WorldGen.genRand.Next(-50, -21) * 0.1f;
        Main.npc[index].velocity.X = (float) WorldGen.genRand.Next(0, 26) * 0.1f * (float) -Main.npc[index].direction;
        Main.npc[index].direction *= -1;
        Main.npc[index].netUpdate = true;
      }
      if (maxValue4 <= 0 || NPC.CountNPCS(654) + NPC.CountNPCS(653) >= 8 || WorldGen.genRand.Next(maxValue4) != 0)
        return;
      int Type5 = 653;
      if (WorldGen.genRand.Next(2) == 0)
        Type5 = 654;
      int index1 = NPC.NewNPC((IEntitySource) WorldGen.GetNPCSource_TileBreak(i, j), i * 16 + 10, j * 16, Type5);
      Main.npc[index1].TargetClosest();
      Main.npc[index1].velocity.Y = (float) WorldGen.genRand.Next(-50, -21) * 0.1f;
      Main.npc[index1].velocity.X = (float) WorldGen.genRand.Next(0, 26) * 0.1f * (float) -Main.npc[index1].direction;
      Main.npc[index1].direction *= -1;
      Main.npc[index1].netUpdate = true;
    }

    public static void KillTile_PlaySounds(int i, int j, bool fail, Tile tileCache)
    {
      if (WorldGen.gen)
        return;
      int type = (int) tileCache.type;
      if (type == (int) sbyte.MaxValue || type == 623)
        SoundEngine.PlaySound(SoundID.Item27, i * 16, j * 16);
      else if (type == 147 || type == 224)
      {
        if (WorldGen.genRand.Next(2) == 0)
          SoundEngine.PlaySound(SoundID.Item48, i * 16, j * 16);
        else
          SoundEngine.PlaySound(SoundID.Item49, i * 16, j * 16);
      }
      else if (type == 161 || type == 163 || type == 164 || type == 200 || type == 541)
        SoundEngine.PlaySound(SoundID.Item50, i * 16, j * 16);
      else if (type == 518 || type == 519 || type == 528 || type == 529 || type == 549 || type == 637 || type == 638 || type == 636)
        SoundEngine.PlaySound(6, i * 16, j * 16);
      else if (type == 530 && tileCache.frameX < (short) 270)
        SoundEngine.PlaySound(6, i * 16, j * 16);
      else if (type == 3 || type == 110)
      {
        SoundEngine.PlaySound(6, i * 16, j * 16);
      }
      else
      {
        switch (type)
        {
          case 24:
            SoundEngine.PlaySound(6, i * 16, j * 16);
            break;
          case 254:
            SoundEngine.PlaySound(6, i * 16, j * 16);
            break;
          default:
            if (Main.tileAlch[type] || type == 384 || type == 227 || type == 32 || type == 51 || type == 52 || type == 61 || type == 62 || type == 69 || type == 655 || type == 71 || type == 73 || type == 74 || type == 113 || type == 115 || type == 184 || type == 192 || type == 205 || type == 233 || type == 352 || type == 382 || type == 624 || type == 656)
            {
              SoundEngine.PlaySound(6, i * 16, j * 16);
              break;
            }
            switch (type)
            {
              case 201:
                SoundEngine.PlaySound(6, i * 16, j * 16);
                break;
              case 485:
                SoundEngine.PlaySound(4, i * 16, j * 16, 11);
                break;
              default:
                if (type == 481 || type == 482 || type == 483)
                {
                  SoundEngine.PlaySound(SoundID.Item127, i * 16, j * 16);
                  break;
                }
                if (type == 1 || type == 6 || type == 7 || type == 8 || type == 9 || type == 22 || type == 140 || type == 25 || type == 37 || type == 38 || type == 39 || type == 41 || type == 43 || type == 44 || type == 45 || type == 46 || type == 47 || type == 48 || type == 56 || type == 58 || type == 63 || type == 64 || type == 65 || type == 66 || type == 67 || type == 68 || type == 75 || type == 76 || type == 107 || type == 108 || type == 111 || type == 117 || type == 118 || type == 119 || type == 120 || type == 121 || type == 122 || type == 150 || type == 151 || type == 152 || type == 153 || type == 154 || type == 155 || type == 156 || type == 160 || type == 161 || type == 166 || type == 167 || type == 168 || type == 169 || type == 175 || type == 176 || type == 177 || type == 203 || type == 202 || type == 204 || type == 206 || type == 211 || type == 221 || type == 222 || type == 223 || type == 226 || type == 248 || type == 249 || type == 250 || type == 272 || type == 273 || type == 274 || type == 478 || type == 284 || type == 325 || type == 346 || type == 347 || type == 348 || type == 350 || type == 367 || type == 357 || type == 368 || type == 369 || type == 370 || type == 407 || type == 472 || type == 473 || type == 500 || type == 501 || type == 502 || type == 503 || type == 546 || type == 557 || type == 566 || type == 618 || type == 408 || type == 409 || type == 669 || type == 670 || type == 671 || type == 672 || type == 673 || type == 674 || type == 675 || type == 676 || type == 677 || type == 678 || type == 679 || type == 680 || type == 681 || type == 682 || type == 683 || type == 684 || type == 685 || type == 686 || type == 687 || type == 689 || type == 688 || type == 690 || type == 691 || type == 692)
                {
                  SoundEngine.PlaySound(21, i * 16, j * 16);
                  break;
                }
                if (type == 666)
                {
                  SoundEngine.PlaySound(SoundID.Item177, i * 16, j * 16);
                  break;
                }
                if (type == 231 || type == 195 || type == 474)
                {
                  SoundEngine.PlaySound(4, i * 16, j * 16);
                  if (type == 231)
                  {
                    SoundEngine.PlaySound(SoundID.Item173, i * 16, j * 16);
                    break;
                  }
                  break;
                }
                if (type == 26 && tileCache.frameX >= (short) 54)
                {
                  SoundEngine.PlaySound(4, i * 16, j * 16);
                  break;
                }
                if (type == 314)
                {
                  SoundEngine.PlaySound(SoundID.Item52, i * 16, j * 16);
                  break;
                }
                if (type >= 330 && type <= 333)
                {
                  SoundEngine.PlaySound(18, i * 16, j * 16);
                  break;
                }
                if ((type == 162 || type == 385 || type == 129 || type == 165 && tileCache.frameX < (short) 54) && !fail)
                {
                  SoundEngine.PlaySound(SoundID.Item27, i * 16, j * 16);
                  break;
                }
                if (type != 138)
                {
                  SoundEngine.PlaySound(0, i * 16, j * 16);
                  break;
                }
                break;
            }
            break;
        }
      }
      if (fail)
        return;
      if (tileCache.type == (ushort) 13)
        SoundEngine.PlaySound(13, i * 16, j * 16);
      else if (tileCache.type == (ushort) 54)
        SoundEngine.PlaySound(13, i * 16, j * 16);
      else if (tileCache.type == (ushort) 326)
        SoundEngine.PlaySound(13, i * 16, j * 16);
      else if (tileCache.type == (ushort) 327)
        SoundEngine.PlaySound(13, i * 16, j * 16);
      else if (tileCache.type == (ushort) 458)
        SoundEngine.PlaySound(13, i * 16, j * 16);
      else if (tileCache.type == (ushort) 459)
        SoundEngine.PlaySound(13, i * 16, j * 16);
      else if (tileCache.type == (ushort) 345)
        SoundEngine.PlaySound(13, i * 16, j * 16);
      else if (tileCache.type == (ushort) 328)
        SoundEngine.PlaySound(13, i * 16, j * 16);
      else if (tileCache.type == (ushort) 329)
        SoundEngine.PlaySound(13, i * 16, j * 16);
      else if (tileCache.type == (ushort) 507)
      {
        SoundEngine.PlaySound(13, i * 16, j * 16);
      }
      else
      {
        if (tileCache.type != (ushort) 508)
          return;
        SoundEngine.PlaySound(13, i * 16, j * 16);
      }
    }

    public static Microsoft.Xna.Framework.Rectangle? GetTileVisualHitbox(int x, int y)
    {
      Tile tile = Main.tile[x, y];
      if (tile == null || !tile.nactive())
        return new Microsoft.Xna.Framework.Rectangle?();
      Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(x * 16, y * 16, 16, 16);
      if (tile.type == (ushort) 323)
        rectangle.X += (int) tile.frameY;
      if (tile.halfBrick())
      {
        rectangle.Y += 8;
        rectangle.Height = 8;
      }
      return new Microsoft.Xna.Framework.Rectangle?(rectangle);
    }

    public static int KillTile_GetTileDustAmount(bool fail, Tile tileCache)
    {
      switch (tileCache.type)
      {
        case 125:
        case 138:
        case 172:
        case 287:
        case 300:
        case 301:
        case 302:
        case 303:
        case 304:
        case 305:
        case 306:
        case 307:
        case 308:
        case 354:
        case 355:
        case 373:
        case 374:
        case 375:
        case 376:
        case 461:
        case 484:
        case 499:
        case 564:
        case 565:
        case 593:
        case 594:
        case 617:
        case 664:
        case 665:
          return 0;
        case 184:
          if ((int) tileCache.frameX / 22 >= 5)
            return 5;
          return !fail ? 10 : 3;
        case 231:
          return !fail ? 6 : 3;
        case 481:
        case 482:
        case 483:
          return 3;
        case 534:
        case 536:
        case 539:
        case 625:
        case 627:
          return !fail ? 5 : 3;
        case 541:
          return 1;
        case 549:
          return 2;
        case 630:
        case 631:
          return 0;
        case 654:
          return 0;
        default:
          return !fail ? 10 : 3;
      }
    }

    public static int KillTile_MakeTileDust(int i, int j, Tile tileCache)
    {
      int Type1 = 0;
      if (tileCache.type == (ushort) 216)
        Type1 = -1;
      if (tileCache.type == (ushort) 324)
        Type1 = tileCache.frameY != (short) 0 ? 281 + (int) tileCache.frameX / 18 : 280;
      if (tileCache.type == (ushort) 216)
        Type1 = -1;
      if (tileCache.type == (ushort) 335)
        Type1 = -1;
      if (tileCache.type == (ushort) 338)
        Type1 = -1;
      if (tileCache.type == (ushort) 0)
        Type1 = 0;
      if (tileCache.type == (ushort) 192)
        Type1 = 3;
      if (tileCache.type == (ushort) 208)
        Type1 = 126;
      else if (tileCache.type == (ushort) 408 || tileCache.type == (ushort) 409)
        Type1 = 265;
      else if (tileCache.type == (ushort) 669)
        Type1 = 314;
      else if (tileCache.type == (ushort) 670)
        Type1 = 315;
      else if (tileCache.type == (ushort) 671)
        Type1 = 316;
      else if (tileCache.type == (ushort) 672)
        Type1 = 317;
      else if (tileCache.type == (ushort) 673)
        Type1 = 318;
      else if (tileCache.type == (ushort) 674)
        Type1 = 319;
      else if (tileCache.type == (ushort) 675)
        Type1 = 320;
      else if (tileCache.type == (ushort) 676)
        Type1 = 321;
      if (tileCache.type == (ushort) 16)
      {
        Type1 = 1;
        if (tileCache.frameX >= (short) 36)
          Type1 = 82;
      }
      else if (tileCache.type == (ushort) 415 || tileCache.type == (ushort) 500)
        Type1 = 6;
      else if (tileCache.type == (ushort) 416 || tileCache.type == (ushort) 501)
        Type1 = 61;
      else if (tileCache.type == (ushort) 417 || tileCache.type == (ushort) 502)
        Type1 = 242;
      else if (tileCache.type == (ushort) 418 || tileCache.type == (ushort) 503)
        Type1 = 135;
      else if (tileCache.type == (ushort) 474)
        Type1 = 18;
      if (tileCache.type == (ushort) 1 || tileCache.type == (ushort) 17 || tileCache.type == (ushort) 38 || tileCache.type == (ushort) 39 || tileCache.type == (ushort) 41 || tileCache.type == (ushort) 43 || tileCache.type == (ushort) 44 || tileCache.type == (ushort) 481 || tileCache.type == (ushort) 482 || tileCache.type == (ushort) 483 || tileCache.type == (ushort) 48 || Main.tileStone[(int) tileCache.type] || tileCache.type == (ushort) 85 || tileCache.type == (ushort) 90 || tileCache.type == (ushort) 92 || tileCache.type == (ushort) 96 || tileCache.type == (ushort) 97 || tileCache.type == (ushort) 99 || tileCache.type == (ushort) 117 || tileCache.type == (ushort) 130 || tileCache.type == (ushort) 131 || tileCache.type == (ushort) 132 || tileCache.type == (ushort) 135 || tileCache.type == (ushort) 135 || tileCache.type == (ushort) 142 || tileCache.type == (ushort) 143 || tileCache.type == (ushort) 144 || tileCache.type == (ushort) 210 || tileCache.type == (ushort) 207 || tileCache.type == (ushort) 235 || tileCache.type == (ushort) 247 || tileCache.type == (ushort) 272 || tileCache.type == (ushort) 273 || tileCache.type == (ushort) 283 || tileCache.type == (ushort) 410 || tileCache.type == (ushort) 480 || tileCache.type == (ushort) 509 || tileCache.type == (ushort) 618 || tileCache.type == (ushort) 657 || tileCache.type == (ushort) 658 || tileCache.type == (ushort) 677 || tileCache.type == (ushort) 678 || tileCache.type == (ushort) 679)
        Type1 = 1;
      if (tileCache.type == (ushort) 379)
        Type1 = 257;
      if (tileCache.type == (ushort) 311)
        Type1 = 207;
      if (tileCache.type == (ushort) 312)
        Type1 = 208;
      if (tileCache.type == (ushort) 313)
        Type1 = 209;
      if (tileCache.type == (ushort) 104)
        Type1 = -1;
      if (tileCache.type == (ushort) 95 || tileCache.type == (ushort) 98 || tileCache.type == (ushort) 100 || tileCache.type == (ushort) 174 || tileCache.type == (ushort) 173)
        Type1 = 6;
      if (tileCache.type == (ushort) 30 || tileCache.type == (ushort) 86 || tileCache.type == (ushort) 94 || tileCache.type == (ushort) 106 || tileCache.type == (ushort) 114 || tileCache.type == (ushort) 124 || tileCache.type == (ushort) 128 || tileCache.type == (ushort) 269)
        Type1 = 7;
      if (tileCache.type == (ushort) 372)
        Type1 = 242;
      if (tileCache.type == (ushort) 646)
        Type1 = 29;
      if (tileCache.type == (ushort) 49)
        Type1 = 29;
      if (tileCache.type == (ushort) 371)
        Type1 = 243;
      if (tileCache.type == (ushort) 334)
        Type1 = 7;
      switch (tileCache.type)
      {
        case 10:
        case 11:
        case 87:
        case 89:
        case 93:
        case 139:
        case 209:
        case 319:
        case 320:
        case 386:
        case 387:
        case 390:
        case 405:
        case 406:
        case 411:
        case 412:
        case 419:
        case 420:
        case 421:
        case 422:
        case 423:
        case 424:
        case 425:
        case 428:
        case 429:
        case 441:
        case 442:
        case 445:
        case 446:
        case 447:
        case 448:
        case 449:
        case 450:
        case 451:
        case 452:
        case 453:
        case 455:
        case 456:
        case 457:
        case 462:
        case 463:
        case 464:
        case 465:
        case 466:
        case 468:
        case 476:
        case 486:
        case 487:
        case 489:
        case 490:
        case 491:
        case 493:
        case 494:
        case 497:
        case 510:
        case 511:
        case 520:
        case 521:
        case 522:
        case 523:
        case 524:
        case 525:
        case 526:
        case 527:
        case 531:
        case 545:
        case 547:
        case 548:
        case 560:
        case 564:
        case 565:
        case 567:
        case 572:
        case 579:
        case 591:
        case 592:
        case 593:
        case 594:
        case 613:
        case 614:
        case 621:
        case 622:
        case 623:
        case 624:
        case 630:
        case 631:
        case 656:
          Type1 = -1;
          break;
        case 41:
        case 481:
        case 677:
          Type1 = 275;
          break;
        case 43:
        case 482:
        case 678:
          Type1 = 276;
          break;
        case 44:
        case 483:
        case 679:
          Type1 = 277;
          break;
        case 184:
          int num1 = (int) tileCache.frameX / 22;
          switch (num1)
          {
            case 5:
              Type1 = 258;
              break;
            case 6:
              Type1 = 299;
              break;
            case 7:
              Type1 = 300;
              break;
            case 8:
              Type1 = 301;
              break;
            case 9:
              Type1 = 305;
              break;
            case 10:
              Type1 = 267;
              break;
            default:
              Type1 = 93 + num1;
              break;
          }
          break;
        case 407:
          Type1 = 10;
          break;
        case 454:
          Type1 = 139;
          break;
        case 472:
        case 546:
        case 557:
          Type1 = 8;
          break;
        case 473:
          Type1 = 82;
          break;
        case 498:
          Type1 = 30;
          break;
        case 512:
          Type1 = 93;
          break;
        case 513:
          Type1 = 94;
          break;
        case 514:
          Type1 = 95;
          break;
        case 515:
          Type1 = 96;
          break;
        case 516:
          Type1 = 97;
          break;
        case 517:
        case 687:
          Type1 = 258;
          break;
        case 535:
        case 689:
          Type1 = 299;
          break;
        case 537:
        case 690:
          Type1 = 300;
          break;
        case 540:
        case 688:
          Type1 = 301;
          break;
        case 541:
          Type1 = 226;
          break;
        case 583:
          Type1 = WorldGen.genRand.Next(10) == 0 ? 87 : 1;
          break;
        case 584:
          Type1 = WorldGen.genRand.Next(10) == 0 ? 86 : 1;
          break;
        case 585:
          Type1 = WorldGen.genRand.Next(10) == 0 ? 88 : 1;
          break;
        case 586:
          Type1 = WorldGen.genRand.Next(10) == 0 ? 89 : 1;
          break;
        case 587:
          Type1 = WorldGen.genRand.Next(10) == 0 ? 90 : 1;
          break;
        case 588:
          Type1 = WorldGen.genRand.Next(10) == 0 ? 91 : 1;
          break;
        case 589:
          Type1 = WorldGen.genRand.Next(10) == 0 ? 138 : 1;
          break;
        case 590:
          Type1 = 1;
          break;
        case 595:
          Type1 = 78;
          break;
        case 596:
          Type1 = 78;
          break;
        case 615:
          Type1 = 78;
          break;
        case 616:
          Type1 = 78;
          break;
        case 626:
        case 691:
          Type1 = 305;
          break;
        case 633:
          Type1 = WorldGen.genRand.Next(6) != 0 ? 237 : 36;
          break;
        case 634:
          Type1 = WorldGen.genRand.Next(10) != 0 ? 36 : 31;
          if (WorldGen.genRand.Next(12) == 0)
          {
            Type1 = 6;
            break;
          }
          break;
        case 637:
        case 638:
          Type1 = 237;
          break;
        case 668:
          Type1 = 0;
          break;
      }
      if (Main.tileMoss[(int) tileCache.type])
        Type1 = tileCache.type != (ushort) 381 ? (tileCache.type != (ushort) 534 ? (tileCache.type != (ushort) 536 ? (tileCache.type != (ushort) 539 ? (tileCache.type != (ushort) 625 ? (tileCache.type != (ushort) 627 ? (int) tileCache.type - 179 + 93 : 267) : 305) : 301) : 300) : 299) : 258;
      if (tileCache.type == (ushort) 240)
      {
        int num2 = (int) tileCache.frameX / 54;
        if (tileCache.frameY >= (short) 54)
          num2 += 36 * ((int) tileCache.frameY / 54);
        Type1 = 7;
        if (num2 == 16 || num2 == 17)
          Type1 = 26;
        if (num2 >= 46 && num2 <= 49)
          Type1 = -1;
      }
      if (tileCache.type == (ushort) 241)
        Type1 = 1;
      if (tileCache.type == (ushort) 242)
        Type1 = -1;
      int num3;
      if (tileCache.type == (ushort) 529)
      {
        switch (Main.tile[i, j + 1].type)
        {
          case 112:
            Type1 = num3 = 17;
            break;
          case 116:
            Type1 = num3 = 47;
            break;
          case 234:
            Type1 = num3 = 125;
            break;
          default:
            Type1 = i < WorldGen.beachDistance || i > Main.maxTilesX - WorldGen.beachDistance ? 290 : 289;
            break;
        }
      }
      if (tileCache.type == (ushort) 356)
        Type1 = -1;
      if (tileCache.type == (ushort) 663)
        Type1 = -1;
      if (tileCache.type == (ushort) 351)
        Type1 = -1;
      if (tileCache.type == (ushort) 246)
        Type1 = -1;
      if (tileCache.type == (ushort) 36)
        Type1 = -1;
      if (tileCache.type == (ushort) 365)
        Type1 = 239;
      if (tileCache.type == (ushort) 366)
        Type1 = 30;
      if (tileCache.type == (ushort) 504)
        Type1 = -1;
      if (tileCache.type == (ushort) 357 || tileCache.type == (ushort) 367 || tileCache.type == (ushort) 561)
        Type1 = 236;
      if (tileCache.type == (ushort) 368 || tileCache.type == (ushort) 369 || tileCache.type == (ushort) 576)
        Type1 = 240;
      if (tileCache.type == (ushort) 170)
        Type1 = 196;
      if (tileCache.type == (ushort) 315)
        Type1 = 225;
      if (tileCache.type == (ushort) 641)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 161 : 243;
      if (tileCache.type == (ushort) 659)
        Type1 = 308;
      if (tileCache.type == (ushort) 667)
        Type1 = 308;
      if (tileCache.type == (ushort) 346)
        Type1 = 128;
      if (tileCache.type == (ushort) 347)
        Type1 = 117;
      if (tileCache.type == (ushort) 348)
        Type1 = 42;
      if (tileCache.type == (ushort) 350)
        Type1 = 226;
      if (tileCache.type == (ushort) 370)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 23 : 6;
      if (tileCache.type == (ushort) 171)
        Type1 = WorldGen.genRand.Next(2) != 0 ? -1 : 196;
      if (tileCache.type == (ushort) 326)
        Type1 = 13;
      if (tileCache.type == (ushort) 327)
        Type1 = 13;
      if (tileCache.type == (ushort) 345)
        Type1 = 13;
      if (tileCache.type == (ushort) 458)
        Type1 = 13;
      if (tileCache.type == (ushort) 459)
        Type1 = 13;
      if (tileCache.type == (ushort) 336)
        Type1 = 6;
      if (tileCache.type == (ushort) 340)
        Type1 = 75;
      if (tileCache.type == (ushort) 341)
        Type1 = 65;
      if (tileCache.type == (ushort) 342)
        Type1 = 135;
      if (tileCache.type == (ushort) 343)
        Type1 = 169;
      if (tileCache.type == (ushort) 344)
        Type1 = 156;
      if (tileCache.type == (ushort) 328)
        Type1 = 13;
      if (tileCache.type == (ushort) 329)
        Type1 = 13;
      if (tileCache.type == (ushort) 507)
        Type1 = 13;
      if (tileCache.type == (ushort) 508)
        Type1 = 13;
      if (tileCache.type == (ushort) 562)
        Type1 = -1;
      if (tileCache.type == (ushort) 571)
        Type1 = 40;
      if (tileCache.type == (ushort) 563)
        Type1 = -1;
      if (tileCache.type == (ushort) 330)
        Type1 = 9;
      if (tileCache.type == (ushort) 331)
        Type1 = 11;
      if (tileCache.type == (ushort) 332)
        Type1 = 19;
      if (tileCache.type == (ushort) 333)
        Type1 = 11;
      if (tileCache.type == (ushort) 101)
        Type1 = -1;
      if (tileCache.type == (ushort) 19)
      {
        switch ((int) tileCache.frameY / 18)
        {
          case 0:
            Type1 = 7;
            break;
          case 1:
            Type1 = 77;
            break;
          case 2:
            Type1 = 78;
            break;
          case 3:
            Type1 = 79;
            break;
          case 4:
            Type1 = 26;
            break;
          case 5:
            Type1 = 126;
            break;
          case 6:
            Type1 = 275;
            break;
          case 7:
            Type1 = 277;
            break;
          case 8:
            Type1 = 276;
            break;
          case 9:
            Type1 = 1;
            break;
          case 10:
            Type1 = 214;
            break;
          case 11:
            Type1 = 214;
            break;
          case 12:
            Type1 = 214;
            break;
          case 13:
            Type1 = 109;
            break;
          case 14:
            Type1 = 13;
            break;
          case 15:
            Type1 = 189;
            break;
          case 16:
            Type1 = 191;
            break;
          case 17:
            Type1 = 215;
            break;
          case 18:
            Type1 = 26;
            break;
          case 19:
            Type1 = 214;
            break;
          case 20:
            Type1 = 4;
            break;
          case 21:
            Type1 = 10;
            break;
          case 22:
            Type1 = 32;
            break;
          case 23:
            Type1 = 78;
            break;
          case 24:
            Type1 = 147;
            break;
          case 25:
            Type1 = 40;
            break;
          case 26:
            Type1 = 226;
            break;
          case 27:
            Type1 = 23;
            break;
          case 28:
            Type1 = 240;
            break;
          case 29:
            Type1 = 236;
            break;
          case 30:
            Type1 = 68 + Main.rand.Next(3);
            break;
          case 31:
            Type1 = 10;
            break;
          case 32:
            Type1 = 78;
            break;
          case 33:
            Type1 = 148;
            break;
          case 34:
            Type1 = 5;
            break;
          case 35:
            Type1 = 80;
            break;
          case 37:
            Type1 = 18;
            break;
          case 38:
            Type1 = 6;
            break;
          case 39:
            Type1 = 61;
            break;
          case 40:
            Type1 = 242;
            break;
          case 41:
            Type1 = 135;
            break;
          case 42:
            Type1 = 287;
            break;
          case 44:
            Type1 = 273;
            break;
          case 45:
            Type1 = 243;
            break;
          case 46:
            Type1 = 243;
            break;
          case 47:
            Type1 = 36;
            break;
          case 48:
            Type1 = 226;
            break;
          default:
            Type1 = 1;
            break;
        }
      }
      if (tileCache.type == (ushort) 79)
      {
        int num4 = (int) tileCache.frameY / 36;
        Type1 = num4 != 0 ? (num4 != 1 ? (num4 != 2 ? (num4 != 3 ? (num4 != 4 ? (num4 != 8 ? (num4 < 9 ? 1 : -1) : 109) : 126) : 79) : 78) : 77) : 7;
      }
      if (tileCache.type == (ushort) 18)
      {
        switch ((int) tileCache.frameX / 36)
        {
          case 0:
            Type1 = 7;
            break;
          case 1:
            Type1 = 77;
            break;
          case 2:
            Type1 = 78;
            break;
          case 3:
            Type1 = 79;
            break;
          case 4:
            Type1 = 26;
            break;
          case 5:
            Type1 = 40;
            break;
          case 6:
            Type1 = 5;
            break;
          case 7:
            Type1 = 26;
            break;
          case 8:
            Type1 = 4;
            break;
          case 9:
            Type1 = 126;
            break;
          case 10:
            Type1 = 148;
            break;
          case 11:
          case 12:
          case 13:
            Type1 = 1;
            break;
          case 14:
            Type1 = 109;
            break;
          case 15:
            Type1 = 126;
            break;
          default:
            Type1 = -1;
            break;
        }
      }
      if (tileCache.type == (ushort) 14 || tileCache.type == (ushort) 87 || tileCache.type == (ushort) 88 || tileCache.type == (ushort) 469)
        Type1 = -1;
      if (tileCache.type >= (ushort) byte.MaxValue && tileCache.type <= (ushort) 261)
      {
        int num5 = (int) tileCache.type - (int) byte.MaxValue;
        Type1 = 86 + num5;
        if (num5 == 6)
          Type1 = 138;
      }
      if (tileCache.type >= (ushort) 262 && tileCache.type <= (ushort) 268)
      {
        int num6 = (int) tileCache.type - 262;
        Type1 = 86 + num6;
        if (num6 == 6)
          Type1 = 138;
      }
      if (tileCache.type == (ushort) 178)
      {
        int num7 = (int) tileCache.frameX / 18;
        Type1 = 86 + num7;
        if (num7 == 6)
          Type1 = 138;
      }
      if (tileCache.type == (ushort) 440)
      {
        switch ((int) tileCache.frameX / 54)
        {
          case 0:
            Type1 = 90;
            break;
          case 1:
            Type1 = 88;
            break;
          case 2:
            Type1 = 89;
            break;
          case 3:
            Type1 = 87;
            break;
          case 4:
            Type1 = 86;
            break;
          case 5:
            Type1 = 91;
            break;
          case 6:
            Type1 = 138;
            break;
          default:
            Type1 = -1;
            break;
        }
        if (tileCache.frameY < (short) 54)
          Type1 = -1;
      }
      switch (tileCache.type)
      {
        case 426:
        case 427:
          Type1 = 90;
          break;
        case 430:
        case 435:
          Type1 = 89;
          break;
        case 431:
        case 436:
          Type1 = 88;
          break;
        case 432:
        case 437:
          Type1 = 87;
          break;
        case 433:
        case 438:
          Type1 = 86;
          break;
        case 434:
        case 439:
          Type1 = 91;
          break;
        case 496:
          Type1 = 109;
          break;
        case 549:
          Type1 = 3;
          break;
        case 552:
          Type1 = 32;
          break;
      }
      if (tileCache.type == (ushort) 186)
        Type1 = tileCache.frameX > (short) 360 ? (tileCache.frameX > (short) 846 ? (tileCache.frameX > (short) 954 ? (tileCache.frameX > (short) 1062 ? (tileCache.frameX > (short) 1170 ? (tileCache.frameX > (short) 1332 ? (tileCache.frameX > (short) 1386 ? 80 : 10) : 0) : 10) : 11) : 9) : 1) : 26;
      if (tileCache.type == (ushort) 187)
      {
        if (tileCache.frameX <= (short) 144)
          Type1 = 1;
        else if (tileCache.frameX <= (short) 306)
          Type1 = 38;
        else if (tileCache.frameX <= (short) 468)
          Type1 = 36;
        else if (tileCache.frameX <= (short) 738)
          Type1 = 30;
        else if (tileCache.frameX <= (short) 970)
          Type1 = 1;
        else if (tileCache.frameX <= (short) 1132)
          Type1 = 148;
        else if (tileCache.frameX <= (short) 1132)
          Type1 = 155;
        else if (tileCache.frameX <= (short) 1348)
          Type1 = 1;
        else if (tileCache.frameX <= (short) 1564)
          Type1 = 0;
        else if (tileCache.frameX <= (short) 1890)
          Type1 = 250;
        else if (tileCache.frameX <= (short) 2196)
          Type1 = 240;
        else if (tileCache.frameX <= (short) 2520)
          Type1 = 236;
      }
      if (tileCache.type == (ushort) 647)
      {
        int num8 = (int) tileCache.frameX / 54;
        if (num8 < 7)
          Type1 = 26;
        else if (num8 < 16)
          Type1 = 1;
        else if (num8 < 18)
          Type1 = 9;
        else if (num8 < 20)
          Type1 = 11;
        else if (num8 < 22)
          Type1 = 10;
        else if (num8 < 26)
          Type1 = 7;
        else if (num8 < 32)
          Type1 = 80;
        else if (num8 < 35)
          Type1 = 80;
      }
      if (tileCache.type == (ushort) 648)
      {
        int num9 = (int) tileCache.frameX / 54 + (int) tileCache.frameY / 36 * 35;
        if (num9 < 3)
          Type1 = 1;
        else if (num9 < 6)
          Type1 = 38;
        else if (num9 < 9)
          Type1 = 36;
        else if (num9 < 14)
          Type1 = 30;
        else if (num9 < 17)
          Type1 = 1;
        else if (num9 < 18)
          Type1 = 1;
        else if (num9 < 21)
          Type1 = 148;
        else if (num9 < 29)
          Type1 = 155;
        else if (num9 < 35)
          Type1 = 287;
        else if (num9 < 41)
          Type1 = 240;
        else if (num9 < 47)
          Type1 = 236;
        else if (num9 < 50)
          Type1 = 0;
        else if (num9 < 52)
          Type1 = 2;
        else if (num9 < 55)
          Type1 = 26;
      }
      if (tileCache.type == (ushort) 105)
      {
        Type1 = 1;
        if (tileCache.frameX >= (short) 1548 && tileCache.frameX <= (short) 1654 && tileCache.frameY < (short) 54)
          Type1 = 148;
      }
      if (tileCache.type == (ushort) 349)
        Type1 = 1;
      if (tileCache.type == (ushort) 337 || tileCache.type == (ushort) 506)
        Type1 = 1;
      if (tileCache.type == (ushort) 239)
      {
        int num10 = (int) tileCache.frameX / 18;
        if (num10 == 0)
          Type1 = 9;
        if (num10 == 1)
          Type1 = 81;
        if (num10 == 2)
          Type1 = 8;
        if (num10 == 3)
          Type1 = 82;
        if (num10 == 4)
          Type1 = 11;
        if (num10 == 5)
          Type1 = 83;
        if (num10 == 6)
          Type1 = 10;
        if (num10 == 7)
          Type1 = 84;
        if (num10 == 8)
          Type1 = 14;
        if (num10 == 9)
          Type1 = 23;
        if (num10 == 10)
          Type1 = 25;
        if (num10 == 11)
          Type1 = 48;
        if (num10 == 12)
          Type1 = 144;
        if (num10 == 13)
          Type1 = 49;
        if (num10 == 14)
          Type1 = 145;
        if (num10 == 15)
          Type1 = 50;
        if (num10 == 16)
          Type1 = 146;
        if (num10 == 17)
          Type1 = 128;
        if (num10 == 18)
          Type1 = 84;
        if (num10 == 19)
          Type1 = 117;
        if (num10 == 20)
          Type1 = 42;
        if (num10 == 21)
          Type1 = -1;
        if (num10 == 22)
          Type1 = 265;
      }
      if (tileCache.type == (ushort) 185)
      {
        if (tileCache.frameY == (short) 18)
        {
          int num11 = (int) tileCache.frameX / 36;
          if (num11 < 6)
            Type1 = 1;
          else if (num11 < 16)
          {
            Type1 = 26;
          }
          else
          {
            switch (num11)
            {
              case 16:
                Type1 = 9;
                break;
              case 17:
                Type1 = 11;
                break;
              case 18:
                Type1 = 10;
                break;
              case 19:
                Type1 = 86;
                break;
              case 20:
                Type1 = 87;
                break;
              case 21:
                Type1 = 88;
                break;
              case 22:
                Type1 = 89;
                break;
              case 23:
                Type1 = 90;
                break;
              case 24:
                Type1 = 91;
                break;
              default:
                if (num11 < 31)
                {
                  Type1 = 80;
                  break;
                }
                if (num11 < 33)
                {
                  Type1 = 7;
                  break;
                }
                if (num11 < 34)
                {
                  Type1 = 8;
                  break;
                }
                if (num11 < 38)
                {
                  Type1 = 30;
                  break;
                }
                if (num11 < 41)
                {
                  Type1 = 1;
                  break;
                }
                if (num11 < 47)
                {
                  Type1 = 287;
                  break;
                }
                if (num11 < 53)
                {
                  Type1 = 240;
                  break;
                }
                if (num11 < 59)
                {
                  Type1 = 236;
                  break;
                }
                break;
            }
          }
        }
        else
        {
          int num12 = (int) tileCache.frameX / 18;
          if (num12 < 6)
            Type1 = 1;
          else if (num12 < 12)
            Type1 = 0;
          else if (num12 < 28)
            Type1 = 26;
          else if (num12 < 33)
            Type1 = 1;
          else if (num12 < 36)
            Type1 = 0;
          else if (num12 < 48)
            Type1 = 80;
          else if (num12 < 54)
            Type1 = 30;
          else if (num12 < 60)
            Type1 = 287;
          else if (num12 < 66)
            Type1 = 240;
          else if (num12 < 72)
            Type1 = 236;
          else if (num12 < 73)
            Type1 = 0;
          else if (num12 < 77)
            Type1 = 32;
        }
      }
      if (tileCache.type == (ushort) 649)
      {
        int num13 = (int) tileCache.frameX / 36 + (int) tileCache.frameY / 18 * 53;
        if (num13 < 6)
          Type1 = 1;
        else if (num13 < 16)
        {
          Type1 = 26;
        }
        else
        {
          switch (num13)
          {
            case 16:
              Type1 = 9;
              break;
            case 17:
              Type1 = 11;
              break;
            case 18:
              Type1 = 10;
              break;
            case 19:
              Type1 = 86;
              break;
            case 20:
              Type1 = 87;
              break;
            case 21:
              Type1 = 88;
              break;
            case 22:
              Type1 = 89;
              break;
            case 23:
              Type1 = 90;
              break;
            case 24:
              Type1 = 91;
              break;
            default:
              if (num13 < 31)
              {
                Type1 = 80;
                break;
              }
              if (num13 < 33)
              {
                Type1 = 7;
                break;
              }
              if (num13 < 34)
              {
                Type1 = 8;
                break;
              }
              if (num13 < 38)
              {
                Type1 = 30;
                break;
              }
              if (num13 < 41)
              {
                Type1 = 1;
                break;
              }
              if (num13 < 47)
              {
                Type1 = 287;
                break;
              }
              if (num13 < 53)
              {
                Type1 = 240;
                break;
              }
              if (num13 < 59)
              {
                Type1 = 236;
                break;
              }
              if (num13 < 62)
              {
                Type1 = 0;
                break;
              }
              if (num13 < 65)
              {
                Type1 = 32;
                break;
              }
              break;
          }
        }
      }
      if (tileCache.type == (ushort) 650)
      {
        int num14 = (int) tileCache.frameX / 18;
        if (num14 < 6)
          Type1 = 1;
        else if (num14 < 12)
          Type1 = 0;
        else if (num14 < 28)
          Type1 = 26;
        else if (num14 < 33)
          Type1 = 1;
        else if (num14 < 36)
          Type1 = 0;
        else if (num14 < 48)
          Type1 = 80;
        else if (num14 < 54)
          Type1 = 30;
        else if (num14 < 60)
          Type1 = 287;
        else if (num14 < 66)
          Type1 = 240;
        else if (num14 < 72)
          Type1 = 236;
        else if (num14 < 73)
          Type1 = 0;
        else if (num14 < 77)
          Type1 = 32;
      }
      if (tileCache.type == (ushort) 237)
        Type1 = 148;
      if (tileCache.type == (ushort) 157)
        Type1 = 77;
      if (tileCache.type == (ushort) 158 || tileCache.type == (ushort) 232 || tileCache.type == (ushort) 383 || tileCache.type == (ushort) 575)
        Type1 = 78;
      if (tileCache.type == (ushort) 159)
        Type1 = 78;
      if (tileCache.type == (ushort) 15)
        Type1 = -1;
      if (tileCache.type == (ushort) 191)
        Type1 = 7;
      if (tileCache.type == (ushort) 5)
      {
        Type1 = 7;
        if (i > 5 && i < Main.maxTilesX - 5)
        {
          int index1 = i;
          int index2 = j;
          if (tileCache.frameX == (short) 66 && tileCache.frameY <= (short) 45)
            ++index1;
          if (tileCache.frameX == (short) 88 && tileCache.frameY >= (short) 66 && tileCache.frameY <= (short) 110)
            --index1;
          if (tileCache.frameX == (short) 22 && tileCache.frameY >= (short) 132 && tileCache.frameY <= (short) 176)
            --index1;
          if (tileCache.frameX == (short) 44 && tileCache.frameY >= (short) 132 && tileCache.frameY <= (short) 176)
            ++index1;
          if (tileCache.frameX == (short) 44 && tileCache.frameY >= (short) 132 && tileCache.frameY <= (short) 176)
            ++index1;
          if (tileCache.frameX == (short) 44 && tileCache.frameY >= (short) 198)
            ++index1;
          if (tileCache.frameX == (short) 66 && tileCache.frameY >= (short) 198)
            --index1;
          while (Main.tile[index1, index2] != null && (!Main.tile[index1, index2].active() || !Main.tileSolid[(int) Main.tile[index1, index2].type]))
            ++index2;
          if (Main.tile[index1, index2] != null)
          {
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 23)
              Type1 = 77;
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 661)
              Type1 = 77;
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 60)
              Type1 = 78;
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 70)
              Type1 = 26;
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 109)
              Type1 = 79;
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 199)
              Type1 = 121;
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 662)
              Type1 = 121;
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 147)
              Type1 = 122;
          }
        }
      }
      if (tileCache.type == (ushort) 323)
      {
        Type1 = 215;
        if (i > 5 && i < Main.maxTilesX - 5)
        {
          int index3 = i;
          int index4 = j;
          while (Main.tile[index3, index4] != null && (!Main.tile[index3, index4].active() || !Main.tileSolid[(int) Main.tile[index3, index4].type]))
            ++index4;
          if (Main.tile[index3, index4] != null)
          {
            if (Main.tile[index3, index4].active() && Main.tile[index3, index4].type == (ushort) 234)
              Type1 = 121;
            if (Main.tile[index3, index4].active() && Main.tile[index3, index4].type == (ushort) 116)
              Type1 = 79;
            if (Main.tile[index3, index4].active() && Main.tile[index3, index4].type == (ushort) 112)
              Type1 = 77;
          }
        }
      }
      if (tileCache.type == (ushort) 137)
      {
        switch ((int) tileCache.frameY / 18)
        {
          case 1:
          case 2:
          case 3:
          case 4:
            Type1 = 148;
            break;
          case 5:
            Type1 = 1;
            break;
          default:
            Type1 = 1;
            break;
        }
      }
      if (tileCache.type == (ushort) 443)
        Type1 = 1;
      if (tileCache.type == (ushort) 444)
        Type1 = -1;
      if (tileCache.type == (ushort) 212)
        Type1 = -1;
      if (tileCache.type == (ushort) 213)
        Type1 = 129;
      if (tileCache.type == (ushort) 214)
        Type1 = 1;
      if (tileCache.type == (ushort) 215)
        Type1 = -6;
      if (tileCache.type == (ushort) 325)
        Type1 = 81;
      if (tileCache.type == (ushort) 251)
        Type1 = 189;
      if (tileCache.type == (ushort) 252)
        Type1 = 190;
      if (tileCache.type == (ushort) 253)
        Type1 = 191;
      if (tileCache.type == (ushort) 254)
      {
        if (tileCache.frameX < (short) 72)
          Type1 = 3;
        else if (tileCache.frameX < (short) 108)
        {
          Type1 = 3;
          if (WorldGen.genRand.Next(3) == 0)
            Type1 = 189;
        }
        else if (tileCache.frameX < (short) 144)
        {
          Type1 = 3;
          if (WorldGen.genRand.Next(2) == 0)
            Type1 = 189;
        }
        else
        {
          Type1 = 3;
          if (WorldGen.genRand.Next(4) != 0)
            Type1 = 189;
        }
      }
      if (tileCache.type == (ushort) 467)
        Type1 = -1;
      if (tileCache.type == (ushort) 21)
        Type1 = tileCache.frameX < (short) 1008 ? (tileCache.frameX < (short) 612 ? (tileCache.frameX < (short) 576 ? (tileCache.frameX < (short) 540 ? (tileCache.frameX < (short) 504 ? (tileCache.frameX < (short) 468 ? (tileCache.frameX < (short) 432 ? (tileCache.frameX < (short) 396 ? (tileCache.frameX < (short) 360 ? (tileCache.frameX < (short) 324 ? (tileCache.frameX < (short) 288 ? (tileCache.frameX < (short) 252 ? (tileCache.frameX < (short) 216 ? (tileCache.frameX < (short) 180 ? (tileCache.frameX < (short) 108 ? (tileCache.frameX < (short) 36 ? 7 : 10) : 37) : 7) : 1) : 77) : 78) : 79) : 10) : 11) : 7) : 116) : 126) : 26) : 148) : 11) : -1;
      if (tileCache.type == (ushort) 382)
        Type1 = 3;
      if (tileCache.type == (ushort) 2 || tileCache.type == (ushort) 477)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 2 : 0;
      if (tileCache.type == (ushort) sbyte.MaxValue)
        Type1 = 67;
      if (tileCache.type == (ushort) 91)
        Type1 = -1;
      if (tileCache.type == (ushort) 198)
        Type1 = 109;
      if (tileCache.type == (ushort) 26)
        Type1 = tileCache.frameX < (short) 54 ? 8 : 5;
      if (tileCache.type == (ushort) 34)
        Type1 = -1;
      if (tileCache.type == (ushort) 6)
        Type1 = 8;
      if (tileCache.type == (ushort) 7 || tileCache.type == (ushort) 47 || tileCache.type == (ushort) 284 || tileCache.type == (ushort) 682)
        Type1 = 9;
      if (tileCache.type == (ushort) 8 || tileCache.type == (ushort) 45 || tileCache.type == (ushort) 102 || tileCache.type == (ushort) 680)
        Type1 = 10;
      if (tileCache.type == (ushort) 9 || tileCache.type == (ushort) 42 || tileCache.type == (ushort) 46 || tileCache.type == (ushort) 126 || tileCache.type == (ushort) 136 || tileCache.type == (ushort) 681)
        Type1 = 11;
      if (tileCache.type == (ushort) 166 || tileCache.type == (ushort) 175)
        Type1 = 81;
      if (tileCache.type == (ushort) 167)
        Type1 = 82;
      if (tileCache.type == (ushort) 168 || tileCache.type == (ushort) 176)
        Type1 = 83;
      if (tileCache.type == (ushort) 169 || tileCache.type == (ushort) 177)
        Type1 = 84;
      if (tileCache.type == (ushort) 199 || tileCache.type == (ushort) 662)
        Type1 = 117;
      if (tileCache.type == (ushort) 205)
        Type1 = 125;
      if (tileCache.type == (ushort) 201)
        Type1 = 125;
      if (tileCache.type == (ushort) 211)
        Type1 = 128;
      if (tileCache.type == (ushort) 227)
      {
        switch ((int) tileCache.frameX / 34)
        {
          case 0:
          case 1:
            Type1 = 26;
            break;
          case 2:
          case 4:
          case 5:
          case 6:
            Type1 = 40;
            break;
          case 3:
            Type1 = 3;
            break;
          case 7:
            Type1 = 117;
            break;
          case 8:
            Type1 = 17;
            break;
          case 9:
            Type1 = 6;
            break;
          case 10:
            Type1 = 3;
            break;
          case 11:
            Type1 = 26;
            break;
        }
      }
      if (tileCache.type == (ushort) 204 || tileCache.type == (ushort) 478)
      {
        Type1 = 117;
        if (WorldGen.genRand.Next(2) == 0)
          Type1 = 1;
      }
      if (tileCache.type == (ushort) 203)
        Type1 = 117;
      if (tileCache.type == (ushort) 243)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 13 : 7;
      if (tileCache.type == (ushort) 219)
        Type1 = -1;
      if (tileCache.type == (ushort) 642)
        Type1 = (int) sbyte.MinValue;
      if (tileCache.type == (ushort) 244)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 13 : 1;
      if (tileCache.type == (ushort) 597)
        Type1 = -1;
      else if (tileCache.type >= (ushort) 358 && tileCache.type <= (ushort) 364 || tileCache.type >= (ushort) 275 && tileCache.type <= (ushort) 282 || tileCache.type == (ushort) 285 || tileCache.type == (ushort) 286 || tileCache.type >= (ushort) 288 && tileCache.type <= (ushort) 297 || tileCache.type >= (ushort) 316 && tileCache.type <= (ushort) 318 || tileCache.type == (ushort) 298 || tileCache.type == (ushort) 299 || tileCache.type == (ushort) 309 || tileCache.type == (ushort) 310 || tileCache.type == (ushort) 339 || tileCache.type == (ushort) 538 || tileCache.type == (ushort) 413 || tileCache.type == (ushort) 414 || tileCache.type == (ushort) 505 || tileCache.type == (ushort) 521 || tileCache.type == (ushort) 522 || tileCache.type == (ushort) 523 || tileCache.type == (ushort) 524 || tileCache.type == (ushort) 525 || tileCache.type == (ushort) 526 || tileCache.type == (ushort) 527 || tileCache.type == (ushort) 532 || tileCache.type == (ushort) 543 || tileCache.type == (ushort) 544 || tileCache.type == (ushort) 550 || tileCache.type == (ushort) 551 || tileCache.type == (ushort) 533 || tileCache.type == (ushort) 553 || tileCache.type == (ushort) 554 || tileCache.type == (ushort) 555 || tileCache.type == (ushort) 556 || tileCache.type == (ushort) 558 || tileCache.type == (ushort) 559 || tileCache.type == (ushort) 542 || tileCache.type == (ushort) 391 || tileCache.type == (ushort) 394 || tileCache.type == (ushort) 392 || tileCache.type == (ushort) 393 || tileCache.type == (ushort) 568 || tileCache.type == (ushort) 569 || tileCache.type == (ushort) 570 || tileCache.type == (ushort) 582 || tileCache.type == (ushort) 580 || tileCache.type == (ushort) 598 || tileCache.type == (ushort) 599 || tileCache.type == (ushort) 600 || tileCache.type == (ushort) 601 || tileCache.type == (ushort) 602 || tileCache.type == (ushort) 603 || tileCache.type == (ushort) 604 || tileCache.type == (ushort) 605 || tileCache.type == (ushort) 606 || tileCache.type == (ushort) 607 || tileCache.type == (ushort) 608 || tileCache.type == (ushort) 609 || tileCache.type == (ushort) 610 || tileCache.type == (ushort) 611 || tileCache.type == (ushort) 612 || tileCache.type == (ushort) 619 || tileCache.type == (ushort) 620 || tileCache.type == (ushort) 629 || tileCache.type == (ushort) 632 || tileCache.type == (ushort) 640 || tileCache.type == (ushort) 643 || tileCache.type == (ushort) 644 || tileCache.type == (ushort) 645)
      {
        Type1 = 13;
        if (WorldGen.genRand.Next(3) != 0)
          Type1 = -1;
      }
      if (tileCache.type == (ushort) 13)
        Type1 = tileCache.frameX < (short) 90 ? 13 : -1;
      if (tileCache.type == (ushort) 189)
        Type1 = 16;
      if (tileCache.type == (ushort) 460)
        Type1 = 16;
      if (tileCache.type == (ushort) 530)
      {
        switch (Main.tile[i, j + 2 - (int) tileCache.frameY / 18].type)
        {
          case 112:
            Type1 = 17;
            break;
          case 116:
            Type1 = 47;
            break;
          case 234:
            Type1 = 125;
            break;
          default:
            Type1 = tileCache.frameX >= (short) 270 ? 291 : 40;
            break;
        }
      }
      if (tileCache.type == (ushort) 518)
      {
        if (tileCache.frameY == (short) 0)
          Type1 = 3;
        else if (tileCache.frameY == (short) 18)
          Type1 = 47;
        else if (tileCache.frameY == (short) 36)
          Type1 = 40;
      }
      else if (tileCache.type == (ushort) 519)
      {
        if (tileCache.frameY == (short) 0)
          Type1 = 3;
        else if (tileCache.frameY == (short) 18)
          Type1 = 40;
        else if (tileCache.frameY == (short) 36)
          Type1 = 47;
        else if (tileCache.frameY == (short) 54)
          Type1 = 125;
        else if (tileCache.frameY == (short) 72)
          Type1 = 17;
        else if (tileCache.frameY == (short) 90)
          Type1 = 26;
      }
      else if (tileCache.type == (ushort) 636)
        Type1 = 17;
      else if (tileCache.type == (ushort) 528)
        Type1 = 26;
      if (tileCache.type == (ushort) 12)
        Type1 = 12;
      if (tileCache.type == (ushort) 639)
        Type1 = 48;
      if (tileCache.type == (ushort) 3 || tileCache.type == (ushort) 73)
        Type1 = 3;
      if (tileCache.type == (ushort) 54)
        Type1 = 13;
      if (tileCache.type == (ushort) 22 || tileCache.type == (ushort) 140)
        Type1 = 14;
      if (tileCache.type == (ushort) 78)
        Type1 = 22;
      if (tileCache.type == (ushort) 28 || tileCache.type == (ushort) 653)
      {
        Type1 = 22;
        if (tileCache.frameY >= (short) 72 && tileCache.frameY <= (short) 90)
          Type1 = 1;
        if (tileCache.frameY >= (short) 144 && tileCache.frameY <= (short) 234)
          Type1 = 48;
        if (tileCache.frameY >= (short) 252 && tileCache.frameY <= (short) 358)
          Type1 = 85;
        if (tileCache.frameY >= (short) 360 && tileCache.frameY <= (short) 466)
          Type1 = 26;
        if (tileCache.frameY >= (short) 468 && tileCache.frameY <= (short) 574)
          Type1 = 36;
        if (tileCache.frameY >= (short) 576 && tileCache.frameY <= (short) 790)
          Type1 = 18;
        if (tileCache.frameY >= (short) 792 && tileCache.frameY <= (short) 898)
          Type1 = 5;
        if (tileCache.frameY >= (short) 900 && tileCache.frameY <= (short) 1006)
          Type1 = 0;
        if (tileCache.frameY >= (short) 1008 && tileCache.frameY <= (short) 1114)
          Type1 = 148;
        if (tileCache.frameY >= (short) 1116 && tileCache.frameY <= (short) 1222)
          Type1 = 241;
        if (tileCache.frameY >= (short) 1224 && tileCache.frameY <= (short) 1330)
          Type1 = 287;
      }
      if (tileCache.type == (ushort) 163)
        Type1 = 118;
      if (tileCache.type == (ushort) 164)
        Type1 = 119;
      if (tileCache.type == (ushort) 200)
        Type1 = 120;
      if (tileCache.type == (ushort) 221 || tileCache.type == (ushort) 248)
        Type1 = 144;
      if (tileCache.type == (ushort) 222 || tileCache.type == (ushort) 249)
        Type1 = 145;
      if (tileCache.type == (ushort) 223 || tileCache.type == (ushort) 250)
        Type1 = 146;
      if (tileCache.type == (ushort) 224)
        Type1 = 149;
      if (tileCache.type == (ushort) 225)
        Type1 = 147;
      if (tileCache.type == (ushort) 229)
        Type1 = 153;
      if (tileCache.type == (ushort) 231)
      {
        Type1 = 153;
        if (WorldGen.genRand.Next(3) == 0)
          Type1 = 26;
      }
      if (tileCache.type == (ushort) 226)
        Type1 = 148;
      if (tileCache.type == (ushort) 103)
        Type1 = -1;
      if (tileCache.type == (ushort) 29)
        Type1 = 23;
      if (tileCache.type == (ushort) 40)
        Type1 = 28;
      if (tileCache.type == (ushort) 50)
        Type1 = 22;
      if (tileCache.type == (ushort) 51)
        Type1 = 30;
      if (tileCache.type == (ushort) 52 || tileCache.type == (ushort) 353)
        Type1 = 3;
      if (tileCache.type == (ushort) 53 || tileCache.type == (ushort) 81 || tileCache.type == (ushort) 151 || tileCache.type == (ushort) 202 || tileCache.type == (ushort) 274 || tileCache.type == (ushort) 495)
        Type1 = 32;
      if (tileCache.type == (ushort) 56 || tileCache.type == (ushort) 152)
        Type1 = 37;
      if (tileCache.type == (ushort) 75 || tileCache.type == (ushort) 683)
        Type1 = 109;
      if (tileCache.type == (ushort) 57 || tileCache.type == (ushort) 119 || tileCache.type == (ushort) 141 || tileCache.type == (ushort) 234 || tileCache.type == (ushort) 635 || tileCache.type == (ushort) 654)
        Type1 = 36;
      if (tileCache.type == (ushort) 59 || tileCache.type == (ushort) 120)
        Type1 = 38;
      if (tileCache.type == (ushort) 61 || tileCache.type == (ushort) 62 || tileCache.type == (ushort) 74 || tileCache.type == (ushort) 80 || tileCache.type == (ushort) 188 || tileCache.type == (ushort) 233 || tileCache.type == (ushort) 236 || tileCache.type == (ushort) 384 || tileCache.type == (ushort) 652 || tileCache.type == (ushort) 651)
        Type1 = 40;
      if (tileCache.type == (ushort) 485)
        Type1 = 32;
      if (tileCache.type == (ushort) 238)
        Type1 = WorldGen.genRand.Next(3) != 0 ? 166 : 167;
      if (tileCache.type == (ushort) 69)
        Type1 = 7;
      if (tileCache.type == (ushort) 655)
        Type1 = 166;
      if (tileCache.type == (ushort) 71 || tileCache.type == (ushort) 72 || tileCache.type == (ushort) 190 || tileCache.type == (ushort) 578)
        Type1 = 26;
      if (tileCache.type == (ushort) 70)
        Type1 = 17;
      if (tileCache.type == (ushort) 112)
        Type1 = 14;
      if (tileCache.type == (ushort) 123)
        Type1 = 53;
      if (tileCache.type == (ushort) 161)
        Type1 = 80;
      if (tileCache.type == (ushort) 206)
        Type1 = 80;
      if (tileCache.type == (ushort) 162)
        Type1 = 80;
      if (tileCache.type == (ushort) 165)
      {
        switch ((int) tileCache.frameX / 54)
        {
          case 0:
            Type1 = 80;
            break;
          case 1:
            Type1 = 1;
            break;
          case 2:
            Type1 = 30;
            break;
          case 3:
            Type1 = 147;
            break;
          case 4:
            Type1 = 1;
            break;
          case 5:
            Type1 = 14;
            break;
          case 6:
            Type1 = 117;
            break;
          case 7:
            Type1 = 250;
            break;
          case 8:
            Type1 = 240;
            break;
          case 9:
            Type1 = 236;
            break;
          default:
            Type1 = 1;
            break;
        }
      }
      if (tileCache.type == (ushort) 666)
        Type1 = 322;
      if (tileCache.type == (ushort) 193)
        Type1 = 4;
      if (tileCache.type == (ushort) 194)
        Type1 = 26;
      if (tileCache.type == (ushort) 195)
        Type1 = 5;
      if (tileCache.type == (ushort) 196)
        Type1 = 108;
      if (tileCache.type == (ushort) 460)
        Type1 = 108;
      if (tileCache.type == (ushort) 197)
        Type1 = 4;
      if (tileCache.type == (ushort) 153)
        Type1 = 26;
      if (tileCache.type == (ushort) 154)
        Type1 = 32;
      if (tileCache.type == (ushort) 155)
        Type1 = 2;
      if (tileCache.type == (ushort) 156)
        Type1 = 1;
      if (tileCache.type == (ushort) 116 || tileCache.type == (ushort) 118 || tileCache.type == (ushort) 147 || tileCache.type == (ushort) 148)
        Type1 = 51;
      if (tileCache.type == (ushort) 109 || tileCache.type == (ushort) 492)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 47 : 0;
      if (tileCache.type == (ushort) 110 || tileCache.type == (ushort) 113 || tileCache.type == (ushort) 115)
        Type1 = 47;
      if (tileCache.type == (ushort) 107 || tileCache.type == (ushort) 121 || tileCache.type == (ushort) 685)
        Type1 = 48;
      if (tileCache.type == (ushort) 108 || tileCache.type == (ushort) 122 || tileCache.type == (ushort) 146 || tileCache.type == (ushort) 686)
        Type1 = 49;
      if (tileCache.type == (ushort) 111 || tileCache.type == (ushort) 145 || tileCache.type == (ushort) 150)
        Type1 = 50;
      if (tileCache.type == (ushort) 133)
      {
        Type1 = 50;
        if (tileCache.frameX >= (short) 54)
          Type1 = 146;
      }
      if (tileCache.type == (ushort) 134)
      {
        Type1 = 49;
        if (tileCache.frameX >= (short) 36)
          Type1 = 145;
      }
      if (tileCache.type == (ushort) 149)
        Type1 = 49;
      if (Main.tileAlch[(int) tileCache.type])
      {
        int num15 = (int) tileCache.frameX / 18;
        if (num15 == 0)
          Type1 = 3;
        if (num15 == 1)
          Type1 = 3;
        if (num15 == 2)
          Type1 = 7;
        if (num15 == 3)
          Type1 = 17;
        if (num15 == 4)
          Type1 = 289;
        if (num15 == 5)
          Type1 = 6;
        if (num15 == 6)
          Type1 = 224;
      }
      if (tileCache.type == (ushort) 58 || tileCache.type == (ushort) 76 || tileCache.type == (ushort) 77 || tileCache.type == (ushort) 684)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 25 : 6;
      if (tileCache.type == (ushort) 37)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 23 : 6;
      if (tileCache.type == (ushort) 32)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 24 : 14;
      if (tileCache.type == (ushort) 352)
        Type1 = WorldGen.genRand.Next(3) != 0 ? 125 : 5;
      if (tileCache.type == (ushort) 23 || tileCache.type == (ushort) 24 || tileCache.type == (ushort) 661)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 17 : 14;
      if (tileCache.type == (ushort) 25 || tileCache.type == (ushort) 31)
        Type1 = tileCache.type != (ushort) 31 || tileCache.frameX < (short) 36 ? (WorldGen.genRand.Next(2) != 0 ? 1 : 14) : 5;
      if (tileCache.type == (ushort) 20)
      {
        switch ((int) tileCache.frameX / 54)
        {
          case 1:
            Type1 = 122;
            break;
          case 2:
            Type1 = 78;
            break;
          case 3:
            Type1 = 77;
            break;
          case 4:
            Type1 = 121;
            break;
          case 5:
            Type1 = 79;
            break;
          default:
            Type1 = 7;
            break;
        }
      }
      if (tileCache.type == (ushort) 27)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 19 : 3;
      if (tileCache.type == (ushort) 129)
      {
        if (tileCache.frameX >= (short) 324)
          num3 = 69;
        Type1 = tileCache.frameX == (short) 0 || tileCache.frameX == (short) 54 || tileCache.frameX == (short) 108 ? 68 : (tileCache.frameX == (short) 18 || tileCache.frameX == (short) 72 || tileCache.frameX == (short) 126 ? 69 : 70);
      }
      if (tileCache.type == (ushort) 385)
        Type1 = WorldGen.genRand.Next(68, 71);
      if (tileCache.type == (ushort) 4)
      {
        int index = (int) MathHelper.Clamp((float) ((int) tileCache.frameY / 22), 0.0f, (float) ((int) TorchID.Count - 1));
        Type1 = TorchID.Dust[index];
      }
      if (tileCache.type == (ushort) 35)
      {
        Type1 = 189;
        if (tileCache.frameX < (short) 36 && WorldGen.genRand.Next(2) == 0)
          Type1 = 6;
      }
      if ((tileCache.type == (ushort) 34 || tileCache.type == (ushort) 42) && WorldGen.genRand.Next(2) == 0)
        Type1 = 6;
      if (tileCache.type == (ushort) 270)
        Type1 = -1;
      if (tileCache.type == (ushort) 271)
        Type1 = -1;
      if (tileCache.type == (ushort) 581)
        Type1 = -1;
      if (tileCache.type == (ushort) 660)
        Type1 = -1;
      if (tileCache.type == (ushort) 79 || tileCache.type == (ushort) 90 || tileCache.type == (ushort) 101)
        Type1 = -1;
      if (tileCache.type == (ushort) 33 || tileCache.type == (ushort) 34 || tileCache.type == (ushort) 42 || tileCache.type == (ushort) 93 || tileCache.type == (ushort) 100)
        Type1 = -1;
      if (tileCache.type == (ushort) 321 || tileCache.type == (ushort) 574)
        Type1 = 214;
      if (tileCache.type == (ushort) 322)
        Type1 = 215;
      if (tileCache.type == (ushort) 635)
        Type1 = 36;
      bool flag = tileCache.type == (ushort) 178 || tileCache.type == (ushort) 440;
      switch (tileCache.type)
      {
        case 178:
        case 426:
        case 427:
        case 430:
        case 431:
        case 432:
        case 433:
        case 434:
        case 435:
        case 436:
        case 437:
        case 438:
        case 439:
        case 440:
          flag = true;
          break;
      }
      if (Type1 < 0)
        return 6000;
      if (tileCache.type == (ushort) 627 || tileCache.type == (ushort) 628 || tileCache.type == (ushort) 184 && (int) tileCache.frameX / 22 == 10)
      {
        int index = Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type1, newColor: new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB));
        Main.dust[index].noGravity = true;
        Main.dust[index].noLightEmittence = true;
        return index;
      }
      if (tileCache.type == (ushort) 518)
      {
        int num16 = (int) tileCache.liquid / 16 - 3;
        if (WorldGen.SolidTile(i, j - 1) && num16 > 8)
          num16 = 8;
        return Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16 - num16)), 16, 16, Type1);
      }
      if (tileCache.type == (ushort) 352 && Type1 == 5)
      {
        int index = Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 5, Alpha: 100);
        Main.dust[index].scale = 1.5f;
        Main.dust[index].noGravity = true;
        Main.dust[index].velocity *= 1.65f;
        Main.dust[index].fadeIn = 1.6f;
        return index;
      }
      if (tileCache.type == (ushort) 160 || tileCache.type == (ushort) 692)
      {
        int index = Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 66, Alpha: 100, newColor: new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), Scale: 0.75f);
        Main.dust[index].noGravity = true;
        return index;
      }
      if (tileCache.type == (ushort) 323)
      {
        int frameY = (int) tileCache.frameY;
        return Dust.NewDust(new Vector2((float) (i * 16 + frameY), (float) (j * 16)), 16, 16, Type1);
      }
      if (tileCache.type == (ushort) 314)
      {
        int index = Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 213, (float) WorldGen.genRand.Next(-2, 3), (float) WorldGen.genRand.Next(-2, 3));
        Main.dust[index].noGravity = true;
        Main.dust[index].fadeIn = (float) ((double) Main.dust[index].scale + 1.0 + 0.0099999997764825821 * (double) WorldGen.genRand.Next(0, 51));
        Main.dust[index].noGravity = true;
        return index;
      }
      if (flag)
      {
        int index = Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type1, Alpha: 75, Scale: 0.75f);
        Main.dust[index].noLight = true;
        return index;
      }
      if (tileCache.type == (ushort) 193 || tileCache.type == (ushort) 18 && Type1 == 4 || tileCache.type == (ushort) 19 && Type1 == 4)
        return Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type1, Alpha: 75, newColor: new Color(0, 80, (int) byte.MaxValue, 100), Scale: 0.75f);
      if (tileCache.type == (ushort) 197)
        return Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type1, Alpha: 75, newColor: new Color(97, 200, (int) byte.MaxValue, 100), Scale: 0.75f);
      if (tileCache.type == (ushort) 185 && Type1 >= 86 && Type1 <= 91)
      {
        int index = Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type1, Alpha: 75, Scale: 0.75f);
        Main.dust[index].noLight = true;
        return index;
      }
      if (tileCache.type == (ushort) 4 && Type1 == 66)
      {
        int index = Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type1, newColor: new Color((float) Main.DiscoR / (float) byte.MaxValue, (float) Main.DiscoG / (float) byte.MaxValue, (float) Main.DiscoB / (float) byte.MaxValue));
        Main.dust[index].noGravity = true;
        return index;
      }
      if (Type1 != 139)
        return Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type1);
      int Type2 = Type1 + Main.rand.Next(4);
      return Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type2);
    }

    public static bool IsOpenDoorAnchorFrame(int x, int y)
    {
      Tile tile = Main.tile[x, y];
      if (!tile.active() || tile.type != (ushort) 11)
        return false;
      int num = (int) tile.frameX % 72;
      return num < 18 || num >= 54;
    }

    public static bool IsLockedDoor(int x, int y) => WorldGen.IsLockedDoor(Main.tile[x, y]);

    public static bool IsLockedDoor(Tile t) => t.type == (ushort) 10 && t.frameY >= (short) 594 && t.frameY <= (short) 646 && t.frameX < (short) 54;

    public static void DropDoorItem(int x, int y, int doorStyle)
    {
      int Type = 0;
      switch (doorStyle)
      {
        case 0:
          Type = 25;
          break;
        case 9:
          Type = 837;
          break;
        case 10:
          Type = 912;
          break;
        case 12:
          Type = 1137;
          break;
        case 13:
          Type = 1138;
          break;
        case 14:
          Type = 1139;
          break;
        case 15:
          Type = 1140;
          break;
        case 16:
          Type = 1411;
          break;
        case 17:
          Type = 1412;
          break;
        case 18:
          Type = 1413;
          break;
        case 19:
          Type = 1458;
          break;
        default:
          if (doorStyle >= 20 && doorStyle <= 23)
          {
            Type = 1709 + doorStyle - 20;
            break;
          }
          switch (doorStyle)
          {
            case 24:
              Type = 1793;
              break;
            case 25:
              Type = 1815;
              break;
            case 26:
              Type = 1924;
              break;
            case 27:
              Type = 2044;
              break;
            case 28:
              Type = 2265;
              break;
            case 29:
              Type = 2528;
              break;
            case 30:
              Type = 2561;
              break;
            case 31:
              Type = 2576;
              break;
            case 32:
              Type = 2815;
              break;
            case 33:
              Type = 3129;
              break;
            case 34:
              Type = 3131;
              break;
            case 35:
              Type = 3130;
              break;
            case 36:
              Type = 3888;
              break;
            case 37:
              Type = 3941;
              break;
            case 38:
              Type = 3967;
              break;
            case 39:
              Type = 4155;
              break;
            case 40:
              Type = 4176;
              break;
            case 41:
              Type = 4197;
              break;
            case 42:
              Type = 4218;
              break;
            case 43:
              Type = 4307;
              break;
            case 44:
              Type = 4415;
              break;
            case 45:
              Type = 4576;
              break;
            case 46:
              Type = 5158;
              break;
            case 47:
              Type = 5179;
              break;
            case 48:
              Type = 5200;
              break;
            default:
              if (doorStyle >= 4 && doorStyle <= 8)
              {
                Type = 812 + doorStyle;
                break;
              }
              if (doorStyle != 11)
              {
                Type = 649 + doorStyle;
                break;
              }
              break;
          }
          break;
      }
      if (Type == 0)
        return;
      Item.NewItem(WorldGen.GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, Type);
    }

    public static IEntitySource GetItemSource_FromTileBreak(int x, int y) => (IEntitySource) new EntitySource_TileBreak(x, y);

    public static IEntitySource GetItemSource_FromWallBreak(int x, int y) => (IEntitySource) new EntitySource_TileBreak(x, y);

    public static IEntitySource GetItemSource_FromTreeShake(int x, int y) => (IEntitySource) new EntitySource_ShakeTree(x, y);

    public static bool PlayerLOS(int x, int y)
    {
      Microsoft.Xna.Framework.Rectangle rectangle1 = new Microsoft.Xna.Framework.Rectangle(x * 16, y * 16, 16, 16);
      for (int index = 0; index < (int) byte.MaxValue; ++index)
      {
        if (Main.player[index].active)
        {
          Microsoft.Xna.Framework.Rectangle rectangle2 = new Microsoft.Xna.Framework.Rectangle((int) ((double) Main.player[index].position.X + (double) Main.player[index].width * 0.5 - (double) NPC.sWidth * 0.6), (int) ((double) Main.player[index].position.Y + (double) Main.player[index].height * 0.5 - (double) NPC.sHeight * 0.6), (int) ((double) NPC.sWidth * 1.2), (int) ((double) NPC.sHeight * 1.2));
          if (rectangle1.Intersects(rectangle2))
            return true;
        }
      }
      return false;
    }

    public static void ChlorophyteDefense(int x, int y)
    {
      if (!Main.remixWorld)
        return;
      if (Main.tile[x, y].type == (ushort) 23 || Main.tile[x, y].type == (ushort) 199 || Main.tile[x, y].type == (ushort) 661 || Main.tile[x, y].type == (ushort) 662)
      {
        Main.tile[x, y].type = (ushort) 60;
        WorldGen.SquareTileFrame(x, y);
        if (Main.netMode != 2)
          return;
        NetMessage.SendTileSquare(-1, x, y);
      }
      else if (Main.tile[x, y].type == (ushort) 25 || Main.tile[x, y].type == (ushort) 203)
      {
        Main.tile[x, y].type = (ushort) 1;
        WorldGen.SquareTileFrame(x, y);
        if (Main.netMode != 2)
          return;
        NetMessage.SendTileSquare(-1, x, y);
      }
      else if (Main.tile[x, y].type == (ushort) 112 || Main.tile[x, y].type == (ushort) 234)
      {
        Main.tile[x, y].type = (ushort) 53;
        WorldGen.SquareTileFrame(x, y);
        if (Main.netMode != 2)
          return;
        NetMessage.SendTileSquare(-1, x, y);
      }
      else if (Main.tile[x, y].type == (ushort) 398 || Main.tile[x, y].type == (ushort) 399)
      {
        Main.tile[x, y].type = (ushort) 397;
        WorldGen.SquareTileFrame(x, y);
        if (Main.netMode != 2)
          return;
        NetMessage.SendTileSquare(-1, x, y);
      }
      else if (Main.tile[x, y].type == (ushort) 400 || Main.tile[x, y].type == (ushort) 401)
      {
        Main.tile[x, y].type = (ushort) 396;
        WorldGen.SquareTileFrame(x, y);
        if (Main.netMode != 2)
          return;
        NetMessage.SendTileSquare(-1, x, y);
      }
      else
      {
        if (Main.tile[x, y].type != (ushort) 24 && Main.tile[x, y].type != (ushort) 201 && Main.tile[x, y].type != (ushort) 32 && Main.tile[x, y].type != (ushort) 352 && Main.tile[x, y].type != (ushort) 636 && Main.tile[x, y].type != (ushort) 205)
          return;
        WorldGen.KillTile(x, y);
        if (Main.netMode != 2)
          return;
        NetMessage.SendTileSquare(-1, x, y);
      }
    }

    public static bool Chlorophyte(int i, int j)
    {
      int num1 = 40;
      int num2 = 130;
      int num3 = 35;
      int num4 = 85;
      if (Main.remixWorld)
      {
        num1 += 5;
        num2 *= 15;
        num3 -= 4;
        num4 -= 8;
      }
      else if ((double) j < Main.rockLayer)
      {
        num1 /= 2;
        num2 /= 2;
        num3 = (int) ((double) num3 * 1.5);
        num4 = (int) ((double) num4 * 1.5);
      }
      int num5 = 0;
      for (int x = i - num3; x < i + num3; ++x)
      {
        for (int y = j - num3; y < j + num3; ++y)
        {
          if (WorldGen.InWorld(x, y) && Main.tile[x, y].active() && Main.tile[x, y].type == (ushort) 211)
            ++num5;
        }
      }
      if (num5 > num1)
        return false;
      int num6 = 0;
      for (int x = i - num4; x < i + num4; ++x)
      {
        for (int y = j - num4; y < j + num4; ++y)
        {
          if (WorldGen.InWorld(x, y) && Main.tile[x, y].active() && Main.tile[x, y].type == (ushort) 211)
            ++num6;
        }
      }
      return num6 <= num2;
    }

    private static bool nearbyChlorophyte(int i, int j)
    {
      double num1 = 0.0;
      int num2 = 5;
      if (i <= num2 + 5 || i >= Main.maxTilesX - num2 - 5 || j <= num2 + 5 || j >= Main.maxTilesY - num2 - 5)
        return false;
      for (int index1 = i - num2; index1 <= i + num2; ++index1)
      {
        for (int index2 = j - num2; index2 <= j + num2; ++index2)
        {
          if (Main.tile[index1, index2].active() && (Main.tile[index1, index2].type == (ushort) 211 || Main.tile[index1, index2].type == (ushort) 346))
          {
            ++num1;
            if (num1 >= 3.0)
              return true;
          }
        }
      }
      if (num1 > 0.0)
      {
        if (Main.remixWorld)
        {
          if ((double) WorldGen.genRand.Next(-1, 3) < num1)
            return true;
        }
        else if ((double) WorldGen.genRand.Next(-1, 4) < num1)
          return true;
      }
      return false;
    }

    public static int CountNearBlocksTypes(
      int i,
      int j,
      int radius,
      int cap = 0,
      params int[] tiletypes)
    {
      if (tiletypes.Length == 0)
        return 0;
      int num1 = i - radius;
      int num2 = i + radius;
      int num3 = j - radius;
      int num4 = j + radius;
      int max = Main.maxTilesX - 1;
      int num5 = Utils.Clamp<int>(num1, 0, max);
      int num6 = Utils.Clamp<int>(num2, 0, Main.maxTilesX - 1);
      int num7 = Utils.Clamp<int>(num3, 0, Main.maxTilesY - 1);
      int num8 = Utils.Clamp<int>(num4, 0, Main.maxTilesY - 1);
      int num9 = 0;
      for (int index1 = num5; index1 <= num6; ++index1)
      {
        for (int index2 = num7; index2 <= num8; ++index2)
        {
          if (Main.tile[index1, index2].active())
          {
            foreach (int tiletype in tiletypes)
            {
              if (tiletype == (int) Main.tile[index1, index2].type)
              {
                ++num9;
                if (cap > 0 && num9 >= cap)
                  return num9;
                break;
              }
            }
          }
        }
      }
      return num9;
    }

    public static void hardUpdateWorld(int i, int j)
    {
      if (!Main.hardMode || Main.tile[i, j].inActive())
        return;
      int type = (int) Main.tile[i, j].type;
      if (type > 0 && type < (int) TileID.Count && TileID.Sets.CanGrowCrystalShards[type] && ((double) j > Main.rockLayer || Main.remixWorld) && WorldGen.genRand.Next(5) == 0)
      {
        int num1 = WorldGen.genRand.Next(4);
        int num2 = 0;
        int num3 = 0;
        switch (num1)
        {
          case 0:
            num2 = -1;
            break;
          case 1:
            num2 = 1;
            break;
          default:
            num3 = num1 != 0 ? 1 : -1;
            break;
        }
        if (!Main.tile[i + num2, j + num3].active())
        {
          int num4 = 0;
          int num5 = 6;
          for (int index1 = i - num5; index1 <= i + num5; ++index1)
          {
            for (int index2 = j - num5; index2 <= j + num5; ++index2)
            {
              if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 129)
                ++num4;
            }
          }
          if (num4 < 2)
          {
            int style = (int) (short) WorldGen.genRand.Next(18);
            if (WorldGen.genRand.Next(50) == 0)
              style = (int) (short) (18 + WorldGen.genRand.Next(6));
            WorldGen.PlaceTile(i + num2, j + num3, 129, true, style: style);
            NetMessage.SendTileSquare(-1, i + num2, j + num3);
          }
        }
      }
      if ((double) j > (Main.worldSurface + Main.rockLayer) / 2.0 || Main.remixWorld)
      {
        if (type == 60 && WorldGen.genRand.Next(300) == 0)
        {
          int index3 = i + WorldGen.genRand.Next(-10, 11);
          int index4 = j + WorldGen.genRand.Next(-10, 11);
          if (WorldGen.InWorld(index3, index4, 2) && Main.tile[index3, index4].active() && Main.tile[index3, index4].type == (ushort) 59 && (!Main.tile[index3, index4 - 1].active() || Main.tile[index3, index4 - 1].type != (ushort) 5 && Main.tile[index3, index4 - 1].type != (ushort) 236 && Main.tile[index3, index4 - 1].type != (ushort) 238) && WorldGen.Chlorophyte(index3, index4))
          {
            Main.tile[index3, index4].type = (ushort) 211;
            WorldGen.SquareTileFrame(index3, index4);
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, index3, index4);
          }
        }
        if (type == 211 || type == 346)
        {
          int index5 = i;
          int index6 = j;
          if (WorldGen.genRand.Next(3) != 0)
          {
            int num = WorldGen.genRand.Next(4);
            if (num == 0)
              ++index5;
            if (num == 1)
              --index5;
            if (num == 2)
              ++index6;
            if (num == 3)
              --index6;
            if (WorldGen.InWorld(index5, index6, 2) && Main.tile[index5, index6].active() && (Main.tile[index5, index6].type == (ushort) 59 || Main.tile[index5, index6].type == (ushort) 60) && WorldGen.Chlorophyte(index5, index6))
            {
              Main.tile[index5, index6].type = (ushort) 211;
              WorldGen.SquareTileFrame(index5, index6);
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index5, index6);
            }
          }
          bool flag = true;
          while (flag)
          {
            flag = false;
            int index7 = i + Main.rand.Next(-6, 7);
            int index8 = j + Main.rand.Next(-6, 7);
            if (WorldGen.InWorld(index7, index8, 2) && Main.tile[index7, index8].active())
            {
              if (Main.tile[index7, index8].type == (ushort) 661 || Main.tile[index7, index8].type == (ushort) 662 || Main.tile[index7, index8].type == (ushort) 23 || Main.tile[index7, index8].type == (ushort) 199 || Main.tile[index7, index8].type == (ushort) 2 || Main.tile[index7, index8].type == (ushort) 477 || Main.tile[index7, index8].type == (ushort) 492 || Main.tile[index7, index8].type == (ushort) 109)
              {
                Main.tile[index7, index8].type = (ushort) 60;
                WorldGen.SquareTileFrame(index7, index8);
                if (Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, index7, index8);
                flag = true;
              }
              else if (Main.tile[index7, index8].type == (ushort) 0)
              {
                Main.tile[index7, index8].type = (ushort) 59;
                WorldGen.SquareTileFrame(index7, index8);
                if (Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, index7, index8);
                flag = true;
              }
              else if (Main.tile[index7, index8].type == (ushort) 25 || Main.tile[index7, index8].type == (ushort) 203)
              {
                Main.tile[index7, index8].type = (ushort) 1;
                WorldGen.SquareTileFrame(index7, index8);
                if (Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, index7, index8);
                flag = true;
              }
              else if (Main.tile[index7, index8].type == (ushort) 112 || Main.tile[index7, index8].type == (ushort) 234)
              {
                Main.tile[index7, index8].type = (ushort) 53;
                WorldGen.SquareTileFrame(index7, index8);
                if (Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, index7, index8);
                flag = true;
              }
              else if (Main.tile[index7, index8].type == (ushort) 398 || Main.tile[index7, index8].type == (ushort) 399)
              {
                Main.tile[index7, index8].type = (ushort) 397;
                WorldGen.SquareTileFrame(index7, index8);
                if (Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, index7, index8);
                flag = true;
              }
              else if (Main.tile[index7, index8].type == (ushort) 400 || Main.tile[index7, index8].type == (ushort) 401)
              {
                Main.tile[index7, index8].type = (ushort) 396;
                WorldGen.SquareTileFrame(index7, index8);
                if (Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, index7, index8);
                flag = true;
              }
              else if (Main.tile[index7, index8].type == (ushort) 24 || Main.tile[index7, index8].type == (ushort) 201 || Main.tile[index7, index8].type == (ushort) 32 || Main.tile[index7, index8].type == (ushort) 352 || Main.tile[index7, index8].type == (ushort) 636 || Main.tile[index7, index8].type == (ushort) 205)
              {
                WorldGen.KillTile(index7, index8);
                if (Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, index7, index8);
                flag = true;
              }
            }
          }
        }
      }
      if (NPC.downedPlantBoss && WorldGen.genRand.Next(2) != 0 || !WorldGen.AllowedToSpreadInfections)
        return;
      if (type == 23 || type == 25 || type == 32 || type == 112 || type == 163 || type == 400 || type == 398 || type == 636 || type == 661)
      {
        bool flag = true;
        while (flag)
        {
          flag = false;
          int index9 = i + WorldGen.genRand.Next(-3, 4);
          int index10 = j + WorldGen.genRand.Next(-3, 4);
          if (WorldGen.InWorld(index9, index10, 10))
          {
            if (WorldGen.nearbyChlorophyte(index9, index10))
              WorldGen.ChlorophyteDefense(index9, index10);
            else if (WorldGen.CountNearBlocksTypes(index9, index10, 2, 1, 27) <= 0)
            {
              if (Main.tile[index9, index10].type == (ushort) 2)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index9, index10].type = (ushort) 23;
                WorldGen.SquareTileFrame(index9, index10);
                NetMessage.SendTileSquare(-1, index9, index10);
              }
              else if (Main.tile[index9, index10].type == (ushort) 1 || Main.tileMoss[(int) Main.tile[index9, index10].type])
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index9, index10].type = (ushort) 25;
                WorldGen.SquareTileFrame(index9, index10);
                NetMessage.SendTileSquare(-1, index9, index10);
              }
              else if (Main.tile[index9, index10].type == (ushort) 53)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index9, index10].type = (ushort) 112;
                WorldGen.SquareTileFrame(index9, index10);
                NetMessage.SendTileSquare(-1, index9, index10);
              }
              else if (Main.tile[index9, index10].type == (ushort) 396)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index9, index10].type = (ushort) 400;
                WorldGen.SquareTileFrame(index9, index10);
                NetMessage.SendTileSquare(-1, index9, index10);
              }
              else if (Main.tile[index9, index10].type == (ushort) 397)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index9, index10].type = (ushort) 398;
                WorldGen.SquareTileFrame(index9, index10);
                NetMessage.SendTileSquare(-1, index9, index10);
              }
              else if (Main.tile[index9, index10].type == (ushort) 60)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index9, index10].type = (ushort) 661;
                WorldGen.SquareTileFrame(index9, index10);
                NetMessage.SendTileSquare(-1, index9, index10);
              }
              else if (Main.tile[index9, index10].type == (ushort) 69)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index9, index10].type = (ushort) 32;
                WorldGen.SquareTileFrame(index9, index10);
                NetMessage.SendTileSquare(-1, index9, index10);
              }
              else if (Main.tile[index9, index10].type == (ushort) 161)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index9, index10].type = (ushort) 163;
                WorldGen.SquareTileFrame(index9, index10);
                NetMessage.SendTileSquare(-1, index9, index10);
              }
            }
          }
        }
      }
      if (type == 199 || type == 200 || type == 201 || type == 203 || type == 205 || type == 234 || type == 352 || type == 401 || type == 399 || type == 662)
      {
        bool flag = true;
        while (flag)
        {
          flag = false;
          int index11 = i + WorldGen.genRand.Next(-3, 4);
          int index12 = j + WorldGen.genRand.Next(-3, 4);
          if (WorldGen.InWorld(index11, index12, 10))
          {
            if (WorldGen.nearbyChlorophyte(index11, index12))
              WorldGen.ChlorophyteDefense(index11, index12);
            else if (WorldGen.CountNearBlocksTypes(index11, index12, 2, 1, 27) <= 0)
            {
              if (Main.tile[index11, index12].type == (ushort) 2)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index11, index12].type = (ushort) 199;
                WorldGen.SquareTileFrame(index11, index12);
                NetMessage.SendTileSquare(-1, index11, index12);
              }
              else if (Main.tile[index11, index12].type == (ushort) 1 || Main.tileMoss[(int) Main.tile[index11, index12].type])
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index11, index12].type = (ushort) 203;
                WorldGen.SquareTileFrame(index11, index12);
                NetMessage.SendTileSquare(-1, index11, index12);
              }
              else if (Main.tile[index11, index12].type == (ushort) 53)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index11, index12].type = (ushort) 234;
                WorldGen.SquareTileFrame(index11, index12);
                NetMessage.SendTileSquare(-1, index11, index12);
              }
              else if (Main.tile[index11, index12].type == (ushort) 396)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index11, index12].type = (ushort) 401;
                WorldGen.SquareTileFrame(index11, index12);
                NetMessage.SendTileSquare(-1, index11, index12);
              }
              else if (Main.tile[index11, index12].type == (ushort) 397)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index11, index12].type = (ushort) 399;
                WorldGen.SquareTileFrame(index11, index12);
                NetMessage.SendTileSquare(-1, index11, index12);
              }
              else if (Main.tile[index11, index12].type == (ushort) 60)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index11, index12].type = (ushort) 662;
                WorldGen.SquareTileFrame(index11, index12);
                NetMessage.SendTileSquare(-1, index11, index12);
              }
              else if (Main.tile[index11, index12].type == (ushort) 69)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index11, index12].type = (ushort) 352;
                WorldGen.SquareTileFrame(index11, index12);
                NetMessage.SendTileSquare(-1, index11, index12);
              }
              else if (Main.tile[index11, index12].type == (ushort) 161)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index11, index12].type = (ushort) 200;
                WorldGen.SquareTileFrame(index11, index12);
                NetMessage.SendTileSquare(-1, index11, index12);
              }
            }
          }
        }
      }
      if (type != 109 && type != 110 && type != 113 && type != 115 && type != 116 && type != 117 && type != 164 && type != 402 && type != 403 && type != 492)
        return;
      bool flag1 = true;
      while (flag1)
      {
        flag1 = false;
        int index13 = i + WorldGen.genRand.Next(-3, 4);
        int index14 = j + WorldGen.genRand.Next(-3, 4);
        if (WorldGen.InWorld(index13, index14, 10))
        {
          if (WorldGen.CountNearBlocksTypes(index13, index14, 2, 1, 27) <= 0)
          {
            if (Main.tile[index13, index14].type == (ushort) 2)
            {
              if (WorldGen.genRand.Next(2) == 0)
                flag1 = true;
              Main.tile[index13, index14].type = (ushort) 109;
              WorldGen.SquareTileFrame(index13, index14);
              NetMessage.SendTileSquare(-1, index13, index14);
            }
            else if (Main.tile[index13, index14].type == (ushort) 477)
            {
              if (WorldGen.genRand.Next(2) == 0)
                flag1 = true;
              Main.tile[index13, index14].type = (ushort) 492;
              WorldGen.SquareTileFrame(index13, index14);
              NetMessage.SendTileSquare(-1, index13, index14);
            }
            else if (Main.tile[index13, index14].type == (ushort) 1 || Main.tileMoss[(int) Main.tile[index13, index14].type])
            {
              if (WorldGen.genRand.Next(2) == 0)
                flag1 = true;
              Main.tile[index13, index14].type = (ushort) 117;
              WorldGen.SquareTileFrame(index13, index14);
              NetMessage.SendTileSquare(-1, index13, index14);
            }
            else if (Main.tile[index13, index14].type == (ushort) 53)
            {
              if (WorldGen.genRand.Next(2) == 0)
                flag1 = true;
              Main.tile[index13, index14].type = (ushort) 116;
              WorldGen.SquareTileFrame(index13, index14);
              NetMessage.SendTileSquare(-1, index13, index14);
            }
            else if (Main.tile[index13, index14].type == (ushort) 396)
            {
              if (WorldGen.genRand.Next(2) == 0)
                flag1 = true;
              Main.tile[index13, index14].type = (ushort) 403;
              WorldGen.SquareTileFrame(index13, index14);
              NetMessage.SendTileSquare(-1, index13, index14);
            }
            else if (Main.tile[index13, index14].type == (ushort) 397)
            {
              if (WorldGen.genRand.Next(2) == 0)
                flag1 = true;
              Main.tile[index13, index14].type = (ushort) 402;
              WorldGen.SquareTileFrame(index13, index14);
              NetMessage.SendTileSquare(-1, index13, index14);
            }
            else if (Main.tile[index13, index14].type == (ushort) 161)
            {
              if (WorldGen.genRand.Next(2) == 0)
                flag1 = true;
              Main.tile[index13, index14].type = (ushort) 164;
              WorldGen.SquareTileFrame(index13, index14);
              NetMessage.SendTileSquare(-1, index13, index14);
            }
          }
        }
      }
    }

    public static bool SolidTile(Tile testTile)
    {
      try
      {
        if (testTile == null)
          return true;
        if (testTile.active())
        {
          if (Main.tileSolid[(int) testTile.type])
          {
            if (!Main.tileSolidTop[(int) testTile.type])
            {
              if (!testTile.halfBrick())
              {
                if (testTile.slope() == (byte) 0)
                {
                  if (!testTile.inActive())
                    return true;
                }
              }
            }
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static bool TileEmpty(int i, int j) => Main.tile[i, j] == null || !Main.tile[i, j].active() || Main.tile[i, j].inActive();

    public static bool SolidOrSlopedTile(Tile tile) => tile != null && tile.active() && Main.tileSolid[(int) tile.type] && !Main.tileSolidTop[(int) tile.type] && !tile.inActive();

    public static int TileType(int x, int y) => !Main.tile[x, y].active() ? -1 : (int) Main.tile[x, y].type;

    public static bool SolidOrSlopedTile(int x, int y) => WorldGen.SolidOrSlopedTile(Main.tile[x, y]);

    public static bool IsRope(int x, int y) => Main.tile[x, y] != null && Main.tile[x, y].active() && (Main.tileRope[(int) Main.tile[x, y].type] || (Main.tile[x, y].type == (ushort) 314 || TileID.Sets.Platforms[(int) Main.tile[x, y].type]) && Main.tile[x, y - 1] != null && Main.tile[x, y + 1] != null && Main.tile[x, y - 1].active() && Main.tile[x, y + 1].active() && Main.tileRope[(int) Main.tile[x, y - 1].type] && Main.tileRope[(int) Main.tile[x, y + 1].type]);

    public static bool SolidTile(Point p) => WorldGen.SolidTile(p.X, p.Y);

    public static bool SolidTile(int i, int j, bool noDoors = false)
    {
      try
      {
        if (Main.tile[i, j] == null)
          return true;
        if (Main.tile[i, j].active())
        {
          if (Main.tileSolid[(int) Main.tile[i, j].type])
          {
            if (!Main.tileSolidTop[(int) Main.tile[i, j].type])
            {
              if (!Main.tile[i, j].halfBrick())
              {
                if (Main.tile[i, j].slope() == (byte) 0)
                {
                  if (!Main.tile[i, j].inActive())
                    return !noDoors || Main.tile[i, j].type != (ushort) 10;
                }
              }
            }
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static bool SolidTile2(Tile testTile)
    {
      try
      {
        if (testTile == null)
          return true;
        if (testTile.active())
        {
          if (Main.tileSolid[(int) testTile.type])
          {
            if (testTile.slope() == (byte) 0)
            {
              if (!testTile.halfBrick())
              {
                if (!testTile.inActive())
                  return true;
              }
            }
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static bool PlatformProperTopFrame(short frameX)
    {
      int num = (int) frameX / TileObjectData.PlatformFrameWidth();
      if (num >= 0 && num <= 7 || num >= 12 && num <= 16)
        return true;
      return num >= 25 && num <= 26;
    }

    public static bool SolidTileAllowBottomSlope(int i, int j)
    {
      try
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return true;
        if (tile.active())
        {
          if (!Main.tileSolid[(int) tile.type])
          {
            if (!Main.tileSolidTop[(int) tile.type])
              goto label_12;
          }
          if (tile.topSlope())
          {
            if (TileID.Sets.Platforms[(int) tile.type])
            {
              if (!WorldGen.PlatformProperTopFrame(tile.frameX))
                goto label_12;
            }
            else
              goto label_12;
          }
          if (!tile.halfBrick())
          {
            if (!tile.inActive())
              return true;
          }
        }
      }
      catch
      {
      }
label_12:
      return false;
    }

    public static bool ActiveAndWalkableTile(int i, int j)
    {
      try
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return true;
        if (tile.active())
        {
          if (Main.tileSolid[(int) tile.type])
          {
            if (!tile.inActive())
              return true;
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static bool SolidTileAllowTopSlope(int i, int j)
    {
      try
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return true;
        if (tile.active())
        {
          if (!Main.tileSolid[(int) tile.type])
          {
            if (tile.type != (ushort) 380)
              goto label_11;
          }
          if (tile.bottomSlope())
          {
            if (TileID.Sets.Platforms[(int) tile.type])
            {
              if (!tile.halfBrick())
                goto label_11;
            }
            else
              goto label_11;
          }
          if (!tile.inActive())
            return true;
        }
      }
      catch
      {
      }
label_11:
      return false;
    }

    public static bool SolidTileAllowLeftSlope(int i, int j)
    {
      try
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return true;
        if (tile.active())
        {
          if (Main.tileSolid[(int) tile.type])
          {
            if (!tile.rightSlope())
            {
              if (!TileID.Sets.Platforms[(int) tile.type])
              {
                if (!tile.inActive())
                  return true;
              }
            }
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static bool SolidTileAllowRightSlope(int i, int j)
    {
      try
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return true;
        if (tile.active())
        {
          if (Main.tileSolid[(int) tile.type])
          {
            if (!tile.leftSlope())
            {
              if (!TileID.Sets.Platforms[(int) tile.type])
              {
                if (!tile.inActive())
                  return true;
              }
            }
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static bool TopEdgeCanBeAttachedTo(int i, int j)
    {
      try
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return true;
        if (tile.active())
        {
          if (!Main.tileSolid[(int) tile.type])
          {
            if (!Main.tileSolidTop[(int) tile.type])
              goto label_12;
          }
          if (tile.topSlope())
          {
            if (TileID.Sets.Platforms[(int) tile.type])
            {
              if (!WorldGen.PlatformProperTopFrame(tile.frameX))
                goto label_12;
            }
            else
              goto label_12;
          }
          if (!tile.halfBrick())
          {
            if (!tile.inActive())
              return true;
          }
        }
      }
      catch
      {
      }
label_12:
      return false;
    }

    public static bool RightEdgeCanBeAttachedTo(int i, int j)
    {
      try
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return true;
        if (tile.active())
        {
          if (Main.tileSolid[(int) tile.type])
          {
            if (!Main.tileSolidTop[(int) tile.type])
            {
              if (!tile.rightSlope())
              {
                if (!tile.halfBrick())
                {
                  if (!tile.inActive())
                  {
                    if (!Main.tileNoAttach[(int) tile.type])
                      return true;
                  }
                }
              }
            }
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static bool LeftEdgeCanBeAttachedTo(int i, int j)
    {
      try
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return true;
        if (tile.active())
        {
          if (Main.tileSolid[(int) tile.type])
          {
            if (!Main.tileSolidTop[(int) tile.type])
            {
              if (!tile.leftSlope())
              {
                if (!tile.halfBrick())
                {
                  if (!tile.inActive())
                  {
                    if (!Main.tileNoAttach[(int) tile.type])
                      return true;
                  }
                }
              }
            }
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static bool BottomEdgeCanBeAttachedTo(int i, int j)
    {
      try
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return true;
        if (tile.active())
        {
          if (Main.tileSolid[(int) tile.type])
          {
            if (!Main.tileSolidTop[(int) tile.type])
            {
              if (!tile.bottomSlope())
              {
                if (!tile.inActive())
                {
                  if (!Main.tileNoAttach[(int) tile.type])
                    return true;
                }
              }
            }
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static bool SolidTile3(int i, int j) => WorldGen.InWorld(i, j, 1) && WorldGen.SolidTile3(Main.tile[i, j]);

    public static bool SolidTile3(Tile t) => t != null && t.active() && !t.inActive() && Main.tileSolid[(int) t.type] && !Main.tileSolidTop[(int) t.type];

    public static bool SolidTile2(int i, int j)
    {
      try
      {
        if (Main.tile[i, j] == null)
          return true;
        if (Main.tile[i, j].active())
        {
          if (Main.tileSolid[(int) Main.tile[i, j].type])
          {
            if (!TileID.Sets.Platforms[(int) Main.tile[i, j].type] || !Main.tile[i, j].halfBrick() && !Main.tile[i, j].topSlope())
            {
              if (Main.tile[i, j].slope() != (byte) 0)
                goto label_10;
            }
            if (!Main.tile[i, j].halfBrick())
            {
              if (!Main.tile[i, j].inActive())
                return true;
            }
          }
        }
      }
      catch
      {
      }
label_10:
      return false;
    }

    public static bool SolidTileNoAttach(int i, int j)
    {
      try
      {
        if (Main.tile[i, j] == null)
          return true;
        if (Main.tile[i, j].active())
        {
          if (Main.tileSolid[(int) Main.tile[i, j].type])
          {
            if (!Main.tileNoAttach[(int) Main.tile[i, j].type])
            {
              if (Main.tile[i, j].slope() == (byte) 0)
              {
                if (!Main.tile[i, j].halfBrick())
                {
                  if (!Main.tile[i, j].inActive())
                    return true;
                }
              }
            }
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static void MineHouse(int i, int j)
    {
      if (i < 50 || i > Main.maxTilesX - 50 || j < 50 || j > Main.maxTilesY - 50)
        return;
      int num1 = WorldGen.genRand.Next(6, 12);
      int num2 = WorldGen.genRand.Next(3, 6);
      int num3 = WorldGen.genRand.Next(15, 30);
      int num4 = WorldGen.genRand.Next(15, 30);
      if (WorldGen.SolidTile(i, j) || Main.tile[i, j].wall > (ushort) 0)
        return;
      int num5 = j - num1;
      int num6 = j + num2;
      for (int index1 = 0; index1 < 2; ++index1)
      {
        bool flag1 = true;
        int i1 = i;
        int j1 = j;
        int num7 = -1;
        int num8 = num3;
        if (index1 == 1)
        {
          num7 = 1;
          num8 = num4;
          ++i1;
        }
        while (flag1)
        {
          if (j1 - num1 < num5)
            num5 = j1 - num1;
          if (j1 + num2 > num6)
            num6 = j1 + num2;
          for (int index2 = 0; index2 < 2; ++index2)
          {
            int j2 = j1;
            bool flag2 = true;
            int num9 = num1;
            int num10 = -1;
            if (index2 == 1)
            {
              ++j2;
              num9 = num2;
              num10 = 1;
            }
            while (flag2)
            {
              if (i1 != i && Main.tile[i1 - num7, j2].wall != (ushort) 27 && (WorldGen.SolidTile(i1 - num7, j2) || !Main.tile[i1 - num7, j2].active() || Main.tile[i1 - num7, j2].halfBrick() || Main.tile[i1 - num7, j2].slope() != (byte) 0))
              {
                Main.tile[i1 - num7, j2].active(true);
                Main.tile[i1 - num7, j2].type = (ushort) 30;
              }
              if (WorldGen.SolidTile(i1 - 1, j2) || Main.tile[i1 - 1, j2].halfBrick() || Main.tile[i1 - 1, j2].slope() != (byte) 0)
                Main.tile[i1 - 1, j2].type = (ushort) 30;
              if (WorldGen.SolidTile(i1 + 1, j2) || Main.tile[i1 + 1, j2].halfBrick() || Main.tile[i1 + 1, j2].slope() != (byte) 0)
                Main.tile[i1 + 1, j2].type = (ushort) 30;
              if (WorldGen.SolidTile(i1, j2) || Main.tile[i1, j2].halfBrick() || Main.tile[i1, j2].slope() != (byte) 0)
              {
                int num11 = 0;
                if (WorldGen.SolidTile(i1 - 1, j2))
                  ++num11;
                if (WorldGen.SolidTile(i1 + 1, j2))
                  ++num11;
                if (WorldGen.SolidTile(i1, j2 - 1))
                  ++num11;
                if (WorldGen.SolidTile(i1, j2 + 1))
                  ++num11;
                if (num11 < 2)
                {
                  Main.tile[i1, j2].active(false);
                }
                else
                {
                  flag2 = false;
                  Main.tile[i1, j2].type = (ushort) 30;
                }
              }
              else
              {
                Main.tile[i1, j2].wall = (ushort) 27;
                Main.tile[i1, j2].liquid = (byte) 0;
                Main.tile[i1, j2].lava(false);
              }
              j2 += num10;
              --num9;
              if (num9 <= 0)
              {
                if (!Main.tile[i1, j2].active())
                {
                  Main.tile[i1, j2].active(true);
                  Main.tile[i1, j2].type = (ushort) 30;
                }
                flag2 = false;
              }
            }
          }
          --num8;
          i1 += num7;
          if (WorldGen.SolidTile(i1, j1))
          {
            int num12 = 0;
            int num13 = 0;
            int j3 = j1;
            bool flag3 = true;
            while (flag3)
            {
              --j3;
              ++num12;
              if (WorldGen.SolidTile(i1 - num7, j3))
              {
                num12 = 999;
                flag3 = false;
              }
              else if (!WorldGen.SolidTile(i1, j3))
                flag3 = false;
            }
            int j4 = j1;
            bool flag4 = true;
            while (flag4)
            {
              ++j4;
              ++num13;
              if (WorldGen.SolidTile(i1 - num7, j4))
              {
                num13 = 999;
                flag4 = false;
              }
              else if (!WorldGen.SolidTile(i1, j4))
                flag4 = false;
            }
            if (num13 <= num12)
            {
              if (num13 > num2)
                num8 = 0;
              else
                j1 += num13 + 1;
            }
            else if (num12 > num1)
              num8 = 0;
            else
              j1 -= num12 + 1;
          }
          if (num8 <= 0)
            flag1 = false;
        }
      }
      int minValue1 = i - num3 - 1;
      int maxValue1 = i + num4 + 2;
      int minValue2 = num5 - 1;
      int maxValue2 = num6 + 2;
      for (int i2 = minValue1; i2 < maxValue1; ++i2)
      {
        for (int j5 = minValue2; j5 < maxValue2; ++j5)
        {
          if (Main.tile[i2, j5].wall == (ushort) 27 && !Main.tile[i2, j5].active())
          {
            if (Main.tile[i2 - 1, j5].wall != (ushort) 27 && i2 < i && !WorldGen.SolidTile(i2 - 1, j5))
            {
              WorldGen.PlaceTile(i2, j5, 30, true);
              Main.tile[i2, j5].wall = (ushort) 0;
            }
            if (Main.tile[i2 + 1, j5].wall != (ushort) 27 && i2 > i && !WorldGen.SolidTile(i2 + 1, j5))
            {
              WorldGen.PlaceTile(i2, j5, 30, true);
              Main.tile[i2, j5].wall = (ushort) 0;
            }
            for (int i3 = i2 - 1; i3 <= i2 + 1; ++i3)
            {
              for (int j6 = j5 - 1; j6 <= j5 + 1; ++j6)
              {
                if (WorldGen.SolidTile(i3, j6))
                  Main.tile[i3, j6].type = (ushort) 30;
              }
            }
          }
          if (Main.tile[i2, j5].type == (ushort) 30 && Main.tile[i2 - 1, j5].wall == (ushort) 27 && Main.tile[i2 + 1, j5].wall == (ushort) 27 && (Main.tile[i2, j5 - 1].wall == (ushort) 27 || Main.tile[i2, j5 - 1].active()) && (Main.tile[i2, j5 + 1].wall == (ushort) 27 || Main.tile[i2, j5 + 1].active()))
          {
            Main.tile[i2, j5].active(false);
            Main.tile[i2, j5].wall = (ushort) 27;
          }
        }
      }
      for (int index3 = minValue1; index3 < maxValue1; ++index3)
      {
        for (int index4 = minValue2; index4 < maxValue2; ++index4)
        {
          if (Main.tile[index3, index4].type == (ushort) 30)
          {
            if (Main.tile[index3 - 1, index4].wall == (ushort) 27 && Main.tile[index3 + 1, index4].wall == (ushort) 27 && !Main.tile[index3 - 1, index4].active() && !Main.tile[index3 + 1, index4].active())
            {
              Main.tile[index3, index4].active(false);
              Main.tile[index3, index4].wall = (ushort) 27;
            }
            if (!TileID.Sets.BasicChest[(int) Main.tile[index3, index4 - 1].type] && Main.tile[index3 - 1, index4].wall == (ushort) 27 && Main.tile[index3 + 1, index4].type == (ushort) 30 && Main.tile[index3 + 2, index4].wall == (ushort) 27 && !Main.tile[index3 - 1, index4].active() && !Main.tile[index3 + 2, index4].active())
            {
              Main.tile[index3, index4].active(false);
              Main.tile[index3, index4].wall = (ushort) 27;
              Main.tile[index3 + 1, index4].active(false);
              Main.tile[index3 + 1, index4].wall = (ushort) 27;
            }
            if (Main.tile[index3, index4 - 1].wall == (ushort) 27 && Main.tile[index3, index4 + 1].wall == (ushort) 27 && !Main.tile[index3, index4 - 1].active() && !Main.tile[index3, index4 + 1].active())
            {
              Main.tile[index3, index4].active(false);
              Main.tile[index3, index4].wall = (ushort) 27;
            }
          }
        }
      }
      for (int i4 = minValue1; i4 < maxValue1; ++i4)
      {
        for (int j7 = maxValue2; j7 > minValue2; --j7)
        {
          bool flag5 = false;
          if (Main.tile[i4, j7].active() && Main.tile[i4, j7].type == (ushort) 30)
          {
            int num14 = -1;
            for (int index5 = 0; index5 < 2; ++index5)
            {
              if (!WorldGen.SolidTile(i4 + num14, j7) && Main.tile[i4 + num14, j7].wall == (ushort) 0)
              {
                int num15 = 0;
                int j8 = j7;
                int num16 = j7;
                while (Main.tile[i4, j8].active() && Main.tile[i4, j8].type == (ushort) 30 && !WorldGen.SolidTile(i4 + num14, j8) && Main.tile[i4 + num14, j8].wall == (ushort) 0)
                {
                  --j8;
                  ++num15;
                }
                int num17 = j8 + 1 + 1;
                if (num15 > 4)
                {
                  if (WorldGen.genRand.Next(2) == 0)
                  {
                    int j9 = num16 - 1;
                    bool flag6 = true;
                    for (int index6 = i4 - 2; index6 <= i4 + 2; ++index6)
                    {
                      for (int index7 = j9 - 2; index7 <= j9; ++index7)
                      {
                        if (index6 != i4 && Main.tile[index6, index7].active())
                          flag6 = false;
                      }
                    }
                    if (flag6)
                    {
                      Main.tile[i4, j9].active(false);
                      Main.tile[i4, j9 - 1].active(false);
                      Main.tile[i4, j9 - 2].active(false);
                      WorldGen.PlaceTile(i4, j9, 10, true);
                      flag5 = true;
                    }
                  }
                  if (!flag5)
                  {
                    for (int index8 = num17; index8 < num16; ++index8)
                      Main.tile[i4, index8].type = (ushort) 124;
                  }
                }
              }
              num14 = 1;
            }
          }
          if (flag5)
            break;
        }
      }
      int num18 = WorldGen.genRand.Next(1, 2);
      if (WorldGen.genRand.Next(4) == 0)
        num18 = 0;
      if (WorldGen.genRand.Next(6) == 0)
        ++num18;
      if (WorldGen.genRand.Next(10) == 0)
        ++num18;
      for (int index9 = 0; index9 < num18; ++index9)
      {
        int num19 = 0;
        int index10 = WorldGen.genRand.Next(minValue1, maxValue1);
        int index11;
        for (index11 = WorldGen.genRand.Next(minValue2, maxValue2); !Main.wallHouse[(int) Main.tile[index10, index11].wall] || Main.tile[index10, index11].active(); index11 = WorldGen.genRand.Next(minValue2, maxValue2))
        {
          ++num19;
          if (num19 <= 1000)
            index10 = WorldGen.genRand.Next(minValue1, maxValue1);
          else
            break;
        }
        if (num19 <= 1000)
        {
          for (int index12 = 0; index12 < 2; ++index12)
          {
            int index13 = index10;
            int index14 = index10;
            while (!Main.tile[index13, index11].active() && Main.wallHouse[(int) Main.tile[index13, index11].wall])
              --index13;
            int num20 = index13 + 1;
            while (!Main.tile[index14, index11].active() && Main.wallHouse[(int) Main.tile[index14, index11].wall])
              ++index14;
            int num21 = index14 - 1;
            i = (num20 + num21) / 2;
            int index15 = index11;
            int index16 = index11;
            while (!Main.tile[index10, index15].active() && Main.wallHouse[(int) Main.tile[index10, index15].wall])
              --index15;
            int num22 = index15 + 1;
            while (!Main.tile[index10, index16].active() && Main.wallHouse[(int) Main.tile[index10, index16].wall])
              ++index16;
            int num23 = index16 - 1;
            index11 = (num22 + num23) / 2;
          }
          int index17 = index10;
          int index18 = index10;
          while (!Main.tile[index17, index11].active() && !Main.tile[index17, index11 - 1].active() && !Main.tile[index17, index11 + 1].active())
            --index17;
          int num24 = index17 + 1;
          while (!Main.tile[index18, index11].active() && !Main.tile[index18, index11 - 1].active() && !Main.tile[index18, index11 + 1].active())
            ++index18;
          int num25 = index18 - 1;
          int index19 = index11;
          int index20 = index11;
          while (!Main.tile[index10, index19].active() && !Main.tile[index10 - 1, index19].active() && !Main.tile[index10 + 1, index19].active())
            --index19;
          int num26 = index19 + 1;
          while (!Main.tile[index10, index20].active() && !Main.tile[index10 - 1, index20].active() && !Main.tile[index10 + 1, index20].active())
            ++index20;
          int num27 = index20 - 1;
          int num28 = (num24 + num25) / 2;
          int num29 = (num26 + num27) / 2;
          int num30 = num25 - num24;
          int num31 = num27 - num26;
          if (num30 > 7 && num31 > 5)
          {
            int num32 = 0;
            if (WorldGen.nearPicture2(i, num29))
              num32 = -1;
            if (num32 == 0)
            {
              PaintingEntry paintingEntry = WorldGen.RandHousePicture();
              if (!WorldGen.nearPicture(num28, num29))
                WorldGen.PlaceTile(num28, num29, paintingEntry.tileType, true, style: paintingEntry.style);
            }
          }
        }
        else
          break;
      }
      for (int i5 = minValue1; i5 < maxValue1; i5 = i5 + WorldGen.genRand.Next(4) + 1)
      {
        bool flag = true;
        for (int j10 = minValue2; j10 < maxValue2; ++j10)
        {
          for (int i6 = i5 - 3; i6 <= i5 + 3; ++i6)
          {
            if (Main.tile[i6, j10].active() && (!WorldGen.SolidTile(i6, j10) || Main.tile[i6, j10].type == (ushort) 10))
              flag = false;
          }
        }
        if (flag)
        {
          for (int j11 = minValue2; j11 < maxValue2; ++j11)
          {
            if (Main.tile[i5, j11].wall == (ushort) 27 && !Main.tile[i5, j11].active())
              WorldGen.PlaceTile(i5, j11, 124, true);
          }
        }
      }
      for (int index21 = 0; index21 < 4; ++index21)
      {
        int i7 = WorldGen.genRand.Next(minValue1 + 2, maxValue1 - 1);
        int index22;
        for (index22 = WorldGen.genRand.Next(minValue2 + 2, maxValue2 - 1); Main.tile[i7, index22].wall != (ushort) 27; index22 = WorldGen.genRand.Next(minValue2 + 2, maxValue2 - 1))
          i7 = WorldGen.genRand.Next(minValue1 + 2, maxValue1 - 1);
        while (Main.tile[i7, index22].active())
          --index22;
        while (!Main.tile[i7, index22].active())
          ++index22;
        int j12 = index22 - 1;
        if (Main.tile[i7, j12].wall == (ushort) 27)
        {
          if (WorldGen.genRand.Next(3) == 0)
          {
            int Type = WorldGen.genRand.Next(9);
            if (Type == 0)
              Type = 14;
            if (Type == 1)
              Type = 16;
            if (Type == 2)
              Type = 18;
            if (Type == 3)
              Type = 86;
            if (Type == 4)
              Type = 87;
            if (Type == 5)
              Type = 94;
            if (Type == 6)
              Type = 101;
            if (Type == 7)
              Type = 104;
            if (Type == 8)
              Type = 106;
            WorldGen.PlaceTile(i7, j12, Type, true);
          }
          else if (GenVars.statueList != null)
          {
            int index23 = WorldGen.genRand.Next(2, GenVars.statueList.Length);
            WorldGen.PlaceTile(i7, j12, (int) GenVars.statueList[index23].X, true, true, style: ((int) GenVars.statueList[index23].Y));
          }
        }
      }
      for (int index24 = 0; index24 < 40; ++index24)
      {
        int i8 = WorldGen.genRand.Next(minValue1 + 2, maxValue1 - 1);
        int index25;
        for (index25 = WorldGen.genRand.Next(minValue2 + 2, maxValue2 - 1); Main.tile[i8, index25].wall != (ushort) 27; index25 = WorldGen.genRand.Next(minValue2 + 2, maxValue2 - 1))
          i8 = WorldGen.genRand.Next(minValue1 + 2, maxValue1 - 1);
        while (Main.tile[i8, index25].active())
          --index25;
        while (!Main.tile[i8, index25].active())
          ++index25;
        int j13 = index25 - 1;
        if (Main.tile[i8, j13].wall == (ushort) 27 && WorldGen.genRand.Next(2) == 0)
        {
          int style = WorldGen.genRand.Next(22, 26);
          WorldGen.PlaceTile(i8, j13, 186, true, style: style);
        }
      }
      for (int index26 = 0; index26 < 20; ++index26)
      {
        int i9 = WorldGen.genRand.Next(minValue1 + 2, maxValue1 - 1);
        int index27;
        for (index27 = WorldGen.genRand.Next(minValue2 + 2, maxValue2 - 1); Main.tile[i9, index27].wall != (ushort) 27; index27 = WorldGen.genRand.Next(minValue2 + 2, maxValue2 - 1))
          i9 = WorldGen.genRand.Next(minValue1 + 2, maxValue1 - 1);
        while (Main.tile[i9, index27].active())
          --index27;
        while (!Main.tile[i9, index27].active())
          ++index27;
        int j14 = index27 - 1;
        if (Main.tile[i9, j14].wall == (ushort) 27 && WorldGen.genRand.Next(2) == 0)
        {
          int X = WorldGen.genRand.Next(31, 34);
          WorldGen.PlaceSmallPile(i9, j14, X, 1);
        }
      }
      for (int index28 = 0; index28 < 15; ++index28)
      {
        int i10 = WorldGen.genRand.Next(minValue1 + 2, maxValue1 - 1);
        int j15;
        for (j15 = WorldGen.genRand.Next(minValue2 + 2, maxValue2 - 1); Main.tile[i10, j15].wall != (ushort) 27; j15 = WorldGen.genRand.Next(minValue2 + 2, maxValue2 - 1))
          i10 = WorldGen.genRand.Next(minValue1 + 2, maxValue1 - 1);
        while (Main.tile[i10, j15].active())
          --j15;
        while (j15 > 0 && !Main.tile[i10, j15 - 1].active())
          --j15;
        if (Main.tile[i10, j15].wall == (ushort) 27)
        {
          int style = 0;
          int Type;
          if (WorldGen.genRand.Next(10) < 9)
          {
            Type = -1;
          }
          else
          {
            Type = 34;
            style = WorldGen.genRand.Next(6);
          }
          if (Type > 0)
          {
            WorldGen.PlaceTile(i10, j15, Type, true, style: style);
            if ((int) Main.tile[i10, j15].type == Type)
            {
              if (Type == 4)
              {
                Main.tile[i10, j15].frameX += (short) 54;
              }
              else
              {
                int index29 = i10;
                int index30 = j15;
                int index31 = index30 - (int) Main.tile[index29, index30].frameY % 54 / 18;
                int num33 = (int) Main.tile[index29, index30].frameX / 18;
                if (num33 > 2)
                  num33 -= 3;
                int index32 = index29 - num33;
                short num34 = 54;
                if (Main.tile[index32, index31].frameX > (short) 0)
                  num34 = (short) -54;
                for (int index33 = index32; index33 < index32 + 3; ++index33)
                {
                  for (int index34 = index31; index34 < index31 + 3; ++index34)
                    Main.tile[index33, index34].frameX += num34;
                }
              }
            }
          }
        }
      }
    }

    public static void CountTiles(int X)
    {
      if (X == 0)
      {
        WorldGen.totalEvil = WorldGen.totalEvil2;
        WorldGen.totalBlood = WorldGen.totalBlood2;
        WorldGen.totalSolid = WorldGen.totalSolid2;
        WorldGen.totalGood = WorldGen.totalGood2;
        WorldGen.tGood = (byte) Math.Round((double) WorldGen.totalGood / (double) WorldGen.totalSolid * 100.0);
        WorldGen.tEvil = (byte) Math.Round((double) WorldGen.totalEvil / (double) WorldGen.totalSolid * 100.0);
        WorldGen.tBlood = (byte) Math.Round((double) WorldGen.totalBlood / (double) WorldGen.totalSolid * 100.0);
        if (WorldGen.tGood == (byte) 0 && WorldGen.totalGood > 0)
          WorldGen.tGood = (byte) 1;
        if (WorldGen.tEvil == (byte) 0 && WorldGen.totalEvil > 0)
          WorldGen.tEvil = (byte) 1;
        if (WorldGen.tBlood == (byte) 0 && WorldGen.totalBlood > 0)
          WorldGen.tBlood = (byte) 1;
        if (Main.netMode == 2)
          NetMessage.SendData(57);
        WorldGen.totalEvil2 = 0;
        WorldGen.totalSolid2 = 0;
        WorldGen.totalGood2 = 0;
        WorldGen.totalBlood2 = 0;
      }
      ushort index1 = 0;
      int num1 = 0;
      int num2 = 0;
      int num3 = 0;
      do
      {
        int num4;
        int num5;
        if (num2 == 0)
        {
          num4 = 0;
          num3 = (int) (Main.worldSurface + 1.0);
          num5 = 5;
        }
        else
        {
          num4 = num3;
          num3 = Main.maxTilesY;
          num5 = 1;
        }
        for (int index2 = num4; index2 < num3; ++index2)
        {
          Tile tile = Main.tile[X, index2] ?? (Main.tile[X, index2] = new Tile());
          ushort type = tile.type;
          if (type != (ushort) 0 || tile.active())
          {
            if ((int) type == (int) index1)
            {
              num1 += num5;
            }
            else
            {
              WorldGen.tileCounts[(int) index1] += num1;
              index1 = type;
              num1 = num5;
            }
          }
        }
        WorldGen.tileCounts[(int) index1] += num1;
        num1 = 0;
        ++num2;
      }
      while (num2 < 2);
      WorldGen.AddUpAlignmentCounts();
    }

    public static void AddUpAlignmentCounts(bool clearCounts = false)
    {
      if (clearCounts)
      {
        WorldGen.totalEvil2 = 0;
        WorldGen.totalSolid2 = 0;
        WorldGen.totalGood2 = 0;
        WorldGen.totalBlood2 = 0;
      }
      for (int index = 0; index < TileID.Sets.HallowCountCollection.Count; ++index)
        WorldGen.totalGood2 += WorldGen.tileCounts[TileID.Sets.HallowCountCollection[index]];
      for (int index = 0; index < TileID.Sets.CorruptCountCollection.Count; ++index)
        WorldGen.totalEvil2 += WorldGen.tileCounts[TileID.Sets.CorruptCountCollection[index]];
      for (int index = 0; index < TileID.Sets.CrimsonCountCollection.Count; ++index)
        WorldGen.totalBlood2 += WorldGen.tileCounts[TileID.Sets.CrimsonCountCollection[index]];
      WorldGen.totalSolid2 += WorldGen.tileCounts[2] + WorldGen.tileCounts[477] + WorldGen.tileCounts[1] + WorldGen.tileCounts[60] + WorldGen.tileCounts[53] + WorldGen.tileCounts[161];
      WorldGen.totalSolid2 += WorldGen.tileCounts[164] + WorldGen.tileCounts[109] + WorldGen.tileCounts[492] + WorldGen.tileCounts[117] + WorldGen.tileCounts[116];
      WorldGen.totalSolid2 += WorldGen.tileCounts[23] + WorldGen.tileCounts[661] + WorldGen.tileCounts[163] + WorldGen.tileCounts[112] + WorldGen.tileCounts[25];
      WorldGen.totalSolid2 += WorldGen.tileCounts[199] + WorldGen.tileCounts[662] + WorldGen.tileCounts[234] + WorldGen.tileCounts[203] + WorldGen.tileCounts[200];
      Array.Clear((Array) WorldGen.tileCounts, 0, WorldGen.tileCounts.Length);
    }

    public static void plantDye(int i, int j, bool exoticPlant = false)
    {
      UnifiedRandom unifiedRandom = WorldGen.gen ? WorldGen.genRand : Main.rand;
      if (!Main.tile[i, j].active() || i < 95 || i > Main.maxTilesX - 95 || j < 95 || j > Main.maxTilesY - 95)
        return;
      int num1 = 90;
      if (exoticPlant)
        num1 = 240;
      if (((double) j < Main.worldSurface || WorldGen.remixWorldGen) && (!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == (ushort) 3 || Main.tile[i, j - 1].type == (ushort) 51 || Main.tile[i, j - 1].type == (ushort) 61 || Main.tile[i, j - 1].type == (ushort) 73 || Main.tile[i, j - 1].type == (ushort) 74 || Main.tile[i, j - 1].type == (ushort) 184))
      {
        int num2 = Utils.Clamp<int>(i - num1, 1, Main.maxTilesX - 1 - 1);
        int num3 = Utils.Clamp<int>(i + num1, 1, Main.maxTilesX - 1 - 1);
        int num4 = Utils.Clamp<int>(j - num1, 1, Main.maxTilesY - 1 - 1);
        int num5 = Utils.Clamp<int>(j + num1, 1, Main.maxTilesY - 1 - 1);
        for (int index1 = num2; index1 < num3; ++index1)
        {
          for (int index2 = num4; index2 < num5; ++index2)
          {
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 227 && (!exoticPlant || Main.tile[index1, index2].frameX >= (short) 272) && (exoticPlant || Main.tile[index1, index2].frameX < (short) 272))
              return;
          }
        }
        if (exoticPlant)
        {
          int type = (int) Main.tile[i, j].type;
          bool flag = TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Moss[type] || type == 0;
          if (Main.tile[i, j - 1].liquid > (byte) 0 && (Main.tile[i, j - 1].lava() || Main.tile[i, j - 1].honey()))
            flag = false;
          if (flag)
            WorldGen.PlaceTile(i, j - 1, 227, true, style: WorldGen.genRand.Next(8, 12));
        }
        else if (Main.tile[i, j].type == (ushort) 2 || Main.tile[i, j].type == (ushort) 109)
        {
          if (unifiedRandom.Next(4) == 0)
            WorldGen.PlaceTile(i, j - 1, 227, true, style: 4);
          else
            WorldGen.PlaceTile(i, j - 1, 227, true, style: 3);
        }
        else if (Main.tile[i, j].type == (ushort) 60)
        {
          if (unifiedRandom.Next(2) == 0)
            WorldGen.PlaceTile(i, j - 1, 227, true, style: 2);
          else
            WorldGen.PlaceTile(i, j - 1, 227, true, style: 4);
        }
        else if (Main.tile[i, j].type == (ushort) 53 && Main.tile[i, j - 1].liquid == byte.MaxValue && Main.tile[i, j - 2].liquid == byte.MaxValue)
          WorldGen.PlaceTile(i, j - 1, 227, true, style: 2);
        else if (Main.tile[i, j].type == (ushort) 80 && !Main.tile[i - 1, j - 1].active())
        {
          if (!Main.tile[i + 1, j - 1].active())
          {
            try
            {
              bool flag = true;
              for (int index3 = i - 5; index3 <= i + 5; ++index3)
              {
                for (int index4 = j - 5; index4 <= j + 15; ++index4)
                {
                  if (Main.tile[index3, index4].active() && (Main.tile[index3, index4].type == (ushort) 112 || Main.tile[index3, index4].type == (ushort) 234))
                    flag = false;
                }
              }
              if (flag)
                WorldGen.PlaceTile(i, j - 1, 227, true, style: 6);
            }
            catch
            {
            }
          }
        }
      }
      if ((double) j < Main.worldSurface && !WorldGen.remixWorldGen || j >= Main.UnderworldLayer)
        return;
      if (!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == (ushort) 3 || Main.tile[i, j - 1].type == (ushort) 51 || Main.tile[i, j - 1].type == (ushort) 61 || Main.tile[i, j - 1].type == (ushort) 73 || Main.tile[i, j - 1].type == (ushort) 74 || Main.tile[i, j - 1].type == (ushort) 184)
      {
        int num6 = Utils.Clamp<int>(i - num1, 1, Main.maxTilesX - 1 - 1);
        int num7 = Utils.Clamp<int>(i + num1, 1, Main.maxTilesX - 1 - 1);
        int num8 = Utils.Clamp<int>(j - num1, 1, Main.maxTilesY - 1 - 1);
        int num9 = Utils.Clamp<int>(j + num1, 1, Main.maxTilesY - 1 - 1);
        for (int index5 = num6; index5 < num7; ++index5)
        {
          for (int index6 = num8; index6 < num9; ++index6)
          {
            if (Main.tile[index5, index6].active() && Main.tile[index5, index6].type == (ushort) 227 && (!exoticPlant || Main.tile[index5, index6].frameX >= (short) 272) && (exoticPlant || Main.tile[index5, index6].frameX < (short) 272))
              return;
          }
        }
        if (exoticPlant)
        {
          int type = (int) Main.tile[i, j].type;
          if ((TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Moss[type] ? 1 : (type == 0 ? 1 : 0)) != 0)
            WorldGen.PlaceTile(i, j - 1, 227, true, style: WorldGen.genRand.Next(8, 12));
        }
        else if (Main.tile[i, j].type == (ushort) 60)
        {
          if (unifiedRandom.Next(2) == 0)
            WorldGen.PlaceTile(i, j - 1, 227, true, style: 2);
          else if (unifiedRandom.Next(2) == 0)
            WorldGen.PlaceTile(i, j - 1, 227, true);
          else
            WorldGen.PlaceTile(i, j - 1, 227, true, style: 1);
        }
        else if (Main.tile[i, j].type == (ushort) 0 || Main.tile[i, j].type == (ushort) 1 || Main.tile[i, j].type == (ushort) 59)
        {
          if (unifiedRandom.Next(2) == 0)
            WorldGen.PlaceTile(i, j - 1, 227, true);
          else
            WorldGen.PlaceTile(i, j - 1, 227, true, style: 1);
        }
        else if (Main.tile[i, j - 1].liquid == byte.MaxValue && Main.tile[i, j - 2].liquid == byte.MaxValue)
          WorldGen.PlaceTile(i, j - 1, 227, true, style: 5);
      }
      if (Main.tile[i, j + 1].active() || exoticPlant)
        return;
      for (int index7 = i - num1; index7 < i + num1; ++index7)
      {
        for (int index8 = j - num1; index8 < j + num1; ++index8)
        {
          if (Main.tile[index7, index8].active() && Main.tile[index7, index8].type == (ushort) 227)
            return;
        }
      }
      if (Main.tile[i, j].type != (ushort) 0)
        return;
      WorldGen.PlaceTile(i, j + 1, 227, true, style: 7);
    }

    private static int MossConversion(int thisType, int otherType)
    {
      if (TileID.Sets.tileMossBrick[thisType] && otherType == 38 || Main.tileMoss[thisType] && otherType == 1)
        return thisType;
      switch (thisType)
      {
        case 179:
          return 512;
        case 180:
          return 513;
        case 181:
          return 514;
        case 182:
          return 515;
        case 183:
          return 516;
        case 381:
          return 517;
        case 512:
          return 179;
        case 513:
          return 180;
        case 514:
          return 181;
        case 515:
          return 182;
        case 516:
          return 183;
        case 517:
          return 381;
        case 534:
          return 535;
        case 535:
          return 534;
        case 536:
          return 537;
        case 537:
          return 536;
        case 539:
          return 540;
        case 540:
          return 539;
        case 625:
          return 626;
        case 626:
          return 625;
        case 627:
          return 628;
        case 628:
          return 627;
        default:
          return 0;
      }
    }

    public static void UpdateWorld()
    {
      if (WorldGen.gen)
        return;
      WorldGen.AllowedToSpreadInfections = true;
      CreativePowers.StopBiomeSpreadPower power = CreativePowerManager.Instance.GetPower<CreativePowers.StopBiomeSpreadPower>();
      if (power != null && power.GetIsUnlocked())
        WorldGen.AllowedToSpreadInfections = !power.Enabled;
      int wallDist = 3;
      Wiring.UpdateMech();
      TileEntity.UpdateStart();
      foreach (TileEntity tileEntity in TileEntity.ByID.Values)
        tileEntity.Update();
      TileEntity.UpdateEnd();
      WorldGen.UpdateLunarApocalypse();
      if (Main.netMode != 1)
      {
        ++WorldGen.totalD;
        if (WorldGen.totalD >= 30)
        {
          WorldGen.totalD = 0;
          WorldGen.CountTiles(WorldGen.totalX);
          ++WorldGen.totalX;
          if (WorldGen.totalX >= Main.maxTilesX)
            WorldGen.totalX = 0;
        }
      }
      ++Liquid.skipCount;
      if (Liquid.skipCount > 1)
      {
        Liquid.UpdateLiquid();
        Liquid.skipCount = 0;
      }
      int worldUpdateRate = WorldGen.GetWorldUpdateRate();
      if (worldUpdateRate == 0)
        return;
      double num1 = 2.9999999242136255E-05 * (double) worldUpdateRate;
      double num2 = 1.4999999621068127E-05 * (double) worldUpdateRate;
      double num3 = 2.4999999368446879E-05 * (double) worldUpdateRate;
      bool checkNPCSpawns = false;
      ++WorldGen.spawnDelay;
      if (Main.invasionType > 0 || Main.eclipse)
        WorldGen.spawnDelay = 0;
      if (WorldGen.spawnDelay >= 20)
      {
        checkNPCSpawns = true;
        WorldGen.spawnDelay = 0;
        if (WorldGen.prioritizedTownNPCType != 37)
        {
          for (int index = 0; index < 200; ++index)
          {
            if (Main.npc[index].active && Main.npc[index].homeless && Main.npc[index].townNPC && Main.npc[index].type != 368)
            {
              WorldGen.prioritizedTownNPCType = Main.npc[index].type;
              break;
            }
          }
        }
      }
      double num4 = (double) (Main.maxTilesX * Main.maxTilesY) * num1;
      int num5 = 151;
      int num6 = (int) Utils.Lerp((double) num5, (double) num5 * 2.8, Utils.Clamp<double>((double) Main.maxTilesX / 4200.0 - 1.0, 0.0, 1.0));
      for (int index = 0; (double) index < num4; ++index)
      {
        if (Main.rand.Next(num6 * 100) == 0)
          WorldGen.PlantAlch();
        WorldGen.UpdateWorld_OvergroundTile(WorldGen.genRand.Next(10, Main.maxTilesX - 10), WorldGen.genRand.Next(10, (int) Main.worldSurface - 1), checkNPCSpawns, wallDist);
      }
      if (Main.remixWorld)
      {
        for (int index = 0; (double) index < (double) (Main.maxTilesX * Main.maxTilesY) * num3; ++index)
        {
          int i = WorldGen.genRand.Next(10, Main.maxTilesX - 10);
          int j = WorldGen.genRand.Next((int) Main.worldSurface - 1, Main.maxTilesY - 20);
          WorldGen.growGrassUnderground = true;
          WorldGen.UpdateWorld_UndergroundTile(i, j, checkNPCSpawns, wallDist);
          WorldGen.UpdateWorld_OvergroundTile(i, j, checkNPCSpawns, wallDist);
          WorldGen.growGrassUnderground = false;
        }
      }
      else
      {
        for (int index = 0; (double) index < (double) (Main.maxTilesX * Main.maxTilesY) * num2; ++index)
          WorldGen.UpdateWorld_UndergroundTile(WorldGen.genRand.Next(10, Main.maxTilesX - 10), WorldGen.genRand.Next((int) Main.worldSurface - 1, Main.maxTilesY - 20), checkNPCSpawns, wallDist);
      }
      if (Main.dayTime && !Main.remixWorld)
        return;
      for (int index = 0; index < Main.dayRate; ++index)
      {
        double num7 = (double) Main.maxTilesX / 4200.0 * (double) Star.starfallBoost;
        if ((double) Main.rand.Next(8000) < 10.0 * num7)
        {
          int num8 = 12;
          Vector2 Position = new Vector2((float) ((Main.rand.Next(Main.maxTilesX - 50) + 100) * 16), (float) (Main.rand.Next((int) ((double) Main.maxTilesY * 0.05)) * 16));
          int ai1 = -1;
          if (Main.expertMode && Main.rand.Next(15) == 0)
          {
            int closest = (int) Player.FindClosest(Position, 1, 1);
            if ((double) Main.player[closest].position.Y < Main.worldSurface * 16.0 && Main.player[closest].afkCounter < 3600)
            {
              int num9 = Main.rand.Next(1, 640);
              Position.X = Main.player[closest].position.X + (float) Main.rand.Next(-num9, num9 + 1);
              ai1 = closest;
            }
          }
          if (!Collision.SolidCollision(Position, 16, 16))
          {
            float num10 = (float) Main.rand.Next(-100, 101);
            float num11 = (float) (Main.rand.Next(200) + 100);
            float num12 = (float) Math.Sqrt((double) num10 * (double) num10 + (double) num11 * (double) num11);
            float num13 = (float) num8 / num12;
            float SpeedX = num10 * num13;
            float SpeedY = num11 * num13;
            Projectile.NewProjectile((IEntitySource) new EntitySource_ByProjectileSourceId(11), Position.X, Position.Y, SpeedX, SpeedY, 720, 0, 0.0f, Main.myPlayer, ai1: ((float) ai1));
          }
        }
      }
    }

    public static int GetWorldUpdateRate()
    {
      int worldUpdateRate = Math.Min(Main.desiredWorldTilesUpdateRate, 24);
      if (CreativePowerManager.Instance.GetPower<CreativePowers.FreezeTime>().Enabled)
        worldUpdateRate = 0;
      return worldUpdateRate;
    }

    private static void UpdateWorld_OvergroundTile(
      int i,
      int j,
      bool checkNPCSpawns,
      int wallDist)
    {
      int minI = i - 1;
      int maxI = i + 2;
      int index1 = j - 1;
      int maxJ = j + 2;
      if (minI < 10)
        minI = 10;
      if (maxI > Main.maxTilesX - 10)
        maxI = Main.maxTilesX - 10;
      if (index1 < 10)
        index1 = 10;
      if (maxJ > Main.maxTilesY - 10)
        maxJ = Main.maxTilesY - 10;
      if (Main.tile[i, j] == null)
        return;
      if (Main.tile[i, j].type == (ushort) 655 && !NPC.AnyNPCs(262))
      {
        WorldGen.KillTile(i, j);
        if (Main.netMode == 2)
          NetMessage.SendData(17, number2: ((float) i), number3: ((float) j));
      }
      if (Main.tile[i, j].type == (ushort) 85)
        WorldGen.TryGrowingAbigailsFlower(i, j);
      else if (Main.tileAlch[(int) Main.tile[i, j].type])
        WorldGen.GrowAlch(i, j);
      else if ((double) j < Main.worldSurface + 10.0 && (i < WorldGen.beachDistance || i > Main.maxTilesX - WorldGen.beachDistance) && !Main.tile[i, j].active())
      {
        int maxValue = 3000 - (int) ((double) Math.Abs(Main.windSpeedCurrent) * 1250.0);
        if (Main.raining)
          maxValue -= (int) (1250.0 * (double) Main.maxRaining);
        if (maxValue < 300)
          maxValue = 300;
        if (WorldGen.genRand.Next(maxValue) == 0)
        {
          int j1 = j;
          while ((double) j1 < Main.worldSurface + 10.0 && !Main.tile[i, j1].active() && j1 - j < 15)
            ++j1;
          if (Main.tile[i, j1].active() && Main.tile[i, j1].type == (ushort) 53 && WorldGen.SolidTileAllowBottomSlope(i, j1))
          {
            int index2 = j1 - 1;
            int num1 = WorldGen.genRand.Next(2, 5);
            int num2 = WorldGen.genRand.Next(8, 11);
            int num3 = 0;
            for (int index3 = i - num2; index3 <= i + num2; ++index3)
            {
              for (int index4 = index2 - num2; index4 <= index2 + num2; ++index4)
              {
                if (Main.tile[index3, index4].active() && (Main.tile[index3, index4].type == (ushort) 324 || Main.tile[index3, index4].type == (ushort) 81))
                  ++num3;
              }
            }
            if (num3 < num1)
            {
              if (WorldGen.genRand.Next(2) == 0 && Main.tile[i, index2].liquid >= (byte) 230)
              {
                WorldGen.PlaceTile(i, index2, 81, true);
                if (Main.netMode == 2 && Main.tile[i, index2].active())
                  NetMessage.SendTileSquare(-1, i, index2);
              }
              else
              {
                WorldGen.PlaceTile(i, index2, 324, true, style: WorldGen.RollRandomSeaShellStyle());
                if (Main.netMode == 2 && Main.tile[i, index2].active())
                  NetMessage.SendTileSquare(-1, i, index2);
              }
            }
          }
        }
      }
      if ((Main.tile[i, j].type == (ushort) 596 || Main.tile[i, j].type == (ushort) 616 || Main.tile[i, j].type == (ushort) 595 || Main.tile[i, j].type == (ushort) 615) && (Main.tile[i, j + 1].type == (ushort) 199 || Main.tile[i, j + 1].type == (ushort) 23))
      {
        WorldGen.KillTile(i, j);
        if (Main.netMode == 2)
          NetMessage.SendTileSquare(-1, i, j);
      }
      if ((Main.tile[i, j].type == (ushort) 571 || Main.tile[i, j].type == (ushort) 60 && Main.tile[i, j - 1].liquid > (byte) 0) && WorldGen.genRand.Next(5) == 0 && (!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == (ushort) 61 || Main.tile[i, j - 1].type == (ushort) 74 || Main.tile[i, j - 1].type == (ushort) 518) && (Main.tile[i, j].type != (ushort) 60 || WorldGen.genRand.Next(30) == 0) && WorldGen.PlaceBamboo(i, j - 1))
        NetMessage.SendTileSquare(-1, i, j - 1, 1, 2);
      if (Main.tile[i, j].type == (ushort) 518)
      {
        if (Main.tile[i, j].liquid == (byte) 0 || (int) Main.tile[i, j].liquid / 16 >= 9 && WorldGen.SolidTile(i, j - 1) || Main.tile[i, j - 1].liquid > (byte) 0 && Main.tile[i, j - 1].active())
        {
          WorldGen.KillTile(i, j);
          if (Main.netMode == 2)
            NetMessage.SendData(17, number2: ((float) i), number3: ((float) j));
        }
        else
          WorldGen.CheckLilyPad(i, j);
      }
      else if (Main.tile[i, j].type == (ushort) 519)
      {
        WorldGen.CheckCatTail(i, j);
        if (Main.tile[i, j].active() && WorldGen.genRand.Next(8) == 0)
        {
          WorldGen.GrowCatTail(i, j);
          WorldGen.CheckCatTail(i, j);
        }
      }
      else if (Main.tile[i, j].liquid > (byte) 32)
      {
        if (Main.tile[i, j].active())
        {
          if (TileID.Sets.SlowlyDiesInWater[(int) Main.tile[i, j].type])
          {
            WorldGen.KillTile(i, j);
            if (Main.netMode == 2)
              NetMessage.SendData(17, number2: ((float) i), number3: ((float) j));
          }
          else if (Main.tile[i, j].type == (ushort) 60)
            WorldGen.UpdateWorld_GrassGrowth(i, j, minI, maxI, index1, maxJ, false);
        }
        else if (WorldGen.genRand.Next(600) == 0)
        {
          WorldGen.PlaceTile(i, j, 518, true);
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, i, j);
        }
        else if (WorldGen.genRand.Next(600) == 0)
        {
          WorldGen.PlaceTile(i, j, 519, true);
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, i, j);
        }
      }
      else if (Main.tile[i, j].nactive())
      {
        WorldGen.hardUpdateWorld(i, j);
        if (Main.rand.Next(3000) == 0)
          WorldGen.plantDye(i, j);
        else if (Main.hardMode && ((double) i < (double) Main.maxTilesX * 0.4 || (double) i > (double) Main.maxTilesX * 0.6) && Main.rand.Next(15000) == 0)
          WorldGen.plantDye(i, j, true);
        if (Main.tile[i, j].type == (ushort) 80)
        {
          if (WorldGen.genRand.Next(15) == 0)
            WorldGen.GrowCactus(i, j);
        }
        else if (Main.tile[i, j].type == (ushort) 529)
        {
          if (WorldGen.CheckSeaOat(i, j) && WorldGen.genRand.Next(20) == 0)
            WorldGen.GrowSeaOat(i, j);
        }
        else if (TileID.Sets.Conversion.Sand[(int) Main.tile[i, j].type])
        {
          if (!Main.tile[i, index1].active())
          {
            if (WorldGen.genRand.Next(25) == 0)
            {
              WorldGen.PlaceOasisPlant(i, index1);
              if (Main.tile[i, index1].type == (ushort) 530 && Main.netMode == 2)
                NetMessage.SendTileSquare(-1, i - 1, index1 - 1, 3, 2);
            }
            if (WorldGen.genRand.Next(20) != 0 || !WorldGen.PlantSeaOat(i, index1))
            {
              if (i < WorldGen.oceanDistance || i > Main.maxTilesX - WorldGen.oceanDistance)
              {
                if (WorldGen.genRand.Next(500) == 0)
                {
                  int num4 = 7;
                  int num5 = 6;
                  int num6 = 0;
                  for (int index5 = i - num4; index5 <= i + num4; ++index5)
                  {
                    for (int index6 = index1 - num4; index6 <= index1 + num4; ++index6)
                    {
                      if (Main.tile[index5, index6].active() && Main.tile[index5, index6].type == (ushort) 81)
                        ++num6;
                    }
                  }
                  if (num6 < num5 && Main.tile[i, index1].liquid == byte.MaxValue && Main.tile[i, index1 - 1].liquid == byte.MaxValue && Main.tile[i, index1 - 2].liquid == byte.MaxValue && Main.tile[i, index1 - 3].liquid == byte.MaxValue && Main.tile[i, index1 - 4].liquid == byte.MaxValue)
                  {
                    WorldGen.PlaceTile(i, index1, 81, true);
                    if (Main.netMode == 2 && Main.tile[i, index1].active())
                      NetMessage.SendTileSquare(-1, i, index1);
                  }
                }
              }
              else if (i > WorldGen.beachDistance + 20 && i < Main.maxTilesX - WorldGen.beachDistance - 20 && WorldGen.genRand.Next(300) == 0)
                WorldGen.GrowCactus(i, j);
            }
          }
        }
        else if (Main.tile[i, j].type == (ushort) 530)
        {
          if (!WorldGen.OasisPlantWaterCheck(i, j, true))
          {
            WorldGen.KillTile(i, j);
            if (Main.netMode == 2)
              NetMessage.SendData(17, number2: ((float) i), number3: ((float) j));
          }
        }
        else if (Main.tile[i, j].type == (ushort) 147 || Main.tile[i, j].type == (ushort) 161 || Main.tile[i, j].type == (ushort) 163 || Main.tile[i, j].type == (ushort) 164 || Main.tile[i, j].type == (ushort) 200)
        {
          if (Main.rand.Next(10) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 2].active())
          {
            int num7 = i - 3;
            int num8 = i + 4;
            int num9 = 0;
            for (int index7 = num7; index7 < num8; ++index7)
            {
              if (Main.tile[index7, j].type == (ushort) 165 && Main.tile[index7, j].active())
                ++num9;
              if (Main.tile[index7, j + 1].type == (ushort) 165 && Main.tile[index7, j + 1].active())
                ++num9;
              if (Main.tile[index7, j + 2].type == (ushort) 165 && Main.tile[index7, j + 2].active())
                ++num9;
              if (Main.tile[index7, j + 3].type == (ushort) 165 && Main.tile[index7, j + 3].active())
                ++num9;
            }
            if (num9 < 2)
            {
              WorldGen.PlaceTight(i, j + 1);
              WorldGen.SquareTileFrame(i, j + 1);
              if (Main.netMode == 2 && Main.tile[i, j + 1].active())
                NetMessage.SendTileSquare(-1, i, j + 1, 1, 2);
            }
          }
        }
        else if (Main.tile[i, j].type == (ushort) 254)
        {
          if (Main.rand.Next(((int) Main.tile[i, j].frameX + 10) / 10) == 0)
            WorldGen.GrowPumpkin(i, j, 254);
        }
        else if (Main.tile[i, j].type == (ushort) 78 || Main.tile[i, j].type == (ushort) 380 || Main.tile[i, j].type == (ushort) 579)
        {
          if (!Main.tile[i, index1].active() && WorldGen.genRand.Next(2) == 0)
          {
            WorldGen.PlaceTile(i, index1, 3, true);
            if (Main.netMode == 2 && Main.tile[i, index1].active())
              NetMessage.SendTileSquare(-1, i, index1);
          }
        }
        else if (TileID.Sets.SpreadOverground[(int) Main.tile[i, j].type])
        {
          WorldGen.UpdateWorld_GrassGrowth(i, j, minI, maxI, index1, maxJ, false);
          int type = (int) Main.tile[i, j].type;
          switch (type)
          {
            case 32:
            case 352:
              if (WorldGen.genRand.Next(3) == 0)
              {
                if (type == 32)
                {
                  WorldGen.GrowSpike(i, j, (ushort) 32, (ushort) 23);
                  break;
                }
                WorldGen.GrowSpike(i, j, (ushort) 352, (ushort) 199);
                break;
              }
              break;
          }
        }
        else if (Main.tileMoss[(int) Main.tile[i, j].type] || TileID.Sets.tileMossBrick[(int) Main.tile[i, j].type])
        {
          if (WorldGen.genRand.NextDouble() < 0.5)
          {
            int type1 = (int) Main.tile[i, j].type;
            bool flag = false;
            TileColorCache color = Main.tile[i, j].BlockColorAndCoating();
            for (int i1 = minI; i1 < maxI; ++i1)
            {
              for (int j2 = index1; j2 < maxJ; ++j2)
              {
                if ((i != i1 || j != j2) && Main.tile[i1, j2].active() && (Main.tile[i1, j2].type == (ushort) 1 || Main.tile[i1, j2].type == (ushort) 38))
                {
                  int type2 = (int) Main.tile[i1, j2].type;
                  int grass = WorldGen.MossConversion(type1, type2);
                  WorldGen.SpreadGrass(i1, j2, (int) Main.tile[i1, j2].type, grass, false, color);
                  if ((int) Main.tile[i1, j2].type == grass)
                  {
                    WorldGen.SquareTileFrame(i1, j2);
                    flag = true;
                  }
                }
              }
            }
            if (Main.netMode == 2 & flag)
              NetMessage.SendTileSquare(-1, i, j, 3);
            if (WorldGen.genRand.Next(6) == 0)
            {
              int index8 = i;
              int index9 = j;
              switch (WorldGen.genRand.Next(4))
              {
                case 0:
                  --index8;
                  break;
                case 1:
                  ++index8;
                  break;
                case 2:
                  --index9;
                  break;
                default:
                  ++index9;
                  break;
              }
              if (!Main.tile[index8, index9].active())
              {
                if (WorldGen.PlaceTile(index8, index9, 184, true))
                  Main.tile[index8, index9].CopyPaintAndCoating(Main.tile[i, j]);
                if (Main.netMode == 2 && Main.tile[index8, index9].active())
                  NetMessage.SendTileSquare(-1, index8, index9);
              }
            }
          }
        }
        else if (Main.tile[i, j].type == (ushort) 20)
        {
          if (WorldGen.genRand.Next(20) == 0)
            WorldGen.AttemptToGrowTreeFromSapling(i, j, false);
        }
        else if (Main.tile[i, j].type == (ushort) 595)
        {
          if (WorldGen.genRand.Next(5) == 0)
            WorldGen.AttemptToGrowTreeFromSapling(i, j, false);
        }
        else if (Main.tile[i, j].type == (ushort) 615)
        {
          if (WorldGen.genRand.Next(5) == 0)
            WorldGen.AttemptToGrowTreeFromSapling(i, j, false);
        }
        else if (Main.tile[i, j].type == (ushort) 3 && WorldGen.genRand.Next(20) == 0)
        {
          if (Main.tile[i, j].frameX != (short) 144)
          {
            Main.tile[i, j].type = (ushort) 73;
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, i, j);
          }
        }
        else if (Main.tile[i, j].type == (ushort) 110 && WorldGen.genRand.Next(20) == 0 && Main.tile[i, j].frameX < (short) 144)
        {
          Main.tile[i, j].type = (ushort) 113;
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, i, j);
        }
      }
      else
      {
        if (Main.tile[i, j].wall == (ushort) 62 && Main.tile[i, j].liquid == (byte) 0)
          WorldGen.GrowWeb(i, j);
        if (checkNPCSpawns)
          WorldGen.TrySpawningTownNPC(i, j);
      }
      if (WorldGen.AllowedToSpreadInfections)
      {
        if (Main.tile[i, j].wall == (ushort) 81 || Main.tile[i, j].wall == (ushort) 83 || Main.tile[i, j].type == (ushort) 199 && Main.tile[i, j].active())
        {
          int index10 = i + WorldGen.genRand.Next(-2, 3);
          int index11 = j + WorldGen.genRand.Next(-2, 3);
          if (WorldGen.InWorld(index10, index11, 10) && Main.tile[index10, index11].wall >= (ushort) 63 && Main.tile[index10, index11].wall <= (ushort) 68)
          {
            bool flag = false;
label_187:
            for (int index12 = i - wallDist; index12 < i + wallDist; ++index12)
            {
              for (int index13 = j - wallDist; index13 < j + wallDist; ++index13)
              {
                if (Main.tile[index12, index13].active())
                {
                  switch (Main.tile[index12, index13].type)
                  {
                    case 199:
                    case 200:
                    case 201:
                    case 203:
                    case 205:
                    case 234:
                    case 352:
                    case 662:
                      flag = true;
                      goto label_187;
                    default:
                      continue;
                  }
                }
              }
            }
            if (flag)
            {
              Main.tile[index10, index11].wall = (ushort) 81;
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index10, index11);
            }
          }
        }
        else if (Main.tile[i, j].wall == (ushort) 69 || Main.tile[i, j].wall == (ushort) 3 || Main.tile[i, j].type == (ushort) 23 && Main.tile[i, j].active())
        {
          int index14 = i + WorldGen.genRand.Next(-2, 3);
          int index15 = j + WorldGen.genRand.Next(-2, 3);
          if (WorldGen.InWorld(index14, index15, 10) && Main.tile[index14, index15].wall >= (ushort) 63 && Main.tile[index14, index15].wall <= (ushort) 68)
          {
            bool flag = false;
label_201:
            for (int index16 = i - wallDist; index16 < i + wallDist; ++index16)
            {
              for (int index17 = j - wallDist; index17 < j + wallDist; ++index17)
              {
                if (Main.tile[index16, index17].active())
                {
                  switch (Main.tile[index16, index17].type)
                  {
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 32:
                    case 112:
                    case 163:
                    case 636:
                    case 661:
                      flag = true;
                      goto label_201;
                    default:
                      continue;
                  }
                }
              }
            }
            if (flag)
            {
              Main.tile[index14, index15].wall = (ushort) 69;
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index14, index15);
            }
          }
        }
        else if (Main.tile[i, j].wall == (ushort) 70 || Main.tile[i, j].type == (ushort) 109 && Main.tile[i, j].active())
        {
          int index18 = i + WorldGen.genRand.Next(-2, 3);
          int index19 = j + WorldGen.genRand.Next(-2, 3);
          if (WorldGen.InWorld(index18, index19, 10) && Main.tile[index18, index19].wall == (ushort) 63 || Main.tile[index18, index19].wall == (ushort) 65 || Main.tile[index18, index19].wall == (ushort) 66 || Main.tile[index18, index19].wall == (ushort) 68)
          {
            bool flag = false;
label_215:
            for (int index20 = i - wallDist; index20 < i + wallDist; ++index20)
            {
              for (int index21 = j - wallDist; index21 < j + wallDist; ++index21)
              {
                if (Main.tile[index20, index21].active())
                {
                  switch (Main.tile[index20, index21].type)
                  {
                    case 109:
                    case 110:
                    case 113:
                    case 115:
                    case 116:
                    case 117:
                    case 164:
                      flag = true;
                      goto label_215;
                    default:
                      continue;
                  }
                }
              }
            }
            if (flag)
            {
              Main.tile[index18, index19].wall = (ushort) 70;
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index18, index19);
            }
          }
        }
        WorldGen.SpreadDesertWalls(wallDist, i, j);
      }
      if (Main.tile[i, j].nactive())
      {
        if (Main.tile[i, j].type == (ushort) 2 || Main.tile[i, j].type == (ushort) 52 || Main.tile[i, j].type == (ushort) 382 || Main.tile[i, j].type == (ushort) 192 && WorldGen.genRand.Next(10) == 0)
        {
          int num10 = 60;
          if (Main.tile[i, j].type == (ushort) 52 || Main.tile[i, j].type == (ushort) 382)
            num10 = 20;
          if (WorldGen.genRand.Next(1) == 0 && WorldGen.GrowMoreVines(i, j) && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
          {
            bool flag = false;
            ushort num11 = 52;
            if (Main.tile[i, j].type == (ushort) 382)
              num11 = (ushort) 382;
            else if (Main.tile[i, j].type != (ushort) 52)
            {
              if (Main.tile[i, j].wall == (ushort) 68 || Main.tile[i, j].wall == (ushort) 65 || Main.tile[i, j].wall == (ushort) 66 || Main.tile[i, j].wall == (ushort) 63)
                num11 = (ushort) 382;
              else if (Main.tile[i, j + 1].wall == (ushort) 68 || Main.tile[i, j + 1].wall == (ushort) 65 || Main.tile[i, j + 1].wall == (ushort) 66 || Main.tile[i, j + 1].wall == (ushort) 63)
                num11 = (ushort) 382;
              if (Main.remixWorld && WorldGen.genRand.Next(5) == 0)
                num11 = (ushort) 382;
            }
            for (int index22 = j; index22 > j - 10; --index22)
            {
              if (Main.tile[i, index22].bottomSlope())
              {
                flag = false;
                break;
              }
              if (Main.tile[i, index22].active() && Main.tile[i, index22].type == (ushort) 2 && !Main.tile[i, index22].bottomSlope())
              {
                flag = true;
                break;
              }
            }
            if (flag)
            {
              int index23 = i;
              int index24 = j + 1;
              Main.tile[index23, index24].type = num11;
              Main.tile[index23, index24].active(true);
              Main.tile[index23, index24].CopyPaintAndCoating(Main.tile[i, j]);
              WorldGen.SquareTileFrame(index23, index24);
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index23, index24);
            }
          }
        }
        else if (Main.tile[i, j].type == (ushort) 61 && WorldGen.genRand.Next(3) == 0 && Main.tile[i, j].frameX < (short) 144)
        {
          if (Main.rand.Next(4) == 0)
            Main.tile[i, j].frameX = (short) (162 + WorldGen.genRand.Next(8) * 18);
          Main.tile[i, j].type = (ushort) 74;
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, i, j);
        }
        if ((Main.tile[i, j].type == (ushort) 60 || Main.tile[i, j].type == (ushort) 62) && WorldGen.GrowMoreVines(i, j))
        {
          int maxValue = 30;
          if (Main.tile[i, j].type == (ushort) 62)
            maxValue = 10;
          if (WorldGen.genRand.Next(maxValue) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
          {
            bool flag = false;
            for (int index25 = j; index25 > j - 10; --index25)
            {
              if (Main.tile[i, index25].bottomSlope())
              {
                flag = false;
                break;
              }
              if (Main.tile[i, index25].active() && Main.tile[i, index25].type == (ushort) 60 && !Main.tile[i, index25].bottomSlope())
              {
                flag = true;
                break;
              }
            }
            if (flag)
            {
              int index26 = i;
              int index27 = j + 1;
              Main.tile[index26, index27].type = (ushort) 62;
              Main.tile[index26, index27].active(true);
              Main.tile[index26, index27].CopyPaintAndCoating(Main.tile[i, j]);
              WorldGen.SquareTileFrame(index26, index27);
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index26, index27);
            }
          }
        }
        else if ((Main.tile[i, j].type == (ushort) 70 || Main.tile[i, j].type == (ushort) 528) && WorldGen.GrowMoreVines(i, j))
        {
          int maxValue = 70;
          if (Main.tile[i, j].type == (ushort) 528)
            maxValue = 7;
          if (WorldGen.genRand.Next(maxValue) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
          {
            bool flag = false;
            for (int index28 = j; index28 > j - 10; --index28)
            {
              if (Main.tile[i, index28].bottomSlope())
              {
                flag = false;
                break;
              }
              if (Main.tile[i, index28].active() && Main.tile[i, index28].type == (ushort) 70 && !Main.tile[i, index28].bottomSlope())
              {
                flag = true;
                break;
              }
            }
            if (flag)
            {
              int index29 = i;
              int index30 = j + 1;
              Main.tile[index29, index30].type = (ushort) 528;
              Main.tile[index29, index30].active(true);
              Main.tile[index29, index30].CopyPaintAndCoating(Main.tile[i, j]);
              WorldGen.SquareTileFrame(index29, index30);
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index29, index30);
            }
          }
        }
        else if ((Main.tile[i, j].type == (ushort) 109 || Main.tile[i, j].type == (ushort) 115) && WorldGen.GrowMoreVines(i, j))
        {
          int maxValue = 60;
          if (Main.tile[i, j].type == (ushort) 115)
            maxValue = 20;
          if (WorldGen.genRand.Next(maxValue) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
          {
            bool flag = false;
            for (int index31 = j; index31 > j - 10; --index31)
            {
              if (Main.tile[i, index31].bottomSlope())
              {
                flag = false;
                break;
              }
              if (Main.tile[i, index31].active() && Main.tile[i, index31].type == (ushort) 109 && !Main.tile[i, index31].bottomSlope())
              {
                flag = true;
                break;
              }
            }
            if (flag)
            {
              int index32 = i;
              int index33 = j + 1;
              Main.tile[index32, index33].type = (ushort) 115;
              Main.tile[index32, index33].active(true);
              Main.tile[index32, index33].CopyPaintAndCoating(Main.tile[i, j]);
              WorldGen.SquareTileFrame(index32, index33);
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index32, index33);
            }
          }
        }
        else if ((Main.tile[i, j].type == (ushort) 23 || Main.tile[i, j].type == (ushort) 661 || Main.tile[i, j].type == (ushort) 636) && WorldGen.GrowMoreVines(i, j))
        {
          int maxValue = 60;
          if (Main.tile[i, j].type == (ushort) 636)
            maxValue = 20;
          if (WorldGen.genRand.Next(maxValue) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
          {
            bool flag = false;
            for (int index34 = j; index34 > j - 10; --index34)
            {
              if (Main.tile[i, index34].bottomSlope())
              {
                flag = false;
                break;
              }
              if (Main.tile[i, index34].active() && (Main.tile[i, index34].type == (ushort) 23 || Main.tile[i, index34].type == (ushort) 661) && !Main.tile[i, index34].bottomSlope())
              {
                flag = true;
                break;
              }
            }
            if (flag)
            {
              int index35 = i;
              int index36 = j + 1;
              Main.tile[index35, index36].type = (ushort) 636;
              Main.tile[index35, index36].active(true);
              Main.tile[index35, index36].CopyPaintAndCoating(Main.tile[i, j]);
              WorldGen.SquareTileFrame(index35, index36);
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index35, index36);
            }
          }
        }
        else if ((Main.tile[i, j].type == (ushort) 199 || Main.tile[i, j].type == (ushort) 662 || Main.tile[i, j].type == (ushort) 205) && WorldGen.GrowMoreVines(i, j))
        {
          int maxValue = 60;
          if (Main.tile[i, j].type == (ushort) 205)
            maxValue = 20;
          if (WorldGen.genRand.Next(maxValue) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
          {
            bool flag = false;
            for (int index37 = j; index37 > j - 10; --index37)
            {
              if (Main.tile[i, index37].bottomSlope())
              {
                flag = false;
                break;
              }
              if (Main.tile[i, index37].active() && (Main.tile[i, index37].type == (ushort) 199 || Main.tile[i, index37].type == (ushort) 662) && !Main.tile[i, index37].bottomSlope())
              {
                flag = true;
                break;
              }
            }
            if (flag)
            {
              int index38 = i;
              int index39 = j + 1;
              Main.tile[index38, index39].type = (ushort) 205;
              Main.tile[index38, index39].active(true);
              Main.tile[index38, index39].CopyPaintAndCoating(Main.tile[i, j]);
              WorldGen.SquareTileFrame(index38, index39);
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index38, index39);
            }
          }
        }
        else if ((Main.tile[i, j].type == (ushort) 633 || Main.tile[i, j].type == (ushort) 638) && WorldGen.GrowMoreVines(i, j))
        {
          int maxValue = 70;
          if (Main.tile[i, j].type == (ushort) 638)
            maxValue = 7;
          if (WorldGen.genRand.Next(maxValue) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
          {
            bool flag = false;
            for (int index40 = j; index40 > j - 10; --index40)
            {
              if (Main.tile[i, index40].bottomSlope())
              {
                flag = false;
                break;
              }
              if (Main.tile[i, index40].active() && Main.tile[i, index40].type == (ushort) 633 && !Main.tile[i, index40].bottomSlope())
              {
                flag = true;
                break;
              }
            }
            if (flag)
            {
              int index41 = i;
              int index42 = j + 1;
              Main.tile[index41, index42].type = (ushort) 638;
              Main.tile[index41, index42].active(true);
              Main.tile[index41, index42].CopyPaintAndCoating(Main.tile[i, j]);
              WorldGen.SquareTileFrame(index41, index42);
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index41, index42);
            }
          }
        }
      }
      if (Main.remixWorld || !Main.dontStarveWorld || (double) Main.rand.Next(200) >= 100.0 * (double) Main.maxRaining || (double) Main.maxRaining < 0.20000000298023224)
        return;
      WorldGen.DontStarveTryWateringTile(i, j);
    }

    public static bool AttemptToGrowTreeFromSapling(int x, int y, bool underground)
    {
      if (Main.netMode == 1 || !WorldGen.InWorld(x, y, 2))
        return false;
      Tile tile = Main.tile[x, y];
      if (tile == null || !tile.active())
        return false;
      switch (tile.type)
      {
        case 20:
          bool growTreeFromSapling1;
          switch ((int) tile.frameX / 54)
          {
            case 6:
            case 7:
            case 8:
            case 9:
              if (underground)
                return false;
              growTreeFromSapling1 = WorldGen.GrowPalmTree(x, y);
              break;
            case 10:
              growTreeFromSapling1 = WorldGen.TryGrowingTreeByType(634, x, y);
              break;
            default:
              if (underground)
                return false;
              growTreeFromSapling1 = WorldGen.GrowTree(x, y);
              break;
          }
          if (growTreeFromSapling1 && WorldGen.PlayerLOS(x, y))
            WorldGen.TreeGrowFXCheck(x, y);
          return growTreeFromSapling1;
        case 590:
          if (!underground)
            return false;
          int num1 = (int) tile.frameX / 54;
          int treeTileType1 = 587;
          switch (num1)
          {
            case 0:
              treeTileType1 = 583;
              break;
            case 1:
              treeTileType1 = 584;
              break;
            case 2:
              treeTileType1 = 585;
              break;
            case 3:
              treeTileType1 = 586;
              break;
            case 4:
              treeTileType1 = 587;
              break;
            case 5:
              treeTileType1 = 588;
              break;
            case 6:
              treeTileType1 = 589;
              break;
          }
          bool growTreeFromSapling2 = WorldGen.TryGrowingTreeByType(treeTileType1, x, y);
          if (growTreeFromSapling2 && WorldGen.PlayerLOS(x, y))
            WorldGen.TreeGrowFXCheck(x, y);
          return growTreeFromSapling2;
        case 595:
          int num2 = (int) tile.frameX / 54;
          int treeTileType2 = 596;
          if (num2 == 0)
            treeTileType2 = 596;
          bool growTreeFromSapling3 = WorldGen.TryGrowingTreeByType(treeTileType2, x, y);
          if (growTreeFromSapling3 && WorldGen.PlayerLOS(x, y))
            WorldGen.TreeGrowFXCheck(x, y);
          return growTreeFromSapling3;
        case 615:
          int num3 = (int) tile.frameX / 54;
          int treeTileType3 = 616;
          if (num3 == 0)
            treeTileType3 = 616;
          bool growTreeFromSapling4 = WorldGen.TryGrowingTreeByType(treeTileType3, x, y);
          if (growTreeFromSapling4 && WorldGen.PlayerLOS(x, y))
            WorldGen.TreeGrowFXCheck(x, y);
          return growTreeFromSapling4;
        default:
          return false;
      }
    }

    public static void DontStarveTryWateringTile(int x, int y)
    {
      Tile checkTile = Main.tile[x, y];
      if (!checkTile.active() || !TileObjectData.CheckWaterDeath(checkTile) || WorldGen.IsSafeFromRain(x, y) || WorldGen.HasAnyWireNearby(x, y, 0) || WorldGen.TryToggleLight(x, y, new bool?(false), false))
        return;
      WorldGen.KillTile(x, y);
      if (Main.netMode != 2)
        return;
      NetMessage.SendData(17, number2: ((float) x), number3: ((float) y));
    }

    public static bool HasAnyWireNearby(int sourceX, int sourceY, int boxSpread)
    {
      int num1 = Utils.Clamp<int>(sourceX - boxSpread, 0, Main.maxTilesX - 1);
      int num2 = Utils.Clamp<int>(sourceX + boxSpread, 0, Main.maxTilesX - 1);
      int num3 = Utils.Clamp<int>(sourceY - boxSpread, 0, Main.maxTilesY - 1);
      int num4 = Utils.Clamp<int>(sourceY + boxSpread, 0, Main.maxTilesY - 1);
      for (int index1 = num1; index1 <= num2; ++index1)
      {
        for (int index2 = num3; index2 <= num4; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile != null && (tile.wire() || tile.wire2() || tile.wire3() || tile.wire4()))
            return true;
        }
      }
      return false;
    }

    public static bool IsSafeFromRain(int startX, int startY)
    {
      Vector2D vector2D = Vector2D.op_UnaryNegation(Rain.GetRainFallVelocity().SafeNormalize(new Vector2(0.0f, 1f)).ToVector2D());
      Vector2D start = Vector2D.op_Addition(Vector2D.op_Multiply(new Vector2D((double) startX, (double) startY), 16.0), Vector2D.op_Multiply(Vector2D.One, 8.0));
      double num = 85.0;
      DelegateMethods.CheckResultOut = false;
      Utils.PlotTileLine(start, Vector2D.op_Addition(start, Vector2D.op_Multiply(Vector2D.op_Multiply(vector2D, 16.0), num)), 4.0, new Utils.TileActionAttempt(DelegateMethods.CheckStopForSolids));
      return DelegateMethods.CheckResultOut;
    }

    public static bool TryToggleLight(int x, int y, bool? forcedState, bool skipWires)
    {
      Tile tile = Main.tile[x, y];
      if (!tile.active())
        return false;
      switch (tile.type)
      {
        case 4:
          Wiring.ToggleTorch(x, y, tile, forcedState);
          return true;
        case 33:
        case 49:
        case 174:
        case 372:
        case 646:
          Wiring.ToggleCandle(x, y, tile, forcedState);
          return true;
        case 34:
          Wiring.ToggleChandelier(x, y, tile, forcedState, skipWires);
          return true;
        case 42:
          Wiring.ToggleHangingLantern(x, y, tile, forcedState, skipWires);
          return true;
        case 92:
          Wiring.ToggleLampPost(x, y, tile, forcedState, skipWires);
          return true;
        case 93:
          Wiring.ToggleLamp(x, y, tile, forcedState, skipWires);
          return true;
        case 95:
        case 100:
        case 126:
        case 173:
        case 564:
          Wiring.Toggle2x2Light(x, y, tile, forcedState, skipWires);
          return true;
        case 149:
          Wiring.ToggleHolidayLight(x, y, tile, forcedState);
          return true;
        case 215:
          Wiring.ToggleCampFire(x, y, tile, forcedState, skipWires);
          return true;
        case 405:
          Wiring.ToggleFirePlace(x, y, tile, forcedState, skipWires);
          return true;
        default:
          return false;
      }
    }

    private static bool HasValidGroundForAbigailsFlowerBelowSpot(int x, int y)
    {
      if (!WorldGen.InWorld(x, y, 2))
        return false;
      Tile tile = Main.tile[x, y + 1];
      if (tile == null || !tile.active())
        return false;
      ushort type = tile.type;
      return type >= (ushort) 0 && (int) type < (int) TileID.Count && (type == (ushort) 70 || type == (ushort) 633 || TileID.Sets.Conversion.Grass[(int) type]) && WorldGen.SolidTileAllowBottomSlope(x, y + 1);
    }

    private static bool TryGrowingAbigailsFlower(int i, int j)
    {
      if (Main.rand.Next(30) != 0)
        return false;
      int num = 1;
      if (Main.dontStarveWorld)
        num = 2;
      for (int index1 = 0; index1 < num; ++index1)
      {
        int index2 = WorldGen.genRand.Next(Math.Max(10, i - 10), Math.Min(Main.maxTilesX - 10, i + 10));
        int index3 = WorldGen.genRand.Next(Math.Max(10, j - 10), Math.Min(Main.maxTilesY - 10, j + 10));
        if (WorldGen.HasValidGroundForAbigailsFlowerBelowSpot(index2, index3) && WorldGen.NoNearbyAbigailsFlower(index2, index3) && WorldGen.PlaceTile(index2, index3, 624, true))
        {
          if (Main.netMode == 2 && Main.tile[index2, index3] != null && Main.tile[index2, index3].active())
            NetMessage.SendTileSquare(-1, index2, index3);
          return true;
        }
      }
      return false;
    }

    private static bool NoNearbyAbigailsFlower(int i, int j)
    {
      int num1 = Utils.Clamp<int>(i - 120, 10, Main.maxTilesX - 1 - 10);
      int num2 = Utils.Clamp<int>(i + 120, 10, Main.maxTilesX - 1 - 10);
      int num3 = Utils.Clamp<int>(j - 120, 10, Main.maxTilesY - 1 - 10);
      int num4 = Utils.Clamp<int>(j + 120, 10, Main.maxTilesY - 1 - 10);
      for (int index1 = num1; index1 <= num2; ++index1)
      {
        for (int index2 = num3; index2 <= num4; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile.active() && tile.type == (ushort) 624)
            return false;
        }
      }
      return true;
    }

    private static bool HasValidGroundForGlowTulipBelowSpot(int x, int y)
    {
      if (!WorldGen.InWorld(x, y, 2))
        return false;
      Tile tile = Main.tile[x, y + 1];
      if (tile == null || !tile.active())
        return false;
      ushort type = tile.type;
      return type >= (ushort) 0 && (int) type < (int) TileID.Count && (type == (ushort) 0 || type == (ushort) 70 || type == (ushort) 633 || type == (ushort) 59 || type == (ushort) 225 || TileID.Sets.Conversion.Grass[(int) type] || TileID.Sets.Conversion.Stone[(int) type] || Main.tileMoss[(int) type]) && WorldGen.SolidTileAllowBottomSlope(x, y + 1);
    }

    private static bool TryGrowingGlowTulip(int i, int j)
    {
      int num = 5;
      for (int index1 = 0; index1 < num; ++index1)
      {
        int index2 = WorldGen.genRand.Next(Math.Max(10, i - 10), Math.Min(Main.maxTilesX - 10, i + 10));
        int index3 = WorldGen.genRand.Next(Math.Max(10, j - 10), Math.Min(Main.maxTilesY - 10, j + 10));
        if (WorldGen.HasValidGroundForGlowTulipBelowSpot(index2, index3) && WorldGen.NoNearbyGlowTulips(index2, index3))
        {
          WorldGen.PlaceTile(index2, index3, 656, true);
          Tile tile = Main.tile[index2, index3];
          if (tile.active() && tile.type == (ushort) 656)
          {
            if (!WorldGen.generatingWorld && Main.netMode == 2 && Main.tile[index2, index3] != null && Main.tile[index2, index3].active())
              NetMessage.SendTileSquare(-1, index2, index3);
            return true;
          }
        }
      }
      return false;
    }

    private static bool NoNearbyGlowTulips(int i, int j)
    {
      int num1 = Utils.Clamp<int>(i - 120, 10, Main.maxTilesX - 1 - 10);
      int num2 = Utils.Clamp<int>(i + 120, 10, Main.maxTilesX - 1 - 10);
      int num3 = Utils.Clamp<int>(j - 120, 10, Main.maxTilesY - 1 - 10);
      int num4 = Utils.Clamp<int>(j + 120, 10, Main.maxTilesY - 1 - 10);
      for (int index1 = num1; index1 <= num2; ++index1)
      {
        for (int index2 = num3; index2 <= num4; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile.active() && tile.type == (ushort) 656)
            return false;
        }
      }
      return true;
    }

    private static void UpdateWorld_UndergroundTile(
      int i,
      int j,
      bool checkNPCSpawns,
      int wallDist)
    {
      int minI = i - 1;
      int maxI = i + 2;
      int minJ = j - 1;
      int maxJ = j + 2;
      if (minI < 10)
        minI = 10;
      if (maxI > Main.maxTilesX - 10)
        maxI = Main.maxTilesX - 10;
      if (minJ < 10)
        minJ = 10;
      if (maxJ > Main.maxTilesY - 10)
        maxJ = Main.maxTilesY - 10;
      if (Main.tile[i, j] == null)
        return;
      if (Main.tile[i, j].type == (ushort) 655 && !NPC.AnyNPCs(262))
      {
        WorldGen.KillTile(i, j);
        if (Main.netMode == 2)
          NetMessage.SendData(17, number2: ((float) i), number3: ((float) j));
      }
      if (Main.tileAlch[(int) Main.tile[i, j].type])
        WorldGen.GrowAlch(i, j);
      else if (Main.tile[i, j].nactive())
      {
        WorldGen.hardUpdateWorld(i, j);
        if (Main.rand.Next(2500) == 0)
          WorldGen.plantDye(i, j);
        else if (Main.hardMode && Main.rand.Next(10000) == 0)
          WorldGen.plantDye(i, j, true);
        if (Main.tile[i, j].type == (ushort) 519)
        {
          WorldGen.CheckCatTail(i, j);
          if (Main.tile[i, j].active() && WorldGen.genRand.Next(2) == 0)
          {
            WorldGen.GrowCatTail(i, j);
            WorldGen.CheckCatTail(i, j);
          }
        }
        if (Main.tile[i, j].type == (ushort) 549)
          WorldGen.GrowCheckSeaweed(i, j);
        else if (Main.tile[i, j].type == (ushort) 53 && !Main.tile[i, j].topSlope() && !Main.tile[i, j].halfBrick() && !Main.tile[i, j - 1].active() && WorldGen.genRand.Next(20) == 0)
          WorldGen.GrowCheckSeaweed(i, j);
        else if (TileID.Sets.SpreadUnderground[(int) Main.tile[i, j].type])
        {
          WorldGen.UpdateWorld_GrassGrowth(i, j, minI, maxI, minJ, maxJ, true);
          int type = (int) Main.tile[i, j].type;
          switch (type)
          {
            case 32:
            case 352:
              if (WorldGen.genRand.Next(3) == 0)
              {
                if (type == 32)
                {
                  WorldGen.GrowSpike(i, j, (ushort) 32, (ushort) 23);
                  break;
                }
                WorldGen.GrowSpike(i, j, (ushort) 352, (ushort) 199);
                break;
              }
              break;
          }
        }
        else if (Main.tile[i, j].type == (ushort) 61 && WorldGen.genRand.Next(3) == 0)
        {
          if (Main.tile[i, j].frameX < (short) 144)
          {
            if (Main.rand.Next(4) == 0)
              Main.tile[i, j].frameX = (short) (162 + WorldGen.genRand.Next(8) * 18);
            Main.tile[i, j].type = (ushort) 74;
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, i, j);
          }
        }
        else if ((Main.tile[i, j].type == (ushort) 60 || Main.tile[i, j].type == (ushort) 62) && WorldGen.genRand.Next(5) == 0 && WorldGen.GrowMoreVines(i, j))
        {
          if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
          {
            bool flag = false;
            for (int index = j; index > j - 10; --index)
            {
              if (Main.tile[i, index].bottomSlope())
              {
                flag = false;
                break;
              }
              if (Main.tile[i, index].active() && Main.tile[i, index].type == (ushort) 60 && !Main.tile[i, index].bottomSlope())
              {
                flag = true;
                break;
              }
            }
            if (flag)
            {
              int index1 = i;
              int index2 = j + 1;
              Main.tile[index1, index2].type = (ushort) 62;
              Main.tile[index1, index2].active(true);
              WorldGen.SquareTileFrame(index1, index2);
              Main.tile[index1, index2].CopyPaintAndCoating(Main.tile[index1, index2 - 1]);
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index1, index2);
            }
          }
        }
        else if ((Main.tile[i, j].type == (ushort) 633 || Main.tile[i, j].type == (ushort) 638) && WorldGen.GrowMoreVines(i, j))
        {
          if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
          {
            int maxValue = 70;
            if (Main.tile[i, j].type == (ushort) 638)
              maxValue = 7;
            if (WorldGen.genRand.Next(maxValue) == 0)
            {
              bool flag = false;
              for (int index = j; index > j - 10; --index)
              {
                if (Main.tile[i, index].bottomSlope())
                {
                  flag = false;
                  break;
                }
                if (Main.tile[i, index].active() && Main.tile[i, index].type == (ushort) 633 && !Main.tile[i, index].bottomSlope())
                {
                  flag = true;
                  break;
                }
              }
              if (flag)
              {
                int index3 = i;
                int index4 = j + 1;
                Main.tile[index3, index4].type = (ushort) 638;
                Main.tile[index3, index4].active(true);
                Main.tile[index3, index4].CopyPaintAndCoating(Main.tile[index3, index4 - 1]);
                WorldGen.SquareTileFrame(index3, index4);
                if (Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, index3, index4);
              }
            }
          }
        }
        else if ((Main.tile[i, j].type == (ushort) 70 || Main.tile[i, j].type == (ushort) 528) && WorldGen.GrowMoreVines(i, j))
        {
          if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
          {
            int maxValue = 70;
            if (Main.tile[i, j].type == (ushort) 528)
              maxValue = 7;
            if (WorldGen.genRand.Next(maxValue) == 0)
            {
              bool flag = false;
              for (int index = j; index > j - 10; --index)
              {
                if (Main.tile[i, index].bottomSlope())
                {
                  flag = false;
                  break;
                }
                if (Main.tile[i, index].active() && Main.tile[i, index].type == (ushort) 70 && !Main.tile[i, index].bottomSlope())
                {
                  flag = true;
                  break;
                }
              }
              if (flag)
              {
                int index5 = i;
                int index6 = j + 1;
                Main.tile[index5, index6].type = (ushort) 528;
                Main.tile[index5, index6].active(true);
                Main.tile[index5, index6].CopyPaintAndCoating(Main.tile[index5, index6 - 1]);
                WorldGen.SquareTileFrame(index5, index6);
                if (Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, index5, index6);
              }
            }
          }
        }
        else if ((Main.tile[i, j].type == (ushort) 661 || Main.tile[i, j].type == (ushort) 636) && WorldGen.GrowMoreVines(i, j))
        {
          if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
          {
            int maxValue = 70;
            if (Main.tile[i, j].type == (ushort) 636)
              maxValue = 7;
            if (WorldGen.genRand.Next(maxValue) == 0)
            {
              bool flag = false;
              for (int index = j; index > j - 10; --index)
              {
                if (Main.tile[i, index].bottomSlope())
                {
                  flag = false;
                  break;
                }
                if (Main.tile[i, index].active() && Main.tile[i, index].type == (ushort) 661 && !Main.tile[i, index].bottomSlope())
                {
                  flag = true;
                  break;
                }
              }
              if (flag)
              {
                int index7 = i;
                int index8 = j + 1;
                Main.tile[index7, index8].type = (ushort) 636;
                Main.tile[index7, index8].active(true);
                Main.tile[index7, index8].CopyPaintAndCoating(Main.tile[index7, index8 - 1]);
                WorldGen.SquareTileFrame(index7, index8);
                if (Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, index7, index8);
              }
            }
          }
        }
        else if ((Main.tile[i, j].type == (ushort) 662 || Main.tile[i, j].type == (ushort) 205) && WorldGen.GrowMoreVines(i, j))
        {
          if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
          {
            int maxValue = 70;
            if (Main.tile[i, j].type == (ushort) 205)
              maxValue = 7;
            if (WorldGen.genRand.Next(maxValue) == 0)
            {
              bool flag = false;
              for (int index = j; index > j - 10; --index)
              {
                if (Main.tile[i, index].bottomSlope())
                {
                  flag = false;
                  break;
                }
                if (Main.tile[i, index].active() && Main.tile[i, index].type == (ushort) 662 && !Main.tile[i, index].bottomSlope())
                {
                  flag = true;
                  break;
                }
              }
              if (flag)
              {
                int index9 = i;
                int index10 = j + 1;
                Main.tile[index9, index10].type = (ushort) 205;
                Main.tile[index9, index10].active(true);
                Main.tile[index9, index10].CopyPaintAndCoating(Main.tile[index9, index10 - 1]);
                WorldGen.SquareTileFrame(index9, index10);
                if (Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, index9, index10);
              }
            }
          }
        }
        else if ((Main.tile[i, j].type == (ushort) 60 || Main.tile[i, j].type == (ushort) 62) && WorldGen.genRand.Next(80) == 0 && !WorldGen.PlayerLOS(i, j))
        {
          bool flag = true;
          int num = j;
          if (Main.tile[i, j].type == (ushort) 60)
            ++num;
          for (int i1 = i; i1 < i + 2; ++i1)
          {
            int j1 = num - 1;
            if (!WorldGen.AnchorValid(Framing.GetTileSafely(i1, j1), AnchorType.SolidTile) || Main.tile[i1, j1].bottomSlope())
              flag = false;
            if (Main.tile[i1, j1].liquid > (byte) 0 || Main.wallHouse[(int) Main.tile[i1, j1].wall])
              flag = false;
            if (flag)
            {
              for (int index = num; index < num + 2; ++index)
              {
                if ((!Main.tile[i1, index].active() || Main.tileCut[(int) Main.tile[i1, index].type] && Main.tile[i1, index].type != (ushort) 444 ? (!Main.tile[i1, index].lava() ? 1 : 0) : 0) == 0)
                  flag = false;
                if (!flag)
                  break;
              }
              if (!flag)
                break;
            }
            else
              break;
          }
          if (flag)
          {
            if (WorldGen.CountNearBlocksTypes(i, j, 20, 1, 444) > 0)
              flag = false;
          }
          if (flag)
          {
            for (int i2 = i; i2 < i + 2; ++i2)
            {
              Main.tile[i2, num - 1].slope((byte) 0);
              Main.tile[i2, num - 1].halfBrick(false);
              for (int j2 = num; j2 < num + 2; ++j2)
              {
                if (Main.tile[i2, j2].active())
                  WorldGen.KillTile(i2, j2);
              }
            }
            for (int index11 = i; index11 < i + 2; ++index11)
            {
              for (int index12 = num; index12 < num + 2; ++index12)
              {
                Main.tile[index11, index12].active(true);
                Main.tile[index11, index12].type = (ushort) 444;
                Main.tile[index11, index12].frameX = (short) ((index11 - i) * 18);
                Main.tile[index11, index12].frameY = (short) ((index12 - num) * 18);
              }
            }
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, i, num - 1, 2, 3);
          }
        }
        else if (Main.tile[i, j].type == (ushort) 396 && WorldGen.genRand.Next(80) == 0 && !WorldGen.PlayerLOS(i, j))
        {
          bool flag1 = true;
          int num = j - 1;
          for (int i3 = i; i3 < i + 2; ++i3)
          {
            int j3 = num + 1;
            if (!WorldGen.AnchorValid(Framing.GetTileSafely(i3, j3), AnchorType.SolidTile) || Main.tile[i3, j3].topSlope())
              flag1 = false;
            if (Main.tile[i3, j3].liquid > (byte) 0 || Main.wallHouse[(int) Main.tile[i3, j3].wall])
              flag1 = false;
            if (flag1)
            {
              for (int index = num - 2; index < num; ++index)
              {
                if ((!Main.tile[i3, index].active() || Main.tileCut[(int) Main.tile[i3, index].type] && Main.tile[i3, index].type != (ushort) 485 ? (!Main.tile[i3, index].lava() ? 1 : 0) : 0) == 0)
                  flag1 = false;
                if (!flag1)
                  break;
              }
              if (!flag1)
                break;
            }
            else
              break;
          }
          if (flag1)
          {
            if (WorldGen.CountNearBlocksTypes(i, j, 20, 1, 485) > 0)
              flag1 = false;
          }
          if (flag1)
          {
            bool flag2 = true;
            for (int index = -1; index >= -3; --index)
            {
              if (Main.tile[i, j + index].active())
              {
                flag2 = false;
                break;
              }
            }
            if (flag2)
            {
              WorldGen.PlaceTile(i, j - 1, 485, true, style: WorldGen.genRand.Next(4));
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, i, j - 2, 2, 2);
            }
          }
        }
        else if (Main.tile[i, j].type == (ushort) 69)
          WorldGen.GrowSpike(i, j, (ushort) 69, (ushort) 60);
        else if (Main.tile[i, j].type == (ushort) 147 || Main.tile[i, j].type == (ushort) 161 || Main.tile[i, j].type == (ushort) 163 || Main.tile[i, j].type == (ushort) 164 || Main.tile[i, j].type == (ushort) 200)
        {
          if (Main.rand.Next(10) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 2].active())
          {
            int num1 = i - 3;
            int num2 = i + 4;
            int num3 = 0;
            for (int index = num1; index < num2; ++index)
            {
              if (Main.tile[index, j].type == (ushort) 165 && Main.tile[index, j].active())
                ++num3;
              if (Main.tile[index, j + 1].type == (ushort) 165 && Main.tile[index, j + 1].active())
                ++num3;
              if (Main.tile[index, j + 2].type == (ushort) 165 && Main.tile[index, j + 2].active())
                ++num3;
              if (Main.tile[index, j + 3].type == (ushort) 165 && Main.tile[index, j + 3].active())
                ++num3;
            }
            if (num3 < 2)
            {
              WorldGen.PlaceTight(i, j + 1);
              WorldGen.SquareTileFrame(i, j + 1);
              if (Main.netMode == 2 && Main.tile[i, j + 1].active())
                NetMessage.SendTileSquare(-1, i, j + 1, 1, 2);
            }
          }
        }
        else if (Main.tileMoss[(int) Main.tile[i, j].type] || TileID.Sets.tileMossBrick[(int) Main.tile[i, j].type])
        {
          int type1 = (int) Main.tile[i, j].type;
          bool flag = false;
          TileColorCache color = Main.tile[i, j].BlockColorAndCoating();
          for (int i4 = minI; i4 < maxI; ++i4)
          {
            for (int j4 = minJ; j4 < maxJ; ++j4)
            {
              if ((i != i4 || j != j4) && Main.tile[i4, j4].active() && (Main.tile[i4, j4].type == (ushort) 1 || Main.tile[i4, j4].type == (ushort) 38))
              {
                int type2 = (int) Main.tile[i4, j4].type;
                int grass = WorldGen.MossConversion(type1, type2);
                WorldGen.SpreadGrass(i4, j4, (int) Main.tile[i4, j4].type, grass, false, color);
                if ((int) Main.tile[i4, j4].type == grass)
                {
                  WorldGen.SquareTileFrame(i4, j4);
                  flag = true;
                }
              }
            }
          }
          if (Main.netMode == 2 & flag)
            NetMessage.SendTileSquare(-1, i, j, 3);
          if (WorldGen.genRand.Next(6) == 0)
          {
            int index13 = i;
            int index14 = j;
            switch (WorldGen.genRand.Next(4))
            {
              case 0:
                --index13;
                break;
              case 1:
                ++index13;
                break;
              case 2:
                --index14;
                break;
              default:
                ++index14;
                break;
            }
            if (!Main.tile[index13, index14].active())
            {
              if (WorldGen.PlaceTile(index13, index14, 184, true))
                Main.tile[index13, index14].CopyPaintAndCoating(Main.tile[i, j]);
              if (Main.netMode == 2 && Main.tile[index13, index14].active())
                NetMessage.SendTileSquare(-1, index13, index14);
            }
          }
        }
        else if (Main.tile[i, j].type == (ushort) 20)
        {
          if (WorldGen.genRand.Next(5) == 0)
            WorldGen.AttemptToGrowTreeFromSapling(i, j, true);
        }
        else if (Main.tile[i, j].type == (ushort) 590)
        {
          if (WorldGen.genRand.Next(5) == 0)
            WorldGen.AttemptToGrowTreeFromSapling(i, j, true);
        }
        else if (Main.tile[i, j].type == (ushort) 595)
        {
          if (WorldGen.genRand.Next(5) == 0)
            WorldGen.AttemptToGrowTreeFromSapling(i, j, true);
        }
        else if (Main.tile[i, j].type == (ushort) 615 && WorldGen.genRand.Next(5) == 0)
          WorldGen.AttemptToGrowTreeFromSapling(i, j, true);
      }
      else
      {
        if (Main.tile[i, j].wall == (ushort) 62 && Main.tile[i, j].liquid == (byte) 0)
          WorldGen.GrowWeb(i, j);
        if (checkNPCSpawns)
          WorldGen.TrySpawningTownNPC(i, j);
      }
      if (WorldGen.AllowedToSpreadInfections)
      {
        if (Main.tile[i, j].wall == (ushort) 81 || Main.tile[i, j].wall == (ushort) 83 || Main.tile[i, j].type == (ushort) 199 && Main.tile[i, j].active())
        {
          int index15 = i + WorldGen.genRand.Next(-2, 3);
          int index16 = j + WorldGen.genRand.Next(-2, 3);
          if (WorldGen.InWorld(index15, index16, 10) && Main.tile[index15, index16].wall >= (ushort) 63 && Main.tile[index15, index16].wall <= (ushort) 68)
          {
            bool flag = false;
label_243:
            for (int index17 = i - wallDist; index17 < i + wallDist; ++index17)
            {
              for (int index18 = j - wallDist; index18 < j + wallDist; ++index18)
              {
                if (Main.tile[index17, index18].active())
                {
                  switch (Main.tile[index17, index18].type)
                  {
                    case 199:
                    case 200:
                    case 201:
                    case 203:
                    case 205:
                    case 234:
                    case 352:
                    case 662:
                      flag = true;
                      goto label_243;
                    default:
                      continue;
                  }
                }
              }
            }
            if (flag)
            {
              Main.tile[index15, index16].wall = (ushort) 81;
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index15, index16);
            }
          }
        }
        else if (Main.tile[i, j].wall == (ushort) 69 || Main.tile[i, j].wall == (ushort) 3 || Main.tile[i, j].type == (ushort) 23 && Main.tile[i, j].active())
        {
          int index19 = i + WorldGen.genRand.Next(-2, 3);
          int index20 = j + WorldGen.genRand.Next(-2, 3);
          if (WorldGen.InWorld(index19, index20, 10) && Main.tile[index19, index20].wall >= (ushort) 63 && Main.tile[index19, index20].wall <= (ushort) 68)
          {
            bool flag = false;
label_257:
            for (int index21 = i - wallDist; index21 < i + wallDist; ++index21)
            {
              for (int index22 = j - wallDist; index22 < j + wallDist; ++index22)
              {
                if (Main.tile[index21, index22].active())
                {
                  switch (Main.tile[index21, index22].type)
                  {
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 32:
                    case 112:
                    case 163:
                    case 636:
                    case 661:
                      flag = true;
                      goto label_257;
                    default:
                      continue;
                  }
                }
              }
            }
            if (flag)
            {
              Main.tile[index19, index20].wall = (ushort) 69;
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index19, index20);
            }
          }
        }
        else if (Main.tile[i, j].wall == (ushort) 70 || Main.tile[i, j].type == (ushort) 109 && Main.tile[i, j].active())
        {
          int index23 = i + WorldGen.genRand.Next(-2, 3);
          int index24 = j + WorldGen.genRand.Next(-2, 3);
          if (WorldGen.InWorld(index23, index24, 10) && Main.tile[index23, index24].wall == (ushort) 63 || Main.tile[index23, index24].wall == (ushort) 65 || Main.tile[index23, index24].wall == (ushort) 66 || Main.tile[index23, index24].wall == (ushort) 68)
          {
            bool flag = false;
label_271:
            for (int index25 = i - wallDist; index25 < i + wallDist; ++index25)
            {
              for (int index26 = j - wallDist; index26 < j + wallDist; ++index26)
              {
                if (Main.tile[index25, index26].active())
                {
                  switch (Main.tile[index25, index26].type)
                  {
                    case 109:
                    case 110:
                    case 113:
                    case 115:
                    case 116:
                    case 117:
                    case 164:
                      flag = true;
                      goto label_271;
                    default:
                      continue;
                  }
                }
              }
            }
            if (flag)
            {
              Main.tile[index23, index24].wall = (ushort) 70;
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index23, index24);
            }
          }
        }
        WorldGen.SpreadDesertWalls(wallDist, i, j);
      }
      if (!Main.tile[i, j].nactive())
        return;
      if (Main.tile[i, j].type == (ushort) 61 && WorldGen.genRand.Next(3) == 0 && Main.tile[i, j].frameX < (short) 144)
      {
        if (Main.rand.Next(4) == 0)
          Main.tile[i, j].frameX = (short) (162 + WorldGen.genRand.Next(8) * 18);
        Main.tile[i, j].type = (ushort) 74;
        if (Main.netMode == 2)
          NetMessage.SendTileSquare(-1, i, j);
      }
      if ((Main.tile[i, j].type == (ushort) 60 || Main.tile[i, j].type == (ushort) 62) && WorldGen.GrowMoreVines(i, j))
      {
        int maxValue = 30;
        if (Main.tile[i, j].type == (ushort) 62)
          maxValue = 10;
        if (WorldGen.genRand.Next(maxValue) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
          return;
        bool flag = false;
        for (int index = j; index > j - 10; --index)
        {
          if (Main.tile[i, index].bottomSlope())
          {
            flag = false;
            break;
          }
          if (Main.tile[i, index].active() && Main.tile[i, index].type == (ushort) 60 && !Main.tile[i, index].bottomSlope())
          {
            flag = true;
            break;
          }
        }
        if (!flag)
          return;
        int index27 = i;
        int index28 = j + 1;
        Main.tile[index27, index28].type = (ushort) 62;
        Main.tile[index27, index28].active(true);
        Main.tile[index27, index28].CopyPaintAndCoating(Main.tile[index27, index28 - 1]);
        WorldGen.SquareTileFrame(index27, index28);
        if (Main.netMode != 2)
          return;
        NetMessage.SendTileSquare(-1, index27, index28);
      }
      else if ((Main.tile[i, j].type == (ushort) 633 || Main.tile[i, j].type == (ushort) 638) && WorldGen.GrowMoreVines(i, j))
      {
        int maxValue = 70;
        if (Main.tile[i, j].type == (ushort) 638)
          maxValue = 7;
        if (WorldGen.genRand.Next(maxValue) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
          return;
        bool flag = false;
        for (int index = j; index > j - 10; --index)
        {
          if (Main.tile[i, index].bottomSlope())
          {
            flag = false;
            break;
          }
          if (Main.tile[i, index].active() && Main.tile[i, index].type == (ushort) 633 && !Main.tile[i, index].bottomSlope())
          {
            flag = true;
            break;
          }
        }
        if (!flag)
          return;
        int index29 = i;
        int index30 = j + 1;
        Main.tile[index29, index30].type = (ushort) 638;
        Main.tile[index29, index30].active(true);
        Main.tile[index29, index30].CopyPaintAndCoating(Main.tile[index29, index30 - 1]);
        WorldGen.SquareTileFrame(index29, index30);
        if (Main.netMode != 2)
          return;
        NetMessage.SendTileSquare(-1, index29, index30);
      }
      else
      {
        if (Main.tile[i, j].type != (ushort) 70 && Main.tile[i, j].type != (ushort) 528 || !WorldGen.GrowMoreVines(i, j))
          return;
        int maxValue = 70;
        if (Main.tile[i, j].type == (ushort) 528)
          maxValue = 7;
        if (WorldGen.genRand.Next(maxValue) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
          return;
        bool flag = false;
        for (int index = j; index > j - 10; --index)
        {
          if (Main.tile[i, index].bottomSlope())
          {
            flag = false;
            break;
          }
          if (Main.tile[i, index].active() && Main.tile[i, index].type == (ushort) 70 && !Main.tile[i, index].bottomSlope())
          {
            flag = true;
            break;
          }
        }
        if (!flag)
          return;
        int index31 = i;
        int index32 = j + 1;
        Main.tile[index31, index32].type = (ushort) 528;
        Main.tile[index31, index32].active(true);
        Main.tile[index31, index32].CopyPaintAndCoating(Main.tile[index31, index32 - 1]);
        WorldGen.SquareTileFrame(index31, index32);
        if (Main.netMode != 2)
          return;
        NetMessage.SendTileSquare(-1, index31, index32);
      }
    }

    private static void GrowWeb(int i, int j)
    {
      if (WorldGen.genRand.Next(10) != 0)
        return;
      int num1 = WorldGen.genRand.Next(2, 4);
      int num2 = i - num1;
      int num3 = i + num1;
      int num4 = j - num1;
      int num5 = j + num1;
      bool flag = false;
      for (int i1 = num2; i1 <= num3; ++i1)
      {
        for (int j1 = num4; j1 <= num5; ++j1)
        {
          if (WorldGen.SolidTile(i1, j1))
          {
            flag = true;
            break;
          }
        }
      }
      if (!flag || Main.tile[i, j].active())
        return;
      WorldGen.PlaceTile(i, j, 51, true);
      WorldGen.TileFrame(i, j, true);
      if (Main.netMode != 2)
        return;
      NetMessage.SendTileSquare(-1, i, j, 1);
    }

    public static bool GeneratePlanteraBulbOnAllMechsDefeated()
    {
      int num1 = (double) Main.dungeonX > (double) Main.maxTilesX * 0.5 ? 1 : 0;
      int x = num1 != 0 ? (int) ((double) Main.maxTilesX * 0.15) : (int) ((double) Main.maxTilesX * 0.65);
      int num2 = num1 != 0 ? (int) ((double) Main.maxTilesX * 0.35) : (int) ((double) Main.maxTilesX * 0.85);
      int worldSurface = (int) Main.worldSurface;
      int underworldLayer = Main.UnderworldLayer;
      int width = num2 - x;
      int num3 = worldSurface;
      int height = underworldLayer - num3;
      Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(x, worldSurface, width, height);
      int num4 = 2500;
      while (num4 > 0)
      {
        bool forceBulb = num4 < 500;
        bool flag1 = num4 < 200;
        --num4;
        Point point = new Point(rectangle.X + WorldGen.genRand.Next(rectangle.Width), rectangle.Y + WorldGen.genRand.Next(rectangle.Height));
        Tile tile = Main.tile[point.X, point.Y];
        int num5 = 500;
        bool flag2 = false;
        while (!flag2)
        {
          --num5;
          if (num5 <= 0)
            flag2 = true;
          --point.Y;
          if (point.Y >= rectangle.Y)
          {
            tile = Main.tile[point.X, point.Y];
            if (tile != null && (flag1 || tile.active()))
            {
              if (tile.type == (ushort) 60)
                flag2 = true;
              else if (forceBulb && tile.type == (ushort) 59)
                flag2 = true;
            }
          }
          else
            break;
        }
        if (tile != null && ((tile.active() | flag1 ? 1 : 0) & (tile.type == (ushort) 60 ? (true ? 1 : 0) : (!forceBulb ? (false ? 1 : 0) : (tile.type == (ushort) 59 ? 1 : 0)))) != 0 && (WorldGen.AttemptToGeneratePlanteraBulbAt(point.X, point.Y - 1, forceBulb) || WorldGen.AttemptToGeneratePlanteraBulbAt(point.X - 1, point.Y - 1, forceBulb) || WorldGen.AttemptToGeneratePlanteraBulbAt(point.X + 1, point.Y - 1, forceBulb)))
          return true;
      }
      return false;
    }

    private static bool AttemptToGeneratePlanteraBulbAt(int i, int j, bool forceBulb)
    {
      if (forceBulb)
      {
        int num1 = 0;
        for (int index1 = -2; index1 < 2; ++index1)
        {
          for (int index2 = -2; index2 < 2; ++index2)
          {
            int index3 = i + index1;
            int index4 = j + index2;
            Tile t = Main.tile[index3, index4];
            if (t.type == (ushort) 59 || t.type == (ushort) 60)
              ++num1;
            else if (t.active())
              --num1;
            if (WorldGen.IsAContainer(t) || t.type == (ushort) 226 || t.type == (ushort) 237 || t.type == (ushort) 10 || t.type == (ushort) 11 || t.type == (ushort) 26 || t.type == (ushort) 16 || t.type == (ushort) 15 || t.type == (ushort) 14 || t.type == (ushort) 104 || TileID.Sets.Paintings[(int) t.type] || t.type == (ushort) 158 || t.type == (ushort) 105 || t.type == (ushort) 531 || t.type == (ushort) 349 || t.type == (ushort) 138 || t.type == (ushort) 664 || t.type == (ushort) 665 || t.type == (ushort) 137 || t.type == (ushort) 443 || t.type == (ushort) 12 || t.type == (ushort) 665 || t.type == (ushort) 314)
            {
              num1 = -1;
              break;
            }
          }
          if (num1 <= -1)
            break;
        }
        if (num1 < 12)
          return false;
        for (int index5 = -2; index5 < 2; ++index5)
        {
          for (int index6 = -2; index6 < 2; ++index6)
          {
            int i1 = i + index5;
            int j1 = j + index6;
            int num2 = index5 == -2 || index5 == 1 || index6 == -2 ? 1 : (index6 == 1 ? 1 : 0);
            Tile tile = Main.tile[i1, j1];
            tile.ClearTile();
            if (num2 != 0)
            {
              tile.type = (ushort) 60;
              tile.active(true);
            }
            WorldGen.SquareTileFrame(i1, j1);
          }
        }
        WorldGen.PlaceJunglePlant(i, j, (ushort) 238, 0, 0);
        if (Main.tile[i, j].type == (ushort) 238)
        {
          WorldGen.SquareTileFrame(i, j);
          WorldGen.SquareTileFrame(i + 2, j);
          WorldGen.SquareTileFrame(i - 1, j);
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, i, j, 8);
          return true;
        }
      }
      else
      {
        WorldGen.PlaceJunglePlant(i, j, (ushort) 238, 0, 0);
        if (Main.tile[i, j].type == (ushort) 238)
        {
          WorldGen.SquareTileFrame(i, j);
          WorldGen.SquareTileFrame(i + 2, j);
          WorldGen.SquareTileFrame(i - 1, j);
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, i, j, 5);
          return true;
        }
      }
      return false;
    }

    private static void UpdateWorld_GrassGrowth(
      int i,
      int j,
      int minI,
      int maxI,
      int minJ,
      int maxJ,
      bool underground)
    {
      if (!WorldGen.InWorld(i, j, 10))
        return;
      if (underground)
      {
        int type = (int) Main.tile[i, j].type;
        int dirt1 = -1;
        int dirt2 = -1;
        int Type = -1;
        int maxValue1 = 1;
        int grass1 = type;
        int grass2 = -1;
        switch (type)
        {
          case 23:
            dirt1 = 0;
            dirt2 = 59;
            grass1 = 23;
            grass2 = 661;
            Type = 24;
            maxValue1 = 2;
            if (!WorldGen.AllowedToSpreadInfections)
              return;
            break;
          case 60:
            dirt1 = 59;
            Type = 61;
            maxValue1 = 10;
            break;
          case 70:
            dirt1 = 59;
            Type = 71;
            maxValue1 = 10;
            break;
          case 199:
            dirt1 = 0;
            dirt2 = 59;
            grass1 = 199;
            grass2 = 662;
            Type = 201;
            maxValue1 = 2;
            if (!WorldGen.AllowedToSpreadInfections)
              return;
            break;
          case 633:
            dirt1 = 57;
            Type = 637;
            maxValue1 = 2;
            break;
          case 661:
            dirt1 = 59;
            dirt2 = 0;
            grass1 = 661;
            grass2 = 23;
            Type = 24;
            maxValue1 = 2;
            if (!WorldGen.AllowedToSpreadInfections)
              return;
            break;
          case 662:
            dirt1 = 59;
            dirt2 = 0;
            grass1 = 662;
            grass2 = 199;
            Type = 201;
            maxValue1 = 2;
            if (!WorldGen.AllowedToSpreadInfections)
              return;
            break;
        }
        bool flag1 = false;
        if (Type != -1 && !Main.tile[i, minJ].active() && WorldGen.genRand.Next(maxValue1) == 0)
        {
          flag1 = true;
          if (WorldGen.PlaceTile(i, minJ, Type, true))
            Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
          if (Main.netMode == 2 && Main.tile[i, minJ].active())
            NetMessage.SendTileSquare(-1, i, minJ);
        }
        if (dirt1 != -1)
        {
          bool flag2 = false;
          TileColorCache color = Main.tile[i, j].BlockColorAndCoating();
          for (int index1 = minI; index1 < maxI; ++index1)
          {
            for (int index2 = minJ; index2 < maxJ; ++index2)
            {
              if (WorldGen.InWorld(index1, index2, 10) && (i != index1 || j != index2) && Main.tile[index1, index2].active())
              {
                if ((int) Main.tile[index1, index2].type == dirt1)
                {
                  WorldGen.SpreadGrass(index1, index2, dirt1, grass1, false, color);
                  if ((int) Main.tile[index1, index2].type == grass1)
                  {
                    WorldGen.SquareTileFrame(index1, index2);
                    flag2 = true;
                  }
                }
                else if (dirt2 > -1 && grass2 > -1 && (int) Main.tile[index1, index2].type == dirt2)
                {
                  WorldGen.SpreadGrass(index1, index2, dirt2, grass2, false, color);
                  if ((int) Main.tile[index1, index2].type == grass2)
                  {
                    WorldGen.SquareTileFrame(index1, index2);
                    flag2 = true;
                  }
                }
              }
            }
          }
          if (Main.netMode == 2 & flag2)
            NetMessage.SendTileSquare(-1, i, j, 3);
        }
        switch (type)
        {
          case 60:
            if (flag1 || WorldGen.genRand.Next(25) != 0 || Main.tile[i, minJ].liquid != (byte) 0)
              break;
            if (Main.hardMode && NPC.downedMechBoss1 && NPC.downedMechBoss2 && NPC.downedMechBoss3 && WorldGen.genRand.Next(60) == 0)
            {
              bool flag3 = true;
              int num = 150;
              for (int index3 = i - num; index3 < i + num; index3 += 2)
              {
                for (int index4 = j - num; index4 < j + num; index4 += 2)
                {
                  if (index3 > 1 && index3 < Main.maxTilesX - 2 && index4 > 1 && index4 < Main.maxTilesY - 2 && Main.tile[index3, index4].active() && Main.tile[index3, index4].type == (ushort) 238)
                  {
                    flag3 = false;
                    break;
                  }
                }
              }
              if (flag3)
              {
                WorldGen.PlaceJunglePlant(i, minJ, (ushort) 238, 0, 0);
                WorldGen.SquareTileFrame(i, minJ);
                WorldGen.SquareTileFrame(i + 2, minJ);
                WorldGen.SquareTileFrame(i - 1, minJ);
                if (Main.tile[i, minJ].type == (ushort) 238 && Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, i, minJ, 5);
              }
            }
            int maxValue2 = Main.expertMode ? 30 : 40;
            if (Main.hardMode && NPC.downedMechBossAny && WorldGen.genRand.Next(maxValue2) == 0)
            {
              bool flag4 = true;
              int num = 60;
              if (Main.expertMode)
                num -= 10;
              for (int index5 = i - num; index5 < i + num; index5 += 2)
              {
                for (int index6 = j - num; index6 < j + num; index6 += 2)
                {
                  if (index5 > 1 && index5 < Main.maxTilesX - 2 && index6 > 1 && index6 < Main.maxTilesY - 2 && Main.tile[index5, index6].active() && Main.tile[index5, index6].type == (ushort) 236)
                  {
                    flag4 = false;
                    break;
                  }
                }
              }
              if (!flag4)
                break;
              WorldGen.PlaceJunglePlant(i, minJ, (ushort) 236, WorldGen.genRand.Next(3), 0);
              WorldGen.SquareTileFrame(i, minJ);
              WorldGen.SquareTileFrame(i + 1, minJ + 1);
              if (Main.tile[i, minJ].type != (ushort) 236 || Main.netMode != 2)
                break;
              NetMessage.SendTileSquare(-1, i, minJ, 4);
              break;
            }
            WorldGen.PlaceJunglePlant(i, minJ, (ushort) 233, WorldGen.genRand.Next(8), 0);
            if (Main.tile[i, minJ].type != (ushort) 233)
              break;
            if (Main.netMode == 2)
            {
              NetMessage.SendTileSquare(-1, i, minJ, 4);
              break;
            }
            WorldGen.PlaceJunglePlant(i, minJ, (ushort) 233, WorldGen.genRand.Next(12), 1);
            if (Main.tile[i, minJ].type != (ushort) 233 || Main.netMode != 2)
              break;
            NetMessage.SendTileSquare(-1, i, minJ, 3);
            break;
          case 70:
            if (Main.tile[i, j - 1].liquid > (byte) 0)
              WorldGen.PlaceCatTail(i, j - 1);
            if (WorldGen.genRand.Next(250) != 0 || !WorldGen.GrowTree(i, j) || !WorldGen.PlayerLOS(i, j))
              break;
            WorldGen.TreeGrowFXCheck(i, j - 1);
            break;
        }
      }
      else
      {
        int grass3 = (int) Main.tile[i, j].type;
        switch (grass3)
        {
          case 2:
          case 23:
          case 32:
          case 109:
          case 199:
          case 352:
          case 477:
          case 492:
          case 661:
          case 662:
            if (Main.halloween && WorldGen.genRand.Next(75) == 0 && (grass3 == 2 || grass3 == 109))
            {
              int num1 = 100;
              int num2 = 0;
              for (int index7 = i - num1; index7 < i + num1; index7 += 2)
              {
                for (int index8 = j - num1; index8 < j + num1; index8 += 2)
                {
                  if (index7 > 1 && index7 < Main.maxTilesX - 2 && index8 > 1 && index8 < Main.maxTilesY - 2 && Main.tile[index7, index8].active() && Main.tile[index7, index8].type == (ushort) 254)
                    ++num2;
                }
              }
              if (num2 < 6)
              {
                WorldGen.PlacePumpkin(i, minJ);
                if (Main.netMode == 2 && Main.tile[i, minJ].type == (ushort) 254)
                  NetMessage.SendTileSquare(-1, i - 1, minJ - 1, 2, 2);
              }
            }
            if (!Main.tile[i, minJ].active() && Main.tile[i, minJ].liquid == (byte) 0)
            {
              int Type = -1;
              if (grass3 == 2 && WorldGen.genRand.Next(12) == 0)
                Type = 3;
              else if (grass3 == 23 && WorldGen.genRand.Next(10) == 0)
                Type = 24;
              else if (grass3 == 199 && WorldGen.genRand.Next(10) == 0)
                Type = 201;
              else if (grass3 == 661 && WorldGen.genRand.Next(10) == 0)
                Type = 24;
              else if (grass3 == 662 && WorldGen.genRand.Next(10) == 0)
                Type = 201;
              else if (grass3 == 109 && WorldGen.genRand.Next(10) == 0)
                Type = 110;
              else if (grass3 == 633 && WorldGen.genRand.Next(10) == 0)
                Type = 637;
              if (Type != -1 && WorldGen.PlaceTile(i, minJ, Type, true))
              {
                Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
                if (Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, i, minJ);
              }
            }
            bool flag5 = false;
            switch (grass3)
            {
              case 32:
                grass3 = 23;
                if (!WorldGen.AllowedToSpreadInfections)
                  return;
                break;
              case 352:
                grass3 = 199;
                if (!WorldGen.AllowedToSpreadInfections)
                  return;
                break;
              case 477:
                grass3 = 2;
                break;
              case 492:
                grass3 = 109;
                break;
            }
            int grass4 = grass3;
            int grass5 = -1;
            if (grass3 == 23 || grass3 == 661)
            {
              grass4 = 23;
              grass5 = 661;
            }
            if (grass3 == 199 || grass3 == 662)
            {
              grass4 = 199;
              grass5 = 662;
            }
            bool flag6 = WorldGen.AllowedToSpreadInfections && (grass3 == 23 || grass3 == 199 || grass3 == 109 || grass3 == 492 || grass3 == 661 || grass3 == 662) && WorldGen.InWorld(i, j, 10);
            for (int index9 = minI; index9 < maxI; ++index9)
            {
              for (int index10 = minJ; index10 < maxJ; ++index10)
              {
                if (WorldGen.InWorld(index9, index10, 10) && (i != index9 || j != index10) && Main.tile[index9, index10].active())
                {
                  int type = (int) Main.tile[index9, index10].type;
                  if (flag6 || type == 0 || grass5 != -1 && type == 59)
                  {
                    TileColorCache color = Main.tile[i, j].BlockColorAndCoating();
                    if (type == 0 || grass5 > -1 && type == 59 || (grass3 == 23 || grass3 == 661 || grass3 == 199 || grass3 == 662) && (type == 2 || type == 109 || type == 477 || type == 492))
                    {
                      WorldGen.SpreadGrass(index9, index10, grass: grass4, repeat: false, color: color);
                      if (grass5 > -1)
                        WorldGen.SpreadGrass(index9, index10, 59, grass5, false, color);
                      if (WorldGen.AllowedToSpreadInfections && (grass3 == 23 || grass3 == 199 || grass3 == 661 || grass3 == 662))
                      {
                        WorldGen.SpreadGrass(index9, index10, 2, grass4, false, color);
                        WorldGen.SpreadGrass(index9, index10, 109, grass4, false, color);
                        WorldGen.SpreadGrass(index9, index10, 477, grass4, false, color);
                        WorldGen.SpreadGrass(index9, index10, 492, grass4, false, color);
                        if (grass5 > -1)
                          WorldGen.SpreadGrass(index9, index10, 60, grass5, false, color);
                      }
                      if ((int) Main.tile[index9, index10].type == grass3 || grass5 > -1 && (int) Main.tile[index9, index10].type == grass5)
                      {
                        WorldGen.SquareTileFrame(index9, index10);
                        flag5 = true;
                      }
                    }
                    if (type == 0 || (grass3 == 109 || grass3 == 492) && (type == 2 || type == 477 || type == 23 || type == 199))
                    {
                      WorldGen.SpreadGrass(index9, index10, grass: grass4, repeat: false, color: color);
                      if (grass3 == 109)
                        WorldGen.SpreadGrass(index9, index10, 2, grass4, false, color);
                      if (grass3 == 492)
                        WorldGen.SpreadGrass(index9, index10, 477, grass4, false, color);
                      else if (grass3 == 109)
                        WorldGen.SpreadGrass(index9, index10, 477, 492, false, color);
                      if ((grass3 == 492 || grass3 == 109) && WorldGen.AllowedToSpreadInfections)
                        WorldGen.SpreadGrass(index9, index10, 23, 109, false, color);
                      if ((grass3 == 492 || grass3 == 109) && WorldGen.AllowedToSpreadInfections)
                        WorldGen.SpreadGrass(index9, index10, 199, 109, false, color);
                      if ((int) Main.tile[index9, index10].type == grass3)
                      {
                        WorldGen.SquareTileFrame(index9, index10);
                        flag5 = true;
                      }
                    }
                  }
                }
              }
            }
            if (!(Main.netMode == 2 & flag5))
              break;
            NetMessage.SendTileSquare(-1, i, j, 3);
            break;
          case 60:
            if (!Main.tile[i, minJ].active() && WorldGen.genRand.Next(7) == 0)
            {
              WorldGen.PlaceTile(i, minJ, 61, true);
              if (Main.tile[i, minJ].active())
                Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
              if (Main.netMode == 2 && Main.tile[i, minJ].active())
                NetMessage.SendTileSquare(-1, i, minJ);
            }
            else if (WorldGen.genRand.Next(500) == 0 && (!Main.tile[i, minJ].active() || Main.tile[i, minJ].type == (ushort) 61 || Main.tile[i, minJ].type == (ushort) 74 || Main.tile[i, minJ].type == (ushort) 69))
            {
              if (WorldGen.GrowTree(i, j) && WorldGen.PlayerLOS(i, j))
                WorldGen.TreeGrowFXCheck(i, j - 1);
            }
            else if (WorldGen.genRand.Next(25) == 0 && Main.tile[i, minJ].liquid == (byte) 0)
            {
              WorldGen.PlaceJunglePlant(i, minJ, (ushort) 233, WorldGen.genRand.Next(8), 0);
              if (Main.tile[i, minJ].type == (ushort) 233)
              {
                if (Main.netMode == 2)
                {
                  NetMessage.SendTileSquare(-1, i, minJ, 4);
                }
                else
                {
                  WorldGen.PlaceJunglePlant(i, minJ, (ushort) 233, WorldGen.genRand.Next(12), 1);
                  if (Main.tile[i, minJ].type == (ushort) 233 && Main.netMode == 2)
                    NetMessage.SendTileSquare(-1, i, minJ, 3);
                }
              }
            }
            bool flag7 = false;
            TileColorCache color1 = Main.tile[i, j].BlockColorAndCoating();
            for (int i1 = minI; i1 < maxI; ++i1)
            {
              for (int j1 = minJ; j1 < maxJ; ++j1)
              {
                if ((i != i1 || j != j1) && Main.tile[i1, j1].active() && Main.tile[i1, j1].type == (ushort) 59)
                {
                  WorldGen.SpreadGrass(i1, j1, 59, grass3, false, color1);
                  if ((int) Main.tile[i1, j1].type == grass3)
                  {
                    WorldGen.SquareTileFrame(i1, j1);
                    flag7 = true;
                  }
                }
              }
            }
            if (!(Main.netMode == 2 & flag7))
              break;
            NetMessage.SendTileSquare(-1, i, j, 3);
            break;
          case 70:
            if (!Main.tile[i, j].inActive())
            {
              if (!Main.tile[i, minJ].active() && WorldGen.genRand.Next(10) == 0)
              {
                WorldGen.PlaceTile(i, minJ, 71, true);
                if (Main.tile[i, minJ].active())
                  Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
                if (Main.netMode == 2 && Main.tile[i, minJ].active())
                  NetMessage.SendTileSquare(-1, i, minJ);
              }
              if (WorldGen.genRand.Next(300) == 0)
              {
                bool flag8 = WorldGen.PlayerLOS(i, j);
                if (WorldGen.GrowTree(i, j) & flag8)
                  WorldGen.TreeGrowFXCheck(i, j - 1);
              }
            }
            bool flag9 = false;
            TileColorCache color2 = Main.tile[i, j].BlockColorAndCoating();
            for (int i2 = minI; i2 < maxI; ++i2)
            {
              for (int j2 = minJ; j2 < maxJ; ++j2)
              {
                if ((i != i2 || j != j2) && Main.tile[i2, j2].active() && Main.tile[i2, j2].type == (ushort) 59)
                {
                  WorldGen.SpreadGrass(i2, j2, 59, grass3, false, color2);
                  if ((int) Main.tile[i2, j2].type == grass3)
                  {
                    WorldGen.SquareTileFrame(i2, j2);
                    flag9 = true;
                  }
                }
              }
            }
            if (!(Main.netMode == 2 & flag9))
              break;
            NetMessage.SendTileSquare(-1, i, j, 3);
            break;
          case 633:
            if (!Main.tile[i, minJ].active() && WorldGen.genRand.Next(10) == 0)
            {
              WorldGen.PlaceTile(i, minJ, 637, true);
              if (Main.tile[i, minJ].active())
                Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
              if (Main.netMode == 2 && Main.tile[i, minJ].active())
                NetMessage.SendTileSquare(-1, i, minJ);
            }
            TileColorCache color3 = Main.tile[i, j].BlockColorAndCoating();
            bool flag10 = false;
            for (int i3 = minI; i3 < maxI; ++i3)
            {
              for (int j3 = minJ; j3 < maxJ; ++j3)
              {
                if ((i != i3 || j != j3) && Main.tile[i3, j3].active() && Main.tile[i3, j3].type == (ushort) 57)
                {
                  WorldGen.SpreadGrass(i3, j3, 57, grass3, false, color3);
                  if ((int) Main.tile[i3, j3].type == grass3)
                  {
                    WorldGen.SquareTileFrame(i3, j3);
                    flag10 = true;
                  }
                }
              }
            }
            if (!(Main.netMode == 2 & flag10))
              break;
            NetMessage.SendTileSquare(-1, i, j, 3);
            break;
        }
      }
    }

    private static void TrySpawningTownNPC(int x, int y)
    {
      bool flag = Main.tileSolid[379];
      Main.tileSolid[379] = true;
      if (WorldGen.prioritizedTownNPCType > 0)
      {
        if (Main.tile[x, y].wall == (ushort) 34)
        {
          if (Main.rand.Next(4) == 0)
          {
            int num1 = (int) WorldGen.SpawnTownNPC(x, y);
          }
        }
        else
        {
          int num2 = (int) WorldGen.SpawnTownNPC(x, y);
        }
      }
      Main.tileSolid[379] = flag;
    }

    public static void SpreadDesertWalls(int wallDist, int i, int j)
    {
      if (!WorldGen.InWorld(i, j, 10) || !WallID.Sets.Conversion.Sandstone[(int) Main.tile[i, j].wall] && (!Main.tile[i, j].active() || !TileID.Sets.Conversion.Sandstone[(int) Main.tile[i, j].type]) && !WallID.Sets.Conversion.HardenedSand[(int) Main.tile[i, j].wall])
        return;
      int num = 0;
      int wall = (int) Main.tile[i, j].wall;
      int type = (int) Main.tile[i, j].type;
      if (WallID.Sets.Corrupt[wall] || TileID.Sets.Corrupt[type])
        num = 1;
      if (WallID.Sets.Hallow[wall] || TileID.Sets.Hallow[type])
        num = 2;
      if (WallID.Sets.Crimson[wall] || TileID.Sets.Crimson[type])
        num = 3;
      if (num == 0)
        return;
      int tileX = i + WorldGen.genRand.Next(-2, 3);
      int tileY = j + WorldGen.genRand.Next(-2, 3);
      bool flag = false;
      if (WallID.Sets.Conversion.PureSand[(int) Main.tile[tileX, tileY].wall])
      {
        switch (num)
        {
          case 1:
            for (int index1 = i - wallDist; index1 < i + wallDist; ++index1)
            {
              for (int index2 = j - wallDist; index2 < j + wallDist; ++index2)
              {
                if (Main.tile[index1, index2].active() && TileID.Sets.Corrupt[(int) Main.tile[index1, index2].type])
                {
                  flag = true;
                  break;
                }
              }
              if (flag)
                break;
            }
            break;
          case 2:
            for (int index3 = i - wallDist; index3 < i + wallDist; ++index3)
            {
              for (int index4 = j - wallDist; index4 < j + wallDist; ++index4)
              {
                if (Main.tile[index3, index4].active() && TileID.Sets.Hallow[(int) Main.tile[index3, index4].type])
                {
                  flag = true;
                  break;
                }
              }
              if (flag)
                break;
            }
            break;
          case 3:
            for (int index5 = i - wallDist; index5 < i + wallDist; ++index5)
            {
              for (int index6 = j - wallDist; index6 < j + wallDist; ++index6)
              {
                if (Main.tile[index5, index6].active() && TileID.Sets.Crimson[(int) Main.tile[index5, index6].type])
                {
                  flag = true;
                  break;
                }
              }
              if (flag)
                break;
            }
            break;
        }
      }
      if (!flag)
        return;
      ushort? nullable = new ushort?();
      if (WallID.Sets.Conversion.Sandstone[(int) Main.tile[tileX, tileY].wall])
      {
        switch (num)
        {
          case 1:
            nullable = new ushort?((ushort) 220);
            break;
          case 2:
            nullable = new ushort?((ushort) 222);
            break;
          case 3:
            nullable = new ushort?((ushort) 221);
            break;
        }
      }
      if (WallID.Sets.Conversion.HardenedSand[(int) Main.tile[tileX, tileY].wall])
      {
        switch (num)
        {
          case 1:
            nullable = new ushort?((ushort) 217);
            break;
          case 2:
            nullable = new ushort?((ushort) 219);
            break;
          case 3:
            nullable = new ushort?((ushort) 218);
            break;
        }
      }
      if (!nullable.HasValue || (int) Main.tile[tileX, tileY].wall == (int) nullable.Value)
        return;
      Main.tile[tileX, tileY].wall = nullable.Value;
      if (Main.netMode != 2)
        return;
      NetMessage.SendTileSquare(-1, tileX, tileY);
    }

    public static void PlaceWall(int i, int j, int type, bool mute = false)
    {
      if (i <= 1 || j <= 1 || i >= Main.maxTilesX - 2 || j >= Main.maxTilesY - 2)
        return;
      if (Main.tile[i, j] == null)
        Main.tile[i, j] = new Tile();
      if (Main.tile[i, j].wall != (ushort) 0)
        return;
      Main.tile[i, j].wall = (ushort) type;
      WorldGen.SquareWallFrame(i, j);
      if (mute)
        return;
      SoundEngine.PlaySound(0, i * 16, j * 16);
    }

    public static void SpreadGrass(
      int i,
      int j,
      int dirt = 0,
      int grass = 2,
      bool repeat = true,
      TileColorCache color = default (TileColorCache))
    {
      try
      {
        if (!WorldGen.InWorld(i, j, 10) || !Main.tile[i, j].active() || (int) Main.tile[i, j].type != dirt)
          return;
        if (WorldGen.gen && (grass == 199 || grass == 23))
        {
          int beachDistance = WorldGen.beachDistance;
          if (!WorldGen.tenthAnniversaryWorldGen && (double) i > (double) Main.maxTilesX * 0.45 && (double) i <= (double) Main.maxTilesX * 0.55 || i < beachDistance || i >= Main.maxTilesX - beachDistance)
            return;
        }
        else if ((WorldGen.gen || grass != 199 && grass != 23 && grass != 661 && grass != 662) && ((int) Main.tile[i, j].type != dirt || !Main.tile[i, j].active() || (double) j >= Main.worldSurface && dirt == 0) && !WorldGen.growGrassUnderground)
          return;
        int num1 = i - 1;
        int num2 = i + 2;
        int num3 = j - 1;
        int num4 = j + 2;
        if (num1 < 0)
          num1 = 0;
        if (num2 > Main.maxTilesX)
          num2 = Main.maxTilesX;
        if (num3 < 0)
          num3 = 0;
        if (num4 > Main.maxTilesY)
          num4 = Main.maxTilesY;
        bool flag = true;
        for (int index1 = num1; index1 < num2; ++index1)
        {
          for (int index2 = num3; index2 < num4; ++index2)
          {
            if (!Main.tile[index1, index2].active() || !Main.tileSolid[(int) Main.tile[index1, index2].type])
              flag = false;
            if (Main.tile[index1, index2].lava() && Main.tile[index1, index2].liquid > (byte) 0)
            {
              flag = true;
              break;
            }
          }
        }
        if (flag || !TileID.Sets.CanBeClearedDuringGeneration[(int) Main.tile[i, j].type] || (grass == 23 || grass == 661) && Main.tile[i, j - 1].type == (ushort) 27 || (grass == 199 || grass == 662) && Main.tile[i, j - 1].type == (ushort) 27 || grass == 109 && Main.tile[i, j - 1].type == (ushort) 27)
          return;
        Main.tile[i, j].type = (ushort) grass;
        Main.tile[i, j].UseBlockColors(color);
        for (int i1 = num1; i1 < num2; ++i1)
        {
          for (int j1 = num3; j1 < num4; ++j1)
          {
            if (Main.tile[i1, j1].active())
            {
              if ((int) Main.tile[i1, j1].type == dirt)
              {
                try
                {
                  if (repeat)
                  {
                    if (WorldGen.grassSpread < 1000)
                    {
                      ++WorldGen.grassSpread;
                      WorldGen.SpreadGrass(i1, j1, dirt, grass);
                      --WorldGen.grassSpread;
                    }
                  }
                }
                catch
                {
                }
              }
            }
          }
        }
      }
      catch
      {
      }
    }

    public static void ChasmRunnerSideways(int i, int j, int direction, int steps)
    {
      double num1 = (double) steps;
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      Vector2D vector2D2;
      vector2D2.X = (double) WorldGen.genRand.Next(10, 21) * 0.1 * (double) direction;
      vector2D2.Y = (double) WorldGen.genRand.Next(-10, 10) * 0.01;
      double num2 = (double) (WorldGen.genRand.Next(5) + 7);
      while (num2 > 0.0)
      {
        if (num1 > 0.0)
        {
          num2 = num2 + (double) WorldGen.genRand.Next(3) - (double) WorldGen.genRand.Next(3);
          if (num2 < 7.0)
            num2 = 7.0;
          if (num2 > 20.0)
            num2 = 20.0;
          if (num1 == 1.0 && num2 < 10.0)
            num2 = 10.0;
        }
        else
          num2 -= (double) WorldGen.genRand.Next(4);
        if (vector2D1.Y > Main.rockLayer && num1 > 0.0)
          num1 = 0.0;
        --num1;
        int num3 = (int) (vector2D1.X - num2 * 0.5);
        int num4 = (int) (vector2D1.X + num2 * 0.5);
        int num5 = (int) (vector2D1.Y - num2 * 0.5);
        int num6 = (int) (vector2D1.Y + num2 * 0.5);
        if (num3 < 0)
          num3 = 0;
        if (num4 > Main.maxTilesX - 1)
          num4 = Main.maxTilesX - 1;
        if (num5 < 0)
          num5 = 0;
        if (num6 > Main.maxTilesY)
          num6 = Main.maxTilesY;
        for (int index1 = num3; index1 < num4; ++index1)
        {
          for (int index2 = num5; index2 < num6; ++index2)
          {
            if (Math.Abs((double) index1 - vector2D1.X) + Math.Abs((double) index2 - vector2D1.Y) < num2 * 0.5 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015) && Main.tile[index1, index2].type != (ushort) 31 && Main.tile[index1, index2].type != (ushort) 22)
              Main.tile[index1, index2].active(false);
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.Y += (double) WorldGen.genRand.Next(-10, 10) * 0.1;
        if (vector2D1.Y < (double) (j - 20))
          vector2D2.Y += (double) WorldGen.genRand.Next(20) * 0.01;
        if (vector2D1.Y > (double) (j + 20))
          vector2D2.Y -= (double) WorldGen.genRand.Next(20) * 0.01;
        if (vector2D2.Y < -0.5)
          vector2D2.Y = -0.5;
        if (vector2D2.Y > 0.5)
          vector2D2.Y = 0.5;
        vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.01;
        switch (direction)
        {
          case -1:
            if (vector2D2.X > -0.5)
              vector2D2.X = -0.5;
            if (vector2D2.X < -2.0)
            {
              vector2D2.X = -2.0;
              break;
            }
            break;
          case 1:
            if (vector2D2.X < 0.5)
              vector2D2.X = 0.5;
            if (vector2D2.X > 2.0)
            {
              vector2D2.X = 2.0;
              break;
            }
            break;
        }
        int num7 = (int) (vector2D1.X - num2 * 1.1);
        int num8 = (int) (vector2D1.X + num2 * 1.1);
        int num9 = (int) (vector2D1.Y - num2 * 1.1);
        int num10 = (int) (vector2D1.Y + num2 * 1.1);
        if (num7 < 1)
          num7 = 1;
        if (num8 > Main.maxTilesX - 1)
          num8 = Main.maxTilesX - 1;
        if (num9 < 0)
          num9 = 0;
        if (num10 > Main.maxTilesY)
          num10 = Main.maxTilesY;
        for (int index3 = num7; index3 < num8; ++index3)
        {
          for (int index4 = num9; index4 < num10; ++index4)
          {
            if (Math.Abs((double) index3 - vector2D1.X) + Math.Abs((double) index4 - vector2D1.Y) < num2 * 1.1 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015) && Main.tile[index3, index4].wall != (ushort) 3)
            {
              if (Main.tile[index3, index4].type != (ushort) 25 && index4 > j + WorldGen.genRand.Next(3, 20))
                Main.tile[index3, index4].active(true);
              Main.tile[index3, index4].active(true);
              if (Main.tile[index3, index4].type != (ushort) 31 && Main.tile[index3, index4].type != (ushort) 22)
                Main.tile[index3, index4].type = (ushort) 25;
              if (Main.tile[index3, index4].wall == (ushort) 2)
                Main.tile[index3, index4].wall = (ushort) 0;
            }
          }
        }
        for (int i1 = num7; i1 < num8; ++i1)
        {
          for (int j1 = num9; j1 < num10; ++j1)
          {
            if (Math.Abs((double) i1 - vector2D1.X) + Math.Abs((double) j1 - vector2D1.Y) < num2 * 1.1 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015) && Main.tile[i1, j1].wall != (ushort) 3)
            {
              if (Main.tile[i1, j1].type != (ushort) 31 && Main.tile[i1, j1].type != (ushort) 22)
                Main.tile[i1, j1].type = (ushort) 25;
              Main.tile[i1, j1].active(true);
              WorldGen.PlaceWall(i1, j1, 3, true);
            }
          }
        }
      }
      if (WorldGen.genRand.Next(3) != 0)
        return;
      int x = (int) vector2D1.X;
      int y = (int) vector2D1.Y;
      while (!Main.tile[x, y].active())
        ++y;
      WorldGen.TileRunner(x, y, (double) WorldGen.genRand.Next(2, 6), WorldGen.genRand.Next(3, 7), 22);
    }

    public static void CrimStart(int i, int j)
    {
      int crimDir = 1;
      int i1 = i;
      int j1 = j;
      if ((double) j1 > Main.worldSurface)
        j1 = (int) Main.worldSurface;
      while (!WorldGen.SolidTile(i1, j1))
        ++j1;
      int num1 = i1;
      int num2 = j1;
      Vector2D position;
      // ISSUE: explicit constructor call
      ((Vector2D) ref position).\u002Ector((double) i1, (double) j1);
      Vector2D vector2D;
      // ISSUE: explicit constructor call
      ((Vector2D) ref vector2D).\u002Ector((double) WorldGen.genRand.Next(-20, 21) * 0.1, (double) WorldGen.genRand.Next(20, 201) * 0.01);
      if (vector2D.X < 0.0)
        crimDir = -1;
      double num3 = (double) WorldGen.genRand.Next(15, 26);
      bool flag1 = true;
      int num4 = 0;
      while (flag1)
      {
        num3 += (double) WorldGen.genRand.Next(-50, 51) * 0.01;
        if (num3 < 15.0)
          num3 = 15.0;
        if (num3 > 25.0)
          num3 = 25.0;
        for (int index1 = (int) (position.X - num3 / 2.0); (double) index1 < position.X + num3 / 2.0; ++index1)
        {
          for (int index2 = (int) (position.Y - num3 / 2.0); (double) index2 < position.Y + num3 / 2.0; ++index2)
          {
            if (index2 > num2)
            {
              if (Math.Abs((double) index1 - position.X) + Math.Abs((double) index2 - position.Y) < num3 * 0.3)
              {
                Main.tile[index1, index2].active(false);
                Main.tile[index1, index2].wall = (ushort) 83;
              }
              else if (Math.Abs((double) index1 - position.X) + Math.Abs((double) index2 - position.Y) < num3 * 0.8 && Main.tile[index1, index2].wall != (ushort) 83)
              {
                Main.tile[index1, index2].active(true);
                Main.tile[index1, index2].type = (ushort) 203;
                if (Math.Abs((double) index1 - position.X) + Math.Abs((double) index2 - position.Y) < num3 * 0.6)
                  Main.tile[index1, index2].wall = (ushort) 83;
              }
            }
            else if (Math.Abs((double) index1 - position.X) + Math.Abs((double) index2 - position.Y) < num3 * 0.3 && Main.tile[index1, index2].active())
            {
              Main.tile[index1, index2].active(false);
              Main.tile[index1, index2].wall = (ushort) 83;
            }
          }
        }
        if (position.X > (double) (num1 + 50))
          num4 = -100;
        if (position.X < (double) (num1 - 50))
          num4 = 100;
        if (num4 < 0)
          vector2D.X -= (double) WorldGen.genRand.Next(20, 51) * 0.01;
        else if (num4 > 0)
          vector2D.X += (double) WorldGen.genRand.Next(20, 51) * 0.01;
        else
          vector2D.X += (double) WorldGen.genRand.Next(-50, 51) * 0.01;
        vector2D.Y += (double) WorldGen.genRand.Next(-50, 51) * 0.01;
        if (vector2D.Y < 0.25)
          vector2D.Y = 0.25;
        if (vector2D.Y > 2.0)
          vector2D.Y = 2.0;
        if (vector2D.X < -2.0)
          vector2D.X = -2.0;
        if (vector2D.X > 2.0)
          vector2D.X = 2.0;
        position = Vector2D.op_Addition(position, vector2D);
        if (position.Y > Main.worldSurface + 100.0)
          flag1 = false;
      }
      double num5 = (double) WorldGen.genRand.Next(40, 55);
      for (int index3 = 0; index3 < 50; ++index3)
      {
        int num6 = (int) position.X + WorldGen.genRand.Next(-20, 21);
        int num7 = (int) position.Y + WorldGen.genRand.Next(-20, 21);
        for (int index4 = (int) ((double) num6 - num5 / 2.0); (double) index4 < (double) num6 + num5 / 2.0; ++index4)
        {
          for (int index5 = (int) ((double) num7 - num5 / 2.0); (double) index5 < (double) num7 + num5 / 2.0; ++index5)
          {
            double num8 = (double) Math.Abs(index4 - num6);
            double num9 = (double) Math.Abs(index5 - num7);
            double num10 = 1.0 + (double) WorldGen.genRand.Next(-20, 21) * 0.01;
            double num11 = 1.0 + (double) WorldGen.genRand.Next(-20, 21) * 0.01;
            double num12 = num10;
            double num13 = num8 * num12;
            double num14 = num9 * num11;
            double num15 = Math.Sqrt(num13 * num13 + num14 * num14);
            if (num15 < num5 * 0.25)
            {
              Main.tile[index4, index5].active(false);
              Main.tile[index4, index5].wall = (ushort) 83;
            }
            else if (num15 < num5 * 0.4 && Main.tile[index4, index5].wall != (ushort) 83)
            {
              Main.tile[index4, index5].active(true);
              Main.tile[index4, index5].type = (ushort) 203;
              if (num15 < num5 * 0.35)
                Main.tile[index4, index5].wall = (ushort) 83;
            }
          }
        }
      }
      int length = WorldGen.genRand.Next(5, 9);
      Vector2D[] vector2DArray = new Vector2D[length];
      for (int index6 = 0; index6 < length; ++index6)
      {
        int x = (int) position.X;
        int y = (int) position.Y;
        int num16 = 0;
        bool flag2 = true;
        Vector2D velocity;
        // ISSUE: explicit constructor call
        ((Vector2D) ref velocity).\u002Ector((double) WorldGen.genRand.Next(-20, 21) * 0.15, (double) WorldGen.genRand.Next(0, 21) * 0.15);
        while (flag2)
        {
          // ISSUE: explicit constructor call
          ((Vector2D) ref velocity).\u002Ector((double) WorldGen.genRand.Next(-20, 21) * 0.15, (double) WorldGen.genRand.Next(0, 21) * 0.15);
          while (Math.Abs(velocity.X) + Math.Abs(velocity.Y) < 1.5)
          {
            // ISSUE: explicit constructor call
            ((Vector2D) ref velocity).\u002Ector((double) WorldGen.genRand.Next(-20, 21) * 0.15, (double) WorldGen.genRand.Next(0, 21) * 0.15);
          }
          flag2 = false;
          for (int index7 = 0; index7 < index6; ++index7)
          {
            if (vector2D.X > vector2DArray[index7].X - 0.75 && vector2D.X < vector2DArray[index7].X + 0.75 && vector2D.Y > vector2DArray[index7].Y - 0.75 && vector2D.Y < vector2DArray[index7].Y + 0.75)
            {
              flag2 = true;
              ++num16;
              break;
            }
          }
          if (num16 > 10000)
            break;
        }
        vector2DArray[index6] = velocity;
        WorldGen.CrimVein(new Vector2D((double) x, (double) y), velocity);
      }
      int num17 = Main.maxTilesX;
      int num18 = 0;
      position.X = (double) num1;
      position.Y = (double) num2;
      double num19 = (double) WorldGen.genRand.Next(25, 35);
      double num20 = (double) WorldGen.genRand.Next(0, 6);
      for (int index8 = 0; index8 < 50; ++index8)
      {
        if (num20 > 0.0)
        {
          double num21 = (double) WorldGen.genRand.Next(10, 30) * 0.01;
          num20 -= num21;
          position.Y -= num21;
        }
        int num22 = (int) position.X + WorldGen.genRand.Next(-2, 3);
        int num23 = (int) position.Y + WorldGen.genRand.Next(-2, 3);
        for (int index9 = (int) ((double) num22 - num19 / 2.0); (double) index9 < (double) num22 + num19 / 2.0; ++index9)
        {
          for (int index10 = (int) ((double) num23 - num19 / 2.0); (double) index10 < (double) num23 + num19 / 2.0; ++index10)
          {
            double num24 = (double) Math.Abs(index9 - num22);
            double num25 = (double) Math.Abs(index10 - num23);
            double num26 = 1.0 + (double) WorldGen.genRand.Next(-20, 21) * 0.005;
            double num27 = 1.0 + (double) WorldGen.genRand.Next(-20, 21) * 0.005;
            double num28 = num26;
            double num29 = num24 * num28;
            double num30 = num25 * num27;
            double num31 = Math.Sqrt(num29 * num29 + num30 * num30);
            if (num31 < num19 * 0.2 * ((double) WorldGen.genRand.Next(90, 111) * 0.01))
            {
              Main.tile[index9, index10].active(false);
              Main.tile[index9, index10].wall = (ushort) 83;
            }
            else if (num31 < num19 * 0.45)
            {
              if (index9 < num17)
                num17 = index9;
              if (index9 > num18)
                num18 = index9;
              if (Main.tile[index9, index10].wall != (ushort) 83)
              {
                Main.tile[index9, index10].active(true);
                Main.tile[index9, index10].type = (ushort) 203;
                if (num31 < num19 * 0.35)
                  Main.tile[index9, index10].wall = (ushort) 83;
              }
            }
          }
        }
      }
      for (int index11 = num17; index11 <= num18; ++index11)
      {
        int index12 = num2;
        while (Main.tile[index11, index12].type == (ushort) 203 && Main.tile[index11, index12].active() || Main.tile[index11, index12].wall == (ushort) 83)
          ++index12;
        for (int index13 = WorldGen.genRand.Next(15, 20); !Main.tile[index11, index12].active() && index13 > 0 && Main.tile[index11, index12].wall != (ushort) 83; ++index12)
        {
          --index13;
          Main.tile[index11, index12].type = (ushort) 203;
          Main.tile[index11, index12].active(true);
        }
      }
      WorldGen.CrimEnt(position, crimDir);
    }

    public static void CrimPlaceHearts()
    {
      for (int index1 = 0; index1 < WorldGen.heartCount; ++index1)
      {
        int num1 = WorldGen.genRand.Next(16, 21);
        int x = WorldGen.heartPos[index1].X;
        int y = WorldGen.heartPos[index1].Y;
        for (int index2 = x - num1 / 2; index2 < x + num1 / 2; ++index2)
        {
          for (int index3 = y - num1 / 2; index3 < y + num1 / 2; ++index3)
          {
            double num2 = (double) Math.Abs(index2 - x);
            double num3 = (double) Math.Abs(index3 - y);
            if (Math.Sqrt(num2 * num2 + num3 * num3) < (double) num1 * 0.4)
            {
              Main.tile[index2, index3].active(true);
              Main.tile[index2, index3].type = (ushort) 203;
              Main.tile[index2, index3].wall = (ushort) 83;
            }
          }
        }
      }
      for (int index4 = 0; index4 < WorldGen.heartCount; ++index4)
      {
        int num4 = WorldGen.genRand.Next(10, 14);
        int x = WorldGen.heartPos[index4].X;
        int y = WorldGen.heartPos[index4].Y;
        for (int index5 = x - num4 / 2; index5 < x + num4 / 2; ++index5)
        {
          for (int index6 = y - num4 / 2; index6 < y + num4 / 2; ++index6)
          {
            double num5 = (double) Math.Abs(index5 - x);
            double num6 = (double) Math.Abs(index6 - y);
            if (Math.Sqrt(num5 * num5 + num6 * num6) < (double) num4 * 0.3)
            {
              Main.tile[index5, index6].active(false);
              Main.tile[index5, index6].wall = (ushort) 83;
            }
          }
        }
      }
      for (int index = 0; index < WorldGen.heartCount; ++index)
        WorldGen.AddShadowOrb(WorldGen.heartPos[index].X, WorldGen.heartPos[index].Y);
    }

    public static void CrimEnt(Vector2D position, int crimDir)
    {
      double num1 = 0.0;
      double num2 = (double) WorldGen.genRand.Next(6, 11);
      bool flag = true;
      Vector2D vector2D;
      // ISSUE: explicit constructor call
      ((Vector2D) ref vector2D).\u002Ector(2.0, (double) WorldGen.genRand.Next(-20, 0) * 0.01);
      vector2D.X *= (double) -crimDir;
      while (flag)
      {
        ++num1;
        if (num1 >= 20.0)
          flag = false;
        num2 += (double) WorldGen.genRand.Next(-10, 11) * 0.02;
        if (num2 < 6.0)
          num2 = 6.0;
        if (num2 > 10.0)
          num2 = 10.0;
        for (int index1 = (int) (position.X - num2 / 2.0); (double) index1 < position.X + num2 / 2.0; ++index1)
        {
          for (int index2 = (int) (position.Y - num2 / 2.0); (double) index2 < position.Y + num2 / 2.0; ++index2)
          {
            double num3 = Math.Abs((double) index1 - position.X);
            double num4 = Math.Abs((double) index2 - position.Y);
            if (Math.Sqrt(num3 * num3 + num4 * num4) < num2 * 0.5 && Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 203)
            {
              Main.tile[index1, index2].active(false);
              flag = true;
              num1 = 0.0;
            }
          }
        }
        position = Vector2D.op_Addition(position, vector2D);
      }
    }

    public static void CrimVein(Vector2D position, Vector2D velocity)
    {
      double num1 = (double) WorldGen.genRand.Next(15, 26);
      bool flag = true;
      Vector2D vector2D1 = velocity;
      Vector2D vector2D2 = position;
      int num2 = WorldGen.genRand.Next(100, 150);
      if (velocity.Y < 0.0)
        num2 -= 25;
      while (flag)
      {
        num1 += (double) WorldGen.genRand.Next(-50, 51) * 0.02;
        if (num1 < 15.0)
          num1 = 15.0;
        if (num1 > 25.0)
          num1 = 25.0;
        for (int index1 = (int) (position.X - num1 / 2.0); (double) index1 < position.X + num1 / 2.0; ++index1)
        {
          for (int index2 = (int) (position.Y - num1 / 2.0); (double) index2 < position.Y + num1 / 2.0; ++index2)
          {
            double num3 = Math.Abs((double) index1 - position.X);
            double num4 = Math.Abs((double) index2 - position.Y);
            double num5 = Math.Sqrt(num3 * num3 + num4 * num4);
            if (num5 < num1 * 0.2)
            {
              Main.tile[index1, index2].active(false);
              Main.tile[index1, index2].wall = (ushort) 83;
            }
            else if (num5 < num1 * 0.5 && Main.tile[index1, index2].wall != (ushort) 83)
            {
              Main.tile[index1, index2].active(true);
              Main.tile[index1, index2].type = (ushort) 203;
              if (num5 < num1 * 0.4)
                Main.tile[index1, index2].wall = (ushort) 83;
            }
          }
        }
        velocity.X += (double) WorldGen.genRand.Next(-50, 51) * 0.05;
        velocity.Y += (double) WorldGen.genRand.Next(-50, 51) * 0.05;
        if (velocity.Y < vector2D1.Y - 0.75)
          velocity.Y = vector2D1.Y - 0.75;
        if (velocity.Y > vector2D1.Y + 0.75)
          velocity.Y = vector2D1.Y + 0.75;
        if (velocity.X < vector2D1.X - 0.75)
          velocity.X = vector2D1.X - 0.75;
        if (velocity.X > vector2D1.X + 0.75)
          velocity.X = vector2D1.X + 0.75;
        position = Vector2D.op_Addition(position, velocity);
        if (Math.Abs(position.X - vector2D2.X) + Math.Abs(position.Y - vector2D2.Y) > (double) num2)
          flag = false;
      }
      WorldGen.heartPos[WorldGen.heartCount] = position.ToPoint();
      ++WorldGen.heartCount;
    }

    public static void ChasmRunner(int i, int j, int steps, bool makeOrb = false)
    {
      bool flag1 = false;
      bool flag2 = false;
      bool flag3 = false;
      if (!makeOrb)
        flag2 = true;
      double num1 = (double) steps;
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      Vector2D vector2D2;
      vector2D2.X = (double) WorldGen.genRand.Next(-10, 11) * 0.1;
      vector2D2.Y = (double) WorldGen.genRand.Next(11) * 0.2 + 0.5;
      int num2 = 5;
      double num3 = (double) (WorldGen.genRand.Next(5) + 7);
      while (num3 > 0.0)
      {
        if (num1 > 0.0)
        {
          num3 = num3 + (double) WorldGen.genRand.Next(3) - (double) WorldGen.genRand.Next(3);
          if (num3 < 7.0)
            num3 = 7.0;
          if (num3 > 20.0)
            num3 = 20.0;
          if (num1 == 1.0 && num3 < 10.0)
            num3 = 10.0;
        }
        else if (vector2D1.Y > Main.worldSurface + 45.0)
          num3 -= (double) WorldGen.genRand.Next(4);
        if (vector2D1.Y > Main.rockLayer && num1 > 0.0)
          num1 = 0.0;
        --num1;
        if (!flag1 && vector2D1.Y > Main.worldSurface + 20.0)
        {
          flag1 = true;
          WorldGen.ChasmRunnerSideways((int) vector2D1.X, (int) vector2D1.Y, -1, WorldGen.genRand.Next(20, 40));
          WorldGen.ChasmRunnerSideways((int) vector2D1.X, (int) vector2D1.Y, 1, WorldGen.genRand.Next(20, 40));
        }
        if (num1 > (double) num2)
        {
          int num4 = (int) (vector2D1.X - num3 * 0.5);
          int num5 = (int) (vector2D1.X + num3 * 0.5);
          int num6 = (int) (vector2D1.Y - num3 * 0.5);
          int num7 = (int) (vector2D1.Y + num3 * 0.5);
          if (num4 < 0)
            num4 = 0;
          if (num5 > Main.maxTilesX - 1)
            num5 = Main.maxTilesX - 1;
          if (num6 < 0)
            num6 = 0;
          if (num7 > Main.maxTilesY)
            num7 = Main.maxTilesY;
          for (int index1 = num4; index1 < num5; ++index1)
          {
            for (int index2 = num6; index2 < num7; ++index2)
            {
              if (Math.Abs((double) index1 - vector2D1.X) + Math.Abs((double) index2 - vector2D1.Y) < num3 * 0.5 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015) && Main.tile[index1, index2].type != (ushort) 31 && Main.tile[index1, index2].type != (ushort) 22)
                Main.tile[index1, index2].active(false);
            }
          }
        }
        if (num1 <= 2.0 && vector2D1.Y < Main.worldSurface + 45.0)
          num1 = 2.0;
        if (num1 <= 0.0)
        {
          if (!flag2)
          {
            flag2 = true;
            WorldGen.AddShadowOrb((int) vector2D1.X, (int) vector2D1.Y);
          }
          else if (!flag3)
          {
            flag3 = false;
            bool flag4 = false;
            int num8 = 0;
            while (!flag4)
            {
              int x = WorldGen.genRand.Next((int) vector2D1.X - 25, (int) vector2D1.X + 25);
              int y = WorldGen.genRand.Next((int) vector2D1.Y - 50, (int) vector2D1.Y);
              if (x < 5)
                x = 5;
              if (x > Main.maxTilesX - 5)
                x = Main.maxTilesX - 5;
              if (y < 5)
                y = 5;
              if (y > Main.maxTilesY - 5)
                y = Main.maxTilesY - 5;
              if ((double) y > Main.worldSurface)
              {
                if (!WorldGen.IsTileNearby(x, y, 26, 3))
                  WorldGen.Place3x2(x, y, (ushort) 26);
                if (Main.tile[x, y].type == (ushort) 26)
                {
                  flag4 = true;
                }
                else
                {
                  ++num8;
                  if (num8 >= 10000)
                    flag4 = true;
                }
              }
              else
                flag4 = true;
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.01;
        if (vector2D2.X > 0.3)
          vector2D2.X = 0.3;
        if (vector2D2.X < -0.3)
          vector2D2.X = -0.3;
        int num9 = (int) (vector2D1.X - num3 * 1.1);
        int num10 = (int) (vector2D1.X + num3 * 1.1);
        int num11 = (int) (vector2D1.Y - num3 * 1.1);
        int num12 = (int) (vector2D1.Y + num3 * 1.1);
        if (num9 < 1)
          num9 = 1;
        if (num10 > Main.maxTilesX - 1)
          num10 = Main.maxTilesX - 1;
        if (num11 < 0)
          num11 = 0;
        if (num12 > Main.maxTilesY)
          num12 = Main.maxTilesY;
        for (int index3 = num9; index3 < num10; ++index3)
        {
          for (int index4 = num11; index4 < num12; ++index4)
          {
            if (Math.Abs((double) index3 - vector2D1.X) + Math.Abs((double) index4 - vector2D1.Y) < num3 * 1.1 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015))
            {
              if (Main.tile[index3, index4].type != (ushort) 25 && index4 > j + WorldGen.genRand.Next(3, 20))
                Main.tile[index3, index4].active(true);
              if (steps <= num2)
                Main.tile[index3, index4].active(true);
              if (Main.tile[index3, index4].type != (ushort) 31)
                Main.tile[index3, index4].type = (ushort) 25;
            }
          }
        }
        for (int index5 = num9; index5 < num10; ++index5)
        {
          for (int index6 = num11; index6 < num12; ++index6)
          {
            if (Math.Abs((double) index5 - vector2D1.X) + Math.Abs((double) index6 - vector2D1.Y) < num3 * 1.1 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015))
            {
              if (Main.tile[index5, index6].type != (ushort) 31)
                Main.tile[index5, index6].type = (ushort) 25;
              if (steps <= num2)
                Main.tile[index5, index6].active(true);
              if (index6 > j + WorldGen.genRand.Next(3, 20))
                Main.tile[index5, index6].wall = (ushort) 3;
            }
          }
        }
      }
    }

    public static void SpawnPlanteraThorns(Vector2 position)
    {
      if (Main.netMode == 1)
        return;
      int num1 = Main.rand.Next(3, 6);
      for (int index1 = 0; index1 < num1; ++index1)
      {
        int num2 = Main.rand.Next(15, 31);
        int index2 = (int) ((double) position.X / 16.0);
        int index3 = (int) ((double) position.Y / 16.0);
        int num3 = 0;
        int num4 = 0;
        if (Main.rand.Next(2) == 0)
          num3 = Main.rand.Next(2) != 0 ? -1 : 1;
        else
          num4 = Main.rand.Next(2) != 0 ? -1 : 1;
        while (num2 > 0)
        {
          --num2;
          if (!Main.tile[index2, index3].active())
          {
            WorldGen.PlaceTile(index2, index3, 655);
            if (Main.tile[index2, index3].active() && Main.netMode == 2)
              NetMessage.SendTileSquare(-1, index2, index3);
          }
          index2 += num3;
          index3 += num4;
          if (!WorldGen.InWorld(index2, index3))
            return;
          if (Main.rand.Next(5) == 0)
          {
            if (num4 == 0)
            {
              num3 = 0;
              num4 = Main.rand.Next(2) != 0 ? -1 : 1;
            }
            else
            {
              num4 = 0;
              num3 = Main.rand.Next(2) != 0 ? -1 : 1;
            }
          }
        }
      }
    }

    public static void GERunner(int i, int j, double speedX = 0.0, double speedY = 0.0, bool good = true)
    {
      int num1 = 0;
      for (int index1 = 20; index1 < Main.maxTilesX - 20; ++index1)
      {
        for (int index2 = 20; index2 < Main.maxTilesY - 20; ++index2)
        {
          if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 225)
            ++num1;
        }
      }
      bool flag1 = false;
      if (num1 > 200000)
        flag1 = true;
      int num2 = (int) ((double) WorldGen.genRand.Next(200, 250) * ((double) Main.maxTilesX / 4200.0));
      double num3 = (double) num2;
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      Vector2D vector2D2;
      vector2D2.X = (double) WorldGen.genRand.Next(-10, 11) * 0.1;
      vector2D2.Y = (double) WorldGen.genRand.Next(-10, 11) * 0.1;
      if (speedX != 0.0 || speedY != 0.0)
      {
        vector2D2.X = speedX;
        vector2D2.Y = speedY;
      }
      bool flag2 = true;
      while (flag2)
      {
        int num4 = (int) (vector2D1.X - num3 * 0.5);
        int num5 = (int) (vector2D1.X + num3 * 0.5);
        int num6 = (int) (vector2D1.Y - num3 * 0.5);
        int num7 = (int) (vector2D1.Y + num3 * 0.5);
        if (num4 < 0)
          num4 = 0;
        if (num5 > Main.maxTilesX)
          num5 = Main.maxTilesX;
        if (num6 < 0)
          num6 = 0;
        if (num7 > Main.maxTilesY - 5)
          num7 = Main.maxTilesY - 5;
        for (int i1 = num4; i1 < num5; ++i1)
        {
          for (int j1 = num6; j1 < num7; ++j1)
          {
            if (Math.Abs((double) i1 - vector2D1.X) + Math.Abs((double) j1 - vector2D1.Y) < (double) num2 * 0.5 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015))
            {
              if (good)
              {
                if (Main.tile[i1, j1].wall == (ushort) 63 || Main.tile[i1, j1].wall == (ushort) 65 || Main.tile[i1, j1].wall == (ushort) 66 || Main.tile[i1, j1].wall == (ushort) 68 || Main.tile[i1, j1].wall == (ushort) 69 || Main.tile[i1, j1].wall == (ushort) 81)
                  Main.tile[i1, j1].wall = (ushort) 70;
                else if (Main.tile[i1, j1].wall == (ushort) 216)
                  Main.tile[i1, j1].wall = (ushort) 219;
                else if (Main.tile[i1, j1].wall == (ushort) 187)
                  Main.tile[i1, j1].wall = (ushort) 222;
                else if (Main.tile[i1, j1].wall == (ushort) 3 || Main.tile[i1, j1].wall == (ushort) 83)
                  Main.tile[i1, j1].wall = (ushort) 28;
                if (flag1 && Main.tile[i1, j1].type == (ushort) 225)
                {
                  Main.tile[i1, j1].type = (ushort) 117;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (flag1 && Main.tile[i1, j1].type == (ushort) 230)
                {
                  Main.tile[i1, j1].type = (ushort) 402;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 2)
                {
                  Main.tile[i1, j1].type = (ushort) 109;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 1 || Main.tile[i1, j1].type == (ushort) 25 || Main.tile[i1, j1].type == (ushort) 203)
                {
                  Main.tile[i1, j1].type = (ushort) 117;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 53 || Main.tile[i1, j1].type == (ushort) 123 || Main.tile[i1, j1].type == (ushort) 112 || Main.tile[i1, j1].type == (ushort) 234)
                {
                  Main.tile[i1, j1].type = (ushort) 116;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 661 || Main.tile[i1, j1].type == (ushort) 662)
                {
                  Main.tile[i1, j1].type = (ushort) 60;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 23 || Main.tile[i1, j1].type == (ushort) 199)
                {
                  Main.tile[i1, j1].type = (ushort) 109;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 161 || Main.tile[i1, j1].type == (ushort) 163 || Main.tile[i1, j1].type == (ushort) 200)
                {
                  Main.tile[i1, j1].type = (ushort) 164;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 396)
                {
                  Main.tile[i1, j1].type = (ushort) 403;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 397)
                {
                  Main.tile[i1, j1].type = (ushort) 402;
                  WorldGen.SquareTileFrame(i1, j1);
                }
              }
              else if (WorldGen.crimson)
              {
                if (Main.tile[i1, j1].wall == (ushort) 63 || Main.tile[i1, j1].wall == (ushort) 65 || Main.tile[i1, j1].wall == (ushort) 66 || Main.tile[i1, j1].wall == (ushort) 68)
                  Main.tile[i1, j1].wall = (ushort) 81;
                else if (Main.tile[i1, j1].wall == (ushort) 216)
                  Main.tile[i1, j1].wall = (ushort) 218;
                else if (Main.tile[i1, j1].wall == (ushort) 187)
                  Main.tile[i1, j1].wall = (ushort) 221;
                if (flag1 && Main.tile[i1, j1].type == (ushort) 225)
                {
                  Main.tile[i1, j1].type = (ushort) 203;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (flag1 && Main.tile[i1, j1].type == (ushort) 230)
                {
                  Main.tile[i1, j1].type = (ushort) 399;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 60 || Main.tile[i1, j1].type == (ushort) 661)
                {
                  Main.tile[i1, j1].type = (ushort) 662;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 2 || Main.tile[i1, j1].type == (ushort) 109)
                {
                  Main.tile[i1, j1].type = (ushort) 199;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 1 || Main.tile[i1, j1].type == (ushort) 117)
                {
                  Main.tile[i1, j1].type = (ushort) 203;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 53 || Main.tile[i1, j1].type == (ushort) 123 || Main.tile[i1, j1].type == (ushort) 116)
                {
                  Main.tile[i1, j1].type = (ushort) 234;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 161 || Main.tile[i1, j1].type == (ushort) 164)
                {
                  Main.tile[i1, j1].type = (ushort) 200;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 396)
                {
                  Main.tile[i1, j1].type = (ushort) 401;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 397)
                {
                  Main.tile[i1, j1].type = (ushort) 399;
                  WorldGen.SquareTileFrame(i1, j1);
                }
              }
              else
              {
                if (Main.tile[i1, j1].wall == (ushort) 63 || Main.tile[i1, j1].wall == (ushort) 65 || Main.tile[i1, j1].wall == (ushort) 66 || Main.tile[i1, j1].wall == (ushort) 68)
                  Main.tile[i1, j1].wall = (ushort) 69;
                else if (Main.tile[i1, j1].wall == (ushort) 216)
                  Main.tile[i1, j1].wall = (ushort) 217;
                else if (Main.tile[i1, j1].wall == (ushort) 187)
                  Main.tile[i1, j1].wall = (ushort) 220;
                if (flag1 && Main.tile[i1, j1].type == (ushort) 225)
                {
                  Main.tile[i1, j1].type = (ushort) 25;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (flag1 && Main.tile[i1, j1].type == (ushort) 230)
                {
                  Main.tile[i1, j1].type = (ushort) 398;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 60 || Main.tile[i1, j1].type == (ushort) 662)
                {
                  Main.tile[i1, j1].type = (ushort) 661;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 2 || Main.tile[i1, j1].type == (ushort) 109)
                {
                  Main.tile[i1, j1].type = (ushort) 23;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 1 || Main.tile[i1, j1].type == (ushort) 117)
                {
                  Main.tile[i1, j1].type = (ushort) 25;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 53 || Main.tile[i1, j1].type == (ushort) 123 || Main.tile[i1, j1].type == (ushort) 116)
                {
                  Main.tile[i1, j1].type = (ushort) 112;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 161 || Main.tile[i1, j1].type == (ushort) 164)
                {
                  Main.tile[i1, j1].type = (ushort) 163;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 396)
                {
                  Main.tile[i1, j1].type = (ushort) 400;
                  WorldGen.SquareTileFrame(i1, j1);
                }
                else if (Main.tile[i1, j1].type == (ushort) 397)
                {
                  Main.tile[i1, j1].type = (ushort) 398;
                  WorldGen.SquareTileFrame(i1, j1);
                }
              }
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        if (vector2D2.X > speedX + 1.0)
          vector2D2.X = speedX + 1.0;
        if (vector2D2.X < speedX - 1.0)
          vector2D2.X = speedX - 1.0;
        if (vector2D1.X < (double) -num2 || vector2D1.Y < (double) -num2 || vector2D1.X > (double) (Main.maxTilesX + num2) || vector2D1.Y > (double) (Main.maxTilesY + num2))
          flag2 = false;
      }
    }

    private static bool badOceanCaveTiles(int x, int y) => Main.tile[x, y].wall == (ushort) 83 || Main.tile[x, y].wall == (ushort) 3 || Main.wallDungeon[(int) Main.tile[x, y].wall] || Main.tile[x, y].type == (ushort) 203 || Main.tile[x, y].type == (ushort) 25 || Main.tileDungeon[(int) Main.tile[x, y].type] || Main.tile[x, y].type == (ushort) 26 || Main.tile[x, y].type == (ushort) 31;

    public static void oceanCave(int i, int j)
    {
      if (GenVars.numOceanCaveTreasure >= GenVars.maxOceanCaveTreasure)
        GenVars.numOceanCaveTreasure = 0;
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      Vector2D vector2D2;
      vector2D2.X = i >= Main.maxTilesX / 2 ? -0.35 - WorldGen.genRand.NextDouble() * 0.5 : 0.25 + WorldGen.genRand.NextDouble() * 0.25;
      vector2D2.Y = 0.4 + WorldGen.genRand.NextDouble() * 0.25;
      ushort num1 = 264;
      ushort num2 = 53;
      ushort num3 = 397;
      double num4 = (double) WorldGen.genRand.Next(17, 25);
      double num5 = (double) WorldGen.genRand.Next(600, 800);
      double num6 = 4.0;
      bool flag1 = true;
      while (num4 > num6 && num5 > 0.0)
      {
        bool flag2 = true;
        bool flag3 = true;
        bool flag4 = true;
        if (vector2D1.X > (double) (WorldGen.beachDistance - 50) && vector2D1.X < (double) (Main.maxTilesX - WorldGen.beachDistance + 50))
        {
          num4 *= 0.96;
          num5 *= 0.96;
        }
        if (num4 < num6 + 2.0 || num5 < 20.0)
          flag4 = false;
        if (flag1)
        {
          num4 -= 0.01 + WorldGen.genRand.NextDouble() * 0.01;
          num5 -= 0.5;
        }
        else
        {
          num4 -= 0.02 + WorldGen.genRand.NextDouble() * 0.02;
          --num5;
        }
        if (flag4)
        {
          GenVars.oceanCaveTreasure[GenVars.numOceanCaveTreasure].X = (int) vector2D1.X;
          GenVars.oceanCaveTreasure[GenVars.numOceanCaveTreasure].Y = (int) vector2D1.Y;
        }
        int num7 = (int) (vector2D1.X - num4 * 3.0);
        int num8 = (int) (vector2D1.X + num4 * 3.0);
        int num9 = (int) (vector2D1.Y - num4 * 3.0);
        int num10 = (int) (vector2D1.Y + num4 * 3.0);
        if (num7 < 1)
          num7 = 1;
        if (num8 > Main.maxTilesX - 1)
          num8 = Main.maxTilesX - 1;
        if (num9 < 1)
          num9 = 1;
        if (num10 > Main.maxTilesY - 1)
          num10 = Main.maxTilesY - 1;
        for (int x1 = num7; x1 < num8; ++x1)
        {
          for (int y1 = num9; y1 < num10; ++y1)
          {
            if (!WorldGen.badOceanCaveTiles(x1, y1))
            {
              Vector2D vector2D3 = new Vector2D(Math.Abs((double) x1 - vector2D1.X), Math.Abs((double) y1 - vector2D1.Y));
              double num11 = ((Vector2D) ref vector2D3).Length();
              if (flag4 && num11 < num4 * 0.5 + 1.0)
              {
                Main.tile[x1, y1].type = num1;
                Main.tile[x1, y1].active(false);
              }
              else if (num11 < num4 * 1.5 + 1.0 && (int) Main.tile[x1, y1].type != (int) num1)
              {
                if ((double) y1 < vector2D1.Y)
                {
                  if (vector2D2.X < 0.0 && (double) x1 < vector2D1.X || vector2D2.X > 0.0 && (double) x1 > vector2D1.X)
                  {
                    if (num11 < num4 * 1.1 + 1.0)
                    {
                      Main.tile[x1, y1].type = num3;
                      if (Main.tile[x1, y1].liquid == byte.MaxValue)
                        Main.tile[x1, y1].wall = (ushort) 0;
                    }
                    else if ((int) Main.tile[x1, y1].type != (int) num3)
                      Main.tile[x1, y1].type = num2;
                  }
                }
                else if (vector2D2.X < 0.0 && x1 < i || vector2D2.X > 0.0 && x1 > i)
                {
                  if (Main.tile[x1, y1].liquid == byte.MaxValue)
                    Main.tile[x1, y1].wall = (ushort) 0;
                  Main.tile[x1, y1].type = num2;
                  Main.tile[x1, y1].active(true);
                  if (x1 == (int) vector2D1.X & flag2)
                  {
                    flag2 = false;
                    int num12 = 50 + WorldGen.genRand.Next(3);
                    int num13 = 43 + WorldGen.genRand.Next(3);
                    int num14 = 20 + WorldGen.genRand.Next(3);
                    int num15 = x1;
                    int num16 = x1 + num14;
                    if (vector2D2.X < 0.0)
                    {
                      num15 = x1 - num14;
                      num16 = x1;
                    }
                    if (num5 < 100.0)
                    {
                      num12 = (int) ((double) num12 * (num5 / 100.0));
                      num13 = (int) ((double) num13 * (num5 / 100.0));
                      num14 = (int) ((double) num14 * (num5 / 100.0));
                    }
                    if (num4 < num6 + 5.0)
                    {
                      double num17 = (num4 - num6) / 5.0;
                      num12 = (int) ((double) num12 * num17);
                      num13 = (int) ((double) num13 * num17);
                      int num18 = (int) ((double) num14 * num17);
                    }
                    for (int index1 = num15; index1 <= num16; ++index1)
                    {
                      for (int index2 = y1; index2 < y1 + num12 && !WorldGen.badOceanCaveTiles(index1, index2); ++index2)
                      {
                        if (index2 > y1 + num13)
                        {
                          if (!WorldGen.SolidTile(index1, index2) || (int) Main.tile[index1, index2].type == (int) num2)
                            Main.tile[index1, index2].type = num3;
                          else
                            break;
                        }
                        else
                          Main.tile[index1, index2].type = num2;
                        Main.tile[index1, index2].active(true);
                        if (WorldGen.genRand.Next(3) == 0)
                        {
                          Main.tile[index1 - 1, index2].type = num2;
                          Main.tile[index1 - 1, index2].active(true);
                        }
                        if (WorldGen.genRand.Next(3) == 0)
                        {
                          Main.tile[index1 + 1, index2].type = num2;
                          Main.tile[index1 + 1, index2].active(true);
                        }
                      }
                    }
                  }
                }
              }
              if (num11 < num4 * 1.3 + 1.0 && y1 > j - 10)
                Main.tile[x1, y1].liquid = byte.MaxValue;
              if (flag3 && x1 == (int) vector2D1.X && (double) y1 > vector2D1.Y)
              {
                flag3 = false;
                int num19 = 100;
                int num20 = 2;
                for (int x2 = x1 - num20; x2 <= x1 + num20; ++x2)
                {
                  for (int y2 = y1; y2 < y1 + num19; ++y2)
                  {
                    if (!WorldGen.badOceanCaveTiles(x2, y2))
                      Main.tile[x2, y2].liquid = byte.MaxValue;
                  }
                }
              }
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += WorldGen.genRand.NextDouble() * 0.1 - 0.05;
        vector2D2.Y += WorldGen.genRand.NextDouble() * 0.1 - 0.05;
        if (flag1)
        {
          if (vector2D1.Y > (Main.worldSurface * 2.0 + Main.rockLayer) / 3.0 && vector2D1.Y > (double) (j + 30))
            flag1 = false;
          vector2D2.Y = Utils.Clamp<double>(vector2D2.Y, 0.35, 1.0);
        }
        else
        {
          if (vector2D1.X < (double) (Main.maxTilesX / 2))
          {
            if (vector2D2.X < 0.5)
              vector2D2.X += 0.02;
          }
          else if (vector2D2.X > -0.5)
            vector2D2.X -= 0.02;
          if (!flag4)
          {
            if (vector2D2.Y < 0.0)
              vector2D2.Y *= 0.95;
            vector2D2.Y += 0.04;
          }
          else if (vector2D1.Y < (Main.worldSurface * 4.0 + Main.rockLayer) / 5.0)
          {
            if (vector2D2.Y < 0.0)
              vector2D2.Y *= 0.97;
            vector2D2.Y += 0.02;
          }
          else if (vector2D2.Y > -0.1)
          {
            vector2D2.Y *= 0.99;
            vector2D2.Y -= 0.01;
          }
          vector2D2.Y = Utils.Clamp<double>(vector2D2.Y, -1.0, 1.0);
        }
        vector2D2.X = vector2D1.X >= (double) (Main.maxTilesX / 2) ? Utils.Clamp<double>(vector2D2.X, -1.0, -0.1) : Utils.Clamp<double>(vector2D2.X, 0.1, 1.0);
      }
      ++GenVars.numOceanCaveTreasure;
    }

    public static void WavyCaverer(
      int startX,
      int startY,
      double waveStrengthScalar,
      double wavePercentScalar,
      int steps,
      int type)
    {
      Vector2D vector2D;
      // ISSUE: explicit constructor call
      ((Vector2D) ref vector2D).\u002Ector((double) startX, (double) startY);
      bool flag1 = startX > Main.maxTilesX / 2;
      int val1_1 = 2 + WorldGen.genRand.Next(2);
      int val1_2 = 15 + WorldGen.genRand.Next(11);
      int num1 = 1 + WorldGen.genRand.Next(2);
      int num2 = (int) Math.Ceiling((double) val1_2 / (double) num1);
      double num3 = 1.0;
      double num4 = 1.0;
      int num5 = (int) (WorldGen.genRand.NextDouble() * 3.0 - 1.0);
      int num6 = val1_1;
      int num7 = 0;
      for (int index1 = 0; index1 < steps; ++index1)
      {
        bool flag2 = index1 < num2;
        bool flag3 = index1 >= steps - num2;
        vector2D.X += flag1 ? -1.0 : 1.0;
        if (!flag2 && !flag3)
        {
          ++num7;
          num3 = Math.Min(2.0, Math.Max(0.5, num3 + (WorldGen.genRand.NextDouble() - 0.5) * 0.25));
          num4 = Math.Min(1.1, Math.Max(0.9, num4 + (WorldGen.genRand.NextDouble() - 0.5) * 0.02));
        }
        double num8 = Math.Sin((double) num7 * 0.1 * num4 * wavePercentScalar) * num3 * waveStrengthScalar;
        vector2D.Y = (double) startY + num8 + (double) (num7 * num5);
        int num9 = num6;
        if (flag2)
          num6 = Math.Min(val1_2, num6 + num1);
        else if (flag3)
          num6 = Math.Max(val1_1, num6 - num1);
        vector2D.Y -= (double) ((num9 + num6) / 4);
        for (int index2 = 0; index2 < num6; ++index2)
        {
          int x = (int) vector2D.X;
          int num10 = (int) vector2D.Y + index2;
          if (WorldGen.InWorld(x, num10, 20))
          {
            if (type >= 0)
              WorldGen.PlaceTile(x, num10, type, true, true);
            else
              WorldGen.KillTile(x, num10);
          }
        }
      }
    }

    public static void TileRunner(
      int i,
      int j,
      double strength,
      int steps,
      int type,
      bool addTile = false,
      double speedX = 0.0,
      double speedY = 0.0,
      bool noYChange = false,
      bool overRide = true,
      int ignoreTileType = -1)
    {
      if (!GenVars.mudWall)
      {
        if (WorldGen.drunkWorldGen)
        {
          strength *= 1.0 + (double) WorldGen.genRand.Next(-80, 81) * 0.01;
          steps = (int) ((double) steps * (1.0 + (double) WorldGen.genRand.Next(-80, 81) * 0.01));
        }
        else if (WorldGen.remixWorldGen)
          strength *= 1.0 + (double) WorldGen.genRand.Next(-50, 51) * 0.01;
        else if (WorldGen.getGoodWorldGen && type != 57)
        {
          strength *= 1.0 + (double) WorldGen.genRand.Next(-80, 81) * 0.015;
          steps += WorldGen.genRand.Next(3);
        }
      }
      double num1 = strength;
      double num2 = (double) steps;
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      Vector2D vector2D2;
      vector2D2.X = (double) WorldGen.genRand.Next(-10, 11) * 0.1;
      vector2D2.Y = (double) WorldGen.genRand.Next(-10, 11) * 0.1;
      if (speedX != 0.0 || speedY != 0.0)
      {
        vector2D2.X = speedX;
        vector2D2.Y = speedY;
      }
      bool flag1 = type == 368;
      bool flag2 = type == 367;
      bool lava = false;
      if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(4) == 0)
        lava = true;
      while (num1 > 0.0 && num2 > 0.0)
      {
        if (WorldGen.drunkWorldGen && WorldGen.genRand.Next(30) == 0)
        {
          vector2D1.X += (double) WorldGen.genRand.Next(-100, 101) * 0.05;
          vector2D1.Y += (double) WorldGen.genRand.Next(-100, 101) * 0.05;
        }
        if (vector2D1.Y < 0.0 && num2 > 0.0 && type == 59)
          num2 = 0.0;
        num1 = strength * (num2 / (double) steps);
        --num2;
        int num3 = (int) (vector2D1.X - num1 * 0.5);
        int num4 = (int) (vector2D1.X + num1 * 0.5);
        int num5 = (int) (vector2D1.Y - num1 * 0.5);
        int num6 = (int) (vector2D1.Y + num1 * 0.5);
        if (num3 < 1)
          num3 = 1;
        if (num4 > Main.maxTilesX - 1)
          num4 = Main.maxTilesX - 1;
        if (num5 < 1)
          num5 = 1;
        if (num6 > Main.maxTilesY - 1)
          num6 = Main.maxTilesY - 1;
        for (int index1 = num3; index1 < num4; ++index1)
        {
          if (index1 < WorldGen.beachDistance + 50 || index1 >= Main.maxTilesX - WorldGen.beachDistance - 50)
            lava = false;
          for (int index2 = num5; index2 < num6; ++index2)
          {
            if ((!WorldGen.drunkWorldGen || index2 >= Main.maxTilesY - 300 || type != 57) && (ignoreTileType < 0 || !Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != ignoreTileType) && Math.Abs((double) index1 - vector2D1.X) + Math.Abs((double) index2 - vector2D1.Y) < strength * 0.5 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015))
            {
              if (GenVars.mudWall && (double) index2 > Main.worldSurface && Main.tile[index1, index2 - 1].wall != (ushort) 2 && index2 < Main.maxTilesY - 210 - WorldGen.genRand.Next(3) && Math.Abs((double) index1 - vector2D1.X) + Math.Abs((double) index2 - vector2D1.Y) < strength * 0.45 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.01))
              {
                if (index2 > GenVars.lavaLine - WorldGen.genRand.Next(0, 4) - 50)
                {
                  if (Main.tile[index1, index2 - 1].wall != (ushort) 64 && Main.tile[index1, index2 + 1].wall != (ushort) 64 && Main.tile[index1 - 1, index2].wall != (ushort) 64 && Main.tile[index1 + 1, index2].wall != (ushort) 64)
                    WorldGen.PlaceWall(index1, index2, 15, true);
                }
                else if (Main.tile[index1, index2 - 1].wall != (ushort) 15 && Main.tile[index1, index2 + 1].wall != (ushort) 15 && Main.tile[index1 - 1, index2].wall != (ushort) 15 && Main.tile[index1 + 1, index2].wall != (ushort) 15)
                  WorldGen.PlaceWall(index1, index2, 64, true);
              }
              if (type < 0)
              {
                if (Main.tile[index1, index2].type != (ushort) 53)
                {
                  if (type == -2 && Main.tile[index1, index2].active() && (index2 < GenVars.waterLine || index2 > GenVars.lavaLine))
                  {
                    Main.tile[index1, index2].liquid = byte.MaxValue;
                    Main.tile[index1, index2].lava(lava);
                    if (WorldGen.remixWorldGen)
                    {
                      if (index2 > GenVars.lavaLine && ((double) index2 < Main.rockLayer - 80.0 || index2 > Main.maxTilesY - 350) && !WorldGen.oceanDepths(index1, index2))
                        Main.tile[index1, index2].lava(true);
                    }
                    else if (index2 > GenVars.lavaLine)
                      Main.tile[index1, index2].lava(true);
                  }
                  Main.tile[index1, index2].active(false);
                }
              }
              else
              {
                if (flag1 && Math.Abs((double) index1 - vector2D1.X) + Math.Abs((double) index2 - vector2D1.Y) < strength * 0.3 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.01))
                  WorldGen.PlaceWall(index1, index2, 180, true);
                if (flag2 && Math.Abs((double) index1 - vector2D1.X) + Math.Abs((double) index2 - vector2D1.Y) < strength * 0.3 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.01))
                  WorldGen.PlaceWall(index1, index2, 178, true);
                if (overRide || !Main.tile[index1, index2].active())
                {
                  Tile tile = Main.tile[index1, index2];
                  bool flag3 = Main.tileStone[type] && tile.type != (ushort) 1;
                  if (!TileID.Sets.CanBeClearedDuringGeneration[(int) tile.type])
                    flag3 = true;
                  switch (tile.type)
                  {
                    case 1:
                      if (type == 59 && (double) index2 < Main.worldSurface + (double) WorldGen.genRand.Next(-50, 50))
                      {
                        flag3 = true;
                        break;
                      }
                      break;
                    case 45:
                    case 147:
                    case 189:
                    case 190:
                    case 196:
                    case 460:
                      flag3 = true;
                      break;
                    case 53:
                      if (type == 59 && GenVars.UndergroundDesertLocation.Contains(index1, index2))
                        flag3 = true;
                      if (type == 40)
                        flag3 = true;
                      if ((double) index2 < Main.worldSurface && type != 59)
                      {
                        flag3 = true;
                        break;
                      }
                      break;
                    case 367:
                    case 368:
                      if (type == 59)
                      {
                        flag3 = true;
                        break;
                      }
                      break;
                    case 396:
                    case 397:
                      flag3 = !TileID.Sets.Ore[type];
                      break;
                  }
                  if (!flag3)
                    tile.type = (ushort) type;
                }
                if (addTile)
                {
                  Main.tile[index1, index2].active(true);
                  Main.tile[index1, index2].liquid = (byte) 0;
                  Main.tile[index1, index2].lava(false);
                }
                if (noYChange && (double) index2 < Main.worldSurface && type != 59)
                  Main.tile[index1, index2].wall = (ushort) 2;
                if (type == 59 && index2 > GenVars.waterLine && Main.tile[index1, index2].liquid > (byte) 0)
                {
                  Main.tile[index1, index2].lava(false);
                  Main.tile[index1, index2].liquid = (byte) 0;
                }
              }
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        if ((!WorldGen.drunkWorldGen || WorldGen.genRand.Next(3) != 0) && num1 > 50.0)
        {
          vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
          --num2;
          vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
          vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
          if (num1 > 100.0)
          {
            vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
            --num2;
            vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
            vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
            if (num1 > 150.0)
            {
              vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
              --num2;
              vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
              vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
              if (num1 > 200.0)
              {
                vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
                --num2;
                vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                if (num1 > 250.0)
                {
                  vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
                  --num2;
                  vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                  vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                  if (num1 > 300.0)
                  {
                    vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
                    --num2;
                    vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                    vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                    if (num1 > 400.0)
                    {
                      vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
                      --num2;
                      vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                      vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                      if (num1 > 500.0)
                      {
                        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
                        --num2;
                        vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                        vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                        if (num1 > 600.0)
                        {
                          vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
                          --num2;
                          vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                          vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                          if (num1 > 700.0)
                          {
                            vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
                            --num2;
                            vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                            vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                            if (num1 > 800.0)
                            {
                              vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
                              --num2;
                              vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                              vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                              if (num1 > 900.0)
                              {
                                vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
                                --num2;
                                vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                                vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        if (WorldGen.drunkWorldGen)
          vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.25;
        if (vector2D2.X > 1.0)
          vector2D2.X = 1.0;
        if (vector2D2.X < -1.0)
          vector2D2.X = -1.0;
        if (!noYChange)
        {
          vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
          if (vector2D2.Y > 1.0)
            vector2D2.Y = 1.0;
          if (vector2D2.Y < -1.0)
            vector2D2.Y = -1.0;
        }
        else if (type != 59 && num1 < 3.0)
        {
          if (vector2D2.Y > 1.0)
            vector2D2.Y = 1.0;
          if (vector2D2.Y < -1.0)
            vector2D2.Y = -1.0;
        }
        if (type == 59 && !noYChange)
        {
          if (vector2D2.Y > 0.5)
            vector2D2.Y = 0.5;
          if (vector2D2.Y < -0.5)
            vector2D2.Y = -0.5;
          if (vector2D1.Y < Main.rockLayer + 100.0)
            vector2D2.Y = 1.0;
          if (vector2D1.Y > (double) (Main.maxTilesY - 300))
            vector2D2.Y = -1.0;
        }
      }
    }

    public static void DirtyRockRunner(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(2, 6);
      double num2 = (double) WorldGen.genRand.Next(5, 50);
      double num3 = num2;
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      Vector2D vector2D2;
      vector2D2.X = (double) WorldGen.genRand.Next(-10, 11) * 0.1;
      vector2D2.Y = (double) WorldGen.genRand.Next(-10, 11) * 0.1;
      while (num1 > 0.0 && num3 > 0.0)
      {
        double num4 = num1 * (num3 / num2);
        --num3;
        int num5 = (int) (vector2D1.X - num4 * 0.5);
        int num6 = (int) (vector2D1.X + num4 * 0.5);
        int num7 = (int) (vector2D1.Y - num4 * 0.5);
        int num8 = (int) (vector2D1.Y + num4 * 0.5);
        if (num5 < 0)
          num5 = 0;
        if (num6 > Main.maxTilesX)
          num6 = Main.maxTilesX;
        if (num7 < 0)
          num7 = 0;
        if (num8 > Main.maxTilesY)
          num8 = Main.maxTilesY;
        for (int index1 = num5; index1 < num6; ++index1)
        {
          for (int index2 = num7; index2 < num8; ++index2)
          {
            if (Math.Abs((double) index1 - vector2D1.X) + Math.Abs((double) index2 - vector2D1.Y) < num1 * 0.5 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015) && Main.tile[index1, index2].wall == (ushort) 2)
              Main.tile[index1, index2].wall = (ushort) 59;
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        if (vector2D2.X > 1.0)
          vector2D2.X = 1.0;
        if (vector2D2.X < -1.0)
          vector2D2.X = -1.0;
        vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        if (vector2D2.Y > 1.0)
          vector2D2.Y = 1.0;
        if (vector2D2.Y < -1.0)
          vector2D2.Y = -1.0;
      }
    }

    public static void MudWallRunner(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(8, 21);
      double num2 = (double) WorldGen.genRand.Next(8, 33);
      double num3 = num2;
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      Vector2D vector2D2;
      vector2D2.X = (double) WorldGen.genRand.Next(-10, 11) * 0.1;
      vector2D2.Y = (double) WorldGen.genRand.Next(-10, 11) * 0.1;
      while (num1 > 0.0 && num3 > 0.0)
      {
        double num4 = num1 * (num3 / num2);
        --num3;
        int num5 = (int) (vector2D1.X - num4 * 0.5);
        int num6 = (int) (vector2D1.X + num4 * 0.5);
        int num7 = (int) (vector2D1.Y - num4 * 0.5);
        int num8 = (int) (vector2D1.Y + num4 * 0.5);
        if (num5 < 0)
          num5 = 0;
        if (num6 > Main.maxTilesX)
          num6 = Main.maxTilesX;
        if (num7 < 0)
          num7 = 0;
        if (num8 > Main.maxTilesY)
          num8 = Main.maxTilesY;
        for (int index1 = num5; index1 < num6; ++index1)
        {
          for (int index2 = num7; index2 < num8; ++index2)
          {
            if (Math.Abs((double) index1 - vector2D1.X) + Math.Abs((double) index2 - vector2D1.Y) < num1 * 0.5 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015) && (double) index2 > Main.worldSurface)
              Main.tile[index1, index2].wall = (ushort) 0;
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        if (vector2D2.X > 1.0)
          vector2D2.X = 1.0;
        if (vector2D2.X < -1.0)
          vector2D2.X = -1.0;
        vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        if (vector2D2.Y > 1.0)
          vector2D2.Y = 1.0;
        if (vector2D2.Y < -1.0)
          vector2D2.Y = -1.0;
      }
    }

    public static void SnowCloudIsland(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(100, 150);
      double num2 = num1;
      double num3 = (double) WorldGen.genRand.Next(20, 30);
      int num4 = i;
      int num5 = i;
      int num6 = i;
      int num7 = j;
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      Vector2D vector2D2;
      vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
        vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      vector2D2.Y = (double) WorldGen.genRand.Next(-20, -10) * 0.02;
      while (num1 > 0.0 && num3 > 0.0)
      {
        num1 -= (double) WorldGen.genRand.Next(4);
        --num3;
        int num8 = (int) (vector2D1.X - num1 * 0.5);
        int num9 = (int) (vector2D1.X + num1 * 0.5);
        int num10 = (int) (vector2D1.Y - num1 * 0.5);
        int num11 = (int) (vector2D1.Y + num1 * 0.5);
        if (num8 < 0)
          num8 = 0;
        if (num9 > Main.maxTilesX)
          num9 = Main.maxTilesX;
        if (num10 < 0)
          num10 = 0;
        if (num11 > Main.maxTilesY)
          num11 = Main.maxTilesY;
        double num12 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        double num13 = vector2D1.Y + 1.0;
        for (int i1 = num8; i1 < num9; ++i1)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num13 += (double) WorldGen.genRand.Next(-1, 2);
          if (num13 < vector2D1.Y)
            num13 = vector2D1.Y;
          if (num13 > vector2D1.Y + 2.0)
            num13 = vector2D1.Y + 2.0;
          for (int j1 = num10; j1 < num11; ++j1)
          {
            if ((double) j1 > num13)
            {
              double num14 = Math.Abs((double) i1 - vector2D1.X);
              double num15 = Math.Abs((double) j1 - vector2D1.Y) * 3.0;
              if (Math.Sqrt(num14 * num14 + num15 * num15) < num12 * 0.4)
              {
                if (i1 < num4)
                  num4 = i1;
                if (i1 > num5)
                  num5 = i1;
                if (j1 < num6)
                  num6 = j1;
                if (j1 > num7)
                  num7 = j1;
                Main.tile[i1, j1].active(true);
                Main.tile[i1, j1].type = (ushort) 189;
                WorldGen.SquareTileFrame(i1, j1);
              }
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-20, 21) * 0.05;
        if (vector2D2.X > 1.0)
          vector2D2.X = 1.0;
        if (vector2D2.X < -1.0)
          vector2D2.X = -1.0;
        if (vector2D2.Y > 0.2)
          vector2D2.Y = -0.2;
        if (vector2D2.Y < -0.2)
          vector2D2.Y = -0.2;
      }
      int minValue1;
      for (int index1 = num4 + WorldGen.genRand.Next(5); index1 < num5; index1 += WorldGen.genRand.Next(minValue1, (int) ((double) minValue1 * 1.5)))
      {
        int index2 = num7;
        while (!Main.tile[index1, index2].active())
          --index2;
        int num16 = index2 + WorldGen.genRand.Next(-3, 4);
        minValue1 = WorldGen.genRand.Next(4, 8);
        int num17 = 189;
        if (WorldGen.genRand.Next(4) == 0)
          num17 = 460;
        for (int i2 = index1 - minValue1; i2 <= index1 + minValue1; ++i2)
        {
          for (int j2 = num16 - minValue1; j2 <= num16 + minValue1; ++j2)
          {
            if (j2 > num6)
            {
              double num18 = (double) Math.Abs(i2 - index1);
              double num19 = (double) (Math.Abs(j2 - num16) * 2);
              if (Math.Sqrt(num18 * num18 + num19 * num19) < (double) (minValue1 + WorldGen.genRand.Next(2)))
              {
                Main.tile[i2, j2].active(true);
                Main.tile[i2, j2].type = (ushort) num17;
                WorldGen.SquareTileFrame(i2, j2);
              }
            }
          }
        }
      }
      double num20 = (double) WorldGen.genRand.Next(80, 95);
      num2 = num20;
      double num21 = (double) WorldGen.genRand.Next(10, 15);
      vector2D1.X = (double) i;
      vector2D1.Y = (double) num6;
      vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
        vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      vector2D2.Y = (double) WorldGen.genRand.Next(-20, -10) * 0.02;
      while (num20 > 0.0 && num21 > 0.0)
      {
        num20 -= (double) WorldGen.genRand.Next(4);
        --num21;
        int num22 = (int) (vector2D1.X - num20 * 0.5);
        int num23 = (int) (vector2D1.X + num20 * 0.5);
        int num24 = num6 - 1;
        int num25 = (int) (vector2D1.Y + num20 * 0.5);
        if (num22 < 0)
          num22 = 0;
        if (num23 > Main.maxTilesX)
          num23 = Main.maxTilesX;
        if (num24 < 0)
          num24 = 0;
        if (num25 > Main.maxTilesY)
          num25 = Main.maxTilesY;
        double num26 = num20 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        double num27 = vector2D1.Y + 1.0;
        for (int i3 = num22; i3 < num23; ++i3)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num27 += (double) WorldGen.genRand.Next(-1, 2);
          if (num27 < vector2D1.Y)
            num27 = vector2D1.Y;
          if (num27 > vector2D1.Y + 2.0)
            num27 = vector2D1.Y + 2.0;
          for (int j3 = num24; j3 < num25; ++j3)
          {
            if ((double) j3 > num27)
            {
              double num28 = Math.Abs((double) i3 - vector2D1.X);
              double num29 = Math.Abs((double) j3 - vector2D1.Y) * 3.0;
              if (Math.Sqrt(num28 * num28 + num29 * num29) < num26 * 0.4 && Main.tile[i3, j3].type == (ushort) 189)
              {
                Main.tile[i3, j3].type = (ushort) 147;
                WorldGen.SquareTileFrame(i3, j3);
              }
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-20, 21) * 0.05;
        if (vector2D2.X > 1.0)
          vector2D2.X = 1.0;
        if (vector2D2.X < -1.0)
          vector2D2.X = -1.0;
        if (vector2D2.Y > 0.2)
          vector2D2.Y = -0.2;
        if (vector2D2.Y < -0.2)
          vector2D2.Y = -0.2;
      }
      int index3 = num4 + WorldGen.genRand.Next(5);
      while (index3 < num5)
      {
        int index4 = num7;
        while ((!Main.tile[index3, index4].active() || Main.tile[index3, index4].type != (ushort) 0) && index3 < num5)
        {
          --index4;
          if (index4 < num6)
          {
            index4 = num7;
            index3 += WorldGen.genRand.Next(1, 4);
          }
        }
        if (index3 < num5)
        {
          int num30 = index4 + WorldGen.genRand.Next(0, 4);
          int minValue2 = WorldGen.genRand.Next(2, 5);
          int num31 = 189;
          for (int i4 = index3 - minValue2; i4 <= index3 + minValue2; ++i4)
          {
            for (int j4 = num30 - minValue2; j4 <= num30 + minValue2; ++j4)
            {
              if (j4 > num6)
              {
                double num32 = (double) Math.Abs(i4 - index3);
                double num33 = (double) (Math.Abs(j4 - num30) * 2);
                if (Math.Sqrt(num32 * num32 + num33 * num33) < (double) minValue2)
                {
                  Main.tile[i4, j4].type = (ushort) num31;
                  WorldGen.SquareTileFrame(i4, j4);
                }
              }
            }
          }
          index3 += WorldGen.genRand.Next(minValue2, (int) ((double) minValue2 * 1.5));
        }
      }
      for (int i5 = num4 - 20; i5 <= num5 + 20; ++i5)
      {
        for (int j5 = num6 - 20; j5 <= num7 + 20; ++j5)
        {
          bool flag = true;
          for (int index5 = i5 - 1; index5 <= i5 + 1; ++index5)
          {
            for (int index6 = j5 - 1; index6 <= j5 + 1; ++index6)
            {
              if (!Main.tile[index5, index6].active())
                flag = false;
            }
          }
          if (flag)
          {
            Main.tile[i5, j5].wall = (ushort) 73;
            WorldGen.SquareWallFrame(i5, j5);
          }
        }
      }
      for (int index7 = num4; index7 <= num5; ++index7)
      {
        int index8 = num6 - 10;
        while (!Main.tile[index7, index8 + 1].active())
          ++index8;
        if (index8 < num7 && Main.tile[index7, index8 + 1].type == (ushort) 189)
        {
          if (WorldGen.genRand.Next(10) == 0)
          {
            int num34 = WorldGen.genRand.Next(1, 3);
            for (int x = index7 - num34; x <= index7 + num34; ++x)
            {
              if (Main.tile[x, index8].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index8))
              {
                Main.tile[x, index8].active(false);
                Main.tile[x, index8].liquid = byte.MaxValue;
                Main.tile[x, index8].lava(false);
                WorldGen.SquareTileFrame(index7, index8);
              }
              if (Main.tile[x, index8 + 1].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index8 + 1))
              {
                Main.tile[x, index8 + 1].active(false);
                Main.tile[x, index8 + 1].liquid = byte.MaxValue;
                Main.tile[x, index8 + 1].lava(false);
                WorldGen.SquareTileFrame(index7, index8 + 1);
              }
              if (x > index7 - num34 && x < index7 + 2 && Main.tile[x, index8 + 2].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index8 + 2))
              {
                Main.tile[x, index8 + 2].active(false);
                Main.tile[x, index8 + 2].liquid = byte.MaxValue;
                Main.tile[x, index8 + 2].lava(false);
                WorldGen.SquareTileFrame(index7, index8 + 2);
              }
            }
          }
          if (WorldGen.genRand.Next(5) == 0 && WorldGen.WillWaterPlacedHereStayPut(index7, index8))
            Main.tile[index7, index8].liquid = byte.MaxValue;
          Main.tile[index7, index8].lava(false);
          WorldGen.SquareTileFrame(index7, index8);
        }
      }
      int num35 = WorldGen.genRand.Next(4);
      for (int index9 = 0; index9 <= num35; ++index9)
      {
        int num36 = WorldGen.genRand.Next(num4 - 5, num5 + 5);
        int num37 = num6 - WorldGen.genRand.Next(20, 40);
        int num38 = WorldGen.genRand.Next(4, 8);
        int num39 = 189;
        if (WorldGen.genRand.Next(2) == 0)
          num39 = 460;
        for (int i6 = num36 - num38; i6 <= num36 + num38; ++i6)
        {
          for (int j6 = num37 - num38; j6 <= num37 + num38; ++j6)
          {
            double num40 = (double) Math.Abs(i6 - num36);
            double num41 = (double) (Math.Abs(j6 - num37) * 2);
            if (Math.Sqrt(num40 * num40 + num41 * num41) < (double) (num38 + WorldGen.genRand.Next(-1, 2)))
            {
              Main.tile[i6, j6].active(true);
              Main.tile[i6, j6].type = (ushort) num39;
              WorldGen.SquareTileFrame(i6, j6);
            }
          }
        }
        for (int index10 = num36 - num38 + 2; index10 <= num36 + num38 - 2; ++index10)
        {
          int index11 = num37 - num38;
          while (!Main.tile[index10, index11].active())
            ++index11;
          if (WorldGen.WillWaterPlacedHereStayPut(index10, index11))
          {
            Main.tile[index10, index11].active(false);
            Main.tile[index10, index11].liquid = byte.MaxValue;
            WorldGen.SquareTileFrame(index10, index11);
          }
        }
      }
    }

    public static void DesertCloudIsland(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(100, 150);
      double num2 = num1;
      double num3 = (double) WorldGen.genRand.Next(20, 30);
      int num4 = i;
      int num5 = i;
      int num6 = i;
      int num7 = j;
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      Vector2D vector2D2;
      vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
        vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      vector2D2.Y = (double) WorldGen.genRand.Next(-20, -10) * 0.02;
      while (num1 > 0.0 && num3 > 0.0)
      {
        num1 -= (double) WorldGen.genRand.Next(4);
        --num3;
        int num8 = (int) (vector2D1.X - num1 * 0.5);
        int num9 = (int) (vector2D1.X + num1 * 0.5);
        int num10 = (int) (vector2D1.Y - num1 * 0.5);
        int num11 = (int) (vector2D1.Y + num1 * 0.5);
        if (num8 < 0)
          num8 = 0;
        if (num9 > Main.maxTilesX)
          num9 = Main.maxTilesX;
        if (num10 < 0)
          num10 = 0;
        if (num11 > Main.maxTilesY)
          num11 = Main.maxTilesY;
        double num12 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        double num13 = vector2D1.Y + 1.0;
        for (int i1 = num8; i1 < num9; ++i1)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num13 += (double) WorldGen.genRand.Next(-1, 2);
          if (num13 < vector2D1.Y)
            num13 = vector2D1.Y;
          if (num13 > vector2D1.Y + 2.0)
            num13 = vector2D1.Y + 2.0;
          for (int j1 = num10; j1 < num11; ++j1)
          {
            if ((double) j1 > num13)
            {
              double num14 = Math.Abs((double) i1 - vector2D1.X);
              double num15 = Math.Abs((double) j1 - vector2D1.Y) * 3.0;
              if (Math.Sqrt(num14 * num14 + num15 * num15) < num12 * 0.4)
              {
                if (i1 < num4)
                  num4 = i1;
                if (i1 > num5)
                  num5 = i1;
                if (j1 < num6)
                  num6 = j1;
                if (j1 > num7)
                  num7 = j1;
                Main.tile[i1, j1].active(true);
                Main.tile[i1, j1].type = (ushort) 189;
                WorldGen.SquareTileFrame(i1, j1);
              }
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-20, 21) * 0.05;
        if (vector2D2.X > 1.0)
          vector2D2.X = 1.0;
        if (vector2D2.X < -1.0)
          vector2D2.X = -1.0;
        if (vector2D2.Y > 0.2)
          vector2D2.Y = -0.2;
        if (vector2D2.Y < -0.2)
          vector2D2.Y = -0.2;
      }
      int minValue1;
      for (int index1 = num4 + WorldGen.genRand.Next(5); index1 < num5; index1 += WorldGen.genRand.Next(minValue1, (int) ((double) minValue1 * 1.5)))
      {
        int index2 = num7;
        while (!Main.tile[index1, index2].active())
          --index2;
        int num16 = index2 + WorldGen.genRand.Next(-3, 4);
        minValue1 = WorldGen.genRand.Next(4, 8);
        int num17 = 189;
        if (WorldGen.genRand.Next(4) == 0)
          num17 = 196;
        for (int i2 = index1 - minValue1; i2 <= index1 + minValue1; ++i2)
        {
          for (int j2 = num16 - minValue1; j2 <= num16 + minValue1; ++j2)
          {
            if (j2 > num6)
            {
              double num18 = (double) Math.Abs(i2 - index1);
              double num19 = (double) (Math.Abs(j2 - num16) * 2);
              if (Math.Sqrt(num18 * num18 + num19 * num19) < (double) (minValue1 + WorldGen.genRand.Next(2)))
              {
                Main.tile[i2, j2].active(true);
                Main.tile[i2, j2].type = (ushort) num17;
                WorldGen.SquareTileFrame(i2, j2);
              }
            }
          }
        }
      }
      double num20 = (double) WorldGen.genRand.Next(80, 95);
      num2 = num20;
      double num21 = (double) WorldGen.genRand.Next(10, 15);
      vector2D1.X = (double) i;
      vector2D1.Y = (double) num6;
      vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
        vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      vector2D2.Y = (double) WorldGen.genRand.Next(-20, -10) * 0.02;
      while (num20 > 0.0 && num21 > 0.0)
      {
        num20 -= (double) WorldGen.genRand.Next(4);
        --num21;
        int num22 = (int) (vector2D1.X - num20 * 0.5);
        int num23 = (int) (vector2D1.X + num20 * 0.5);
        int num24 = num6 - 1;
        int num25 = (int) (vector2D1.Y + num20 * 0.5);
        if (num22 < 0)
          num22 = 0;
        if (num23 > Main.maxTilesX)
          num23 = Main.maxTilesX;
        if (num24 < 0)
          num24 = 0;
        if (num25 > Main.maxTilesY)
          num25 = Main.maxTilesY;
        double num26 = num20 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        double num27 = vector2D1.Y + 1.0;
        for (int i3 = num22; i3 < num23; ++i3)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num27 += (double) WorldGen.genRand.Next(-1, 2);
          if (num27 < vector2D1.Y)
            num27 = vector2D1.Y;
          if (num27 > vector2D1.Y + 2.0)
            num27 = vector2D1.Y + 2.0;
          for (int j3 = num24; j3 < num25; ++j3)
          {
            if ((double) j3 > num27)
            {
              double num28 = Math.Abs((double) i3 - vector2D1.X);
              double num29 = Math.Abs((double) j3 - vector2D1.Y) * 3.0;
              if (Math.Sqrt(num28 * num28 + num29 * num29) < num26 * 0.4 && Main.tile[i3, j3].type == (ushort) 189)
              {
                Main.tile[i3, j3].type = (ushort) 53;
                WorldGen.SquareTileFrame(i3, j3);
              }
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-20, 21) * 0.05;
        if (vector2D2.X > 1.0)
          vector2D2.X = 1.0;
        if (vector2D2.X < -1.0)
          vector2D2.X = -1.0;
        if (vector2D2.Y > 0.2)
          vector2D2.Y = -0.2;
        if (vector2D2.Y < -0.2)
          vector2D2.Y = -0.2;
      }
      int index3 = num4 + WorldGen.genRand.Next(5);
      while (index3 < num5)
      {
        int index4 = num7;
        while ((!Main.tile[index3, index4].active() || Main.tile[index3, index4].type != (ushort) 0) && index3 < num5)
        {
          --index4;
          if (index4 < num6)
          {
            index4 = num7;
            index3 += WorldGen.genRand.Next(1, 4);
          }
        }
        if (index3 < num5)
        {
          int num30 = index4 + WorldGen.genRand.Next(0, 4);
          int minValue2 = WorldGen.genRand.Next(2, 5);
          int num31 = 189;
          for (int i4 = index3 - minValue2; i4 <= index3 + minValue2; ++i4)
          {
            for (int j4 = num30 - minValue2; j4 <= num30 + minValue2; ++j4)
            {
              if (j4 > num6)
              {
                double num32 = (double) Math.Abs(i4 - index3);
                double num33 = (double) (Math.Abs(j4 - num30) * 2);
                if (Math.Sqrt(num32 * num32 + num33 * num33) < (double) minValue2)
                {
                  Main.tile[i4, j4].type = (ushort) num31;
                  WorldGen.SquareTileFrame(i4, j4);
                }
              }
            }
          }
          index3 += WorldGen.genRand.Next(minValue2, (int) ((double) minValue2 * 1.5));
        }
      }
      for (int i5 = num4 - 20; i5 <= num5 + 20; ++i5)
      {
        for (int j5 = num6 - 20; j5 <= num7 + 20; ++j5)
        {
          bool flag = true;
          for (int index5 = i5 - 1; index5 <= i5 + 1; ++index5)
          {
            for (int index6 = j5 - 1; index6 <= j5 + 1; ++index6)
            {
              if (!Main.tile[index5, index6].active())
                flag = false;
            }
          }
          if (flag)
          {
            Main.tile[i5, j5].wall = (ushort) 73;
            WorldGen.SquareWallFrame(i5, j5);
          }
        }
      }
      for (int index7 = num4; index7 <= num5; ++index7)
      {
        int index8 = num6 - 10;
        while (!Main.tile[index7, index8 + 1].active())
          ++index8;
        if (index8 < num7 && Main.tile[index7, index8 + 1].type == (ushort) 189)
        {
          if (WorldGen.genRand.Next(10) == 0)
          {
            int num34 = WorldGen.genRand.Next(1, 3);
            for (int x = index7 - num34; x <= index7 + num34; ++x)
            {
              if (Main.tile[x, index8].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index8))
              {
                Main.tile[x, index8].active(false);
                Main.tile[x, index8].liquid = byte.MaxValue;
                Main.tile[x, index8].lava(false);
                WorldGen.SquareTileFrame(index7, index8);
              }
              if (Main.tile[x, index8 + 1].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index8 + 1))
              {
                Main.tile[x, index8 + 1].active(false);
                Main.tile[x, index8 + 1].liquid = byte.MaxValue;
                Main.tile[x, index8 + 1].lava(false);
                WorldGen.SquareTileFrame(index7, index8 + 1);
              }
              if (x > index7 - num34 && x < index7 + 2 && Main.tile[x, index8 + 2].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index8 + 2))
              {
                Main.tile[x, index8 + 2].active(false);
                Main.tile[x, index8 + 2].liquid = byte.MaxValue;
                Main.tile[x, index8 + 2].lava(false);
                WorldGen.SquareTileFrame(index7, index8 + 2);
              }
            }
          }
          if (WorldGen.genRand.Next(5) == 0 && WorldGen.WillWaterPlacedHereStayPut(index7, index8))
            Main.tile[index7, index8].liquid = byte.MaxValue;
          Main.tile[index7, index8].lava(false);
          WorldGen.SquareTileFrame(index7, index8);
        }
      }
      int num35 = WorldGen.genRand.Next(4);
      for (int index9 = 0; index9 <= num35; ++index9)
      {
        int num36 = WorldGen.genRand.Next(num4 - 5, num5 + 5);
        int num37 = num6 - WorldGen.genRand.Next(20, 40);
        int num38 = WorldGen.genRand.Next(4, 8);
        int num39 = 189;
        if (WorldGen.genRand.Next(2) == 0)
          num39 = 196;
        for (int i6 = num36 - num38; i6 <= num36 + num38; ++i6)
        {
          for (int j6 = num37 - num38; j6 <= num37 + num38; ++j6)
          {
            double num40 = (double) Math.Abs(i6 - num36);
            double num41 = (double) (Math.Abs(j6 - num37) * 2);
            if (Math.Sqrt(num40 * num40 + num41 * num41) < (double) (num38 + WorldGen.genRand.Next(-1, 2)))
            {
              Main.tile[i6, j6].active(true);
              Main.tile[i6, j6].type = (ushort) num39;
              WorldGen.SquareTileFrame(i6, j6);
            }
          }
        }
        for (int index10 = num36 - num38 + 2; index10 <= num36 + num38 - 2; ++index10)
        {
          int index11 = num37 - num38;
          while (!Main.tile[index10, index11].active())
            ++index11;
          if (WorldGen.WillWaterPlacedHereStayPut(index10, index11))
          {
            Main.tile[index10, index11].active(false);
            Main.tile[index10, index11].liquid = byte.MaxValue;
            WorldGen.SquareTileFrame(index10, index11);
          }
        }
      }
    }

    public static void CloudIsland(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(100, 150);
      double num2 = num1;
      double num3 = (double) WorldGen.genRand.Next(20, 30);
      int num4 = i;
      int num5 = i;
      int num6 = i;
      int num7 = j;
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      Vector2D vector2D2;
      vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
        vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      vector2D2.Y = (double) WorldGen.genRand.Next(-20, -10) * 0.02;
      while (num1 > 0.0 && num3 > 0.0)
      {
        num1 -= (double) WorldGen.genRand.Next(4);
        --num3;
        int num8 = (int) (vector2D1.X - num1 * 0.5);
        int num9 = (int) (vector2D1.X + num1 * 0.5);
        int num10 = (int) (vector2D1.Y - num1 * 0.5);
        int num11 = (int) (vector2D1.Y + num1 * 0.5);
        if (num8 < 0)
          num8 = 0;
        if (num9 > Main.maxTilesX)
          num9 = Main.maxTilesX;
        if (num10 < 0)
          num10 = 0;
        if (num11 > Main.maxTilesY)
          num11 = Main.maxTilesY;
        double num12 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        double num13 = vector2D1.Y + 1.0;
        for (int i1 = num8; i1 < num9; ++i1)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num13 += (double) WorldGen.genRand.Next(-1, 2);
          if (num13 < vector2D1.Y)
            num13 = vector2D1.Y;
          if (num13 > vector2D1.Y + 2.0)
            num13 = vector2D1.Y + 2.0;
          for (int j1 = num10; j1 < num11; ++j1)
          {
            if ((double) j1 > num13)
            {
              double num14 = Math.Abs((double) i1 - vector2D1.X);
              double num15 = Math.Abs((double) j1 - vector2D1.Y) * 3.0;
              if (Math.Sqrt(num14 * num14 + num15 * num15) < num12 * 0.4)
              {
                if (i1 < num4)
                  num4 = i1;
                if (i1 > num5)
                  num5 = i1;
                if (j1 < num6)
                  num6 = j1;
                if (j1 > num7)
                  num7 = j1;
                Main.tile[i1, j1].active(true);
                Main.tile[i1, j1].type = (ushort) 189;
                WorldGen.SquareTileFrame(i1, j1);
              }
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-20, 21) * 0.05;
        if (vector2D2.X > 1.0)
          vector2D2.X = 1.0;
        if (vector2D2.X < -1.0)
          vector2D2.X = -1.0;
        if (vector2D2.Y > 0.2)
          vector2D2.Y = -0.2;
        if (vector2D2.Y < -0.2)
          vector2D2.Y = -0.2;
      }
      int minValue1;
      for (int index1 = num4 + WorldGen.genRand.Next(5); index1 < num5; index1 += WorldGen.genRand.Next(minValue1, (int) ((double) minValue1 * 1.5)))
      {
        int index2 = num7;
        while (!Main.tile[index1, index2].active())
          --index2;
        int num16 = index2 + WorldGen.genRand.Next(-3, 4);
        minValue1 = WorldGen.genRand.Next(4, 8);
        int num17 = 189;
        if (WorldGen.genRand.Next(4) == 0)
          num17 = 196;
        for (int i2 = index1 - minValue1; i2 <= index1 + minValue1; ++i2)
        {
          for (int j2 = num16 - minValue1; j2 <= num16 + minValue1; ++j2)
          {
            if (j2 > num6)
            {
              double num18 = (double) Math.Abs(i2 - index1);
              double num19 = (double) (Math.Abs(j2 - num16) * 2);
              if (Math.Sqrt(num18 * num18 + num19 * num19) < (double) (minValue1 + WorldGen.genRand.Next(2)))
              {
                Main.tile[i2, j2].active(true);
                Main.tile[i2, j2].type = (ushort) num17;
                WorldGen.SquareTileFrame(i2, j2);
              }
            }
          }
        }
      }
      double num20 = (double) WorldGen.genRand.Next(80, 95);
      num2 = num20;
      double num21 = (double) WorldGen.genRand.Next(10, 15);
      vector2D1.X = (double) i;
      vector2D1.Y = (double) num6;
      vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
        vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      vector2D2.Y = (double) WorldGen.genRand.Next(-20, -10) * 0.02;
      while (num20 > 0.0 && num21 > 0.0)
      {
        num20 -= (double) WorldGen.genRand.Next(4);
        --num21;
        int num22 = (int) (vector2D1.X - num20 * 0.5);
        int num23 = (int) (vector2D1.X + num20 * 0.5);
        int num24 = num6 - 1;
        int num25 = (int) (vector2D1.Y + num20 * 0.5);
        if (num22 < 0)
          num22 = 0;
        if (num23 > Main.maxTilesX)
          num23 = Main.maxTilesX;
        if (num24 < 0)
          num24 = 0;
        if (num25 > Main.maxTilesY)
          num25 = Main.maxTilesY;
        double num26 = num20 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        double num27 = vector2D1.Y + 1.0;
        for (int i3 = num22; i3 < num23; ++i3)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num27 += (double) WorldGen.genRand.Next(-1, 2);
          if (num27 < vector2D1.Y)
            num27 = vector2D1.Y;
          if (num27 > vector2D1.Y + 2.0)
            num27 = vector2D1.Y + 2.0;
          for (int j3 = num24; j3 < num25; ++j3)
          {
            if ((double) j3 > num27)
            {
              double num28 = Math.Abs((double) i3 - vector2D1.X);
              double num29 = Math.Abs((double) j3 - vector2D1.Y) * 3.0;
              if (Math.Sqrt(num28 * num28 + num29 * num29) < num26 * 0.4 && Main.tile[i3, j3].type == (ushort) 189)
              {
                Main.tile[i3, j3].type = (ushort) 0;
                WorldGen.SquareTileFrame(i3, j3);
              }
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-20, 21) * 0.05;
        if (vector2D2.X > 1.0)
          vector2D2.X = 1.0;
        if (vector2D2.X < -1.0)
          vector2D2.X = -1.0;
        if (vector2D2.Y > 0.2)
          vector2D2.Y = -0.2;
        if (vector2D2.Y < -0.2)
          vector2D2.Y = -0.2;
      }
      int index3 = num4 + WorldGen.genRand.Next(5);
      while (index3 < num5)
      {
        int index4 = num7;
        while ((!Main.tile[index3, index4].active() || Main.tile[index3, index4].type != (ushort) 0) && index3 < num5)
        {
          --index4;
          if (index4 < num6)
          {
            index4 = num7;
            index3 += WorldGen.genRand.Next(1, 4);
          }
        }
        if (index3 < num5)
        {
          int num30 = index4 + WorldGen.genRand.Next(0, 4);
          int minValue2 = WorldGen.genRand.Next(2, 5);
          int num31 = 189;
          for (int i4 = index3 - minValue2; i4 <= index3 + minValue2; ++i4)
          {
            for (int j4 = num30 - minValue2; j4 <= num30 + minValue2; ++j4)
            {
              if (j4 > num6)
              {
                double num32 = (double) Math.Abs(i4 - index3);
                double num33 = (double) (Math.Abs(j4 - num30) * 2);
                if (Math.Sqrt(num32 * num32 + num33 * num33) < (double) minValue2)
                {
                  Main.tile[i4, j4].type = (ushort) num31;
                  WorldGen.SquareTileFrame(i4, j4);
                }
              }
            }
          }
          index3 += WorldGen.genRand.Next(minValue2, (int) ((double) minValue2 * 1.5));
        }
      }
      for (int i5 = num4 - 20; i5 <= num5 + 20; ++i5)
      {
        for (int j5 = num6 - 20; j5 <= num7 + 20; ++j5)
        {
          bool flag = true;
          for (int index5 = i5 - 1; index5 <= i5 + 1; ++index5)
          {
            for (int index6 = j5 - 1; index6 <= j5 + 1; ++index6)
            {
              if (!Main.tile[index5, index6].active())
                flag = false;
            }
          }
          if (flag)
          {
            Main.tile[i5, j5].wall = (ushort) 73;
            WorldGen.SquareWallFrame(i5, j5);
          }
        }
      }
      for (int index7 = num4; index7 <= num5; ++index7)
      {
        int index8 = num6 - 10;
        while (!Main.tile[index7, index8 + 1].active())
          ++index8;
        if (index8 < num7 && Main.tile[index7, index8 + 1].type == (ushort) 189)
        {
          if (WorldGen.genRand.Next(10) == 0)
          {
            int num34 = WorldGen.genRand.Next(1, 3);
            for (int x = index7 - num34; x <= index7 + num34; ++x)
            {
              if (Main.tile[x, index8].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index8))
              {
                Main.tile[x, index8].active(false);
                Main.tile[x, index8].liquid = byte.MaxValue;
                Main.tile[x, index8].lava(false);
                WorldGen.SquareTileFrame(index7, index8);
              }
              if (Main.tile[x, index8 + 1].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index8 + 1))
              {
                Main.tile[x, index8 + 1].active(false);
                Main.tile[x, index8 + 1].liquid = byte.MaxValue;
                Main.tile[x, index8 + 1].lava(false);
                WorldGen.SquareTileFrame(index7, index8 + 1);
              }
              if (x > index7 - num34 && x < index7 + 2 && Main.tile[x, index8 + 2].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index8 + 2))
              {
                Main.tile[x, index8 + 2].active(false);
                Main.tile[x, index8 + 2].liquid = byte.MaxValue;
                Main.tile[x, index8 + 2].lava(false);
                WorldGen.SquareTileFrame(index7, index8 + 2);
              }
            }
          }
          if (WorldGen.genRand.Next(5) == 0 && WorldGen.WillWaterPlacedHereStayPut(index7, index8))
            Main.tile[index7, index8].liquid = byte.MaxValue;
          Main.tile[index7, index8].lava(false);
          WorldGen.SquareTileFrame(index7, index8);
        }
      }
      int num35 = WorldGen.genRand.Next(4);
      for (int index9 = 0; index9 <= num35; ++index9)
      {
        int num36 = WorldGen.genRand.Next(num4 - 5, num5 + 5);
        int num37 = num6 - WorldGen.genRand.Next(20, 40);
        int num38 = WorldGen.genRand.Next(4, 8);
        int num39 = 189;
        if (WorldGen.genRand.Next(2) == 0)
          num39 = 196;
        for (int i6 = num36 - num38; i6 <= num36 + num38; ++i6)
        {
          for (int j6 = num37 - num38; j6 <= num37 + num38; ++j6)
          {
            double num40 = (double) Math.Abs(i6 - num36);
            double num41 = (double) (Math.Abs(j6 - num37) * 2);
            if (Math.Sqrt(num40 * num40 + num41 * num41) < (double) (num38 + WorldGen.genRand.Next(-1, 2)))
            {
              Main.tile[i6, j6].active(true);
              Main.tile[i6, j6].type = (ushort) num39;
              WorldGen.SquareTileFrame(i6, j6);
            }
          }
        }
        for (int index10 = num36 - num38 + 2; index10 <= num36 + num38 - 2; ++index10)
        {
          int index11 = num37 - num38;
          while (!Main.tile[index10, index11].active())
            ++index11;
          if (WorldGen.WillWaterPlacedHereStayPut(index10, index11))
          {
            Main.tile[index10, index11].active(false);
            Main.tile[index10, index11].liquid = byte.MaxValue;
            WorldGen.SquareTileFrame(index10, index11);
          }
        }
      }
    }

    public static bool WillWaterPlacedHereStayPut(int x, int y) => (Main.tile[x, y + 1].active() && Main.tileSolid[(int) Main.tile[x, y + 1].type] && !Main.tileSolidTop[(int) Main.tile[x, y + 1].type] || Main.tile[x, y + 1].liquid == byte.MaxValue) && (Main.tile[x - 1, y].active() && Main.tileSolid[(int) Main.tile[x - 1, y].type] && !Main.tileSolidTop[(int) Main.tile[x - 1, y].type] || Main.tile[x - 1, y].liquid == byte.MaxValue) && (Main.tile[x + 1, y].active() && Main.tileSolid[(int) Main.tile[x + 1, y].type] && !Main.tileSolidTop[(int) Main.tile[x + 1, y].type] || Main.tile[x + 1, y].liquid == byte.MaxValue);

    public static void CloudLake(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(100, 150);
      double num2 = num1;
      double num3 = (double) WorldGen.genRand.Next(20, 30);
      int num4 = i;
      int num5 = i;
      int num6 = i;
      int num7 = j;
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      Vector2D vector2D2;
      vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
        vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      vector2D2.Y = (double) WorldGen.genRand.Next(-20, -10) * 0.02;
      while (num1 > 0.0 && num3 > 0.0)
      {
        num1 -= (double) WorldGen.genRand.Next(4);
        --num3;
        int num8 = (int) (vector2D1.X - num1 * 0.5);
        int num9 = (int) (vector2D1.X + num1 * 0.5);
        int num10 = (int) (vector2D1.Y - num1 * 0.5);
        int num11 = (int) (vector2D1.Y + num1 * 0.5);
        if (num8 < 0)
          num8 = 0;
        if (num9 > Main.maxTilesX)
          num9 = Main.maxTilesX;
        if (num10 < 0)
          num10 = 0;
        if (num11 > Main.maxTilesY)
          num11 = Main.maxTilesY;
        double num12 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        double num13 = vector2D1.Y + 1.0;
        for (int i1 = num8; i1 < num9; ++i1)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num13 += (double) WorldGen.genRand.Next(-1, 2);
          if (num13 < vector2D1.Y)
            num13 = vector2D1.Y;
          if (num13 > vector2D1.Y + 2.0)
            num13 = vector2D1.Y + 2.0;
          for (int j1 = num10; j1 < num11; ++j1)
          {
            if ((double) j1 > num13)
            {
              double num14 = Math.Abs((double) i1 - vector2D1.X);
              double num15 = Math.Abs((double) j1 - vector2D1.Y) * 3.0;
              if (Math.Sqrt(num14 * num14 + num15 * num15) < num12 * 0.4)
              {
                if (i1 < num4)
                  num4 = i1;
                if (i1 > num5)
                  num5 = i1;
                if (j1 < num6)
                  num6 = j1;
                if (j1 > num7)
                  num7 = j1;
                Main.tile[i1, j1].active(true);
                Main.tile[i1, j1].type = (ushort) 189;
                WorldGen.SquareTileFrame(i1, j1);
              }
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-20, 21) * 0.05;
        if (vector2D2.X > 1.0)
          vector2D2.X = 1.0;
        if (vector2D2.X < -1.0)
          vector2D2.X = -1.0;
        if (vector2D2.Y > 0.2)
          vector2D2.Y = -0.2;
        if (vector2D2.Y < -0.2)
          vector2D2.Y = -0.2;
      }
      int minValue;
      for (int index1 = num4 + WorldGen.genRand.Next(5); index1 < num5; index1 += WorldGen.genRand.Next(minValue, (int) ((double) minValue * 1.5)))
      {
        int index2 = num7;
        while (!Main.tile[index1, index2].active())
          --index2;
        int num16 = index2 + WorldGen.genRand.Next(-3, 4);
        minValue = WorldGen.genRand.Next(4, 8);
        int num17 = 189;
        if (WorldGen.genRand.Next(4) == 0)
          num17 = 196;
        for (int i2 = index1 - minValue; i2 <= index1 + minValue; ++i2)
        {
          for (int j2 = num16 - minValue; j2 <= num16 + minValue; ++j2)
          {
            if (j2 > num6)
            {
              double num18 = (double) Math.Abs(i2 - index1);
              double num19 = (double) (Math.Abs(j2 - num16) * 2);
              if (Math.Sqrt(num18 * num18 + num19 * num19) < (double) (minValue + WorldGen.genRand.Next(2)))
              {
                Main.tile[i2, j2].active(true);
                Main.tile[i2, j2].type = (ushort) num17;
                WorldGen.SquareTileFrame(i2, j2);
              }
            }
          }
        }
      }
      double num20 = (double) WorldGen.genRand.Next(80, 95);
      num2 = num20;
      double num21 = (double) WorldGen.genRand.Next(10, 15);
      vector2D1.X = (double) i;
      vector2D1.Y = (double) num6;
      vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
        vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      vector2D2.Y = (double) WorldGen.genRand.Next(-20, -10) * 0.02;
      while (num20 > 0.0 && num21 > 0.0)
      {
        num20 -= (double) WorldGen.genRand.Next(4);
        --num21;
        int num22 = (int) (vector2D1.X - num20 * 0.5);
        int num23 = (int) (vector2D1.X + num20 * 0.5);
        int num24 = num6 - 1;
        int num25 = (int) (vector2D1.Y + num20 * 0.5);
        if (num22 < 0)
          num22 = 0;
        if (num23 > Main.maxTilesX)
          num23 = Main.maxTilesX;
        if (num24 < 0)
          num24 = 0;
        if (num25 > Main.maxTilesY)
          num25 = Main.maxTilesY;
        double num26 = num20 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        double num27 = vector2D1.Y + 1.0;
        for (int x = num22; x < num23; ++x)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num27 += (double) WorldGen.genRand.Next(-1, 2);
          if (num27 < vector2D1.Y)
            num27 = vector2D1.Y;
          if (num27 > vector2D1.Y + 2.0)
            num27 = vector2D1.Y + 2.0;
          for (int y = num24; y < num25; ++y)
          {
            if ((double) y > num27 - 2.0)
            {
              double num28 = Math.Abs((double) x - vector2D1.X);
              double num29 = Math.Abs((double) y - vector2D1.Y) * 3.0;
              if (Math.Sqrt(num28 * num28 + num29 * num29) < num26 * 0.4 && Main.tile[x, y].type == (ushort) 189)
              {
                Main.tile[x, y].active(false);
                if ((double) y > num27 + 1.0)
                {
                  if (WorldGen.WillWaterPlacedHereStayPut(x, y))
                    Main.tile[x, y].liquid = byte.MaxValue;
                  Main.tile[x, y].honey(false);
                  Main.tile[x, y].lava(false);
                }
              }
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-20, 21) * 0.05;
        if (vector2D2.X > 1.0)
          vector2D2.X = 1.0;
        if (vector2D2.X < -1.0)
          vector2D2.X = -1.0;
        if (vector2D2.Y > 0.2)
          vector2D2.Y = -0.2;
        if (vector2D2.Y < 0.0)
          vector2D2.Y = 0.0;
      }
      for (int index3 = num4 - 20; index3 <= num5 + 20; ++index3)
      {
        for (int index4 = num6 - 20; index4 <= num7 + 20; ++index4)
        {
          bool flag = true;
          for (int index5 = index3 - 1; index5 <= index3 + 1; ++index5)
          {
            for (int index6 = index4 - 1; index6 <= index4 + 1; ++index6)
            {
              if (!Main.tile[index5, index6].active())
                flag = false;
            }
          }
          if (flag)
            Main.tile[index3, index4].wall = (ushort) 73;
        }
      }
      for (int index7 = num4; index7 <= num5; ++index7)
      {
        int index8 = num6 - 10;
        while (!Main.tile[index7, index8 + 1].active())
          ++index8;
        if (index8 < num7 && Main.tile[index7, index8 + 1].type == (ushort) 189)
        {
          if (WorldGen.genRand.Next(10) == 0)
          {
            int num30 = WorldGen.genRand.Next(1, 3);
            for (int x = index7 - num30; x <= index7 + num30; ++x)
            {
              if (Main.tile[x, index8].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index8))
              {
                Main.tile[x, index8].active(false);
                Main.tile[x, index8].liquid = byte.MaxValue;
                Main.tile[x, index8].lava(false);
                WorldGen.SquareTileFrame(index7, index8);
              }
              if (Main.tile[x, index8 + 1].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index8 + 1))
              {
                Main.tile[x, index8 + 1].active(false);
                Main.tile[x, index8 + 1].liquid = byte.MaxValue;
                Main.tile[x, index8 + 1].lava(false);
                WorldGen.SquareTileFrame(index7, index8 + 1);
              }
              if (x > index7 - num30 && x < index7 + 2 && Main.tile[x, index8 + 2].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index8 + 2))
              {
                Main.tile[x, index8 + 2].active(false);
                Main.tile[x, index8 + 2].liquid = byte.MaxValue;
                Main.tile[x, index8 + 2].lava(false);
                WorldGen.SquareTileFrame(index7, index8 + 2);
              }
            }
          }
          if (WorldGen.genRand.Next(5) == 0 && WorldGen.WillWaterPlacedHereStayPut(index7, index8))
            Main.tile[index7, index8].liquid = byte.MaxValue;
          Main.tile[index7, index8].lava(false);
          WorldGen.SquareTileFrame(index7, index8);
        }
      }
      int num31 = WorldGen.genRand.Next(1, 4);
      for (int index9 = 0; index9 <= num31; ++index9)
      {
        int num32 = WorldGen.genRand.Next(num4 - 5, num5 + 5);
        int num33 = num6 - WorldGen.genRand.Next(20, 40);
        int num34 = WorldGen.genRand.Next(4, 8);
        int num35 = 189;
        if (WorldGen.genRand.Next(4) != 0)
          num35 = 196;
        for (int i3 = num32 - num34; i3 <= num32 + num34; ++i3)
        {
          for (int j3 = num33 - num34; j3 <= num33 + num34; ++j3)
          {
            double num36 = (double) Math.Abs(i3 - num32);
            double num37 = (double) (Math.Abs(j3 - num33) * 2);
            if (Math.Sqrt(num36 * num36 + num37 * num37) < (double) (num34 + WorldGen.genRand.Next(-1, 2)))
            {
              Main.tile[i3, j3].active(true);
              Main.tile[i3, j3].type = (ushort) num35;
              WorldGen.SquareTileFrame(i3, j3);
            }
          }
        }
        for (int index10 = num32 - num34 + 2; index10 <= num32 + num34 - 2; ++index10)
        {
          int index11 = num33 - num34;
          while (!Main.tile[index10, index11].active())
            ++index11;
          if (WorldGen.WillWaterPlacedHereStayPut(index10, index11))
          {
            Main.tile[index10, index11].active(false);
            Main.tile[index10, index11].liquid = byte.MaxValue;
            WorldGen.SquareTileFrame(index10, index11);
          }
        }
      }
    }

    public static void FloatingIsland(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(80, 120);
      double num2 = (double) WorldGen.genRand.Next(20, 25);
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      Vector2D vector2D2;
      vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
        vector2D2.X = (double) WorldGen.genRand.Next(-20, 21) * 0.2;
      vector2D2.Y = (double) WorldGen.genRand.Next(-20, -10) * 0.02;
      while (num1 > 0.0 && num2 > 0.0)
      {
        num1 -= (double) WorldGen.genRand.Next(4);
        --num2;
        int num3 = (int) (vector2D1.X - num1 * 0.5);
        int num4 = (int) (vector2D1.X + num1 * 0.5);
        int num5 = (int) (vector2D1.Y - num1 * 0.5);
        int num6 = (int) (vector2D1.Y + num1 * 0.5);
        if (num3 < 0)
          num3 = 0;
        if (num4 > Main.maxTilesX)
          num4 = Main.maxTilesX;
        if (num5 < 0)
          num5 = 0;
        if (num6 > Main.maxTilesY)
          num6 = Main.maxTilesY;
        double num7 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        double num8 = vector2D1.Y + 1.0;
        for (int index1 = num3; index1 < num4; ++index1)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num8 += (double) WorldGen.genRand.Next(-1, 2);
          if (num8 < vector2D1.Y)
            num8 = vector2D1.Y;
          if (num8 > vector2D1.Y + 2.0)
            num8 = vector2D1.Y + 2.0;
          for (int index2 = num5; index2 < num6; ++index2)
          {
            if ((double) index2 > num8)
            {
              double num9 = Math.Abs((double) index1 - vector2D1.X);
              double num10 = Math.Abs((double) index2 - vector2D1.Y) * 2.0;
              if (Math.Sqrt(num9 * num9 + num10 * num10) < num7 * 0.4)
              {
                Main.tile[index1, index2].active(true);
                if (Main.tile[index1, index2].type == (ushort) 59)
                  Main.tile[index1, index2].type = (ushort) 0;
              }
            }
          }
        }
        int num11 = (int) (vector2D1.X - num1 * 0.4);
        int num12 = (int) (vector2D1.X + num1 * 0.4);
        int num13 = (int) (vector2D1.Y - num1 * 0.4);
        int num14 = (int) (vector2D1.Y + num1 * 0.4);
        if (num11 < 0)
          num11 = 0;
        if (num12 > Main.maxTilesX)
          num12 = Main.maxTilesX;
        if (num13 < 0)
          num13 = 0;
        if (num14 > Main.maxTilesY)
          num14 = Main.maxTilesY;
        double num15 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        for (int index3 = num11; index3 < num12; ++index3)
        {
          for (int index4 = num13; index4 < num14; ++index4)
          {
            if ((double) index4 > vector2D1.Y + 2.0)
            {
              double num16 = Math.Abs((double) index3 - vector2D1.X);
              double num17 = Math.Abs((double) index4 - vector2D1.Y) * 2.0;
              if (Math.Sqrt(num16 * num16 + num17 * num17) < num15 * 0.4)
                Main.tile[index3, index4].wall = (ushort) 2;
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        if (vector2D2.X > 1.0)
          vector2D2.X = 1.0;
        if (vector2D2.X < -1.0)
          vector2D2.X = -1.0;
        if (vector2D2.Y > 0.2)
          vector2D2.Y = -0.2;
        if (vector2D2.Y < -0.2)
          vector2D2.Y = -0.2;
      }
    }

    public static void Caverer(int X, int Y)
    {
      switch (WorldGen.genRand.Next(2))
      {
        case 0:
          int num1 = WorldGen.genRand.Next(7, 9);
          double xDir1 = (double) WorldGen.genRand.Next(100) * 0.01;
          double yDir1 = 1.0 - xDir1;
          if (WorldGen.genRand.Next(2) == 0)
            xDir1 = -xDir1;
          if (WorldGen.genRand.Next(2) == 0)
            yDir1 = -yDir1;
          Vector2D vector2D1;
          // ISSUE: explicit constructor call
          ((Vector2D) ref vector2D1).\u002Ector((double) X, (double) Y);
          for (int index = 0; index < num1; ++index)
          {
            vector2D1 = WorldGen.digTunnel(vector2D1.X, vector2D1.Y, xDir1, yDir1, WorldGen.genRand.Next(6, 20), WorldGen.genRand.Next(4, 9));
            xDir1 += (double) WorldGen.genRand.Next(-20, 21) * 0.1;
            yDir1 += (double) WorldGen.genRand.Next(-20, 21) * 0.1;
            if (xDir1 < -1.5)
              xDir1 = -1.5;
            if (xDir1 > 1.5)
              xDir1 = 1.5;
            if (yDir1 < -1.5)
              yDir1 = -1.5;
            if (yDir1 > 1.5)
              yDir1 = 1.5;
            double xDir2 = (double) WorldGen.genRand.Next(100) * 0.01;
            double yDir2 = 1.0 - xDir2;
            if (WorldGen.genRand.Next(2) == 0)
              xDir2 = -xDir2;
            if (WorldGen.genRand.Next(2) == 0)
              yDir2 = -yDir2;
            Vector2D vector2D2 = WorldGen.digTunnel(vector2D1.X, vector2D1.Y, xDir2, yDir2, WorldGen.genRand.Next(30, 50), WorldGen.genRand.Next(3, 6));
            WorldGen.TileRunner((int) vector2D2.X, (int) vector2D2.Y, (double) WorldGen.genRand.Next(10, 20), WorldGen.genRand.Next(5, 10), -1);
          }
          break;
        case 1:
          int num2 = WorldGen.genRand.Next(15, 30);
          double xDir3 = (double) WorldGen.genRand.Next(100) * 0.01;
          double yDir3 = 1.0 - xDir3;
          if (WorldGen.genRand.Next(2) == 0)
            xDir3 = -xDir3;
          if (WorldGen.genRand.Next(2) == 0)
            yDir3 = -yDir3;
          Vector2D vector2D3;
          // ISSUE: explicit constructor call
          ((Vector2D) ref vector2D3).\u002Ector((double) X, (double) Y);
          for (int index = 0; index < num2; ++index)
          {
            vector2D3 = WorldGen.digTunnel(vector2D3.X, vector2D3.Y, xDir3, yDir3, WorldGen.genRand.Next(5, 15), WorldGen.genRand.Next(2, 6), true);
            xDir3 += (double) WorldGen.genRand.Next(-20, 21) * 0.1;
            yDir3 += (double) WorldGen.genRand.Next(-20, 21) * 0.1;
            if (xDir3 < -1.5)
              xDir3 = -1.5;
            if (xDir3 > 1.5)
              xDir3 = 1.5;
            if (yDir3 < -1.5)
              yDir3 = -1.5;
            if (yDir3 > 1.5)
              yDir3 = 1.5;
          }
          break;
      }
    }

    public static Vector2D digTunnel(
      double X,
      double Y,
      double xDir,
      double yDir,
      int Steps,
      int Size,
      bool Wet = false)
    {
      double num1 = X;
      double num2 = Y;
      try
      {
        double num3 = 0.0;
        double num4 = 0.0;
        int num5 = Steps;
        double num6 = (double) Size;
        num1 = Utils.Clamp<double>(num1, num6 + 1.0, (double) Main.maxTilesX - num6 - 1.0);
        num2 = Utils.Clamp<double>(num2, num6 + 1.0, (double) Main.maxTilesY - num6 - 1.0);
        for (int index1 = 0; index1 < num5; ++index1)
        {
          for (int index2 = (int) (num1 - num6); (double) index2 <= num1 + num6; ++index2)
          {
            for (int index3 = (int) (num2 - num6); (double) index3 <= num2 + num6; ++index3)
            {
              if (Math.Abs((double) index2 - num1) + Math.Abs((double) index3 - num2) < num6 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.005) && index2 >= 0 && index2 < Main.maxTilesX && index3 >= 0 && index3 < Main.maxTilesY)
              {
                Main.tile[index2, index3].active(false);
                if (Wet)
                  Main.tile[index2, index3].liquid = byte.MaxValue;
              }
            }
          }
          num6 += (double) WorldGen.genRand.Next(-50, 51) * 0.03;
          if (num6 < (double) Size * 0.6)
            num6 = (double) Size * 0.6;
          if (num6 > (double) (Size * 2))
            num6 = (double) (Size * 2);
          num3 += (double) WorldGen.genRand.Next(-20, 21) * 0.01;
          num4 += (double) WorldGen.genRand.Next(-20, 21) * 0.01;
          if (num3 < -1.0)
            num3 = -1.0;
          if (num3 > 1.0)
            num3 = 1.0;
          if (num4 < -1.0)
            num4 = -1.0;
          if (num4 > 1.0)
            num4 = 1.0;
          num1 += (xDir + num3) * 0.6;
          num2 += (yDir + num4) * 0.6;
        }
      }
      catch
      {
      }
      return new Vector2D(num1, num2);
    }

    public static void IslandHouse(int i, int j, int islandStyle)
    {
      bool flag = WorldGen.crimson;
      if (WorldGen.drunkWorldGen)
        flag = GenVars.crimsonLeft && i < Main.maxTilesX / 2 || !GenVars.crimsonLeft && i > Main.maxTilesX / 2;
      byte num1 = 202;
      byte num2 = 82;
      Vector2D vector2D;
      // ISSUE: explicit constructor call
      ((Vector2D) ref vector2D).\u002Ector((double) i, (double) j);
      int num3 = 1;
      if (WorldGen.genRand.Next(2) == 0)
        num3 = -1;
      int num4 = WorldGen.genRand.Next(7, 12);
      int num5 = WorldGen.genRand.Next(5, 7);
      vector2D.X = (double) (i + (num4 + 2) * num3);
      for (int index = j - 15; index < j + 30; ++index)
      {
        if (Main.tile[(int) vector2D.X, index].active())
        {
          vector2D.Y = (double) (index - 1);
          break;
        }
      }
      vector2D.X = (double) i;
      int num6 = (int) (vector2D.X - (double) num4 - 1.0);
      int num7 = (int) (vector2D.X + (double) num4 + 1.0);
      int num8 = (int) (vector2D.Y - (double) num5 - 1.0);
      int num9 = (int) (vector2D.Y + 2.0);
      if (num6 < 0)
        num6 = 0;
      if (num7 > Main.maxTilesX)
        num7 = Main.maxTilesX;
      if (num8 < 0)
        num8 = 0;
      if (num9 > Main.maxTilesY)
        num9 = Main.maxTilesY;
      for (int index1 = num6; index1 <= num7; ++index1)
      {
        for (int index2 = num8 - 1; index2 < num9 + 1; ++index2)
        {
          if (index2 != num8 - 1 || index1 != num6 && index1 != num7)
          {
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].liquid = (byte) 0;
            Main.tile[index1, index2].type = (ushort) num1;
            Main.tile[index1, index2].wall = (ushort) 0;
            Main.tile[index1, index2].halfBrick(false);
            Main.tile[index1, index2].slope((byte) 0);
          }
        }
      }
      int num10 = (int) (vector2D.X - (double) num4);
      int num11 = (int) (vector2D.X + (double) num4);
      int j1 = (int) (vector2D.Y - (double) num5);
      int num12 = (int) (vector2D.Y + 1.0);
      if (num10 < 0)
        num10 = 0;
      if (num11 > Main.maxTilesX)
        num11 = Main.maxTilesX;
      if (j1 < 0)
        j1 = 0;
      if (num12 > Main.maxTilesY)
        num12 = Main.maxTilesY;
      for (int index3 = num10; index3 <= num11; ++index3)
      {
        for (int index4 = j1; index4 < num12; ++index4)
        {
          if ((index4 != j1 || index3 != num10 && index3 != num11) && Main.tile[index3, index4].wall == (ushort) 0)
          {
            Main.tile[index3, index4].active(false);
            Main.tile[index3, index4].wall = (ushort) num2;
          }
        }
      }
      int i1 = i + (num4 + 1) * num3;
      int y = (int) vector2D.Y;
      for (int index = i1 - 2; index <= i1 + 2; ++index)
      {
        Main.tile[index, y].active(false);
        Main.tile[index, y - 1].active(false);
        Main.tile[index, y - 2].active(false);
      }
      if (WorldGen.remixWorldGen)
      {
        if (flag)
          WorldGen.PlaceTile(i1, y, 10, true, style: 5);
        else
          WorldGen.PlaceTile(i1, y, 10, true, style: 38);
      }
      else
        WorldGen.PlaceTile(i1, y, 10, true, style: 9);
      int index5 = i + (num4 + 1) * -num3 - num3;
      for (int index6 = j1; index6 <= num12 + 1; ++index6)
      {
        Main.tile[index5, index6].active(true);
        Main.tile[index5, index6].liquid = (byte) 0;
        Main.tile[index5, index6].type = (ushort) num1;
        Main.tile[index5, index6].wall = (ushort) 0;
        Main.tile[index5, index6].halfBrick(false);
        Main.tile[index5, index6].slope((byte) 0);
      }
      int contain = 0;
      int num13 = GenVars.skyIslandHouseCount;
      if (num13 > 3)
        num13 = WorldGen.genRand.Next(4);
      switch (num13)
      {
        case 0:
          contain = 159;
          break;
        case 1:
          contain = 65;
          break;
        case 2:
          contain = 158;
          break;
        case 3:
          contain = 2219;
          break;
      }
      if (WorldGen.getGoodWorldGen)
        WorldGen.AddBuriedChest(i, y - 3, contain, Style: 2);
      else
        WorldGen.AddBuriedChest(i, y - 3, contain, Style: 13);
      if (islandStyle > 0)
      {
        for (int index7 = 0; index7 < 100000; ++index7)
        {
          int index8 = i + WorldGen.genRand.Next(-50, 51);
          int index9 = y + WorldGen.genRand.Next(21);
          if ((index7 >= 50000 || Main.tile[index8, index9].type != (ushort) 202) && !Main.tile[index8, index9].active())
          {
            WorldGen.Place2xX(index8, index9, (ushort) 207, islandStyle);
            if (Main.tile[index8, index9].active())
            {
              WorldGen.SwitchFountain(index8, index9);
              break;
            }
          }
        }
      }
      ++GenVars.skyIslandHouseCount;
      if (!WorldGen.remixWorldGen)
      {
        int num14 = i - num4 / 2 + 1;
        int num15 = i + num4 / 2 - 1;
        int num16 = 1;
        if (num4 > 10)
          num16 = 2;
        int num17 = (j1 + num12) / 2 - 1;
        for (int index10 = num14 - num16; index10 <= num14 + num16; ++index10)
        {
          for (int index11 = num17 - 1; index11 <= num17 + 1; ++index11)
            Main.tile[index10, index11].wall = (ushort) 21;
        }
        for (int index12 = num15 - num16; index12 <= num15 + num16; ++index12)
        {
          for (int index13 = num17 - 1; index13 <= num17 + 1; ++index13)
            Main.tile[index12, index13].wall = (ushort) 21;
        }
      }
      int i2 = i + (num4 / 2 + 1) * -num3;
      if (WorldGen.remixWorldGen)
      {
        if (flag)
        {
          WorldGen.PlaceTile(i2, num12 - 1, 14, true, style: 5);
          WorldGen.PlaceTile(i2 - 2, num12 - 1, 15, true, plr: 0, style: 8);
          WorldGen.PlaceTile(i2 + 2, num12 - 1, 15, true, plr: 0, style: 8);
        }
        else
        {
          WorldGen.PlaceTile(i2, num12 - 1, 469, true, style: 2);
          WorldGen.PlaceTile(i2 - 2, num12 - 1, 15, true, plr: 0, style: 38);
          WorldGen.PlaceTile(i2 + 2, num12 - 1, 15, true, plr: 0, style: 38);
        }
      }
      else
      {
        WorldGen.PlaceTile(i2, num12 - 1, 14, true, style: 7);
        WorldGen.PlaceTile(i2 - 2, num12 - 1, 15, true, plr: 0, style: 10);
        WorldGen.PlaceTile(i2 + 2, num12 - 1, 15, true, plr: 0, style: 10);
      }
      Main.tile[i2 - 2, num12 - 1].frameX += (short) 18;
      Main.tile[i2 - 2, num12 - 2].frameX += (short) 18;
      if (!WorldGen.remixWorldGen)
      {
        WorldGen.PlaceTile(num10 + 1, j1, 91, true, style: WorldGen.genRand.Next(7, 10));
        WorldGen.PlaceTile(num11 - 1, j1, 91, true, style: WorldGen.genRand.Next(7, 10));
        int i3;
        int j2;
        if (num3 > 0)
        {
          i3 = num10;
          j2 = j1 + 1;
        }
        else
        {
          i3 = num11;
          j2 = j1 + 1;
        }
        WorldGen.PlaceTile(i3, j2, 91, true, style: WorldGen.genRand.Next(7, 10));
      }
      if (islandStyle != 1)
        return;
      int num18 = WorldGen.genRand.Next(3, 6);
      for (int index14 = 0; index14 < 100000; ++index14)
      {
        int i4 = i + WorldGen.genRand.Next(-50, 51);
        int index15 = y + WorldGen.genRand.Next(-10, 21);
        if (!Main.tile[i4, index15].active())
        {
          WorldGen.GrowPalmTree(i4, index15 + 1);
          if (Main.tile[i4, index15].active())
            --num18;
        }
        if (num18 <= 0)
          break;
      }
    }

    public static void Mountinater(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(80, 120);
      double num2 = num1;
      double num3 = (double) WorldGen.genRand.Next(40, 55);
      if (WorldGen.remixWorldGen)
      {
        double num4 = num2 * 1.5;
        num3 *= 1.5;
      }
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j + num3 / 2.0;
      Vector2D vector2D2;
      vector2D2.X = (double) WorldGen.genRand.Next(-10, 11) * 0.1;
      vector2D2.Y = (double) WorldGen.genRand.Next(-20, -10) * 0.1;
      while (num1 > 0.0 && num3 > 0.0)
      {
        num1 -= (double) WorldGen.genRand.Next(4);
        --num3;
        int num5 = (int) (vector2D1.X - num1 * 0.5);
        int num6 = (int) (vector2D1.X + num1 * 0.5);
        int num7 = (int) (vector2D1.Y - num1 * 0.5);
        int num8 = (int) (vector2D1.Y + num1 * 0.5);
        if (num5 < 0)
          num5 = 0;
        if (num6 > Main.maxTilesX)
          num6 = Main.maxTilesX;
        if (num7 < 0)
          num7 = 0;
        if (num8 > Main.maxTilesY)
          num8 = Main.maxTilesY;
        double num9 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        for (int index1 = num5; index1 < num6; ++index1)
        {
          for (int index2 = num7; index2 < num8; ++index2)
          {
            double num10 = Math.Abs((double) index1 - vector2D1.X);
            double num11 = Math.Abs((double) index2 - vector2D1.Y);
            if (Math.Sqrt(num10 * num10 + num11 * num11) < num9 * 0.4 && !Main.tile[index1, index2].active())
            {
              Main.tile[index1, index2].active(true);
              Main.tile[index1, index2].type = (ushort) 0;
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        if (vector2D2.X > 0.5)
          vector2D2.X = 0.5;
        if (vector2D2.X < -0.5)
          vector2D2.X = -0.5;
        if (vector2D2.Y > -0.5)
          vector2D2.Y = -0.5;
        if (vector2D2.Y < -1.5)
          vector2D2.Y = -1.5;
      }
    }

    public static void MakeWateryIceThing(int i, int j)
    {
      if (Main.tile[i, j].liquid <= (byte) 0 || Main.tile[i, j].active() || Main.tile[i, j].lava() && !Main.remixWorld)
        return;
      int index1 = j;
      while (!Main.tile[i, index1].active() && Main.tile[i, index1].liquid > (byte) 0)
      {
        ++index1;
        if (index1 > Main.maxTilesY - 50)
          return;
      }
      if (Main.tile[i, index1].type != (ushort) 147 && Main.tile[i, index1].type != (ushort) 161)
        return;
      int index2 = index1 - 1;
      while (Main.tile[i, index2].liquid > (byte) 0)
      {
        --index2;
        if (index2 < 10)
          return;
      }
      if (Main.tile[i, index2].active())
        return;
      int j1 = index2 + 1;
      if (Main.tile[i, j1].active())
        return;
      for (int i1 = i; !Main.tile[i1, j1].active() && Main.tile[i1, j1].liquid > (byte) 0 && Main.tile[i1, j1 - 1].liquid == (byte) 0 && !Main.tile[i1, j1 - 1].active() && !Main.tile[i1 - 1, j1].halfBrick(); --i1)
        WorldGen.PlaceTile(i1, j1, 162, true);
      for (int i2 = i + 1; !Main.tile[i2, j1].active() && Main.tile[i2, j1].liquid > (byte) 0 && Main.tile[i2, j1 - 1].liquid == (byte) 0 && !Main.tile[i2, j1 - 1].active() && !Main.tile[i2 + 1, j1].halfBrick(); ++i2)
        WorldGen.PlaceTile(i2, j1, 162, true);
    }

    public static void Lakinater(int i, int j, double strengthMultiplier = 1.0)
    {
      double num1 = (double) WorldGen.genRand.Next(25, 50) * strengthMultiplier;
      double num2 = num1;
      double num3 = (double) WorldGen.genRand.Next(30, 80);
      if (WorldGen.genRand.Next(5) == 0)
      {
        num1 *= 1.5;
        num2 *= 1.5;
        num3 *= 1.2;
      }
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j - num3 * 0.3;
      Vector2D vector2D2;
      vector2D2.X = (double) WorldGen.genRand.Next(-10, 11) * 0.1;
      vector2D2.Y = (double) WorldGen.genRand.Next(-20, -10) * 0.1;
      while (num1 > 0.0 && num3 > 0.0)
      {
        if (vector2D1.Y + num2 * 0.5 > Main.worldSurface)
          num3 = 0.0;
        num1 -= (double) WorldGen.genRand.Next(3);
        --num3;
        int num4 = (int) (vector2D1.X - num1 * 0.5);
        int num5 = (int) (vector2D1.X + num1 * 0.5);
        int num6 = (int) (vector2D1.Y - num1 * 0.5);
        int num7 = (int) (vector2D1.Y + num1 * 0.5);
        if (num4 < 0)
          num4 = 0;
        if (num5 > Main.maxTilesX)
          num5 = Main.maxTilesX;
        if (num6 < 0)
          num6 = 0;
        if (num7 > Main.maxTilesY)
          num7 = Main.maxTilesY;
        num2 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        for (int index1 = num4; index1 < num5; ++index1)
        {
          for (int index2 = num6; index2 < num7; ++index2)
          {
            double num8 = Math.Abs((double) index1 - vector2D1.X);
            double num9 = Math.Abs((double) index2 - vector2D1.Y);
            if (Math.Sqrt(num8 * num8 + num9 * num9) < num2 * 0.4)
            {
              if (Main.tile[index1, index2].active())
                Main.tile[index1, index2].liquid = byte.MaxValue;
              Main.tile[index1, index2].active(false);
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        if (vector2D2.X > 0.5)
          vector2D2.X = 0.5;
        if (vector2D2.X < -0.5)
          vector2D2.X = -0.5;
        if (vector2D2.Y > 1.5)
          vector2D2.Y = 1.5;
        if (vector2D2.Y < 0.5)
          vector2D2.Y = 0.5;
      }
    }

    public static void SonOfLakinater(int i, int j, double strengthMultiplier = 1.0)
    {
      bool lava = false;
      if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(3) == 0)
        lava = true;
      double num1 = (double) WorldGen.genRand.Next(15, 31) * strengthMultiplier;
      double num2 = (double) WorldGen.genRand.Next(30, 61);
      if (WorldGen.genRand.Next(5) == 0)
      {
        num1 *= 1.3;
        num2 *= 1.3;
      }
      if (WorldGen.drunkWorldGen)
      {
        num1 *= 1.3;
        num2 *= 1.3;
      }
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      double num3 = WorldGen.genRand.NextDouble() * 0.002;
      Vector2D vector2D2;
      if (WorldGen.genRand.Next(4) != 0)
      {
        vector2D2.X = (double) WorldGen.genRand.Next(-15, 16) * 0.01;
      }
      else
      {
        vector2D2.X = (double) WorldGen.genRand.Next(-50, 51) * 0.01;
        num3 = WorldGen.genRand.NextDouble() * 0.004 + 0.001;
      }
      vector2D2.Y = (double) WorldGen.genRand.Next(101) * 0.01;
      double num4 = num2;
      while (num1 > 3.0 && num2 > 0.0)
      {
        num1 -= (double) WorldGen.genRand.Next(11) * 0.1;
        --num2;
        int num5 = (int) (vector2D1.X - num1 * 4.0);
        int num6 = (int) (vector2D1.X + num1 * 4.0);
        int num7 = (int) (vector2D1.Y - num1 * 3.0);
        int num8 = (int) (vector2D1.Y + num1 * 2.0);
        if (num5 < 0)
          num5 = 0;
        if (num6 > Main.maxTilesX)
          num6 = Main.maxTilesX;
        if (num7 < 0)
          num7 = 0;
        if (num8 > Main.maxTilesY)
          num8 = Main.maxTilesY;
        double num9 = num1;
        for (int index1 = num5; index1 < num6; ++index1)
        {
          for (int index2 = num7; index2 < num8; ++index2)
          {
            double num10 = Math.Abs((double) index1 - vector2D1.X) * 0.6;
            double num11 = Math.Abs((double) index2 - vector2D1.Y) * 1.4;
            double num12 = Math.Abs((double) index1 - vector2D1.X) * 0.3;
            double num13 = Math.Abs((double) index2 - vector2D1.Y) * 5.0;
            double num14 = Utils.Lerp(num10, num12, num2 / num4);
            double num15 = Utils.Lerp(num11, num13, num2 / num4);
            double num16 = Math.Sqrt(num14 * num14 + num15 * num15);
            int num17 = j + 5;
            if (num16 < num9 * 0.4)
            {
              if (index2 >= j)
              {
                if (index2 <= j + 1)
                {
                  if (WorldGen.WillWaterPlacedHereStayPut(index1, index2))
                  {
                    Main.tile[index1, index2].liquid = byte.MaxValue;
                    Main.tile[index1, index2].lava(lava);
                  }
                }
                else
                {
                  Main.tile[index1, index2].liquid = byte.MaxValue;
                  Main.tile[index1, index2].lava(lava);
                }
              }
              Main.tile[index1, index2].active(false);
              if (!WorldGen.gen)
                WorldGen.SquareTileFrame(index1, index2);
              if (Main.tile[index1, index2].type == (ushort) 59 || Main.tile[index1, index2].type == (ushort) 60)
              {
                WorldGen.SpreadGrass(index1 - 1, index2, 59, 60);
                WorldGen.SpreadGrass(index1 + 1, index2, 59, 60);
                WorldGen.SpreadGrass(index1, index2 + 1, 59, 60);
              }
            }
            else if (index2 > j + 1 && num16 < num9 && Main.tile[index1, index2].liquid == (byte) 0)
            {
              if (Math.Abs((double) index1 - vector2D1.X) * 0.8 < num9 && Main.tile[index1, index2].wall > (ushort) 0 && Main.tile[index1 - 1, index2].wall > (ushort) 0 && Main.tile[index1 + 1, index2].wall > (ushort) 0 && Main.tile[index1, index2 + 1].wall > (ushort) 0)
                Main.tile[index1, index2].active(true);
            }
            else if (index2 < j && num2 == num4 - 1.0 && (double) index2 > GenVars.worldSurfaceLow - 20.0 && !TileID.Sets.Clouds[(int) Main.tile[index1, index2].type])
            {
              double num18 = (double) Math.Abs(index1 - i) * 0.7;
              double num19 = (double) Math.Abs(index2 - num17) * 1.35;
              Math.Sqrt(num18 * num18 + num19 * num19);
              double num20 = num9 * 0.4;
              double num21 = (1.0 - (double) Math.Abs(index1 - i) / (double) (num6 - i)) * 2.3;
              double num22 = num21 * num21;
              double num23 = num22 * num22;
              if (index2 < num17 && num18 < num20 + (double) Math.Abs(index2 - num17) * 0.5 * num23)
              {
                Main.tile[index1, index2].active(false);
                if (Main.tile[index1, index2].type == (ushort) 59 || Main.tile[index1, index2].type == (ushort) 60)
                {
                  WorldGen.SpreadGrass(index1 - 1, index2, 59, 60);
                  WorldGen.SpreadGrass(index1 + 1, index2, 59, 60);
                  WorldGen.SpreadGrass(index1, index2 + 1, 59, 60);
                }
              }
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-100, 101) * num3;
        vector2D2.Y += (double) WorldGen.genRand.Next(-100, 101) * 0.01;
        if (vector2D2.X > 1.0)
          vector2D2.X = 1.0;
        if (vector2D2.X < -1.0)
          vector2D2.X = -1.0;
        if (vector2D2.Y > 1.0)
          vector2D2.Y = 1.0;
        double num24 = 0.5 * (1.0 - num2 / num4);
        if (vector2D2.Y < num24)
          vector2D2.Y = num24;
      }
    }

    public static void ShroomPatch(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(80, 100);
      double num2 = (double) WorldGen.genRand.Next(20, 26);
      double num3 = (double) Main.maxTilesX / 4200.0;
      if (WorldGen.getGoodWorldGen && !Main.remixWorld)
        num3 *= 1.5;
      double num4 = num1 * num3;
      double num5 = num2 * num3;
      double num6 = num5 - 1.0;
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j - num5 * 0.3;
      Vector2D vector2D2;
      vector2D2.X = (double) WorldGen.genRand.Next(-100, 101) * 0.005;
      vector2D2.Y = (double) WorldGen.genRand.Next(-200, -100) * 0.005;
      while (num4 > 0.0 && num5 > 0.0)
      {
        num4 -= (double) WorldGen.genRand.Next(3);
        --num5;
        int num7 = (int) (vector2D1.X - num4 * 0.5);
        int num8 = (int) (vector2D1.X + num4 * 0.5);
        int num9 = (int) (vector2D1.Y - num4 * 0.5);
        int num10 = (int) (vector2D1.Y + num4 * 0.5);
        if (num7 < 0)
          num7 = 0;
        if (num8 > Main.maxTilesX)
          num8 = Main.maxTilesX;
        if (num9 < 0)
          num9 = 0;
        if (num10 > Main.maxTilesY)
          num10 = Main.maxTilesY;
        double num11 = num4 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        for (int index1 = num7; index1 < num8; ++index1)
        {
          for (int index2 = num9; index2 < num10; ++index2)
          {
            double num12 = Math.Abs((double) index1 - vector2D1.X);
            double num13 = Math.Abs(((double) index2 - vector2D1.Y) * 2.3);
            double num14 = Math.Sqrt(num12 * num12 + num13 * num13);
            if (num14 < num11 * 0.8 && Main.tile[index1, index2].lava())
              Main.tile[index1, index2].liquid = (byte) 0;
            if (num14 < num11 * 0.2 && (double) index2 < vector2D1.Y)
            {
              Main.tile[index1, index2].active(false);
              if (Main.tile[index1, index2].wall > (ushort) 0)
                Main.tile[index1, index2].wall = (ushort) 80;
            }
            else if (num14 < num11 * 0.4 * (0.95 + WorldGen.genRand.NextDouble() * 0.1))
            {
              Main.tile[index1, index2].type = (ushort) 59;
              if (num5 == num6 && (double) index2 > vector2D1.Y)
                Main.tile[index1, index2].active(true);
              if (Main.tile[index1, index2].wall > (ushort) 0)
                Main.tile[index1, index2].wall = (ushort) 80;
            }
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D1.X += vector2D2.X;
        vector2D2.X += (double) WorldGen.genRand.Next(-100, 110) * 0.005;
        vector2D2.Y -= (double) WorldGen.genRand.Next(110) * 0.005;
        if (vector2D2.X > -0.5 && vector2D2.X < 0.5)
          vector2D2.X = vector2D2.X >= 0.0 ? 0.5 : -0.5;
        if (vector2D2.X > 0.5)
          vector2D2.X = 0.5;
        if (vector2D2.X < -0.5)
          vector2D2.X = -0.5;
        if (vector2D2.Y > 0.5)
          vector2D2.Y = 0.5;
        if (vector2D2.Y < -0.5)
          vector2D2.Y = -0.5;
        for (int index = 0; index < 2; ++index)
        {
          int i1 = (int) vector2D1.X + WorldGen.genRand.Next(-20, 20);
          int j1;
          for (j1 = (int) vector2D1.Y + WorldGen.genRand.Next(0, 20); !Main.tile[i1, j1].active() && Main.tile[i1, j1].type != (ushort) 59; j1 = (int) vector2D1.Y + WorldGen.genRand.Next(0, 20))
            i1 = (int) vector2D1.X + WorldGen.genRand.Next(-20, 20);
          int strength = WorldGen.genRand.Next(10, 20);
          int steps = WorldGen.genRand.Next(10, 20);
          WorldGen.TileRunner(i1, j1, (double) strength, steps, 59, speedY: 2.0, noYChange: true);
        }
      }
    }

    public static void Cavinator(int i, int j, int steps)
    {
      double num1 = (double) WorldGen.genRand.Next(7, 15);
      int num2 = 1;
      if (WorldGen.genRand.Next(2) == 0)
        num2 = -1;
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      int num3 = WorldGen.genRand.Next(20, 40);
      Vector2D vector2D2;
      vector2D2.Y = (double) WorldGen.genRand.Next(10, 20) * 0.01;
      vector2D2.X = (double) num2;
      while (num3 > 0)
      {
        --num3;
        int num4 = (int) (vector2D1.X - num1 * 0.5);
        int num5 = (int) (vector2D1.X + num1 * 0.5);
        int num6 = (int) (vector2D1.Y - num1 * 0.5);
        int num7 = (int) (vector2D1.Y + num1 * 0.5);
        if (num4 < 0)
          num4 = 0;
        if (num5 > Main.maxTilesX)
          num5 = Main.maxTilesX;
        if (num6 < 0)
          num6 = 0;
        if (num7 > Main.maxTilesY)
          num7 = Main.maxTilesY;
        double num8 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        for (int index1 = num4; index1 < num5; ++index1)
        {
          for (int index2 = num6; index2 < num7; ++index2)
          {
            double num9 = Math.Abs((double) index1 - vector2D1.X);
            double num10 = Math.Abs((double) index2 - vector2D1.Y);
            if (Math.Sqrt(num9 * num9 + num10 * num10) < num8 * 0.4 && TileID.Sets.CanBeClearedDuringGeneration[(int) Main.tile[index1, index2].type] && Main.tile[index1, index2].type != (ushort) 53)
              Main.tile[index1, index2].active(false);
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        if (vector2D2.X > (double) num2 + 0.5)
          vector2D2.X = (double) num2 + 0.5;
        if (vector2D2.X < (double) num2 - 0.5)
          vector2D2.X = (double) num2 - 0.5;
        if (vector2D2.Y > 2.0)
          vector2D2.Y = 2.0;
        if (vector2D2.Y < 0.0)
          vector2D2.Y = 0.0;
      }
      if (steps <= 0 || (double) (int) vector2D1.Y >= Main.rockLayer + 50.0)
        return;
      WorldGen.Cavinator((int) vector2D1.X, (int) vector2D1.Y, steps - 1);
    }

    public static void CaveOpenater(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(7, 12);
      int num2 = 1;
      if (WorldGen.genRand.Next(2) == 0)
        num2 = -1;
      if (WorldGen.genRand.Next(10) != 0)
        num2 = i >= Main.maxTilesX / 2 ? -1 : 1;
      Vector2D vector2D1;
      vector2D1.X = (double) i;
      vector2D1.Y = (double) j;
      int num3 = 100;
      Vector2D vector2D2;
      vector2D2.Y = 0.0;
      vector2D2.X = (double) num2;
      while (num3 > 0)
      {
        Tile tile = Main.tile[(int) vector2D1.X, (int) vector2D1.Y];
        if (tile.wall == (ushort) 0 || tile.active() && !TileID.Sets.CanBeClearedDuringGeneration[(int) tile.type])
          num3 = 0;
        --num3;
        int num4 = (int) (vector2D1.X - num1 * 0.5);
        int num5 = (int) (vector2D1.X + num1 * 0.5);
        int num6 = (int) (vector2D1.Y - num1 * 0.5);
        int num7 = (int) (vector2D1.Y + num1 * 0.5);
        if (num4 < 0)
          num4 = 0;
        if (num5 > Main.maxTilesX)
          num5 = Main.maxTilesX;
        if (num6 < 0)
          num6 = 0;
        if (num7 > Main.maxTilesY)
          num7 = Main.maxTilesY;
        double num8 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        for (int index1 = num4; index1 < num5; ++index1)
        {
          for (int index2 = num6; index2 < num7; ++index2)
          {
            double num9 = Math.Abs((double) index1 - vector2D1.X);
            double num10 = Math.Abs((double) index2 - vector2D1.Y);
            if (Math.Sqrt(num9 * num9 + num10 * num10) < num8 * 0.4 && TileID.Sets.CanBeClearedDuringGeneration[(int) Main.tile[index1, index2].type])
              Main.tile[index1, index2].active(false);
          }
        }
        vector2D1 = Vector2D.op_Addition(vector2D1, vector2D2);
        vector2D2.X += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        vector2D2.Y += (double) WorldGen.genRand.Next(-10, 11) * 0.05;
        if (vector2D2.X > (double) num2 + 0.5)
          vector2D2.X = (double) num2 + 0.5;
        if (vector2D2.X < (double) num2 - 0.5)
          vector2D2.X = (double) num2 - 0.5;
        if (vector2D2.Y > 0.0)
          vector2D2.Y = 0.0;
        if (vector2D2.Y < -0.5)
          vector2D2.Y = -0.5;
      }
    }

    public static void DiamondTileFrame(int i, int j)
    {
      WorldGen.TileFrame(i - 1, j);
      WorldGen.TileFrame(i, j - 1);
      WorldGen.TileFrame(i, j + 1);
      WorldGen.TileFrame(i + 1, j);
    }

    public static void SquareTileFrame(int i, int j, bool resetFrame = true)
    {
      WorldGen.TileFrame(i - 1, j - 1);
      WorldGen.TileFrame(i - 1, j);
      WorldGen.TileFrame(i - 1, j + 1);
      WorldGen.TileFrame(i, j - 1);
      WorldGen.TileFrame(i, j, resetFrame);
      WorldGen.TileFrame(i, j + 1);
      WorldGen.TileFrame(i + 1, j - 1);
      WorldGen.TileFrame(i + 1, j);
      WorldGen.TileFrame(i + 1, j + 1);
    }

    public static void SquareWallFrame(int i, int j, bool resetFrame = true)
    {
      Framing.WallFrame(i - 1, j - 1);
      Framing.WallFrame(i - 1, j);
      Framing.WallFrame(i - 1, j + 1);
      Framing.WallFrame(i, j - 1);
      Framing.WallFrame(i, j, resetFrame);
      Framing.WallFrame(i, j + 1);
      Framing.WallFrame(i + 1, j - 1);
      Framing.WallFrame(i + 1, j);
      Framing.WallFrame(i + 1, j + 1);
    }

    public static void SectionTileFrameWithCheck(int startX, int startY, int endX, int endY)
    {
      int sectionX1 = Netplay.GetSectionX(startX);
      int sectionY1 = Netplay.GetSectionY(startY);
      int sectionX2 = Netplay.GetSectionX(endX);
      int sectionY2 = Netplay.GetSectionY(endY);
      for (int index1 = sectionX1; index1 <= sectionX2; ++index1)
      {
        for (int index2 = sectionY1; index2 <= sectionY2; ++index2)
        {
          if (Main.sectionManager.SectionLoaded(index1, index2) && !Main.sectionManager.SectionFramed(index1, index2))
          {
            WorldGen.SectionTileFrame(index1, index2, index1, index2);
            if (!Main.sectionManager.AnyUnfinishedSections)
              return;
          }
        }
      }
    }

    public static void RefreshSections(int startX, int startY, int endX, int endY)
    {
      int sectionX1 = Netplay.GetSectionX(startX);
      int sectionY1 = Netplay.GetSectionY(startY);
      int sectionX2 = Netplay.GetSectionX(endX);
      int sectionY2 = Netplay.GetSectionY(endY);
      for (int index1 = sectionX1; index1 <= sectionX2; ++index1)
      {
        for (int index2 = sectionY1; index2 <= sectionY2; ++index2)
        {
          if (Main.sectionManager.SectionNeedsRefresh(index1, index2))
            WorldGen.RefreshSection(index1, index2);
        }
      }
    }

    public static void RefreshSection(int sectionX, int sectionY)
    {
      int tileStartX;
      int tileEndX;
      int tileStartY;
      int tileEndY;
      WorldGen.GetSectionBounds(sectionX, sectionY, sectionX, sectionY, out tileStartX, out tileEndX, out tileStartY, out tileEndY);
      WorldGen.noMapUpdate = true;
      int totalEcho = 0;
      int totalFramed = 0;
      for (int yStart = tileStartY; yStart < tileEndY; yStart += 50)
      {
        for (int xStart = tileStartX; xStart < tileEndX; xStart += 200)
          WorldGen.RefreshStrip(xStart, yStart, Math.Min(xStart + 200, tileEndX), Math.Min(yStart + 50, tileEndY), ref totalEcho, ref totalFramed);
      }
      WorldGen.noMapUpdate = false;
      Main.sectionManager.SetSectionAsRefreshed(sectionX, sectionY);
    }

    public static void RefreshStrip(
      int xStart,
      int yStart,
      int xEnd,
      int yEnd,
      ref int totalEcho,
      ref int totalFramed)
    {
      int num1 = xStart - 1;
      int num2 = yStart - 1;
      int num3 = xEnd - xStart;
      int num4 = yEnd - yStart;
      if (num4 > 50 || num3 > 200)
        throw new IndexOutOfRangeException();
      int num5 = 0;
      Vertical64BitStrips bitStrip = WorldGen.bitStrip;
      for (int x = 1; x <= num3; ++x)
      {
        Bits64 bits64 = new Bits64();
        for (int i = 1; i <= num4; ++i)
        {
          Tile tile = Main.tile[num1 + x, num2 + i];
          if ((tile == null ? 0 : (tile.invisibleBlock() ? 1 : (tile.invisibleWall() ? 1 : 0))) != 0)
          {
            ++num5;
            bits64[i] = true;
          }
        }
        bitStrip[x] = bits64;
      }
      if (num5 == 0)
        return;
      bitStrip.Expand3x3();
      for (int x = 0; x < num3 + 2; ++x)
      {
        Bits64 bits64 = bitStrip[x];
        if (!bits64.IsEmpty)
        {
          for (int i = 0; i < num4 + 2; ++i)
          {
            if (bits64[i])
            {
              ++totalFramed;
              WorldGen.Reframe(num1 + x, num2 + i);
            }
          }
        }
      }
      bitStrip.Clear();
      totalEcho += num5;
    }

    public static void Reframe(int x, int y, bool resetFrame = false)
    {
      WorldGen.TileFrame(x, y, resetFrame, true);
      Framing.WallFrame(x, y, resetFrame);
    }

    public static void SectionTileFrame(
      int sectionStartX,
      int sectionStartY,
      int sectionEndXInclusive,
      int sectionEndYInclusive)
    {
      Main.mapTime = Main.mapTimeMax + 10;
      WorldGen.noMapUpdate = true;
      int tileStartX;
      int tileEndX;
      int tileStartY;
      int tileEndY;
      WorldGen.GetSectionBounds(sectionStartX, sectionStartY, sectionEndXInclusive, sectionEndYInclusive, out tileStartX, out tileEndX, out tileStartY, out tileEndY);
      for (int x = tileStartX - 1; x < tileEndX + 1; ++x)
      {
        for (int y = tileStartY - 1; y < tileEndY + 1; ++y)
        {
          if (Main.tile[x, y] == null)
            Main.tile[x, y] = new Tile();
          WorldGen.Reframe(x, y, true);
        }
      }
      for (int x = sectionStartX; x <= sectionEndXInclusive; ++x)
      {
        for (int y = sectionStartY; y <= sectionEndYInclusive; ++y)
          Main.sectionManager.SetSectionFramed(x, y);
      }
      WorldGen.noMapUpdate = false;
    }

    public static void GetSectionBounds(
      int sectionStartX,
      int sectionStartY,
      int sectionEndXInclusive,
      int sectionEndYInclusive,
      out int tileStartX,
      out int tileEndX,
      out int tileStartY,
      out int tileEndY)
    {
      tileStartX = sectionStartX * 200;
      tileEndX = (sectionEndXInclusive + 1) * 200;
      tileStartY = sectionStartY * 150;
      tileEndY = (sectionEndYInclusive + 1) * 150;
      if (tileStartX < 1)
        tileStartX = 1;
      if (tileStartY < 1)
        tileStartY = 1;
      if (tileStartX > Main.maxTilesX - 2)
        tileStartX = Main.maxTilesX - 2;
      if (tileStartY > Main.maxTilesY - 2)
        tileStartY = Main.maxTilesY - 2;
      if (tileEndX > Main.maxTilesX - 2)
        tileEndX = Main.maxTilesX - 2;
      if (tileEndY <= Main.maxTilesY - 2)
        return;
      tileEndY = Main.maxTilesY - 2;
    }

    public static void RangeFrame(int startX, int startY, int endX, int endY)
    {
      int num1 = startX;
      int num2 = endX + 1;
      int num3 = startY;
      int num4 = endY + 1;
      for (int i = num1 - 1; i < num2 + 1; ++i)
      {
        for (int j = num3 - 1; j < num4 + 1; ++j)
        {
          WorldGen.TileFrame(i, j);
          Framing.WallFrame(i, j);
        }
      }
    }

    public static void WaterCheck()
    {
      Liquid.tilesIgnoreWater(true);
      Liquid.numLiquid = 0;
      LiquidBuffer.numLiquidBuffer = 0;
      for (int index1 = 1; index1 < Main.maxTilesX - 1; ++index1)
      {
        for (int index2 = Main.maxTilesY - 2; index2 > 0; --index2)
        {
          Tile checkTile = Main.tile[index1, index2];
          checkTile.checkingLiquid(false);
          if (checkTile.liquid > (byte) 0 && checkTile.nactive() && Main.tileSolid[(int) checkTile.type] && !Main.tileSolidTop[(int) checkTile.type])
            checkTile.liquid = (byte) 0;
          else if (checkTile.liquid > (byte) 0)
          {
            if (checkTile.active())
            {
              if (checkTile.lava())
              {
                if (TileObjectData.CheckLavaDeath(checkTile))
                  WorldGen.KillTile(index1, index2);
              }
              else if (TileObjectData.CheckWaterDeath(checkTile))
                WorldGen.KillTile(index1, index2);
            }
            Tile tile1 = Main.tile[index1, index2 + 1];
            if ((!tile1.nactive() || !Main.tileSolid[(int) tile1.type] || Main.tileSolidTop[(int) tile1.type]) && tile1.liquid < byte.MaxValue)
            {
              if (tile1.liquid > (byte) 250)
                tile1.liquid = byte.MaxValue;
              else
                Liquid.AddWater(index1, index2);
            }
            Tile tile2 = Main.tile[index1 - 1, index2];
            Tile tile3 = Main.tile[index1 + 1, index2];
            if ((!tile2.nactive() || !Main.tileSolid[(int) tile2.type] || Main.tileSolidTop[(int) tile2.type]) && (int) tile2.liquid != (int) checkTile.liquid)
              Liquid.AddWater(index1, index2);
            else if ((!tile3.nactive() || !Main.tileSolid[(int) tile3.type] || Main.tileSolidTop[(int) tile3.type]) && (int) tile3.liquid != (int) checkTile.liquid)
              Liquid.AddWater(index1, index2);
            if (checkTile.lava())
            {
              if (tile2.liquid > (byte) 0 && !tile2.lava())
                Liquid.AddWater(index1, index2);
              else if (tile3.liquid > (byte) 0 && !tile3.lava())
                Liquid.AddWater(index1, index2);
              else if (Main.tile[index1, index2 - 1].liquid > (byte) 0 && !Main.tile[index1, index2 - 1].lava())
                Liquid.AddWater(index1, index2);
              else if (tile1.liquid > (byte) 0 && !tile1.lava())
                Liquid.AddWater(index1, index2);
            }
          }
        }
      }
      Liquid.tilesIgnoreWater(false);
    }

    public static void EveryTileFrame()
    {
      Stopwatch stopwatch = new Stopwatch();
      stopwatch.Start();
      WorldGen.noLiquidCheck = true;
      WorldGen.noTileActions = true;
      for (int i = 0; i < Main.maxTilesX; ++i)
      {
        float num = (float) i / (float) Main.maxTilesX;
        Main.statusText = Lang.gen[55].Value + " " + (object) (int) ((double) num * 100.0 + 1.0) + "%";
        for (int j = 0; j < Main.maxTilesY; ++j)
        {
          if (Main.tile[i, j].active())
            WorldGen.TileFrame(i, j, true);
          if (Main.tile[i, j].wall > (ushort) 0)
            Framing.WallFrame(i, j, true);
        }
      }
      WorldGen.noLiquidCheck = false;
      WorldGen.noTileActions = false;
      long elapsedMilliseconds = stopwatch.ElapsedMilliseconds;
    }

    public static void PlantCheck(int x, int y)
    {
      x = Utils.Clamp<int>(x, 1, Main.maxTilesX - 2);
      y = Utils.Clamp<int>(y, 1, Main.maxTilesY - 2);
      for (int index1 = x - 1; index1 <= x + 1; ++index1)
      {
        for (int index2 = y - 1; index2 <= y + 1; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            return;
        }
      }
      int num1 = -1;
      int num2 = (int) Main.tile[x, y].type;
      int num3 = x - 1;
      int num4 = x + 1;
      int maxTilesX = Main.maxTilesX;
      int num5 = y - 1;
      if (y + 1 >= Main.maxTilesY)
        num1 = num2;
      if (x - 1 >= 0 && Main.tile[x - 1, y] != null && Main.tile[x - 1, y].nactive())
      {
        int type1 = (int) Main.tile[x - 1, y].type;
      }
      if (x + 1 < Main.maxTilesX && Main.tile[x + 1, y] != null && Main.tile[x + 1, y].nactive())
      {
        int type2 = (int) Main.tile[x + 1, y].type;
      }
      if (y - 1 >= 0 && Main.tile[x, y - 1] != null && Main.tile[x, y - 1].nactive())
      {
        int type3 = (int) Main.tile[x, y - 1].type;
      }
      if (y + 1 < Main.maxTilesY && Main.tile[x, y + 1] != null && Main.tile[x, y + 1].nactive() && !Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == (byte) 0)
        num1 = (int) Main.tile[x, y + 1].type;
      if (x - 1 >= 0 && y - 1 >= 0 && Main.tile[x - 1, y - 1] != null && Main.tile[x - 1, y - 1].nactive())
      {
        int type4 = (int) Main.tile[x - 1, y - 1].type;
      }
      if (x + 1 < Main.maxTilesX && y - 1 >= 0 && Main.tile[x + 1, y - 1] != null && Main.tile[x + 1, y - 1].nactive())
      {
        int type5 = (int) Main.tile[x + 1, y - 1].type;
      }
      if (x - 1 >= 0 && y + 1 < Main.maxTilesY && Main.tile[x - 1, y + 1] != null && Main.tile[x - 1, y + 1].nactive())
      {
        int type6 = (int) Main.tile[x - 1, y + 1].type;
      }
      if (x + 1 < Main.maxTilesX && y + 1 < Main.maxTilesY && Main.tile[x + 1, y + 1] != null && Main.tile[x + 1, y + 1].nactive())
      {
        int type7 = (int) Main.tile[x + 1, y + 1].type;
      }
      if ((num2 != 3 || num1 == 2 || num1 == 477 || num1 == 78 || num1 == 380 || num1 == 579) && (num2 != 73 || num1 == 2 || num1 == 477 || num1 == 78 || num1 == 380 || num1 == 579) && (num2 != 24 || num1 == 23 || num1 == 661) && (num2 != 61 || num1 == 60) && (num2 != 74 || num1 == 60) && (num2 != 71 || num1 == 70) && (num2 != 110 || num1 == 109 || num1 == 492) && (num2 != 113 || num1 == 109 || num1 == 492) && (num2 != 201 || num1 == 199 || num1 == 662) && (num2 != 637 || num1 == 633))
        return;
      bool flag = false;
      if (num2 == 3 || num2 == 110 || num2 == 24)
        flag = Main.tile[x, y].frameX == (short) 144;
      if (num2 == 201)
        flag = Main.tile[x, y].frameX == (short) 270;
      if ((num2 == 3 || num2 == 73) && num1 != 2 && num1 != 477 && Main.tile[x, y].frameX >= (short) 162)
        Main.tile[x, y].frameX = (short) 126;
      if (num2 == 74 && num1 != 60 && Main.tile[x, y].frameX >= (short) 162)
        Main.tile[x, y].frameX = (short) 126;
      if (num1 == 23 || num1 == 661)
      {
        num2 = 24;
        if (Main.tile[x, y].frameX >= (short) 162)
          Main.tile[x, y].frameX = (short) 126;
      }
      else if (num1 == 2 || num1 == 477)
        num2 = num2 != 113 ? 3 : 73;
      else if (num1 == 109 || num1 == 492)
        num2 = num2 != 73 ? 110 : 113;
      else if (num1 == 199 || num1 == 662)
      {
        num2 = 201;
      }
      else
      {
        switch (num1)
        {
          case 60:
            num2 = 61;
            while (Main.tile[x, y].frameX > (short) 126)
              Main.tile[x, y].frameX -= (short) 126;
            break;
          case 70:
            num2 = 71;
            while (Main.tile[x, y].frameX > (short) 72)
              Main.tile[x, y].frameX -= (short) 72;
            break;
        }
      }
      if (num2 != (int) Main.tile[x, y].type)
      {
        Main.tile[x, y].type = (ushort) num2;
        if (!flag)
          return;
        Main.tile[x, y].frameX = (short) 144;
        if (num2 != 201)
          return;
        Main.tile[x, y].frameX = (short) 270;
      }
      else
        WorldGen.KillTile(x, y);
    }

    public static bool CanPoundTile(int x, int y)
    {
      if (Main.tile[x, y] == null)
        Main.tile[x, y] = new Tile();
      if (Main.tile[x, y - 1] == null)
        Main.tile[x, y - 1] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      switch (Main.tile[x, y].type)
      {
        case 10:
        case 48:
        case 137:
        case 138:
        case 232:
        case 380:
        case 387:
        case 388:
        case 476:
        case 484:
        case 664:
        case 665:
          return false;
        default:
          if (WorldGen.gen && (Main.tile[x, y].type == (ushort) 190 || Main.tile[x, y].type == (ushort) 30))
            return false;
          if (Main.tile[x, y - 1].active())
          {
            switch (Main.tile[x, y - 1].type)
            {
              case 21:
              case 26:
              case 77:
              case 88:
              case 235:
              case 237:
              case 441:
              case 467:
              case 468:
              case 470:
              case 475:
              case 488:
              case 597:
                return false;
            }
          }
          return WorldGen.CanKillTile(x, y);
      }
    }

    public static bool SlopeTile(int i, int j, int slope = 0, bool noEffects = false)
    {
      if (!WorldGen.CanPoundTile(i, j))
        return false;
      Main.tile[i, j].halfBrick(false);
      Main.tile[i, j].slope((byte) slope);
      if (!WorldGen.gen)
      {
        if (!noEffects)
          WorldGen.KillTile(i, j, true, true);
        SoundEngine.PlaySound(0, i * 16, j * 16);
        WorldGen.SquareTileFrame(i, j);
        if (Main.tile[i, j].slope() == (byte) 0)
        {
          Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(i * 16, j * 16, 16, 16);
          for (int index = 0; index < (int) byte.MaxValue; ++index)
          {
            if (Main.player[index].active && !Main.player[index].dead && rectangle.Intersects(new Microsoft.Xna.Framework.Rectangle((int) Main.player[index].position.X, (int) Main.player[index].position.Y, Main.player[index].width, Main.player[index].height)))
            {
              Main.player[index].gfxOffY += Main.player[index].position.Y + (float) Main.player[index].height - (float) rectangle.Y;
              Main.player[index].position.Y = (float) (rectangle.Y - Main.player[index].height);
            }
          }
        }
      }
      return true;
    }

    public static bool PoundTile(int i, int j)
    {
      if (!WorldGen.CanPoundTile(i, j))
        return false;
      if (!Main.tile[i, j].halfBrick())
        Main.tile[i, j].halfBrick(true);
      else
        Main.tile[i, j].halfBrick(false);
      if (!WorldGen.gen)
      {
        WorldGen.KillTile(i, j, true, true);
        SoundEngine.PlaySound(0, i * 16, j * 16);
        WorldGen.SquareTileFrame(i, j);
        if (!Main.tile[i, j].halfBrick())
        {
          Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(i * 16, j * 16, 16, 16);
          for (int index = 0; index < (int) byte.MaxValue; ++index)
          {
            if (Main.player[index].active && !Main.player[index].dead && rectangle.Intersects(new Microsoft.Xna.Framework.Rectangle((int) Main.player[index].position.X, (int) Main.player[index].position.Y, Main.player[index].width, Main.player[index].height)))
            {
              Main.player[index].gfxOffY += Main.player[index].position.Y + (float) Main.player[index].height - (float) rectangle.Y;
              Main.player[index].position.Y = (float) (rectangle.Y - Main.player[index].height);
            }
          }
        }
      }
      return true;
    }

    public static void PoundPlatform(int x, int y)
    {
      if (Main.tile[x, y].halfBrick())
      {
        WorldGen.PoundTile(x, y);
        if (Main.netMode != 1)
          return;
        NetMessage.SendData(17, number: 7, number2: ((float) x), number3: ((float) y), number4: 1f);
      }
      else
      {
        int slope1 = 1;
        int slope2 = 2;
        if (TileID.Sets.Platforms[(int) Main.tile[x + 1, y - 1].type] || TileID.Sets.Platforms[(int) Main.tile[x - 1, y + 1].type] || WorldGen.SolidTile(x + 1, y) && !WorldGen.SolidTile(x - 1, y))
        {
          slope1 = 2;
          slope2 = 1;
        }
        if (Main.tile[x, y].slope() == (byte) 0)
        {
          WorldGen.SlopeTile(x, y, slope1);
          int number4 = (int) Main.tile[x, y].slope();
          if (Main.netMode != 1)
            return;
          NetMessage.SendData(17, number: 14, number2: ((float) x), number3: ((float) y), number4: ((float) number4));
        }
        else if ((int) Main.tile[x, y].slope() == slope1)
        {
          WorldGen.SlopeTile(x, y, slope2);
          int number4 = (int) Main.tile[x, y].slope();
          if (Main.netMode != 1)
            return;
          NetMessage.SendData(17, number: 14, number2: ((float) x), number3: ((float) y), number4: ((float) number4));
        }
        else
        {
          WorldGen.SlopeTile(x, y);
          int number4 = (int) Main.tile[x, y].slope();
          if (Main.netMode == 1)
            NetMessage.SendData(17, number: 14, number2: ((float) x), number3: ((float) y), number4: ((float) number4));
          WorldGen.PoundTile(x, y);
          if (Main.netMode != 1)
            return;
          NetMessage.SendData(17, number: 7, number2: ((float) x), number3: ((float) y), number4: 1f);
        }
      }
    }

    public static int PlatformProperSides(int x, int y, bool acceptNonOpposing = false)
    {
      Tile tile = Main.tile[x, y];
      if (!tile.active() || !TileID.Sets.Platforms[(int) tile.type])
        return 0;
      int num1 = (int) tile.slope();
      int num2 = -1;
      if (num1 == 1)
        num2 = 2;
      if (num1 == 2)
        num2 = 1;
      int num3 = 0;
      int num4 = 1;
      int num5 = 0;
      if (num1 == 1)
        num5 = 1;
      if (num1 == 2)
        num5 = -1;
      if (acceptNonOpposing)
      {
        if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[(int) Main.tile[x + num4, y + num5].type] && (int) Main.tile[x + num4, y + num5].slope() != num2)
          ++num3;
      }
      else if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[(int) Main.tile[x + num4, y + num5].type] && (int) Main.tile[x + num4, y + num5].slope() == num1)
        ++num3;
      int num6 = num4 * -1;
      int num7 = num5 * -1;
      if (acceptNonOpposing)
      {
        if (Main.tile[x + num6, y + num7].active() && TileID.Sets.Platforms[(int) Main.tile[x + num6, y + num7].type] && (int) Main.tile[x + num6, y + num7].slope() != num2)
          ++num3;
      }
      else if (Main.tile[x + num6, y + num7].active() && TileID.Sets.Platforms[(int) Main.tile[x + num6, y + num7].type] && (int) Main.tile[x + num6, y + num7].slope() == num1)
        ++num3;
      return num3;
    }

    public static bool UpdateMapTile(int i, int j, bool addToList = true)
    {
      bool flag = false;
      if (!Main.dedServ && Main.mapEnabled && !WorldGen.noMapUpdate && !WorldGen.gen && !Main.refreshMap && ((Main.Map[i, j].Light <= (byte) 0 ? 0 : (Main.Map.UpdateType(i, j) ? 1 : 0)) & (addToList ? 1 : 0)) != 0)
      {
        flag = true;
        if (MapHelper.numUpdateTile < MapHelper.maxUpdateTile - 1)
        {
          MapHelper.updateTileX[MapHelper.numUpdateTile] = (short) i;
          MapHelper.updateTileY[MapHelper.numUpdateTile] = (short) j;
          ++MapHelper.numUpdateTile;
        }
        else
          Main.refreshMap = true;
      }
      return flag;
    }

    public static void TileMergeAttemptFrametest(
      int i,
      int j,
      int myType,
      int lookfor,
      ref int up,
      ref int down,
      ref int left,
      ref int right,
      ref int upLeft,
      ref int upRight,
      ref int downLeft,
      ref int downRight)
    {
      if (up == lookfor)
      {
        WorldGen.TileFrame(i, j - 1);
        if (WorldGen.mergeDown)
          up = myType;
      }
      if (down == lookfor)
      {
        WorldGen.TileFrame(i, j + 1);
        if (WorldGen.mergeUp)
          down = myType;
      }
      if (left == lookfor)
      {
        WorldGen.TileFrame(i - 1, j);
        if (WorldGen.mergeRight)
          left = myType;
      }
      if (right == lookfor)
      {
        WorldGen.TileFrame(i + 1, j);
        if (WorldGen.mergeLeft)
          right = myType;
      }
      if (upLeft == lookfor)
        upLeft = myType;
      if (upRight == lookfor)
        upRight = myType;
      if (downLeft == lookfor)
        downLeft = myType;
      if (downRight != lookfor)
        return;
      downRight = myType;
    }

    public static void TileMergeAttemptFrametest(
      int i,
      int j,
      int myType,
      bool[] lookfor,
      ref int up,
      ref int down,
      ref int left,
      ref int right,
      ref int upLeft,
      ref int upRight,
      ref int downLeft,
      ref int downRight)
    {
      if (up > -1 && lookfor[up])
      {
        WorldGen.TileFrame(i, j - 1);
        if (WorldGen.mergeDown)
          up = myType;
      }
      if (down > -1 && lookfor[down])
      {
        WorldGen.TileFrame(i, j + 1);
        if (WorldGen.mergeUp)
          down = myType;
      }
      if (left > -1 && lookfor[left])
      {
        WorldGen.TileFrame(i - 1, j);
        if (WorldGen.mergeRight)
          left = myType;
      }
      if (right > -1 && lookfor[right])
      {
        WorldGen.TileFrame(i + 1, j);
        if (WorldGen.mergeLeft)
          right = myType;
      }
      if (upLeft > -1 && lookfor[upLeft])
        upLeft = myType;
      if (upRight > -1 && lookfor[upRight])
        upRight = myType;
      if (downLeft > -1 && lookfor[downLeft])
        downLeft = myType;
      if (downRight <= -1 || !lookfor[downRight])
        return;
      downRight = myType;
    }

    public static void TileMergeAttempt(
      int myType,
      int lookfor,
      ref int up,
      ref int down,
      ref int left,
      ref int right)
    {
      if (lookfor == up)
        up = myType;
      if (lookfor == down)
        down = myType;
      if (lookfor == left)
        left = myType;
      if (lookfor != right)
        return;
      right = myType;
    }

    public static void TileMergeAttempt(
      int myType,
      bool[] lookfor,
      ref int up,
      ref int down,
      ref int left,
      ref int right)
    {
      if (up > -1 && lookfor[up])
        up = myType;
      if (down > -1 && lookfor[down])
        down = myType;
      if (left > -1 && lookfor[left])
        left = myType;
      if (right <= -1 || !lookfor[right])
        return;
      right = myType;
    }

    public static void TileMergeAttempt(
      int myType,
      int lookfor,
      ref int up,
      ref int down,
      ref int left,
      ref int right,
      ref int upLeft,
      ref int upRight,
      ref int downLeft,
      ref int downRight)
    {
      if (lookfor == up)
        up = myType;
      if (lookfor == down)
        down = myType;
      if (lookfor == left)
        left = myType;
      if (lookfor == right)
        right = myType;
      if (lookfor == upLeft)
        upLeft = myType;
      if (lookfor == upRight)
        upRight = myType;
      if (lookfor == downLeft)
        downLeft = myType;
      if (lookfor != downRight)
        return;
      downRight = myType;
    }

    public static void TileMergeAttempt(
      int myType,
      bool[] lookfor,
      ref int up,
      ref int down,
      ref int left,
      ref int right,
      ref int upLeft,
      ref int upRight,
      ref int downLeft,
      ref int downRight)
    {
      if (up > -1 && lookfor[up])
        up = myType;
      if (down > -1 && lookfor[down])
        down = myType;
      if (left > -1 && lookfor[left])
        left = myType;
      if (right > -1 && lookfor[right])
        right = myType;
      if (upLeft > -1 && lookfor[upLeft])
        upLeft = myType;
      if (upRight > -1 && lookfor[upRight])
        upRight = myType;
      if (downLeft > -1 && lookfor[downLeft])
        downLeft = myType;
      if (downRight <= -1 || !lookfor[downRight])
        return;
      downRight = myType;
    }

    public static void TileMergeAttempt(
      int myType,
      bool[] lookfor,
      bool[] exclude,
      ref int up,
      ref int down,
      ref int left,
      ref int right,
      ref int upLeft,
      ref int upRight,
      ref int downLeft,
      ref int downRight)
    {
      if (up > -1 && !exclude[up] && lookfor[up])
        up = myType;
      if (down > -1 && !exclude[down] && lookfor[down])
        down = myType;
      if (left > -1 && !exclude[left] && lookfor[left])
        left = myType;
      if (right > -1 && !exclude[right] && lookfor[right])
        right = myType;
      if (upLeft > -1 && !exclude[upLeft] && lookfor[upLeft])
        upLeft = myType;
      if (upRight > -1 && !exclude[upRight] && lookfor[upRight])
        upRight = myType;
      if (downLeft > -1 && !exclude[downLeft] && lookfor[downLeft])
        downLeft = myType;
      if (downRight <= -1 || exclude[downRight] || !lookfor[downRight])
        return;
      downRight = myType;
    }

    public static void TileMergeAttemptWeird(
      int myType,
      int changeTo,
      bool[] exclude,
      ref int up,
      ref int down,
      ref int left,
      ref int right,
      ref int upLeft,
      ref int upRight,
      ref int downLeft,
      ref int downRight)
    {
      if (up > -1 && !exclude[up] && up != myType)
        up = changeTo;
      if (down > -1 && !exclude[down] && down != myType)
        down = changeTo;
      if (left > -1 && !exclude[left] && left != myType)
        left = changeTo;
      if (right > -1 && !exclude[right] && right != myType)
        right = changeTo;
      if (upLeft > -1 && !exclude[upLeft] && upLeft != myType)
        upLeft = changeTo;
      if (upRight > -1 && !exclude[upRight] && upRight != myType)
        upRight = changeTo;
      if (downLeft > -1 && !exclude[downLeft] && downLeft != myType)
        downLeft = changeTo;
      if (downRight <= -1 || exclude[downRight] || downRight == myType)
        return;
      downRight = changeTo;
    }

    public static int GetTileMossColor(int tileType)
    {
      switch (tileType)
      {
        case 179:
        case 512:
          return 0;
        case 180:
        case 513:
          return 1;
        case 181:
        case 514:
          return 2;
        case 182:
        case 515:
          return 3;
        case 183:
        case 516:
          return 4;
        case 381:
        case 517:
          return 5;
        case 534:
        case 535:
          return 6;
        case 536:
        case 537:
          return 7;
        case 539:
        case 540:
          return 8;
        case 625:
        case 626:
          return 9;
        case 627:
        case 628:
          return 10;
        default:
          return -1;
      }
    }

    public static void CheckFoodPlatter(int x, int y, int type)
    {
      if (Main.tile[x, y] == null || WorldGen.destroyObject || WorldGen.SolidTileAllowBottomSlope(x, y + 1))
        return;
      if (type == 520)
      {
        int key = TEFoodPlatter.Find(x, y);
        if (key != -1 && ((TEFoodPlatter) TileEntity.ByID[key]).item.stack > 0)
        {
          ((TEFoodPlatter) TileEntity.ByID[key]).DropItem();
          if (Main.netMode != 2)
            Main.LocalPlayer.InterruptItemUsageIfOverTile(520);
        }
      }
      WorldGen.destroyObject = true;
      if ((int) Main.tile[x, y].type == type)
        WorldGen.KillTile(x, y);
      if (type == 520)
        TEFoodPlatter.Kill(x, y);
      WorldGen.destroyObject = false;
    }

    public static bool SkipFramingBecauseOfGen => WorldGen.generatingWorld && WorldGen.skipFramingDuringGen;

    public static void TileFrame(int i, int j, bool resetFrame = false, bool noBreak = false)
    {
      bool addToList = false;
      try
      {
        if (i > 5)
        {
          if (j > 5)
          {
            if (i < Main.maxTilesX - 5)
            {
              if (j < Main.maxTilesY - 5)
              {
                if (Main.tile[i, j] != null)
                {
                  if (WorldGen.SkipFramingBecauseOfGen && !Main.tileFrameImportant[(int) Main.tile[i, j].type])
                    return;
                  addToList = WorldGen.UpdateMapTile(i, j);
                  Tile tile1 = Main.tile[i, j];
                  if (!tile1.active())
                  {
                    tile1.halfBrick(false);
                    tile1.ClearBlockPaintAndCoating();
                    tile1.slope((byte) 0);
                  }
                  if (tile1.liquid > (byte) 0 && Main.netMode != 1 && !WorldGen.noLiquidCheck)
                    Liquid.AddWater(i, j);
                  if (tile1.active())
                  {
                    if (noBreak && Main.tileFrameImportant[(int) tile1.type] && tile1.type != (ushort) 4)
                      return;
                    int index1 = (int) tile1.type;
                    if (Main.tileStone[index1])
                      index1 = 1;
                    int frameX = (int) tile1.frameX;
                    int frameY = (int) tile1.frameY;
                    Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(-1, -1, 0, 0);
                    if (Main.tileFrameImportant[(int) tile1.type])
                    {
                      switch (index1)
                      {
                        case 4:
                          WorldGen.CheckTorch(i, j);
                          return;
                        case 136:
                          Tile tile2 = Main.tile[i, j - 1];
                          Tile tile3 = Main.tile[i, j + 1];
                          Tile tile4 = Main.tile[i - 1, j];
                          Tile tile5 = Main.tile[i + 1, j];
                          Tile tile6 = Main.tile[i - 1, j + 1];
                          Tile tile7 = Main.tile[i + 1, j + 1];
                          Tile tile8 = Main.tile[i - 1, j - 1];
                          Tile tile9 = Main.tile[i + 1, j - 1];
                          int index2 = -1;
                          int tree1 = -1;
                          int tree2 = -1;
                          int tree3 = -1;
                          int tree4 = -1;
                          int tree5 = -1;
                          int tree6 = -1;
                          if (tile2 != null && tile2.nactive())
                          {
                            int type = (int) tile2.type;
                          }
                          if (tile3 != null && tile3.nactive() && !tile3.halfBrick() && !tile3.topSlope())
                            index2 = (int) tile3.type;
                          if (tile4 != null && tile4.nactive())
                            tree1 = (int) tile4.type;
                          if (tile5 != null && tile5.nactive())
                            tree2 = (int) tile5.type;
                          if (tile6 != null && tile6.nactive())
                            tree3 = (int) tile6.type;
                          if (tile7 != null && tile7.nactive())
                            tree4 = (int) tile7.type;
                          if (tile8 != null && tile8.nactive())
                            tree5 = (int) tile8.type;
                          if (tile9 != null && tile9.nactive())
                            tree6 = (int) tile9.type;
                          if (index2 >= 0 && Main.tileSolid[index2] && !Main.tileNoAttach[index2] && tile3 != null && !tile3.halfBrick() && (tile3.slope() == (byte) 0 || tile3.bottomSlope()))
                          {
                            tile1.frameX = (short) 0;
                            return;
                          }
                          if (tree1 >= 0 && Main.tileSolid[tree1] && !Main.tileNoAttach[tree1] && tile4 != null && (tile4.leftSlope() || tile4.slope() == (byte) 0) && !tile4.halfBrick() || tree1 >= 0 && TileID.Sets.IsBeam[tree1] || WorldGen.IsTreeType(tree1) && WorldGen.IsTreeType(tree5) && WorldGen.IsTreeType(tree3))
                          {
                            tile1.frameX = (short) 18;
                            return;
                          }
                          if (tree2 >= 0 && Main.tileSolid[tree2] && !Main.tileNoAttach[tree2] && tile5 != null && (tile5.rightSlope() || tile5.slope() == (byte) 0) && !tile5.halfBrick() || tree2 >= 0 && TileID.Sets.IsBeam[tree2] || WorldGen.IsTreeType(tree2) && WorldGen.IsTreeType(tree6) && WorldGen.IsTreeType(tree4))
                          {
                            tile1.frameX = (short) 36;
                            return;
                          }
                          if (tile1.wall > (ushort) 0)
                          {
                            tile1.frameX = (short) 54;
                            return;
                          }
                          WorldGen.KillTile(i, j);
                          return;
                        case 442:
                          WorldGen.CheckProjectilePressurePad(i, j);
                          return;
                        case 518:
                          WorldGen.CheckLilyPad(i, j);
                          return;
                        case 519:
                          WorldGen.CheckCatTail(i, j);
                          return;
                        case 549:
                          WorldGen.CheckUnderwaterPlant((ushort) 549, i, j);
                          return;
                        case 571:
                          WorldGen.CheckBamboo(i, j);
                          return;
                        default:
                          if (index1 == 129 || index1 == 149)
                          {
                            Tile tile10 = Main.tile[i, j - 1];
                            Tile tile11 = Main.tile[i, j + 1];
                            Tile tile12 = Main.tile[i - 1, j];
                            Tile tile13 = Main.tile[i + 1, j];
                            int index3 = -1;
                            int index4 = -1;
                            int index5 = -1;
                            int index6 = -1;
                            if (tile10 != null && tile10.nactive() && !tile10.bottomSlope())
                              index4 = (int) tile10.type;
                            if (tile11 != null && tile11.nactive() && !tile11.halfBrick() && !tile11.topSlope())
                              index3 = (int) tile11.type;
                            if (tile12 != null && tile12.nactive() && !tile13.rightSlope())
                              index5 = (int) tile12.type;
                            if (tile13 != null && tile13.nactive() && !tile13.leftSlope())
                              index6 = (int) tile13.type;
                            if (index3 >= 0 && Main.tileSolid[index3] && !Main.tileSolidTop[index3])
                            {
                              tile1.frameY = (short) 0;
                              return;
                            }
                            if (index5 >= 0 && Main.tileSolid[index5] && !Main.tileSolidTop[index5])
                            {
                              tile1.frameY = (short) 54;
                              return;
                            }
                            if (index6 >= 0 && Main.tileSolid[index6] && !Main.tileSolidTop[index6])
                            {
                              tile1.frameY = (short) 36;
                              return;
                            }
                            if (index4 >= 0 && Main.tileSolid[index4] && !Main.tileSolidTop[index4])
                            {
                              tile1.frameY = (short) 18;
                              return;
                            }
                            WorldGen.KillTile(i, j);
                            return;
                          }
                          if (index1 >= 373 && index1 <= 375 || index1 == 461)
                          {
                            Tile tile14 = Main.tile[i, j - 1];
                            if (tile14 != null && tile14.active() && !tile14.bottomSlope() && Main.tileSolid[(int) tile14.type] && !Main.tileSolidTop[(int) tile14.type])
                              return;
                            WorldGen.KillTile(i, j);
                            return;
                          }
                          switch (index1)
                          {
                            case 178:
                              Tile tile15 = Main.tile[i, j - 1];
                              Tile tile16 = Main.tile[i, j + 1];
                              Tile tile17 = Main.tile[i - 1, j];
                              Tile tile18 = Main.tile[i + 1, j];
                              int index7 = -1;
                              int index8 = -1;
                              int index9 = -1;
                              int index10 = -1;
                              if (tile15 != null && tile15.nactive() && !tile15.bottomSlope())
                                index8 = (int) tile15.type;
                              if (tile16 != null && tile16.nactive() && !tile16.halfBrick() && !tile16.topSlope())
                                index7 = (int) tile16.type;
                              if (tile17 != null && tile17.nactive() && !tile17.halfBrick() && !tile17.rightSlope())
                                index9 = (int) tile17.type;
                              if (tile18 != null && tile18.nactive() && !tile18.halfBrick() && !tile18.leftSlope())
                                index10 = (int) tile18.type;
                              if (index9 == 10)
                                index9 = -1;
                              if (index10 == 10)
                                index10 = -1;
                              short num1 = (short) (WorldGen.genRand.Next(3) * 18);
                              if (index7 >= 0 && Main.tileSolid[index7] && !Main.tileSolidTop[index7])
                              {
                                if (tile1.frameY >= (short) 0 && tile1.frameY <= (short) 36)
                                  return;
                                tile1.frameY = num1;
                                return;
                              }
                              if (index9 >= 0 && Main.tileSolid[index9] && !Main.tileSolidTop[index9])
                              {
                                if (tile1.frameY >= (short) 108 && tile1.frameY <= (short) 54)
                                  return;
                                tile1.frameY = (short) (108 + (int) num1);
                                return;
                              }
                              if (index10 >= 0 && Main.tileSolid[index10] && !Main.tileSolidTop[index10])
                              {
                                if (tile1.frameY >= (short) 162 && tile1.frameY <= (short) 198)
                                  return;
                                tile1.frameY = (short) (162 + (int) num1);
                                return;
                              }
                              if (index8 >= 0 && Main.tileSolid[index8] && !Main.tileSolidTop[index8])
                              {
                                if (tile1.frameY >= (short) 54 && tile1.frameY <= (short) 90)
                                  return;
                                tile1.frameY = (short) (54 + (int) num1);
                                return;
                              }
                              WorldGen.KillTile(i, j);
                              return;
                            case 184:
                              Tile tile19 = Main.tile[i, j - 1];
                              Tile tile20 = Main.tile[i, j + 1];
                              Tile tile21 = Main.tile[i - 1, j];
                              Tile tile22 = Main.tile[i + 1, j];
                              int tileType1 = -1;
                              int tileType2 = -1;
                              int tileType3 = -1;
                              int tileType4 = -1;
                              if (tile19 != null && tile19.active() && !tile19.bottomSlope())
                                tileType2 = (int) tile19.type;
                              if (tile20 != null && tile20.active() && !tile20.halfBrick() && !tile20.topSlope())
                                tileType1 = (int) tile20.type;
                              if (tile21 != null && tile21.active())
                                tileType3 = (int) tile21.type;
                              if (tile22 != null && tile22.active())
                                tileType4 = (int) tile22.type;
                              short num2 = (short) (WorldGen.genRand.Next(3) * 18);
                              if (tileType1 >= 0 && WorldGen.GetTileMossColor(tileType1) != -1)
                              {
                                tile1.frameX = (short) (22 * WorldGen.GetTileMossColor(tileType1));
                                if (tile1.frameY >= (short) 0 && tile1.frameY <= (short) 36)
                                  return;
                                tile1.frameY = num2;
                                return;
                              }
                              if (tileType2 >= 0 && WorldGen.GetTileMossColor(tileType2) != -1)
                              {
                                tile1.frameX = (short) (22 * WorldGen.GetTileMossColor(tileType2));
                                if (tile1.frameY >= (short) 54 && tile1.frameY <= (short) 90)
                                  return;
                                tile1.frameY = (short) (54 + (int) num2);
                                return;
                              }
                              if (tileType3 >= 0 && WorldGen.GetTileMossColor(tileType3) != -1)
                              {
                                tile1.frameX = (short) (22 * WorldGen.GetTileMossColor(tileType3));
                                if (tile1.frameY >= (short) 108 && tile1.frameY <= (short) 144)
                                  return;
                                tile1.frameY = (short) (108 + (int) num2);
                                return;
                              }
                              if (tileType4 >= 0 && WorldGen.GetTileMossColor(tileType4) != -1)
                              {
                                tile1.frameX = (short) (22 * WorldGen.GetTileMossColor(tileType4));
                                if (tile1.frameY >= (short) 162 && tile1.frameY <= (short) 198)
                                  return;
                                tile1.frameY = (short) (162 + (int) num2);
                                return;
                              }
                              WorldGen.KillTile(i, j);
                              return;
                            case 529:
                              if (!WorldGen.SolidTileAllowBottomSlope(i, j + 1))
                              {
                                WorldGen.KillTile(i, j);
                                return;
                              }
                              Tile tile23 = Main.tile[i, j + 1];
                              int num3 = (int) Main.tile[i, j].frameY / 34;
                              if (tile23 != null && tile23.active() && (tile23.type < (ushort) 0 || (int) tile23.type >= (int) TileID.Count || TileID.Sets.Conversion.Sand[(int) tile23.type]))
                                return;
                              WorldGen.KillTile(i, j);
                              return;
                            default:
                              if (index1 == 3 || index1 == 24 || index1 == 61 || index1 == 71 || index1 == 73 || index1 == 74 || index1 == 110 || index1 == 113 || index1 == 201 || index1 == 637)
                              {
                                WorldGen.PlantCheck(i, j);
                                return;
                              }
                              if (index1 == 227)
                              {
                                WorldGen.CheckDye(i, j);
                                return;
                              }
                              if (index1 == 579)
                              {
                                WorldGen.CheckRockGolemHead(i, j);
                                return;
                              }
                              if (index1 == 12 || index1 == 31 || index1 == 639)
                              {
                                WorldGen.CheckOrb(i, j, index1);
                                return;
                              }
                              switch (index1)
                              {
                                case 165:
                                  WorldGen.CheckTight(i, j);
                                  return;
                                case 185:
                                  WorldGen.CheckPile(i, j);
                                  return;
                                case 235:
                                  WorldGen.Check3x1(i, j, index1);
                                  return;
                                case 324:
                                  if (WorldGen.SolidTileAllowBottomSlope(i, j + 1))
                                    return;
                                  WorldGen.KillTile(i, j);
                                  return;
                                default:
                                  if (index1 >= 275 && index1 <= 281 || index1 == 296 || index1 == 297 || index1 == 309 || index1 == 358 || index1 == 359 || index1 == 413 || index1 == 414 || index1 == 542 || index1 == 550 || index1 == 551 || index1 == 553 || index1 == 554 || index1 == 558 || index1 == 559 || index1 == 599 || index1 == 600 || index1 == 601 || index1 == 602 || index1 == 603 || index1 == 604 || index1 == 605 || index1 == 606 || index1 == 607 || index1 == 608 || index1 == 609 || index1 == 610 || index1 == 611 || index1 == 612 || index1 == 632 || index1 == 640 || index1 == 643 || index1 == 644 || index1 == 645)
                                  {
                                    WorldGen.Check6x3(i, j, index1);
                                    return;
                                  }
                                  switch (index1)
                                  {
                                    case 10:
                                      WorldGen.CheckDoorClosed(i, j, tile1, index1);
                                      return;
                                    case 11:
                                      WorldGen.CheckDoorOpen(i, j, tile1);
                                      return;
                                    case 314:
                                      Minecart.FrameTrack(i, j, false);
                                      Tile tile24 = Main.tile[i, j - 1];
                                      Tile tile25 = Main.tile[i, j + 1];
                                      if (tile24 != null && tile24.type >= (ushort) 0 && (int) tile24.type < (int) TileID.Count && Main.tileRope[(int) tile24.type])
                                        WorldGen.TileFrame(i, j - 1);
                                      if (tile25 == null || tile25.type < (ushort) 0 || (int) tile25.type >= (int) TileID.Count || !Main.tileRope[(int) tile25.type])
                                        return;
                                      WorldGen.TileFrame(i, j + 1);
                                      return;
                                    case 380:
                                      Tile tile26 = Main.tile[i - 1, j];
                                      if (tile26 == null)
                                        return;
                                      Tile tile27 = Main.tile[i + 1, j];
                                      if (tile27 == null || Main.tile[i - 1, j + 1] == null || Main.tile[i + 1, j + 1] == null || Main.tile[i - 1, j - 1] == null || Main.tile[i + 1, j - 1] == null)
                                        return;
                                      int index11 = -1;
                                      int index12 = -1;
                                      if (tile26 != null && tile26.active())
                                        index12 = !Main.tileStone[(int) tile26.type] ? (int) tile26.type : 1;
                                      if (tile27 != null && tile27.active())
                                        index11 = !Main.tileStone[(int) tile27.type] ? (int) tile27.type : 1;
                                      if (index11 >= 0 && !Main.tileSolid[index11])
                                        index11 = -1;
                                      if (index12 >= 0 && !Main.tileSolid[index12])
                                        index12 = -1;
                                      rectangle.X = index12 != index1 || index11 != index1 ? (index12 != index1 || index11 == index1 ? (index12 == index1 || index11 != index1 ? 54 : 0) : 36) : 18;
                                      tile1.frameX = (short) rectangle.X;
                                      return;
                                    default:
                                      if (index1 >= 0 && TileID.Sets.Platforms[index1])
                                      {
                                        Tile tile28 = Main.tile[i - 1, j];
                                        if (tile28 == null)
                                          return;
                                        Tile tile29 = Main.tile[i + 1, j];
                                        if (tile29 == null)
                                          return;
                                        Tile tile30 = Main.tile[i - 1, j + 1];
                                        if (tile30 == null)
                                          return;
                                        Tile tile31 = Main.tile[i + 1, j + 1];
                                        if (tile31 == null)
                                          return;
                                        Tile tile32 = Main.tile[i - 1, j - 1];
                                        if (tile32 == null)
                                          return;
                                        Tile tile33 = Main.tile[i + 1, j - 1];
                                        if (tile33 == null)
                                          return;
                                        int index13 = -1;
                                        int index14 = -1;
                                        if (tile28 != null && tile28.active())
                                          index14 = !Main.tileStone[(int) tile28.type] ? (!TileID.Sets.Platforms[(int) tile28.type] ? (int) tile28.type : index1) : 1;
                                        if (tile29 != null && tile29.active())
                                          index13 = !Main.tileStone[(int) tile29.type] ? (!TileID.Sets.Platforms[(int) tile29.type] ? (int) tile29.type : index1) : 1;
                                        if (index13 >= 0 && !Main.tileSolid[index13])
                                          index13 = -1;
                                        if (index14 >= 0 && !Main.tileSolid[index14])
                                          index14 = -1;
                                        if (index14 == index1 && tile28.halfBrick() != tile1.halfBrick())
                                          index14 = -1;
                                        if (index13 == index1 && tile29.halfBrick() != tile1.halfBrick())
                                          index13 = -1;
                                        if (index14 != -1 && index14 != index1 && tile1.halfBrick())
                                          index14 = -1;
                                        if (index13 != -1 && index13 != index1 && tile1.halfBrick())
                                          index13 = -1;
                                        if (index14 == -1 && tile32.active() && (int) tile32.type == index1 && tile32.slope() == (byte) 1)
                                          index14 = index1;
                                        if (index13 == -1 && tile33.active() && (int) tile33.type == index1 && tile33.slope() == (byte) 2)
                                          index13 = index1;
                                        if (index14 == index1 && tile28.slope() == (byte) 2 && index13 != index1)
                                          index13 = -1;
                                        if (index13 == index1 && tile29.slope() == (byte) 1 && index14 != index1)
                                          index14 = -1;
                                        rectangle.X = tile1.slope() != (byte) 1 ? (tile1.slope() != (byte) 2 ? (index14 != index1 || index13 != index1 ? (index14 != index1 || index13 != -1 ? (index14 != -1 || index13 != index1 ? (index14 == index1 || index13 != index1 ? (index14 != index1 || index13 == index1 ? (index14 == index1 || index14 == -1 || index13 != -1 ? (index14 != -1 || index13 == index1 || index13 == -1 ? 90 : 126) : 108) : 72) : 54) : (tile29.slope() != (byte) 1 ? 36 : 288)) : (tile28.slope() != (byte) 2 ? 18 : 270)) : (tile28.slope() != (byte) 2 || tile29.slope() != (byte) 1 ? (tile28.slope() != (byte) 2 ? (tile29.slope() != (byte) 1 ? 0 : 234) : 216) : 252)) : (!TileID.Sets.Platforms[(int) tile28.type] || tile28.slope() != (byte) 0 || tile28.halfBrick() ? (tile30.active() || TileID.Sets.Platforms[(int) tile30.type] && tile30.slope() != (byte) 1 ? (tile29.active() || TileID.Sets.Platforms[(int) tile33.type] && tile33.slope() == (byte) 2 ? 144 : 378) : (tile29.active() || TileID.Sets.Platforms[(int) tile33.type] && tile33.slope() == (byte) 2 ? 342 : 414)) : 450)) : (!TileID.Sets.Platforms[(int) tile29.type] || tile29.slope() != (byte) 0 || tile29.halfBrick() ? (tile31.active() || TileID.Sets.Platforms[(int) tile31.type] && tile31.slope() != (byte) 2 ? (tile28.active() || TileID.Sets.Platforms[(int) tile32.type] && tile32.slope() == (byte) 1 ? 180 : 396) : (tile28.active() || TileID.Sets.Platforms[(int) tile32.type] && tile32.slope() == (byte) 1 ? 360 : 432)) : 468);
                                        tile1.frameX = (short) rectangle.X;
                                        if (Main.tile[i, j - 1] != null && Main.tileRope[(int) Main.tile[i, j - 1].type])
                                          WorldGen.TileFrame(i, j - 1);
                                        if (Main.tile[i, j + 1] == null || !Main.tileRope[(int) Main.tile[i, j + 1].type])
                                          return;
                                        WorldGen.TileFrame(i, j + 1);
                                        return;
                                      }
                                      if (index1 == 233 || index1 == 236 || index1 == 238)
                                      {
                                        WorldGen.CheckJunglePlant(i, j, index1);
                                        return;
                                      }
                                      if (index1 == 530)
                                      {
                                        WorldGen.CheckOasisPlant(i, j);
                                        return;
                                      }
                                      if (index1 == 240 || index1 == 440)
                                      {
                                        WorldGen.Check3x3Wall(i, j);
                                        return;
                                      }
                                      switch (index1)
                                      {
                                        case 241:
                                          WorldGen.Check4x3Wall(i, j);
                                          return;
                                        case 242:
                                          WorldGen.Check6x4Wall(i, j);
                                          return;
                                        case 245:
                                          WorldGen.Check2x3Wall(i, j);
                                          return;
                                        case 246:
                                          WorldGen.Check3x2Wall(i, j);
                                          return;
                                        default:
                                          if (index1 == 464 || index1 == 466)
                                          {
                                            WorldGen.Check5x4(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 334)
                                          {
                                            WorldGen.CheckWeaponsRack(i, j);
                                            return;
                                          }
                                          if (index1 == 471)
                                          {
                                            TEWeaponsRack.Framing_CheckTile(i, j);
                                            return;
                                          }
                                          if (index1 == 34 || index1 == 454)
                                          {
                                            WorldGen.CheckChand(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 547 || index1 == 623)
                                          {
                                            WorldGen.Check2x5(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 548 || index1 == 614)
                                          {
                                            WorldGen.Check3x6(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 613)
                                          {
                                            WorldGen.Check3x5(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 106 || index1 == 212 || index1 == 219 || index1 == 220 || index1 == 228 || index1 == 231 || index1 == 243 || index1 == 247 || index1 == 283 || index1 >= 300 && index1 <= 308 || index1 == 354 || index1 == 406 || index1 == 412 || index1 == 355 || index1 == 452 || index1 == 455 || index1 == 491 || index1 == 499 || index1 == 642)
                                          {
                                            WorldGen.Check3x3(i, j, (int) (ushort) index1);
                                            return;
                                          }
                                          if (index1 == 15 || index1 == 497 || index1 == 20 || index1 == 590 || index1 == 216 || index1 == 338 || index1 == 390 || index1 == 493 || index1 == 595 || index1 == 615)
                                          {
                                            WorldGen.Check1x2(i, j, (ushort) index1);
                                            return;
                                          }
                                          if (index1 == 14 || index1 == 469 || index1 == 17 || index1 == 26 || index1 == 77 || index1 == 86 || index1 == 87 || index1 == 377 || index1 == 88 || index1 == 89 || index1 == 114 || index1 == 133 || index1 == 186 || index1 == 187 || index1 == 215 || index1 == 217 || index1 == 218 || index1 == 237 || index1 == 244 || index1 == 285 || index1 == 286 || index1 == 298 || index1 == 299 || index1 == 310 || index1 == 339 || index1 == 538 || index1 >= 361 && index1 <= 364 || index1 >= 391 && index1 <= 394 || index1 == 405 || index1 == 486 || index1 == 488 || index1 == 532 || index1 == 544 || index1 == 533 || index1 == 552 || index1 == 555 || index1 == 556 || index1 == 582 || index1 == 619 || index1 == 629 || index1 == 647 || index1 == 648 || index1 == 651)
                                          {
                                            WorldGen.Check3x2(i, j, (int) (ushort) index1);
                                            return;
                                          }
                                          if (index1 == 135 || index1 == 144 || index1 == 141 || index1 == 650 || index1 == 210 || index1 == 239 || index1 == 36 || index1 == 428 || index1 == 593 || index1 == 624 || index1 == 656)
                                          {
                                            WorldGen.Check1x1(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 476)
                                          {
                                            WorldGen.CheckGolf1x1(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 494)
                                          {
                                            WorldGen.CheckGolf1x1(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 419 || index1 == 420 || index1 == 423 || index1 == 424 || index1 == 429 || index1 == 445)
                                          {
                                            WorldGen.CheckLogicTiles(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 16 || index1 == 18 || index1 == 29 || index1 == 103 || index1 == 134 || index1 == 462 || index1 == 649)
                                          {
                                            WorldGen.Check2x1(i, j, (ushort) index1);
                                            return;
                                          }
                                          if (index1 == 13 || index1 == 33 || index1 == 50 || index1 == 78 || index1 == 174 || index1 == 372 || index1 == 49 || index1 == 646)
                                          {
                                            WorldGen.CheckOnTable1x1(i, j, index1);
                                            return;
                                          }
                                          if (TileID.Sets.BasicChest[index1])
                                          {
                                            WorldGen.CheckChest(i, j, index1);
                                            return;
                                          }
                                          switch (index1)
                                          {
                                            case 27:
                                              WorldGen.CheckSunflower(i, j);
                                              return;
                                            case 28:
                                            case 653:
                                              WorldGen.CheckPot(i, j, index1);
                                              return;
                                            case 128:
                                              WorldGen.CheckMan(i, j);
                                              return;
                                            case 171:
                                              WorldGen.CheckXmasTree(i, j);
                                              return;
                                            case 254:
                                              WorldGen.Check2x2Style(i, j, index1);
                                              return;
                                            case 269:
                                              WorldGen.CheckWoman(i, j);
                                              return;
                                            case 470:
                                              TEDisplayDoll.Framing_CheckTile(i, j);
                                              return;
                                            case 475:
                                              TEHatRack.Framing_CheckTile(i, j);
                                              return;
                                            case 597:
                                              TETeleportationPylon.Framing_CheckTile(i, j);
                                              return;
                                            default:
                                              if (!TileID.Sets.BasicChestFake[index1] && index1 != 457)
                                              {
                                                if (index1 == 335 || index1 == 411 || index1 == 490 || index1 == 564 || index1 == 565 || index1 == 594)
                                                {
                                                  WorldGen.Check2x2(i, j, index1);
                                                  return;
                                                }
                                                if (index1 == 132 || index1 == 138 || index1 == 484 || index1 == 664 || index1 == 665 || index1 == 142 || index1 == 143 || index1 >= 288 && index1 <= 295 || index1 >= 316 && index1 <= 318 || index1 == 172 || index1 == 360 || index1 == 505 || index1 == 521 || index1 == 522 || index1 == 523 || index1 == 524 || index1 == 525 || index1 == 526 || index1 == 527 || index1 == 543 || index1 == 568 || index1 == 569 || index1 == 570 || index1 == 580 || index1 == 598 || index1 == 620 || index1 == 652 || index1 == 654)
                                                {
                                                  WorldGen.Check2x2(i, j, index1);
                                                  return;
                                                }
                                                if (index1 == 376 || index1 == 443 || index1 == 444 || index1 == 485)
                                                {
                                                  WorldGen.CheckSuper(i, j, index1);
                                                  return;
                                                }
                                                if (index1 == 91)
                                                {
                                                  WorldGen.CheckBanner(i, j, (byte) index1);
                                                  return;
                                                }
                                                if (index1 == 139 || index1 == 35)
                                                {
                                                  WorldGen.CheckMB(i, j, (int) (byte) index1);
                                                  return;
                                                }
                                                if (index1 == 386 || index1 == 387)
                                                {
                                                  WorldGen.CheckTrapDoor(i, j, index1);
                                                  return;
                                                }
                                                if (index1 == 389 || index1 == 388)
                                                {
                                                  WorldGen.CheckTallGate(i, j, index1);
                                                  return;
                                                }
                                                if (index1 == 92 || index1 == 93 || index1 == 453)
                                                {
                                                  WorldGen.Check1xX(i, j, (short) index1);
                                                  return;
                                                }
                                                if (index1 == 104 || index1 == 105 || index1 == 207 || index1 == 320 || index1 == 337 || index1 == 349 || index1 == 356 || index1 == 378 || index1 == 410 || index1 == 456 || index1 == 465 || index1 == 480 || index1 == 489 || index1 == 506 || index1 == 509 || index1 == 531 || index1 == 545 || index1 == 560 || index1 == 591 || index1 == 592 || index1 == 657 || index1 == 658 || index1 == 663)
                                                {
                                                  WorldGen.Check2xX(i, j, (ushort) index1);
                                                  return;
                                                }
                                                if (index1 == 101 || index1 == 102 || index1 == 463 || index1 == 617)
                                                {
                                                  WorldGen.Check3x4(i, j, index1);
                                                  return;
                                                }
                                                if (index1 == 42 || index1 == 270 || index1 == 271 || index1 == 572 || index1 == 581 || index1 == 660)
                                                {
                                                  WorldGen.Check1x2Top(i, j, (ushort) index1);
                                                  return;
                                                }
                                                if (index1 == 55 || index1 == 85 || index1 == 395 || index1 == 425 || index1 == 510 || index1 == 511 || index1 == 573)
                                                {
                                                  WorldGen.CheckSign(i, j, (ushort) index1);
                                                  return;
                                                }
                                                if (index1 == 520)
                                                {
                                                  WorldGen.CheckFoodPlatter(i, j, (int) (ushort) index1);
                                                  return;
                                                }
                                                if (index1 == 209)
                                                {
                                                  WorldGen.CheckCannon(i, j, index1);
                                                  return;
                                                }
                                                if (index1 == 79 || index1 == 90 || index1 == 487)
                                                {
                                                  WorldGen.Check4x2(i, j, index1);
                                                  return;
                                                }
                                                if (index1 == 94 || index1 == 95 || index1 == 97 || index1 == 319 || index1 == 98 || index1 == 99 || index1 == 100 || index1 == 125 || index1 == 126 || index1 == 173 || index1 == 282 || index1 == 287 || index1 == 621 || index1 == 622)
                                                {
                                                  WorldGen.Check2x2(i, j, index1);
                                                  return;
                                                }
                                                switch (index1)
                                                {
                                                  case 81:
                                                    Tile tile34 = Main.tile[i, j - 1];
                                                    Tile tile35 = Main.tile[i, j + 1];
                                                    Tile tile36 = Main.tile[i - 1, j];
                                                    Tile tile37 = Main.tile[i + 1, j];
                                                    int index15 = -1;
                                                    int num4 = -1;
                                                    if (tile34 != null && tile34.active())
                                                      num4 = (int) tile34.type;
                                                    if (tile35 != null && tile35.active())
                                                      index15 = (int) tile35.type;
                                                    if (num4 != -1)
                                                    {
                                                      WorldGen.KillTile(i, j);
                                                      return;
                                                    }
                                                    if (index15 >= 0 && Main.tileSolid[index15] && (tile35 == null || !tile35.halfBrick() && !tile35.topSlope()))
                                                      return;
                                                    WorldGen.KillTile(i, j);
                                                    return;
                                                  case 96:
                                                    WorldGen.Check2x2Style(i, j, index1);
                                                    return;
                                                  default:
                                                    if (Main.tileAlch[index1])
                                                    {
                                                      WorldGen.CheckAlch(i, j);
                                                      return;
                                                    }
                                                    switch (index1)
                                                    {
                                                      case 5:
                                                        WorldGen.CheckTree(i, j);
                                                        return;
                                                      case 72:
                                                        Tile tile38 = Main.tile[i, j - 1];
                                                        Tile tile39 = Main.tile[i, j + 1];
                                                        int num5 = -1;
                                                        int num6 = -1;
                                                        if (tile38 != null && tile38.active())
                                                          num6 = (int) tile38.type;
                                                        if (tile39 != null && tile39.active())
                                                          num5 = (int) tile39.type;
                                                        if (num5 != index1 && num5 != 70)
                                                        {
                                                          WorldGen.KillTile(i, j);
                                                          return;
                                                        }
                                                        if (num6 == index1 || tile1.frameX != (short) 0)
                                                          return;
                                                        tile1.frameNumber((byte) WorldGen.genRand.Next(3));
                                                        if (tile1.frameNumber() == (byte) 0)
                                                        {
                                                          tile1.frameX = (short) 18;
                                                          tile1.frameY = (short) 0;
                                                        }
                                                        if (tile1.frameNumber() == (byte) 1)
                                                        {
                                                          tile1.frameX = (short) 18;
                                                          tile1.frameY = (short) 18;
                                                        }
                                                        if (tile1.frameNumber() != (byte) 2)
                                                          return;
                                                        tile1.frameX = (short) 18;
                                                        tile1.frameY = (short) 36;
                                                        return;
                                                      case 323:
                                                        WorldGen.CheckPalmTree(i, j);
                                                        return;
                                                      case 567:
                                                        WorldGen.CheckGnome(i, j);
                                                        return;
                                                      case 583:
                                                      case 584:
                                                      case 585:
                                                      case 586:
                                                      case 587:
                                                      case 588:
                                                      case 589:
                                                        WorldGen.CheckTreeWithSettings(i, j, new WorldGen.CheckTreeSettings()
                                                        {
                                                          IsGroundValid = new WorldGen.CheckTreeSettings.GroundValidTest(WorldGen.GemTreeGroundTest)
                                                        });
                                                        return;
                                                      case 596:
                                                        WorldGen.CheckTreeWithSettings(i, j, new WorldGen.CheckTreeSettings()
                                                        {
                                                          IsGroundValid = new WorldGen.CheckTreeSettings.GroundValidTest(WorldGen.VanityTreeGroundTest)
                                                        });
                                                        return;
                                                      case 616:
                                                        WorldGen.CheckTreeWithSettings(i, j, new WorldGen.CheckTreeSettings()
                                                        {
                                                          IsGroundValid = new WorldGen.CheckTreeSettings.GroundValidTest(WorldGen.VanityTreeGroundTest)
                                                        });
                                                        return;
                                                      case 630:
                                                      case 631:
                                                        WorldGen.CheckStinkbugBlocker(i, j);
                                                        return;
                                                      case 634:
                                                        WorldGen.CheckTreeWithSettings(i, j, new WorldGen.CheckTreeSettings()
                                                        {
                                                          IsGroundValid = new WorldGen.CheckTreeSettings.GroundValidTest(WorldGen.AshTreeGroundTest)
                                                        });
                                                        return;
                                                      default:
                                                        return;
                                                    }
                                                }
                                              }
                                              else
                                                goto case 254;
                                          }
                                      }
                                  }
                              }
                          }
                      }
                    }
                    else
                    {
                      if (index1 >= (int) byte.MaxValue && index1 <= 268 || index1 == 385 || index1 >= 446 && index1 <= 448)
                      {
                        Framing.SelfFrame8Way(i, j, tile1, resetFrame);
                        return;
                      }
                      Tile tileTopCache = Main.tile[i, j - 1];
                      Tile tileBottomCache = Main.tile[i, j + 1];
                      Tile tile40 = Main.tile[i - 1, j];
                      Tile tile41 = Main.tile[i + 1, j];
                      Tile tile42 = Main.tile[i - 1, j + 1];
                      Tile tile43 = Main.tile[i + 1, j + 1];
                      Tile tile44 = Main.tile[i - 1, j - 1];
                      Tile tile45 = Main.tile[i + 1, j - 1];
                      int upLeft = -1;
                      int up = -1;
                      int upRight = -1;
                      int left = -1;
                      int right = -1;
                      int downLeft = -1;
                      int down = -1;
                      int downRight = -1;
                      if (tile40 != null && tile40.active())
                      {
                        left = !Main.tileStone[(int) tile40.type] ? (int) tile40.type : 1;
                        if (tile40.slope() == (byte) 1 || tile40.slope() == (byte) 3)
                          left = -1;
                      }
                      if (tile41 != null && tile41.active())
                      {
                        right = !Main.tileStone[(int) tile41.type] ? (int) tile41.type : 1;
                        if (tile41.slope() == (byte) 2 || tile41.slope() == (byte) 4)
                          right = -1;
                      }
                      if (tileTopCache != null && tileTopCache.active())
                      {
                        up = !Main.tileStone[(int) tileTopCache.type] ? (int) tileTopCache.type : 1;
                        if (tileTopCache.slope() == (byte) 3 || tileTopCache.slope() == (byte) 4)
                          up = -1;
                      }
                      if (tileBottomCache != null && tileBottomCache.active())
                      {
                        down = !Main.tileStone[(int) tileBottomCache.type] ? (int) tileBottomCache.type : 1;
                        if (tileBottomCache.slope() == (byte) 1 || tileBottomCache.slope() == (byte) 2)
                          down = -1;
                      }
                      if (tile44 != null && tile44.active())
                        upLeft = !Main.tileStone[(int) tile44.type] ? (int) tile44.type : 1;
                      if (tile45 != null && tile45.active())
                        upRight = !Main.tileStone[(int) tile45.type] ? (int) tile45.type : 1;
                      if (tile42 != null && tile42.active())
                        downLeft = !Main.tileStone[(int) tile42.type] ? (int) tile42.type : 1;
                      if (tile43 != null && tile43.active())
                        downRight = !Main.tileStone[(int) tile43.type] ? (int) tile43.type : 1;
                      if (tile1.slope() == (byte) 2)
                      {
                        up = -1;
                        left = -1;
                      }
                      if (tile1.slope() == (byte) 1)
                      {
                        up = -1;
                        right = -1;
                      }
                      if (tile1.slope() == (byte) 4)
                      {
                        down = -1;
                        left = -1;
                      }
                      if (tile1.slope() == (byte) 3)
                      {
                        down = -1;
                        right = -1;
                      }
                      if (index1 == 668)
                        index1 = 0;
                      WorldGen.TileMergeAttempt(0, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      if (index1 == 147)
                        WorldGen.TileMergeAttempt(index1, Main.tileBrick, TileID.Sets.Ices, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      else if (index1 == 161 || index1 == 163 || index1 == 164 || index1 == 200)
                        WorldGen.TileMergeAttempt(index1, Main.tileBrick, TileID.Sets.Snow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      else if (index1 == 162)
                        WorldGen.TileMergeAttempt(index1, Main.tileBrick, TileID.Sets.IcesSnow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      else if (Main.tileBrick[index1])
                      {
                        switch (index1)
                        {
                          case 60:
                          case 70:
                          case 661:
                          case 662:
                            WorldGen.TileMergeAttempt(index1, Main.tileBrick, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            break;
                          case 633:
                            WorldGen.TileMergeAttempt(index1, Main.tileBrick, TileID.Sets.Ash, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            break;
                          default:
                            WorldGen.TileMergeAttempt(index1, Main.tileBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            break;
                        }
                      }
                      else if (Main.tilePile[index1])
                        WorldGen.TileMergeAttempt(index1, Main.tilePile, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      if ((index1 == 1 || Main.tileMoss[index1] || index1 == 117 || index1 == 25 || index1 == 203) && down == 165)
                      {
                        if (tileBottomCache != null && tileBottomCache.frameY == (short) 72)
                          down = index1;
                        else if (tileBottomCache != null && tileBottomCache.frameY == (short) 0)
                          down = index1;
                      }
                      if ((index1 == 1 || Main.tileMoss[index1] || index1 == 117 || index1 == 25 || index1 == 203) && up == 165)
                      {
                        if (tileTopCache != null && tileTopCache.frameY == (short) 90)
                          up = index1;
                        else if (tileTopCache != null && tileTopCache.frameY == (short) 54)
                          up = index1;
                      }
                      if (index1 == 225)
                      {
                        if (down == 165)
                          down = index1;
                        if (up == 165)
                          up = index1;
                      }
                      if ((index1 == 200 || index1 == 161 || index1 == 147 || index1 == 163 || index1 == 164) && down == 165)
                        down = index1;
                      if ((tile1.slope() == (byte) 1 || tile1.slope() == (byte) 2) && down > -1 && !TileID.Sets.Platforms[down])
                        down = index1;
                      if (up > -1 && tileTopCache != null && (tileTopCache.slope() == (byte) 1 || tileTopCache.slope() == (byte) 2) && !TileID.Sets.Platforms[up])
                        up = index1;
                      if ((tile1.slope() == (byte) 3 || tile1.slope() == (byte) 4) && up > -1 && !TileID.Sets.Platforms[up])
                        up = index1;
                      if (down > -1 && tileBottomCache != null && (tileBottomCache.slope() == (byte) 3 || tileBottomCache.slope() == (byte) 4) && !TileID.Sets.Platforms[down])
                        down = index1;
                      if (index1 == 124)
                      {
                        if (up > -1 && Main.tileSolid[up] && !TileID.Sets.Platforms[up])
                          up = index1;
                        if (down > -1 && Main.tileSolid[down] && !TileID.Sets.Platforms[down])
                          down = index1;
                      }
                      if (up > -1 && tileTopCache != null && tileTopCache.halfBrick() && !TileID.Sets.Platforms[up])
                        up = index1;
                      if (left > -1 && tile40 != null && tile40.halfBrick())
                      {
                        if (tile1.halfBrick())
                          left = index1;
                        else if ((int) tile40.type != index1)
                          left = -1;
                      }
                      if (right > -1 && tile41 != null && tile41.halfBrick())
                      {
                        if (tile1.halfBrick())
                          right = index1;
                        else if ((int) tile41.type != index1)
                          right = -1;
                      }
                      if (tile1.halfBrick())
                      {
                        if (left != index1)
                          left = -1;
                        if (right != index1)
                          right = -1;
                        up = -1;
                      }
                      if (tileBottomCache != null && tileBottomCache.halfBrick())
                        down = -1;
                      if (!Main.tileSolid[index1])
                      {
                        if (index1 == 49)
                        {
                          WorldGen.CheckOnTable1x1(i, j, (int) (byte) index1);
                          return;
                        }
                        if (index1 == 80)
                        {
                          WorldGen.CactusFrame(i, j);
                          return;
                        }
                      }
                      WorldGen.mergeUp = false;
                      WorldGen.mergeDown = false;
                      WorldGen.mergeLeft = false;
                      WorldGen.mergeRight = false;
                      int frameNumber;
                      if (resetFrame)
                      {
                        frameNumber = WorldGen.genRand.Next(0, 3);
                        tile1.frameNumber((byte) frameNumber);
                      }
                      else
                        frameNumber = (int) tile1.frameNumber();
                      if (Main.tileLargeFrames[index1] == (byte) 1)
                        frameNumber = new int[4, 3]
                        {
                          {
                            2,
                            4,
                            2
                          },
                          {
                            1,
                            3,
                            1
                          },
                          {
                            2,
                            2,
                            4
                          },
                          {
                            1,
                            1,
                            3
                          }
                        }[j % 4, i % 3] - 1;
                      if (Main.tileLargeFrames[index1] == (byte) 2)
                        frameNumber = i % 2 + j % 2 * 2;
                      if (!Main.tileRope[index1] && TileID.Sets.BlockMergesWithMergeAllBlock[index1])
                        WorldGen.TileMergeAttempt(index1, Main.tileBlendAll, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      if (Main.tileBlendAll[index1])
                        WorldGen.TileMergeAttempt(index1, TileID.Sets.BlockMergesWithMergeAllBlock, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      if (TileID.Sets.ForcedDirtMerging[index1])
                        WorldGen.TileMergeAttempt(index1, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      if (TileID.Sets.Dirt[index1])
                      {
                        if (up > -1 && Main.tileMergeDirt[up])
                        {
                          WorldGen.TileFrame(i, j - 1);
                          if (WorldGen.mergeDown)
                            up = index1;
                        }
                        else if (up == 147)
                        {
                          WorldGen.TileFrame(i, j - 1);
                          if (WorldGen.mergeDown)
                            up = index1;
                        }
                        if (down > -1 && Main.tileMergeDirt[down])
                        {
                          WorldGen.TileFrame(i, j + 1);
                          if (WorldGen.mergeUp)
                            down = index1;
                        }
                        else if (down == 147)
                        {
                          WorldGen.TileFrame(i, j + 1);
                          if (WorldGen.mergeUp)
                            down = index1;
                        }
                        if (left > -1 && Main.tileMergeDirt[left])
                        {
                          WorldGen.TileFrame(i - 1, j);
                          if (WorldGen.mergeRight)
                            left = index1;
                        }
                        else if (left == 147)
                        {
                          WorldGen.TileFrame(i - 1, j);
                          if (WorldGen.mergeRight)
                            left = index1;
                        }
                        if (right > -1 && Main.tileMergeDirt[right])
                        {
                          WorldGen.TileFrame(i + 1, j);
                          if (WorldGen.mergeLeft)
                            right = index1;
                        }
                        else if (right == 147)
                        {
                          WorldGen.TileFrame(i + 1, j);
                          if (WorldGen.mergeLeft)
                            right = index1;
                        }
                        bool[] dirtInAspecialWay = TileID.Sets.Conversion.MergesWithDirtInASpecialWay;
                        if (up > -1 && dirtInAspecialWay[up])
                          up = index1;
                        if (down > -1 && dirtInAspecialWay[down])
                          down = index1;
                        if (left > -1 && dirtInAspecialWay[left])
                          left = index1;
                        if (right > -1 && dirtInAspecialWay[right])
                          right = index1;
                        if (upLeft > -1 && Main.tileMergeDirt[upLeft])
                          upLeft = index1;
                        else if (upLeft > -1 && dirtInAspecialWay[upLeft])
                          upLeft = index1;
                        if (upRight > -1 && Main.tileMergeDirt[upRight])
                          upRight = index1;
                        else if (upRight > -1 && dirtInAspecialWay[upRight])
                          upRight = index1;
                        if (downLeft > -1 && Main.tileMergeDirt[downLeft])
                          downLeft = index1;
                        else if (downLeft > -1 && dirtInAspecialWay[downLeft])
                          downLeft = index1;
                        if (downRight > -1 && Main.tileMergeDirt[downRight])
                          downRight = index1;
                        else if (downRight > -1 && dirtInAspecialWay[downRight])
                          downRight = index1;
                        int myType = 0;
                        WorldGen.TileMergeAttempt(myType, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        WorldGen.TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        WorldGen.TileMergeAttempt(myType, 191, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        if (up > -1 && TileID.Sets.ForcedDirtMerging[up])
                          up = index1;
                        if (down > -1 && TileID.Sets.ForcedDirtMerging[down])
                          down = index1;
                        if (left > -1 && TileID.Sets.ForcedDirtMerging[left])
                          left = index1;
                        if (right > -1 && TileID.Sets.ForcedDirtMerging[right])
                          right = index1;
                        if (upLeft > -1 && TileID.Sets.ForcedDirtMerging[upLeft])
                          upLeft = index1;
                        if (upRight > -1 && TileID.Sets.ForcedDirtMerging[upRight])
                          upRight = index1;
                        if (downLeft > -1 && TileID.Sets.ForcedDirtMerging[downLeft])
                          downLeft = index1;
                        if (downRight > -1 && TileID.Sets.ForcedDirtMerging[downRight])
                          downRight = index1;
                      }
                      else if (Main.tileRope[index1])
                      {
                        if (index1 != 504 && up != index1 && WorldGen.IsRope(i, j - 1))
                          up = index1;
                        if (down != index1 && WorldGen.IsRope(i, j + 1))
                          down = index1;
                        if (index1 != 504 && up > -1 && Main.tileSolid[up] && !Main.tileSolidTop[up])
                          up = index1;
                        if (down > -1 && Main.tileSolid[down])
                          down = index1;
                        if (index1 != 504 && up != index1)
                        {
                          if (left > -1 && Main.tileSolid[left])
                            left = index1;
                          if (right > -1 && Main.tileSolid[right])
                            right = index1;
                        }
                      }
                      else
                      {
                        switch (index1)
                        {
                          case 53:
                            WorldGen.TileMergeAttemptFrametest(i, j, index1, 397, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            WorldGen.TileMergeAttemptFrametest(i, j, index1, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            break;
                          case 112:
                            WorldGen.TileMergeAttemptFrametest(i, j, index1, 398, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            WorldGen.TileMergeAttemptFrametest(i, j, index1, 400, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            break;
                          case 116:
                            WorldGen.TileMergeAttemptFrametest(i, j, index1, 402, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            WorldGen.TileMergeAttemptFrametest(i, j, index1, 403, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            break;
                          case 234:
                            WorldGen.TileMergeAttemptFrametest(i, j, index1, 399, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            WorldGen.TileMergeAttemptFrametest(i, j, index1, 401, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            break;
                        }
                      }
                      if (Main.tileMergeDirt[index1])
                      {
                        WorldGen.TileMergeAttempt(-2, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        if (index1 == 1)
                        {
                          if ((double) j > Main.rockLayer)
                            WorldGen.TileMergeAttemptFrametest(i, j, index1, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          WorldGen.TileMergeAttemptFrametest(i, j, index1, TileID.Sets.Ash, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        }
                      }
                      else if (index1 == 58 || index1 == 76 || index1 == 75)
                      {
                        WorldGen.TileMergeAttempt(-2, TileID.Sets.Ash, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      }
                      else
                      {
                        switch (index1)
                        {
                          case 57:
                            WorldGen.TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            WorldGen.TileMergeAttempt(index1, 633, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            WorldGen.TileMergeAttemptFrametest(i, j, index1, TileID.Sets.HellSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            break;
                          case 59:
                            if ((double) j > Main.rockLayer)
                              WorldGen.TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            WorldGen.TileMergeAttempt(index1, TileID.Sets.GrassSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            WorldGen.TileMergeAttemptFrametest(i, j, index1, TileID.Sets.JungleSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            if ((double) j < Main.rockLayer)
                            {
                              WorldGen.TileMergeAttemptFrametest(i, j, index1, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                              break;
                            }
                            WorldGen.TileMergeAttempt(index1, TileID.Sets.Dirt, ref up, ref down, ref left, ref right);
                            break;
                          case 211:
                            WorldGen.TileMergeAttempt(59, 60, ref up, ref down, ref left, ref right);
                            WorldGen.TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            break;
                          default:
                            if (index1 == 225 || index1 == 226)
                            {
                              WorldGen.TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                              break;
                            }
                            switch (index1)
                            {
                              case 60:
                                WorldGen.TileMergeAttempt(59, 211, ref up, ref down, ref left, ref right);
                                break;
                              case 147:
                                WorldGen.TileMergeAttemptFrametest(i, j, index1, TileID.Sets.IcesSlush, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                break;
                              case 189:
                                WorldGen.TileMergeAttemptFrametest(i, j, index1, TileID.Sets.MergesWithClouds, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                break;
                              case 196:
                                WorldGen.TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                WorldGen.TileMergeAttempt(index1, 460, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                break;
                              case 460:
                                WorldGen.TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                WorldGen.TileMergeAttempt(index1, 196, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                break;
                              default:
                                if (index1 == 161 || index1 == 163 || index1 == 164 || index1 == 200 || index1 == 224)
                                {
                                  WorldGen.TileMergeAttempt(-2, 147, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 162)
                                {
                                  WorldGen.TileMergeAttempt(-2, TileID.Sets.IcesSnow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 32)
                                {
                                  if (down == 23)
                                  {
                                    down = index1;
                                    break;
                                  }
                                  break;
                                }
                                if (index1 == 352)
                                {
                                  if (down == 199)
                                  {
                                    down = index1;
                                    break;
                                  }
                                  break;
                                }
                                if (index1 == 69)
                                {
                                  if (down == 60)
                                  {
                                    down = index1;
                                    break;
                                  }
                                  break;
                                }
                                if (index1 == 655)
                                {
                                  if (down == 60)
                                  {
                                    down = index1;
                                    break;
                                  }
                                  break;
                                }
                                if (index1 == 51)
                                {
                                  WorldGen.TileMergeAttempt(index1, TileID.Sets.AllTiles, Main.tileNoAttach, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 192)
                                {
                                  WorldGen.TileMergeAttemptFrametest(i, j, index1, 191, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 191)
                                {
                                  WorldGen.TileMergeAttempt(-2, 192, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttempt(index1, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 384)
                                {
                                  WorldGen.TileMergeAttemptFrametest(i, j, index1, 383, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 383)
                                {
                                  WorldGen.TileMergeAttempt(-2, 384, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttempt(index1, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 407)
                                {
                                  WorldGen.TileMergeAttempt(-2, 404, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 404)
                                {
                                  WorldGen.TileMergeAttempt(-2, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttemptFrametest(i, j, index1, 407, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 397)
                                {
                                  WorldGen.TileMergeAttempt(-2, 53, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttemptFrametest(i, j, index1, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 396)
                                {
                                  WorldGen.TileMergeAttempt(-2, 397, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttempt(-2, 53, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttemptFrametest(i, j, index1, 404, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 398)
                                {
                                  WorldGen.TileMergeAttempt(-2, 112, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttemptFrametest(i, j, index1, 400, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 400)
                                {
                                  WorldGen.TileMergeAttempt(-2, 398, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttempt(-2, 112, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 399)
                                {
                                  WorldGen.TileMergeAttempt(-2, 234, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttemptFrametest(i, j, index1, 401, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 401)
                                {
                                  WorldGen.TileMergeAttempt(-2, 399, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttempt(-2, 234, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 402)
                                {
                                  WorldGen.TileMergeAttempt(-2, 116, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttemptFrametest(i, j, index1, 403, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 403)
                                {
                                  WorldGen.TileMergeAttempt(-2, 402, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttempt(-2, 116, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                break;
                            }
                            break;
                        }
                      }
                      if (index1 == 0)
                      {
                        WorldGen.TileMergeAttempt(index1, Main.tileMoss, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        WorldGen.TileMergeAttempt(index1, TileID.Sets.tileMossBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      }
                      else if (Main.tileMoss[index1] || TileID.Sets.tileMossBrick[index1])
                      {
                        WorldGen.TileMergeAttempt(index1, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      }
                      else
                      {
                        if (!Main.tileStone[index1])
                        {
                          switch (index1)
                          {
                            case 1:
                              break;
                            case 38:
                              WorldGen.TileMergeAttempt(index1, TileID.Sets.tileMossBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                              goto label_585;
                            default:
                              goto label_585;
                          }
                        }
                        WorldGen.TileMergeAttempt(index1, Main.tileMoss, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      }
label_585:
                      if (TileID.Sets.Conversion.Grass[index1])
                        WorldGen.TileMergeAttempt(index1, TileID.Sets.Ore, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      else if (TileID.Sets.Ore[index1])
                        WorldGen.TileMergeAttempt(index1, TileID.Sets.Conversion.Grass, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      if (index1 >= 0 && index1 < (int) TileID.Count && TileID.Sets.Mud[index1])
                        WorldGen.TileMergeAttempt(index1, TileID.Sets.OreMergesWithMud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      else if (TileID.Sets.OreMergesWithMud[index1])
                        WorldGen.TileMergeAttempt(index1, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      bool flag1 = false;
                      WorldGen.TileMergeCullCache tileMergeCullCache = new WorldGen.TileMergeCullCache();
                      if (!Main.ShouldShowInvisibleWalls())
                      {
                        bool flag2 = tile1.invisibleBlock();
                        ref bool local1 = ref tileMergeCullCache.CullTop;
                        local1 = ((local1 ? 1 : 0) | (tileTopCache == null ? 0 : (tileTopCache.invisibleBlock() != flag2 ? 1 : 0))) != 0;
                        ref bool local2 = ref tileMergeCullCache.CullBottom;
                        local2 = ((local2 ? 1 : 0) | (tileBottomCache == null ? 0 : (tileBottomCache.invisibleBlock() != flag2 ? 1 : 0))) != 0;
                        ref bool local3 = ref tileMergeCullCache.CullLeft;
                        local3 = ((local3 ? 1 : 0) | (tile40 == null ? 0 : (tile40.invisibleBlock() != flag2 ? 1 : 0))) != 0;
                        ref bool local4 = ref tileMergeCullCache.CullRight;
                        local4 = ((local4 ? 1 : 0) | (tile41 == null ? 0 : (tile41.invisibleBlock() != flag2 ? 1 : 0))) != 0;
                        ref bool local5 = ref tileMergeCullCache.CullTopLeft;
                        local5 = ((local5 ? 1 : 0) | (tile44 == null ? 0 : (tile44.invisibleBlock() != flag2 ? 1 : 0))) != 0;
                        ref bool local6 = ref tileMergeCullCache.CullTopRight;
                        local6 = ((local6 ? 1 : 0) | (tile45 == null ? 0 : (tile45.invisibleBlock() != flag2 ? 1 : 0))) != 0;
                        ref bool local7 = ref tileMergeCullCache.CullBottomLeft;
                        local7 = ((local7 ? 1 : 0) | (tile42 == null ? 0 : (tile42.invisibleBlock() != flag2 ? 1 : 0))) != 0;
                        ref bool local8 = ref tileMergeCullCache.CullBottomRight;
                        local8 = ((local8 ? 1 : 0) | (tile43 == null ? 0 : (tile43.invisibleBlock() != flag2 ? 1 : 0))) != 0;
                      }
                      if (index1 == 2 || index1 == 23 || index1 == 661 || index1 == 662 || index1 == 60 || index1 == 477 || index1 == 492 || index1 == 70 || index1 == 109 || index1 == 199 || Main.tileMoss[index1] || TileID.Sets.NeedsGrassFraming[index1] || TileID.Sets.tileMossBrick[index1])
                      {
                        flag1 = true;
                        WorldGen.TileMergeAttemptWeird(index1, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        int index16 = TileID.Sets.NeedsGrassFramingDirt[index1];
                        if (index1 == 60 || index1 == 70 || index1 == 661 || index1 == 662)
                          index16 = 59;
                        else if (Main.tileMoss[index1])
                          index16 = 1;
                        else if (TileID.Sets.tileMossBrick[index1])
                        {
                          index16 = 38;
                        }
                        else
                        {
                          switch (index1)
                          {
                            case 2:
                            case 477:
                              WorldGen.TileMergeAttempt(index16, 23, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                              break;
                            case 23:
                              WorldGen.TileMergeAttempt(index16, 2, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                              break;
                          }
                        }
                        tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        if (up != index1 && up != index16 && (down == index1 || down == index16))
                        {
                          if (left == index16 && right == index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 0;
                                rectangle.Y = 198;
                                break;
                              case 1:
                                rectangle.X = 18;
                                rectangle.Y = 198;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 198;
                                break;
                            }
                          }
                          else if (left == index1 && right == index16)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 198;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 198;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 198;
                                break;
                            }
                          }
                        }
                        else if (down != index1 && down != index16 && (up == index1 || up == index16))
                        {
                          if (left == index16 && right == index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 0;
                                rectangle.Y = 216;
                                break;
                              case 1:
                                rectangle.X = 18;
                                rectangle.Y = 216;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 216;
                                break;
                            }
                          }
                          else if (left == index1 && right == index16)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 216;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 216;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 216;
                                break;
                            }
                          }
                        }
                        else if (left != index1 && left != index16 && (right == index1 || right == index16))
                        {
                          if (up == index16 && down == index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 72;
                                rectangle.Y = 144;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 162;
                                break;
                              default:
                                rectangle.X = 72;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                          else if (down == index1 && up == index16)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 72;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 108;
                                break;
                              default:
                                rectangle.X = 72;
                                rectangle.Y = 126;
                                break;
                            }
                          }
                        }
                        else if (right != index1 && right != index16 && (left == index1 || left == index16))
                        {
                          if (up == index16 && down == index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 90;
                                rectangle.Y = 144;
                                break;
                              case 1:
                                rectangle.X = 90;
                                rectangle.Y = 162;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                          else if (down == index1 && right == up)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 90;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 90;
                                rectangle.Y = 108;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 126;
                                break;
                            }
                          }
                        }
                        else if (up == index1 && down == index1 && left == index1 && right == index1)
                        {
                          if (upLeft != index1 && upRight != index1 && downLeft != index1 && downRight != index1)
                          {
                            if (downRight == index16)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 108;
                                  rectangle.Y = 324;
                                  break;
                                case 1:
                                  rectangle.X = 126;
                                  rectangle.Y = 324;
                                  break;
                                default:
                                  rectangle.X = 144;
                                  rectangle.Y = 324;
                                  break;
                              }
                            }
                            else if (upRight == index16)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 108;
                                  rectangle.Y = 342;
                                  break;
                                case 1:
                                  rectangle.X = 126;
                                  rectangle.Y = 342;
                                  break;
                                default:
                                  rectangle.X = 144;
                                  rectangle.Y = 342;
                                  break;
                              }
                            }
                            else if (downLeft == index16)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 108;
                                  rectangle.Y = 360;
                                  break;
                                case 1:
                                  rectangle.X = 126;
                                  rectangle.Y = 360;
                                  break;
                                default:
                                  rectangle.X = 144;
                                  rectangle.Y = 360;
                                  break;
                              }
                            }
                            else if (upLeft == index16)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 108;
                                  rectangle.Y = 378;
                                  break;
                                case 1:
                                  rectangle.X = 126;
                                  rectangle.Y = 378;
                                  break;
                                default:
                                  rectangle.X = 144;
                                  rectangle.Y = 378;
                                  break;
                              }
                            }
                            else
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 144;
                                  rectangle.Y = 234;
                                  break;
                                case 1:
                                  rectangle.X = 198;
                                  rectangle.Y = 234;
                                  break;
                                default:
                                  rectangle.X = 252;
                                  rectangle.Y = 234;
                                  break;
                              }
                            }
                          }
                          else if (upLeft != index1 && downRight != index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 306;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 306;
                                break;
                              default:
                                rectangle.X = 72;
                                rectangle.Y = 306;
                                break;
                            }
                          }
                          else if (upRight != index1 && downLeft != index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 90;
                                rectangle.Y = 306;
                                break;
                              case 1:
                                rectangle.X = 108;
                                rectangle.Y = 306;
                                break;
                              default:
                                rectangle.X = 126;
                                rectangle.Y = 306;
                                break;
                            }
                          }
                          else if (upLeft != index1 && upRight == index1 && downLeft == index1 && downRight == index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                          else if (upLeft == index1 && upRight != index1 && downLeft == index1 && downRight == index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                          else if (upLeft == index1 && upRight == index1 && downLeft != index1 && downRight == index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 162;
                                break;
                            }
                          }
                          else if (upLeft == index1 && upRight == index1 && downLeft == index1 && downRight != index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 162;
                                break;
                            }
                          }
                        }
                        else if (up == index1 && down == index16 && left == index1 && right == index1 && upLeft == -1 && upRight == -1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 108;
                              rectangle.Y = 18;
                              break;
                            case 1:
                              rectangle.X = 126;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 144;
                              rectangle.Y = 18;
                              break;
                          }
                        }
                        else if (up == index16 && down == index1 && left == index1 && right == index1 && downLeft == -1 && downRight == -1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 108;
                              rectangle.Y = 36;
                              break;
                            case 1:
                              rectangle.X = 126;
                              rectangle.Y = 36;
                              break;
                            default:
                              rectangle.X = 144;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up == index1 && down == index1 && left == index16 && right == index1 && upRight == -1 && downRight == -1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 198;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 198;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 198;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up == index1 && down == index1 && left == index1 && right == index16 && upLeft == -1 && downLeft == -1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 180;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 180;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 180;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up == index1 && down == index16 && left == index1 && right == index1)
                        {
                          if (upRight != -1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                          else if (upLeft != -1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                        }
                        else if (up == index16 && down == index1 && left == index1 && right == index1)
                        {
                          if (downRight != -1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 162;
                                break;
                            }
                          }
                          else if (downLeft != -1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 162;
                                break;
                            }
                          }
                        }
                        else if (up == index1 && down == index1 && left == index1 && right == index16)
                        {
                          if (upLeft != -1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 162;
                                break;
                            }
                          }
                          else if (downLeft != -1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                        }
                        else if (up == index1 && down == index1 && left == index16 && right == index1)
                        {
                          if (upRight != -1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 162;
                                break;
                            }
                          }
                          else if (downRight != -1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                        }
                        else if (up == index16 && down == index1 && left == index1 && right == index1 || up == index1 && down == index16 && left == index1 && right == index1 || up == index1 && down == index1 && left == index16 && right == index1 || up == index1 && down == index1 && left == index1 && right == index16)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 18;
                              rectangle.Y = 18;
                              break;
                            case 1:
                              rectangle.X = 36;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 54;
                              rectangle.Y = 18;
                              break;
                          }
                        }
                        if ((up == index1 || up == index16) && (down == index1 || down == index16) && (left == index1 || left == index16) && (right == index1 || right == index16))
                        {
                          if (upLeft != index1 && upLeft != index16 && (upRight == index1 || upRight == index16) && (downLeft == index1 || downLeft == index16) && (downRight == index1 || downRight == index16))
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                          else if (upRight != index1 && upRight != index16 && (upLeft == index1 || upLeft == index16) && (downLeft == index1 || downLeft == index16) && (downRight == index1 || downRight == index16))
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                          else if (downLeft != index1 && downLeft != index16 && (upLeft == index1 || upLeft == index16) && (upRight == index1 || upRight == index16) && (downRight == index1 || downRight == index16))
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 162;
                                break;
                            }
                          }
                          else if (downRight != index1 && downRight != index16 && (upLeft == index1 || upLeft == index16) && (downLeft == index1 || downLeft == index16) && (upRight == index1 || upRight == index16))
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 162;
                                break;
                            }
                          }
                        }
                        if (up != index16 && up != index1 && down == index1 && left != index16 && left != index1 && right == index1 && downRight != index16 && downRight != index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 90;
                              rectangle.Y = 270;
                              break;
                            case 1:
                              rectangle.X = 108;
                              rectangle.Y = 270;
                              break;
                            default:
                              rectangle.X = 126;
                              rectangle.Y = 270;
                              break;
                          }
                        }
                        else if (up != index16 && up != index1 && down == index1 && left == index1 && right != index16 && right != index1 && downLeft != index16 && downLeft != index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 144;
                              rectangle.Y = 270;
                              break;
                            case 1:
                              rectangle.X = 162;
                              rectangle.Y = 270;
                              break;
                            default:
                              rectangle.X = 180;
                              rectangle.Y = 270;
                              break;
                          }
                        }
                        else if (down != index16 && down != index1 && up == index1 && left != index16 && left != index1 && right == index1 && upRight != index16 && upRight != index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 90;
                              rectangle.Y = 288;
                              break;
                            case 1:
                              rectangle.X = 108;
                              rectangle.Y = 288;
                              break;
                            default:
                              rectangle.X = 126;
                              rectangle.Y = 288;
                              break;
                          }
                        }
                        else if (down != index16 && down != index1 && up == index1 && left == index1 && right != index16 && right != index1 && upLeft != index16 && upLeft != index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 144;
                              rectangle.Y = 288;
                              break;
                            case 1:
                              rectangle.X = 162;
                              rectangle.Y = 288;
                              break;
                            default:
                              rectangle.X = 180;
                              rectangle.Y = 288;
                              break;
                          }
                        }
                        else if (up != index1 && up != index16 && down == index1 && left == index1 && right == index1 && downLeft != index1 && downLeft != index16 && downRight != index1 && downRight != index16)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 144;
                              rectangle.Y = 216;
                              break;
                            case 1:
                              rectangle.X = 198;
                              rectangle.Y = 216;
                              break;
                            default:
                              rectangle.X = 252;
                              rectangle.Y = 216;
                              break;
                          }
                        }
                        else if (down != index1 && down != index16 && up == index1 && left == index1 && right == index1 && upLeft != index1 && upLeft != index16 && upRight != index1 && upRight != index16)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 144;
                              rectangle.Y = 252;
                              break;
                            case 1:
                              rectangle.X = 198;
                              rectangle.Y = 252;
                              break;
                            default:
                              rectangle.X = 252;
                              rectangle.Y = 252;
                              break;
                          }
                        }
                        else if (left != index1 && left != index16 && down == index1 && up == index1 && right == index1 && upRight != index1 && upRight != index16 && downRight != index1 && downRight != index16)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 126;
                              rectangle.Y = 234;
                              break;
                            case 1:
                              rectangle.X = 180;
                              rectangle.Y = 234;
                              break;
                            default:
                              rectangle.X = 234;
                              rectangle.Y = 234;
                              break;
                          }
                        }
                        else if (right != index1 && right != index16 && down == index1 && up == index1 && left == index1 && upLeft != index1 && upLeft != index16 && downLeft != index1 && downLeft != index16)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 162;
                              rectangle.Y = 234;
                              break;
                            case 1:
                              rectangle.X = 216;
                              rectangle.Y = 234;
                              break;
                            default:
                              rectangle.X = 270;
                              rectangle.Y = 234;
                              break;
                          }
                        }
                        else if (up != index16 && up != index1 && (down == index16 || down == index1) && left == index16 && right == index16)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 36;
                              rectangle.Y = 270;
                              break;
                            case 1:
                              rectangle.X = 54;
                              rectangle.Y = 270;
                              break;
                            default:
                              rectangle.X = 72;
                              rectangle.Y = 270;
                              break;
                          }
                        }
                        else if (down != index16 && down != index1 && (up == index16 || up == index1) && left == index16 && right == index16)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 36;
                              rectangle.Y = 288;
                              break;
                            case 1:
                              rectangle.X = 54;
                              rectangle.Y = 288;
                              break;
                            default:
                              rectangle.X = 72;
                              rectangle.Y = 288;
                              break;
                          }
                        }
                        else if (left != index16 && left != index1 && (right == index16 || right == index1) && up == index16 && down == index16)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 0;
                              rectangle.Y = 270;
                              break;
                            case 1:
                              rectangle.X = 0;
                              rectangle.Y = 288;
                              break;
                            default:
                              rectangle.X = 0;
                              rectangle.Y = 306;
                              break;
                          }
                        }
                        else if (right != index16 && right != index1 && (left == index16 || left == index1) && up == index16 && down == index16)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 18;
                              rectangle.Y = 270;
                              break;
                            case 1:
                              rectangle.X = 18;
                              rectangle.Y = 288;
                              break;
                            default:
                              rectangle.X = 18;
                              rectangle.Y = 306;
                              break;
                          }
                        }
                        else if (up == index1 && down == index16 && left == index16 && right == index16)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 198;
                              rectangle.Y = 288;
                              break;
                            case 1:
                              rectangle.X = 216;
                              rectangle.Y = 288;
                              break;
                            default:
                              rectangle.X = 234;
                              rectangle.Y = 288;
                              break;
                          }
                        }
                        else if (up == index16 && down == index1 && left == index16 && right == index16)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 198;
                              rectangle.Y = 270;
                              break;
                            case 1:
                              rectangle.X = 216;
                              rectangle.Y = 270;
                              break;
                            default:
                              rectangle.X = 234;
                              rectangle.Y = 270;
                              break;
                          }
                        }
                        else if (up == index16 && down == index16 && left == index1 && right == index16)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 198;
                              rectangle.Y = 306;
                              break;
                            case 1:
                              rectangle.X = 216;
                              rectangle.Y = 306;
                              break;
                            default:
                              rectangle.X = 234;
                              rectangle.Y = 306;
                              break;
                          }
                        }
                        else if (up == index16 && down == index16 && left == index16 && right == index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 144;
                              rectangle.Y = 306;
                              break;
                            case 1:
                              rectangle.X = 162;
                              rectangle.Y = 306;
                              break;
                            default:
                              rectangle.X = 180;
                              rectangle.Y = 306;
                              break;
                          }
                        }
                        if (up != index1 && up != index16 && down == index1 && left == index1 && right == index1)
                        {
                          if ((downLeft == index16 || downLeft == index1) && downRight != index16 && downRight != index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 0;
                                rectangle.Y = 324;
                                break;
                              case 1:
                                rectangle.X = 18;
                                rectangle.Y = 324;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 324;
                                break;
                            }
                          }
                          else if ((downRight == index16 || downRight == index1) && downLeft != index16 && downLeft != index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 324;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 324;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 324;
                                break;
                            }
                          }
                        }
                        else if (down != index1 && down != index16 && up == index1 && left == index1 && right == index1)
                        {
                          if ((upLeft == index16 || upLeft == index1) && upRight != index16 && upRight != index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 0;
                                rectangle.Y = 342;
                                break;
                              case 1:
                                rectangle.X = 18;
                                rectangle.Y = 342;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 342;
                                break;
                            }
                          }
                          else if ((upRight == index16 || upRight == index1) && upLeft != index16 && upLeft != index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 342;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 342;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 342;
                                break;
                            }
                          }
                        }
                        else if (left != index1 && left != index16 && up == index1 && down == index1 && right == index1)
                        {
                          if ((upRight == index16 || upRight == index1) && downRight != index16 && downRight != index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 360;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 360;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 360;
                                break;
                            }
                          }
                          else if ((downRight == index16 || downRight == index1) && upRight != index16 && upRight != index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 0;
                                rectangle.Y = 360;
                                break;
                              case 1:
                                rectangle.X = 18;
                                rectangle.Y = 360;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 360;
                                break;
                            }
                          }
                        }
                        else if (right != index1 && right != index16 && up == index1 && down == index1 && left == index1)
                        {
                          if ((upLeft == index16 || upLeft == index1) && downLeft != index16 && downLeft != index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 0;
                                rectangle.Y = 378;
                                break;
                              case 1:
                                rectangle.X = 18;
                                rectangle.Y = 378;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 378;
                                break;
                            }
                          }
                          else if ((downLeft == index16 || downLeft == index1) && upLeft != index16 && upLeft != index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 378;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 378;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 378;
                                break;
                            }
                          }
                        }
                        if ((up == index1 || up == index16) && (down == index1 || down == index16) && (left == index1 || left == index16) && (right == index1 || right == index16) && upLeft != -1 && upRight != -1 && downLeft != -1 && downRight != -1)
                        {
                          if ((i + j) % 2 == 1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 108;
                                rectangle.Y = 198;
                                break;
                              case 1:
                                rectangle.X = 126;
                                rectangle.Y = 198;
                                break;
                              default:
                                rectangle.X = 144;
                                rectangle.Y = 198;
                                break;
                            }
                          }
                          else
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 18;
                                rectangle.Y = 18;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 18;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 18;
                                break;
                            }
                          }
                        }
                        if (index16 >= 0 && index16 < (int) TileID.Count && TileID.Sets.Dirt[index16])
                          WorldGen.TileMergeAttempt(-2, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        else if (index16 >= 0 && index16 < (int) TileID.Count && TileID.Sets.Mud[index16])
                          WorldGen.TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        else
                          WorldGen.TileMergeAttempt(-2, index16, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      }
                      WorldGen.TileMergeAttempt(index1, Main.tileMerge[index1], ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      if (rectangle.X == -1 && rectangle.Y == -1 && (Main.tileMergeDirt[index1] || index1 > -1 && TileID.Sets.ChecksForMerge[index1]))
                      {
                        if (!flag1)
                        {
                          flag1 = true;
                          WorldGen.TileMergeAttemptWeird(index1, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        }
                        if (up > -1 && up != index1)
                          up = -1;
                        if (down > -1 && down != index1)
                          down = -1;
                        if (left > -1 && left != index1)
                          left = -1;
                        if (right > -1 && right != index1)
                          right = -1;
                        tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        if (up != -1 && down != -1 && left != -1 && right != -1)
                        {
                          if (up == -2 && down == index1 && left == index1 && right == index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 144;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 162;
                                rectangle.Y = 108;
                                break;
                              default:
                                rectangle.X = 180;
                                rectangle.Y = 108;
                                break;
                            }
                            WorldGen.mergeUp = true;
                          }
                          else if (up == index1 && down == -2 && left == index1 && right == index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 144;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 162;
                                rectangle.Y = 90;
                                break;
                              default:
                                rectangle.X = 180;
                                rectangle.Y = 90;
                                break;
                            }
                            WorldGen.mergeDown = true;
                          }
                          else if (up == index1 && down == index1 && left == -2 && right == index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 162;
                                rectangle.Y = 126;
                                break;
                              case 1:
                                rectangle.X = 162;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 162;
                                rectangle.Y = 162;
                                break;
                            }
                            WorldGen.mergeLeft = true;
                          }
                          else if (up == index1 && down == index1 && left == index1 && right == -2)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 144;
                                rectangle.Y = 126;
                                break;
                              case 1:
                                rectangle.X = 144;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 144;
                                rectangle.Y = 162;
                                break;
                            }
                            WorldGen.mergeRight = true;
                          }
                          else if (up == -2 && down == index1 && left == -2 && right == index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 162;
                                break;
                            }
                            WorldGen.mergeUp = true;
                            WorldGen.mergeLeft = true;
                          }
                          else if (up == -2 && down == index1 && left == index1 && right == -2)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 162;
                                break;
                            }
                            WorldGen.mergeUp = true;
                            WorldGen.mergeRight = true;
                          }
                          else if (up == index1 && down == -2 && left == -2 && right == index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 180;
                                break;
                            }
                            WorldGen.mergeDown = true;
                            WorldGen.mergeLeft = true;
                          }
                          else if (up == index1 && down == -2 && left == index1 && right == -2)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 180;
                                break;
                            }
                            WorldGen.mergeDown = true;
                            WorldGen.mergeRight = true;
                          }
                          else if (up == index1 && down == index1 && left == -2 && right == -2)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 180;
                                rectangle.Y = 126;
                                break;
                              case 1:
                                rectangle.X = 180;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 180;
                                rectangle.Y = 162;
                                break;
                            }
                            WorldGen.mergeLeft = true;
                            WorldGen.mergeRight = true;
                          }
                          else if (up == -2 && down == -2 && left == index1 && right == index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 144;
                                rectangle.Y = 180;
                                break;
                              case 1:
                                rectangle.X = 162;
                                rectangle.Y = 180;
                                break;
                              default:
                                rectangle.X = 180;
                                rectangle.Y = 180;
                                break;
                            }
                            WorldGen.mergeUp = true;
                            WorldGen.mergeDown = true;
                          }
                          else if (up == -2 && down == index1 && left == -2 && right == -2)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 198;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 198;
                                rectangle.Y = 108;
                                break;
                              default:
                                rectangle.X = 198;
                                rectangle.Y = 126;
                                break;
                            }
                            WorldGen.mergeUp = true;
                            WorldGen.mergeLeft = true;
                            WorldGen.mergeRight = true;
                          }
                          else if (up == index1 && down == -2 && left == -2 && right == -2)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 198;
                                rectangle.Y = 144;
                                break;
                              case 1:
                                rectangle.X = 198;
                                rectangle.Y = 162;
                                break;
                              default:
                                rectangle.X = 198;
                                rectangle.Y = 180;
                                break;
                            }
                            WorldGen.mergeDown = true;
                            WorldGen.mergeLeft = true;
                            WorldGen.mergeRight = true;
                          }
                          else if (up == -2 && down == -2 && left == index1 && right == -2)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 216;
                                rectangle.Y = 144;
                                break;
                              case 1:
                                rectangle.X = 216;
                                rectangle.Y = 162;
                                break;
                              default:
                                rectangle.X = 216;
                                rectangle.Y = 180;
                                break;
                            }
                            WorldGen.mergeUp = true;
                            WorldGen.mergeDown = true;
                            WorldGen.mergeRight = true;
                          }
                          else if (up == -2 && down == -2 && left == -2 && right == index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 216;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 216;
                                rectangle.Y = 108;
                                break;
                              default:
                                rectangle.X = 216;
                                rectangle.Y = 126;
                                break;
                            }
                            WorldGen.mergeUp = true;
                            WorldGen.mergeDown = true;
                            WorldGen.mergeLeft = true;
                          }
                          else if (up == -2 && down == -2 && left == -2 && right == -2)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 108;
                                rectangle.Y = 198;
                                break;
                              case 1:
                                rectangle.X = 126;
                                rectangle.Y = 198;
                                break;
                              default:
                                rectangle.X = 144;
                                rectangle.Y = 198;
                                break;
                            }
                            WorldGen.mergeUp = true;
                            WorldGen.mergeDown = true;
                            WorldGen.mergeLeft = true;
                            WorldGen.mergeRight = true;
                          }
                          else if (up == index1 && down == index1 && left == index1 && right == index1)
                          {
                            if (upLeft == -2)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 18;
                                  rectangle.Y = 108;
                                  break;
                                case 1:
                                  rectangle.X = 18;
                                  rectangle.Y = 144;
                                  break;
                                default:
                                  rectangle.X = 18;
                                  rectangle.Y = 180;
                                  break;
                              }
                            }
                            if (upRight == -2)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 0;
                                  rectangle.Y = 108;
                                  break;
                                case 1:
                                  rectangle.X = 0;
                                  rectangle.Y = 144;
                                  break;
                                default:
                                  rectangle.X = 0;
                                  rectangle.Y = 180;
                                  break;
                              }
                            }
                            if (downLeft == -2)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 18;
                                  rectangle.Y = 90;
                                  break;
                                case 1:
                                  rectangle.X = 18;
                                  rectangle.Y = 126;
                                  break;
                                default:
                                  rectangle.X = 18;
                                  rectangle.Y = 162;
                                  break;
                              }
                            }
                            if (downRight == -2)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 0;
                                  rectangle.Y = 90;
                                  break;
                                case 1:
                                  rectangle.X = 0;
                                  rectangle.Y = 126;
                                  break;
                                default:
                                  rectangle.X = 0;
                                  rectangle.Y = 162;
                                  break;
                              }
                            }
                          }
                        }
                        else
                        {
                          if (index1 != 2 && index1 != 23 && index1 != 60 && index1 != 70 && index1 != 109 && index1 != 199 && index1 != 477 && index1 != 492 && index1 != 633 && index1 != 661 && index1 != 662)
                          {
                            if (up == -1 && down == -2 && left == index1 && right == index1)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 234;
                                  rectangle.Y = 0;
                                  break;
                                case 1:
                                  rectangle.X = 252;
                                  rectangle.Y = 0;
                                  break;
                                default:
                                  rectangle.X = 270;
                                  rectangle.Y = 0;
                                  break;
                              }
                              WorldGen.mergeDown = true;
                            }
                            else if (up == -2 && down == -1 && left == index1 && right == index1)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 234;
                                  rectangle.Y = 18;
                                  break;
                                case 1:
                                  rectangle.X = 252;
                                  rectangle.Y = 18;
                                  break;
                                default:
                                  rectangle.X = 270;
                                  rectangle.Y = 18;
                                  break;
                              }
                              WorldGen.mergeUp = true;
                            }
                            else if (up == index1 && down == index1 && left == -1 && right == -2)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 234;
                                  rectangle.Y = 36;
                                  break;
                                case 1:
                                  rectangle.X = 252;
                                  rectangle.Y = 36;
                                  break;
                                default:
                                  rectangle.X = 270;
                                  rectangle.Y = 36;
                                  break;
                              }
                              WorldGen.mergeRight = true;
                            }
                            else if (up == index1 && down == index1 && left == -2 && right == -1)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 234;
                                  rectangle.Y = 54;
                                  break;
                                case 1:
                                  rectangle.X = 252;
                                  rectangle.Y = 54;
                                  break;
                                default:
                                  rectangle.X = 270;
                                  rectangle.Y = 54;
                                  break;
                              }
                              WorldGen.mergeLeft = true;
                            }
                          }
                          if (up != -1 && down != -1 && left == -1 && right == index1)
                          {
                            if (up == -2 && down == index1)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 72;
                                  rectangle.Y = 144;
                                  break;
                                case 1:
                                  rectangle.X = 72;
                                  rectangle.Y = 162;
                                  break;
                                default:
                                  rectangle.X = 72;
                                  rectangle.Y = 180;
                                  break;
                              }
                              WorldGen.mergeUp = true;
                            }
                            else if (down == -2 && up == index1)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 72;
                                  rectangle.Y = 90;
                                  break;
                                case 1:
                                  rectangle.X = 72;
                                  rectangle.Y = 108;
                                  break;
                                default:
                                  rectangle.X = 72;
                                  rectangle.Y = 126;
                                  break;
                              }
                              WorldGen.mergeDown = true;
                            }
                          }
                          else if (up != -1 && down != -1 && left == index1 && right == -1)
                          {
                            if (up == -2 && down == index1)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 90;
                                  rectangle.Y = 144;
                                  break;
                                case 1:
                                  rectangle.X = 90;
                                  rectangle.Y = 162;
                                  break;
                                default:
                                  rectangle.X = 90;
                                  rectangle.Y = 180;
                                  break;
                              }
                              WorldGen.mergeUp = true;
                            }
                            else if (down == -2 && up == index1)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 90;
                                  rectangle.Y = 90;
                                  break;
                                case 1:
                                  rectangle.X = 90;
                                  rectangle.Y = 108;
                                  break;
                                default:
                                  rectangle.X = 90;
                                  rectangle.Y = 126;
                                  break;
                              }
                              WorldGen.mergeDown = true;
                            }
                          }
                          else if (up == -1 && down == index1 && left != -1 && right != -1)
                          {
                            if (left == -2 && right == index1)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 0;
                                  rectangle.Y = 198;
                                  break;
                                case 1:
                                  rectangle.X = 18;
                                  rectangle.Y = 198;
                                  break;
                                default:
                                  rectangle.X = 36;
                                  rectangle.Y = 198;
                                  break;
                              }
                              WorldGen.mergeLeft = true;
                            }
                            else if (right == -2 && left == index1)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 54;
                                  rectangle.Y = 198;
                                  break;
                                case 1:
                                  rectangle.X = 72;
                                  rectangle.Y = 198;
                                  break;
                                default:
                                  rectangle.X = 90;
                                  rectangle.Y = 198;
                                  break;
                              }
                              WorldGen.mergeRight = true;
                            }
                          }
                          else if (up == index1 && down == -1 && left != -1 && right != -1)
                          {
                            if (left == -2 && right == index1)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 0;
                                  rectangle.Y = 216;
                                  break;
                                case 1:
                                  rectangle.X = 18;
                                  rectangle.Y = 216;
                                  break;
                                default:
                                  rectangle.X = 36;
                                  rectangle.Y = 216;
                                  break;
                              }
                              WorldGen.mergeLeft = true;
                            }
                            else if (right == -2 && left == index1)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 54;
                                  rectangle.Y = 216;
                                  break;
                                case 1:
                                  rectangle.X = 72;
                                  rectangle.Y = 216;
                                  break;
                                default:
                                  rectangle.X = 90;
                                  rectangle.Y = 216;
                                  break;
                              }
                              WorldGen.mergeRight = true;
                            }
                          }
                          else if (up != -1 && down != -1 && left == -1 && right == -1)
                          {
                            if (up == -2 && down == -2)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 108;
                                  rectangle.Y = 216;
                                  break;
                                case 1:
                                  rectangle.X = 108;
                                  rectangle.Y = 234;
                                  break;
                                default:
                                  rectangle.X = 108;
                                  rectangle.Y = 252;
                                  break;
                              }
                              WorldGen.mergeUp = true;
                              WorldGen.mergeDown = true;
                            }
                            else if (up == -2)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 126;
                                  rectangle.Y = 144;
                                  break;
                                case 1:
                                  rectangle.X = 126;
                                  rectangle.Y = 162;
                                  break;
                                default:
                                  rectangle.X = 126;
                                  rectangle.Y = 180;
                                  break;
                              }
                              WorldGen.mergeUp = true;
                            }
                            else if (down == -2)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 126;
                                  rectangle.Y = 90;
                                  break;
                                case 1:
                                  rectangle.X = 126;
                                  rectangle.Y = 108;
                                  break;
                                default:
                                  rectangle.X = 126;
                                  rectangle.Y = 126;
                                  break;
                              }
                              WorldGen.mergeDown = true;
                            }
                          }
                          else if (up == -1 && down == -1 && left != -1 && right != -1)
                          {
                            if (left == -2 && right == -2)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 162;
                                  rectangle.Y = 198;
                                  break;
                                case 1:
                                  rectangle.X = 180;
                                  rectangle.Y = 198;
                                  break;
                                default:
                                  rectangle.X = 198;
                                  rectangle.Y = 198;
                                  break;
                              }
                              WorldGen.mergeLeft = true;
                              WorldGen.mergeRight = true;
                            }
                            else if (left == -2)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 0;
                                  rectangle.Y = 252;
                                  break;
                                case 1:
                                  rectangle.X = 18;
                                  rectangle.Y = 252;
                                  break;
                                default:
                                  rectangle.X = 36;
                                  rectangle.Y = 252;
                                  break;
                              }
                              WorldGen.mergeLeft = true;
                            }
                            else if (right == -2)
                            {
                              switch (frameNumber)
                              {
                                case 0:
                                  rectangle.X = 54;
                                  rectangle.Y = 252;
                                  break;
                                case 1:
                                  rectangle.X = 72;
                                  rectangle.Y = 252;
                                  break;
                                default:
                                  rectangle.X = 90;
                                  rectangle.Y = 252;
                                  break;
                              }
                              WorldGen.mergeRight = true;
                            }
                          }
                          else if (up == -2 && down == -1 && left == -1 && right == -1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 108;
                                rectangle.Y = 144;
                                break;
                              case 1:
                                rectangle.X = 108;
                                rectangle.Y = 162;
                                break;
                              default:
                                rectangle.X = 108;
                                rectangle.Y = 180;
                                break;
                            }
                            WorldGen.mergeUp = true;
                          }
                          else if (up == -1 && down == -2 && left == -1 && right == -1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 108;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 108;
                                rectangle.Y = 108;
                                break;
                              default:
                                rectangle.X = 108;
                                rectangle.Y = 126;
                                break;
                            }
                            WorldGen.mergeDown = true;
                          }
                          else if (up == -1 && down == -1 && left == -2 && right == -1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 0;
                                rectangle.Y = 234;
                                break;
                              case 1:
                                rectangle.X = 18;
                                rectangle.Y = 234;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 234;
                                break;
                            }
                            WorldGen.mergeLeft = true;
                          }
                          else if (up == -1 && down == -1 && left == -1 && right == -2)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 234;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 234;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 234;
                                break;
                            }
                            WorldGen.mergeRight = true;
                          }
                        }
                      }
                      int num7 = tile1.blockType();
                      if (TileID.Sets.HasSlopeFrames[index1])
                      {
                        if (num7 == 0)
                        {
                          bool flag3 = index1 == up && tileTopCache != null && tileTopCache.topSlope();
                          bool flag4 = index1 == left && tile40 != null && tile40.leftSlope();
                          bool flag5 = index1 == right && tile41 != null && tile41.rightSlope();
                          bool flag6 = index1 == down && tileBottomCache != null && tileBottomCache.bottomSlope();
                          int num8 = 0;
                          int num9 = 0;
                          if (flag3.ToInt() + flag4.ToInt() + flag5.ToInt() + flag6.ToInt() > 2)
                          {
                            int num10 = (tileTopCache != null && tileTopCache.slope() == (byte) 1).ToInt() + (tile41 != null && tile41.slope() == (byte) 1).ToInt() + (tileBottomCache != null && tileBottomCache.slope() == (byte) 4).ToInt() + (tile40 != null && tile40.slope() == (byte) 4).ToInt();
                            int num11 = (tileTopCache != null && tileTopCache.slope() == (byte) 2).ToInt() + (tile41 != null && tile41.slope() == (byte) 3).ToInt() + (tileBottomCache != null && tileBottomCache.slope() == (byte) 3).ToInt() + (tile40 != null && tile40.slope() == (byte) 2).ToInt();
                            if (num10 == num11)
                            {
                              num8 = 2;
                              num9 = 4;
                            }
                            else if (num10 > num11)
                            {
                              int num12 = index1 != upLeft || tile44 == null ? 0 : (tile44.slope() == (byte) 0 ? 1 : 0);
                              bool flag7 = index1 == downRight && tile43 != null && tile43.slope() == (byte) 0;
                              int num13 = flag7 ? 1 : 0;
                              if ((num12 & num13) != 0)
                                num9 = 4;
                              else if (flag7)
                              {
                                num8 = 6;
                              }
                              else
                              {
                                num8 = 7;
                                num9 = 1;
                              }
                            }
                            else
                            {
                              int num14 = index1 != upRight || tile45 == null ? 0 : (tile45.slope() == (byte) 0 ? 1 : 0);
                              bool flag8 = index1 == downLeft && tile42 != null && tile42.slope() == (byte) 0;
                              int num15 = flag8 ? 1 : 0;
                              if ((num14 & num15) != 0)
                              {
                                num9 = 4;
                                num8 = 1;
                              }
                              else if (flag8)
                              {
                                num8 = 7;
                              }
                              else
                              {
                                num8 = 6;
                                num9 = 1;
                              }
                            }
                            rectangle.X = (18 + num8) * 18;
                            rectangle.Y = num9 * 18;
                          }
                          else
                          {
                            if (flag3 & flag4 && index1 == down && index1 == right)
                              num9 = 2;
                            else if (flag3 & flag5 && index1 == down && index1 == left)
                            {
                              num8 = 1;
                              num9 = 2;
                            }
                            else if (flag5 & flag6 && index1 == up && index1 == left)
                            {
                              num8 = 1;
                              num9 = 3;
                            }
                            else if (flag6 & flag4 && index1 == up && index1 == right)
                              num9 = 3;
                            if (num8 != 0 || num9 != 0)
                            {
                              rectangle.X = (18 + num8) * 18;
                              rectangle.Y = num9 * 18;
                            }
                          }
                        }
                        if (num7 >= 2 && (rectangle.X < 0 || rectangle.Y < 0))
                        {
                          int num16 = -1;
                          int num17 = -1;
                          int num18 = -1;
                          int num19 = 0;
                          int num20 = 0;
                          switch (num7)
                          {
                            case 2:
                              num16 = left;
                              num17 = down;
                              num18 = downLeft;
                              ++num19;
                              break;
                            case 3:
                              num16 = right;
                              num17 = down;
                              num18 = downRight;
                              break;
                            case 4:
                              num16 = left;
                              num17 = up;
                              num18 = upLeft;
                              ++num19;
                              ++num20;
                              break;
                            case 5:
                              num16 = right;
                              num17 = up;
                              num18 = upRight;
                              ++num20;
                              break;
                          }
                          if (index1 != num16 || index1 != num17 || index1 != num18)
                          {
                            if (index1 == num16 && index1 == num17)
                              num19 += 2;
                            else if (index1 == num16)
                              num19 += 4;
                            else if (index1 == num17)
                            {
                              num19 += 4;
                              num20 += 2;
                            }
                            else
                            {
                              num19 += 2;
                              num20 += 2;
                            }
                          }
                          rectangle.X = (18 + num19) * 18;
                          rectangle.Y = num20 * 18;
                        }
                      }
                      if (rectangle.X < 0 || rectangle.Y < 0)
                      {
                        if (!flag1)
                        {
                          WorldGen.TileMergeAttemptWeird(index1, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        }
                        if (index1 == 2 || index1 == 23 || index1 == 60 || index1 == 70 || index1 == 109 || index1 == 199 || index1 == 477 || index1 == 492 || index1 == 633 || index1 == 661 || index1 == 662 || Main.tileMoss[index1] || TileID.Sets.tileMossBrick[index1])
                        {
                          WorldGen.TileMergeAttempt(index1, -2, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        }
                        if (up == index1 && down == index1 && left == index1 && right == index1)
                        {
                          if (upLeft != index1 && upRight != index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 108;
                                rectangle.Y = 18;
                                break;
                              case 1:
                                rectangle.X = 126;
                                rectangle.Y = 18;
                                break;
                              default:
                                rectangle.X = 144;
                                rectangle.Y = 18;
                                break;
                            }
                          }
                          else if (downLeft != index1 && downRight != index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 108;
                                rectangle.Y = 36;
                                break;
                              case 1:
                                rectangle.X = 126;
                                rectangle.Y = 36;
                                break;
                              default:
                                rectangle.X = 144;
                                rectangle.Y = 36;
                                break;
                            }
                          }
                          else if (upLeft != index1 && downLeft != index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 180;
                                rectangle.Y = 0;
                                break;
                              case 1:
                                rectangle.X = 180;
                                rectangle.Y = 18;
                                break;
                              default:
                                rectangle.X = 180;
                                rectangle.Y = 36;
                                break;
                            }
                          }
                          else if (upRight != index1 && downRight != index1)
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 198;
                                rectangle.Y = 0;
                                break;
                              case 1:
                                rectangle.X = 198;
                                rectangle.Y = 18;
                                break;
                              default:
                                rectangle.X = 198;
                                rectangle.Y = 36;
                                break;
                            }
                          }
                          else
                          {
                            switch (frameNumber)
                            {
                              case 0:
                                rectangle.X = 18;
                                rectangle.Y = 18;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 18;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 18;
                                break;
                            }
                          }
                        }
                        else if (up != index1 && down == index1 && left == index1 && right == index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 18;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 36;
                              rectangle.Y = 0;
                              break;
                            default:
                              rectangle.X = 54;
                              rectangle.Y = 0;
                              break;
                          }
                        }
                        else if (up == index1 && down != index1 && left == index1 && right == index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 18;
                              rectangle.Y = 36;
                              break;
                            case 1:
                              rectangle.X = 36;
                              rectangle.Y = 36;
                              break;
                            default:
                              rectangle.X = 54;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up == index1 && down == index1 && left != index1 && right == index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 0;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 0;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 0;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up == index1 && down == index1 && left == index1 && right != index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 72;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 72;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 72;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up != index1 && down == index1 && left != index1 && right == index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 0;
                              rectangle.Y = 54;
                              break;
                            case 1:
                              rectangle.X = 36;
                              rectangle.Y = 54;
                              break;
                            default:
                              rectangle.X = 72;
                              rectangle.Y = 54;
                              break;
                          }
                        }
                        else if (up != index1 && down == index1 && left == index1 && right != index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 18;
                              rectangle.Y = 54;
                              break;
                            case 1:
                              rectangle.X = 54;
                              rectangle.Y = 54;
                              break;
                            default:
                              rectangle.X = 90;
                              rectangle.Y = 54;
                              break;
                          }
                        }
                        else if (up == index1 && down != index1 && left != index1 && right == index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 0;
                              rectangle.Y = 72;
                              break;
                            case 1:
                              rectangle.X = 36;
                              rectangle.Y = 72;
                              break;
                            default:
                              rectangle.X = 72;
                              rectangle.Y = 72;
                              break;
                          }
                        }
                        else if (up == index1 && down != index1 && left == index1 && right != index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 18;
                              rectangle.Y = 72;
                              break;
                            case 1:
                              rectangle.X = 54;
                              rectangle.Y = 72;
                              break;
                            default:
                              rectangle.X = 90;
                              rectangle.Y = 72;
                              break;
                          }
                        }
                        else if (up == index1 && down == index1 && left != index1 && right != index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 90;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 90;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 90;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up != index1 && down != index1 && left == index1 && right == index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 108;
                              rectangle.Y = 72;
                              break;
                            case 1:
                              rectangle.X = 126;
                              rectangle.Y = 72;
                              break;
                            default:
                              rectangle.X = 144;
                              rectangle.Y = 72;
                              break;
                          }
                        }
                        else if (up != index1 && down == index1 && left != index1 && right != index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 108;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 126;
                              rectangle.Y = 0;
                              break;
                            default:
                              rectangle.X = 144;
                              rectangle.Y = 0;
                              break;
                          }
                        }
                        else if (up == index1 && down != index1 && left != index1 && right != index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 108;
                              rectangle.Y = 54;
                              break;
                            case 1:
                              rectangle.X = 126;
                              rectangle.Y = 54;
                              break;
                            default:
                              rectangle.X = 144;
                              rectangle.Y = 54;
                              break;
                          }
                        }
                        else if (up != index1 && down != index1 && left != index1 && right == index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 162;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 162;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 162;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up != index1 && down != index1 && left == index1 && right != index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 216;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 216;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 216;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up != index1 && down != index1 && left != index1 && right != index1)
                        {
                          switch (frameNumber)
                          {
                            case 0:
                              rectangle.X = 162;
                              rectangle.Y = 54;
                              break;
                            case 1:
                              rectangle.X = 180;
                              rectangle.Y = 54;
                              break;
                            default:
                              rectangle.X = 198;
                              rectangle.Y = 54;
                              break;
                          }
                        }
                      }
                      if (rectangle.X <= -1 || rectangle.Y <= -1)
                      {
                        if (frameNumber <= 0)
                        {
                          rectangle.X = 18;
                          rectangle.Y = 18;
                        }
                        else if (frameNumber == 1)
                        {
                          rectangle.X = 36;
                          rectangle.Y = 18;
                        }
                        if (frameNumber >= 2)
                        {
                          rectangle.X = 54;
                          rectangle.Y = 18;
                        }
                      }
                      if (Main.tileLargeFrames[index1] == (byte) 1 && frameNumber == 3)
                        rectangle.Y += 90;
                      if (Main.tileLargeFrames[index1] == (byte) 2 && frameNumber == 3)
                        rectangle.Y += 90;
                      tile1.frameX = (short) rectangle.X;
                      tile1.frameY = (short) rectangle.Y;
                      if (TileID.Sets.IsVine[index1])
                      {
                        up = tileTopCache == null ? index1 : (tileTopCache.nactive() ? (!tileTopCache.bottomSlope() ? (int) tileTopCache.type : -1) : -1);
                        if (index1 != up)
                        {
                          int num21 = up == 60 ? 1 : (up == 62 ? 1 : 0);
                          int num22 = up == 109 ? 1 : (up == 115 ? 1 : 0);
                          bool flag9 = up == 23 || up == 636 || up == 661;
                          bool flag10 = up == 199 || up == 205 || up == 662;
                          bool flag11 = up == 2 || up == 52;
                          bool flag12 = up == 382;
                          int num23 = up == 70 ? 1 : (up == 528 ? 1 : 0);
                          int num24 = up == 633 ? 1 : (up == 638 ? 1 : 0);
                          ushort num25 = 0;
                          if (num24 != 0)
                            num25 = (ushort) 638;
                          if (num23 != 0)
                            num25 = (ushort) 528;
                          if (num22 != 0)
                            num25 = (ushort) 115;
                          if (num21 != 0)
                            num25 = (ushort) 62;
                          if (flag9)
                            num25 = (ushort) 636;
                          if (flag10)
                            num25 = (ushort) 205;
                          if (flag11 && index1 != 382)
                            num25 = (ushort) 52;
                          if (flag12)
                            num25 = (ushort) 382;
                          if (num25 != (ushort) 0 && (int) num25 != index1)
                          {
                            tile1.type = num25;
                            WorldGen.SquareTileFrame(i, j);
                            return;
                          }
                        }
                        if (up != index1)
                        {
                          bool flag13 = false;
                          if (up == -1)
                            flag13 = true;
                          if (index1 == 52 && up != 2 && up != 192)
                            flag13 = true;
                          if (index1 == 382 && up != 2 && up != 192)
                            flag13 = true;
                          if (index1 == 62 && up != 60)
                            flag13 = true;
                          if (index1 == 115 && up != 109)
                            flag13 = true;
                          if (index1 == 528 && up != 70)
                            flag13 = true;
                          if (index1 == 636 && up != 23 && up != 661)
                            flag13 = true;
                          if (index1 == 205 && up != 199 && up != 662)
                            flag13 = true;
                          if (index1 == 638 && up != 633)
                            flag13 = true;
                          if (flag13)
                            WorldGen.KillTile(i, j);
                        }
                      }
                      bool flag14 = false;
                      if (!WorldGen.noTileActions && tile1.active() && TileID.Sets.Falling[index1])
                        WorldGen.SpawnFallingBlockProjectile(i, j, tile1, tileTopCache, tileBottomCache, index1);
                      if (((rectangle.X == frameX || rectangle.Y == frameY || frameX < 0 ? 0 : (frameY >= 0 ? 1 : 0)) | (flag14 ? 1 : 0)) != 0)
                      {
                        ++WorldGen.tileReframeCount;
                        if (WorldGen.tileReframeCount < 25)
                        {
                          int num26 = WorldGen.mergeUp ? 1 : 0;
                          bool mergeDown = WorldGen.mergeDown;
                          bool mergeLeft = WorldGen.mergeLeft;
                          bool mergeRight = WorldGen.mergeRight;
                          WorldGen.TileFrame(i - 1, j);
                          WorldGen.TileFrame(i + 1, j);
                          WorldGen.TileFrame(i, j - 1);
                          WorldGen.TileFrame(i, j + 1);
                          WorldGen.mergeUp = num26 != 0;
                          WorldGen.mergeDown = mergeDown;
                          WorldGen.mergeLeft = mergeLeft;
                          WorldGen.mergeRight = mergeRight;
                        }
                        --WorldGen.tileReframeCount;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      catch
      {
      }
      if (i <= 0 || j <= 0)
        return;
      WorldGen.UpdateMapTile(i, j, addToList);
    }

    private static void StopMergingByInvsibility(
      ref int currentMerge,
      Tile block,
      bool wantedInvisibilityState)
    {
      if (currentMerge <= -1 || block.invisibleBlock() == wantedInvisibilityState)
        return;
      currentMerge = -1;
    }

    private static bool SpawnFallingBlockProjectile(
      int i,
      int j,
      Tile tileCache,
      Tile tileTopCache,
      Tile tileBottomCache,
      int type)
    {
      if (Main.netMode == 1 || tileCache == null || tileTopCache == null || tileBottomCache == null || !WorldGen.BlockBelowMakesSandFall(i, j) || !WorldGen.AllowsSandfall(tileTopCache))
        return false;
      int projType;
      int dmg;
      WorldGen.GetSandfallProjData(type, out projType, out dmg);
      tileCache.ClearTile();
      if (Main.netMode == 0)
      {
        int index = Projectile.NewProjectile((IEntitySource) WorldGen.GetProjectileSource_TileBreak(i, j), (float) (i * 16 + 8), (float) (j * 16 + 8), 0.0f, 0.41f, projType, dmg, 0.0f, Main.myPlayer);
        Main.projectile[index].ai[0] = 1f;
        WorldGen.SquareTileFrame(i, j);
      }
      if (Main.netMode == 2)
      {
        bool flag = false;
        for (int index = 0; index < 1000; ++index)
        {
          if (Main.projectile[index].active && Main.projectile[index].owner == Main.myPlayer && Main.projectile[index].type == projType && Math.Abs(Main.projectile[index].timeLeft - 3600) < 60 && (double) Main.projectile[index].Distance(new Vector2((float) (i * 16 + 8), (float) (j * 16 + 10))) < 4.0)
          {
            flag = true;
            break;
          }
        }
        if (!flag)
        {
          int index = Projectile.NewProjectile((IEntitySource) WorldGen.GetProjectileSource_TileBreak(i, j), (float) (i * 16 + 8), (float) (j * 16 + 8), 0.0f, 2.5f, projType, dmg, 0.0f, Main.myPlayer);
          Main.projectile[index].velocity.Y = 0.5f;
          Main.projectile[index].position.Y += 2f;
          Main.projectile[index].netUpdate = true;
        }
        WorldGen.SquareTileFrame(i, j);
        NetMessage.SendTileSquare(-1, i, j);
        WorldGen.ExploitDestroyQueue.Enqueue(new Point(i, j));
        WorldGen.ExploitDestroyQueue.Enqueue(new Point(i, j - 1));
      }
      return true;
    }

    public static void CheckTorch(int x, int y)
    {
      for (int index1 = x - 1; index1 <= x + 1; ++index1)
      {
        for (int index2 = y - 1; index2 <= y + 1; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            return;
        }
      }
      Tile tile1 = Main.tile[x, y];
      Tile tile2 = Main.tile[x, y - 1];
      Tile tile3 = Main.tile[x, y + 1];
      Tile tile4 = Main.tile[x - 1, y];
      Tile tile5 = Main.tile[x + 1, y];
      Tile tile6 = Main.tile[x - 1, y + 1];
      Tile tile7 = Main.tile[x + 1, y + 1];
      Tile tile8 = Main.tile[x - 1, y - 1];
      Tile tile9 = Main.tile[x + 1, y - 1];
      short num = 0;
      if (tile1.frameX >= (short) 66)
        num = (short) 66;
      int index = -1;
      int tree1 = -1;
      int tree2 = -1;
      int tree3 = -1;
      int tree4 = -1;
      int tree5 = -1;
      int tree6 = -1;
      if (tile2 != null && tile2.active() && !tile2.bottomSlope())
      {
        int type = (int) tile2.type;
      }
      if (tile3 != null && tile3.active() && (TileID.Sets.Platforms[(int) tile3.type] && WorldGen.TopEdgeCanBeAttachedTo(x, y + 1) || !tile3.halfBrick() && !tile3.topSlope()))
        index = (int) tile3.type;
      if (tile4 != null && tile4.active() && (tile4.slope() == (byte) 0 || (int) tile4.slope() % 2 != 1))
        tree1 = (int) tile4.type;
      if (tile5 != null && tile5.active() && (tile5.slope() == (byte) 0 || (int) tile5.slope() % 2 != 0))
        tree2 = (int) tile5.type;
      if (tile6 != null && tile6.active())
        tree3 = (int) tile6.type;
      if (tile7 != null && tile7.active())
        tree4 = (int) tile7.type;
      if (tile8 != null && tile8.active())
        tree5 = (int) tile8.type;
      if (tile9 != null && tile9.active())
        tree6 = (int) tile9.type;
      if (index >= 0 && Main.tileSolid[index] && (!Main.tileNoAttach[index] || TileID.Sets.Platforms[index]))
        tile1.frameX = num;
      else if (tree1 >= 0 && Main.tileSolid[tree1] && !Main.tileNoAttach[tree1] || tree1 >= 0 && TileID.Sets.IsBeam[tree1] || WorldGen.IsTreeType(tree1) && WorldGen.IsTreeType(tree5) && WorldGen.IsTreeType(tree3))
        tile1.frameX = (short) (22 + (int) num);
      else if (tree2 >= 0 && Main.tileSolid[tree2] && !Main.tileNoAttach[tree2] || tree2 >= 0 && TileID.Sets.IsBeam[tree2] || WorldGen.IsTreeType(tree2) && WorldGen.IsTreeType(tree6) && WorldGen.IsTreeType(tree4))
        tile1.frameX = (short) (44 + (int) num);
      else if (tile1.wall > (ushort) 0)
        tile1.frameX = num;
      else
        WorldGen.KillTile(x, y);
    }

    public static void CheckProjectilePressurePad(int i, int j)
    {
      bool canUp;
      bool canLeft;
      bool canRight;
      bool canDown;
      WorldGen.CheckProjectilePressurePad_GetPossiblePlacementDirections(i, j, out canUp, out canLeft, out canRight, out canDown);
      Tile tile = Main.tile[i, j];
      bool flag;
      switch ((int) tile.frameX / 22)
      {
        case 0:
          flag = !canDown;
          break;
        case 1:
          flag = !canUp;
          break;
        case 2:
          flag = !canLeft;
          break;
        case 3:
          flag = !canRight;
          break;
        default:
          flag = true;
          break;
      }
      if (!flag)
        return;
      if (canDown)
        tile.frameX = (short) 0;
      else if (canUp)
        tile.frameX = (short) 22;
      else if (canLeft)
        tile.frameX = (short) 44;
      else if (canRight)
        tile.frameX = (short) 66;
      else
        WorldGen.KillTile(i, j);
    }

    private static void CheckProjectilePressurePad_GetPossiblePlacementDirections(
      int i,
      int j,
      out bool canUp,
      out bool canLeft,
      out bool canRight,
      out bool canDown)
    {
      canUp = false;
      canLeft = false;
      canRight = false;
      canDown = false;
      Tile tile1 = Main.tile[i, j];
      Tile tile2 = Main.tile[i, j - 1];
      Tile tile3 = Main.tile[i, j + 1];
      Tile tile4 = Main.tile[i - 1, j];
      Tile tile5 = Main.tile[i + 1, j];
      Tile tile6 = Main.tile[i - 1, j + 1];
      Tile tile7 = Main.tile[i + 1, j + 1];
      Tile tile8 = Main.tile[i - 1, j - 1];
      Tile tile9 = Main.tile[i + 1, j - 1];
      int index1 = -1;
      int index2 = -1;
      int tree1 = -1;
      int tree2 = -1;
      int tree3 = -1;
      int tree4 = -1;
      int tree5 = -1;
      int tree6 = -1;
      if (tile2 != null && tile2.nactive() && !tile2.bottomSlope())
        index2 = (int) tile2.type;
      if (tile3 != null && tile3.nactive() && !tile3.halfBrick() && !tile3.topSlope())
        index1 = (int) tile3.type;
      if (tile4 != null && tile4.nactive() && (tile4.slope() == (byte) 0 || (int) tile4.slope() % 2 != 1))
        tree1 = (int) tile4.type;
      if (tile5 != null && tile5.nactive() && (tile5.slope() == (byte) 0 || (int) tile5.slope() % 2 != 0))
        tree2 = (int) tile5.type;
      if (tile6 != null && tile6.nactive())
        tree3 = (int) tile6.type;
      if (tile7 != null && tile7.nactive())
        tree4 = (int) tile7.type;
      if (tile8 != null && tile8.nactive())
        tree5 = (int) tile8.type;
      if (tile9 != null && tile9.nactive())
        tree6 = (int) tile9.type;
      if (index1 >= 0 && Main.tileSolid[index1] && (!Main.tileNoAttach[index1] || TileID.Sets.Platforms[index1]) && (tile3.bottomSlope() || tile3.slope() == (byte) 0) && !tile3.halfBrick())
        canDown = true;
      if (index2 >= 0 && Main.tileSolid[index2] && (!Main.tileNoAttach[index2] || TileID.Sets.Platforms[index2] && tile2.halfBrick()) && (tile2.topSlope() || tile2.slope() == (byte) 0 || tile2.halfBrick()))
        canUp = true;
      if (tree1 >= 0 && Main.tileSolid[tree1] && !Main.tileNoAttach[tree1] && (tile4.leftSlope() || tile4.slope() == (byte) 0) && !tile4.halfBrick() || tree1 >= 0 && TileID.Sets.IsBeam[tree1] || WorldGen.IsTreeType(tree1) && WorldGen.IsTreeType(tree5) && WorldGen.IsTreeType(tree3))
        canLeft = true;
      if ((tree2 < 0 || !Main.tileSolid[tree2] || Main.tileNoAttach[tree2] || !tile5.rightSlope() && tile5.slope() != (byte) 0 || tile5.halfBrick()) && (tree2 < 0 || !TileID.Sets.IsBeam[tree2]) && (!WorldGen.IsTreeType(tree2) || !WorldGen.IsTreeType(tree6) || !WorldGen.IsTreeType(tree4)))
        return;
      canRight = true;
    }

    public static bool IsTreeType(int tree) => tree >= 0 && TileID.Sets.IsATreeTrunk[tree];

    public static int CanPlaceProjectilePressurePad(
      int x,
      int y,
      int type = 442,
      int style = 0,
      int direction = 0,
      int alternate = 0)
    {
      bool canUp;
      bool canLeft;
      bool canRight;
      bool canDown;
      WorldGen.CheckProjectilePressurePad_GetPossiblePlacementDirections(x, y, out canUp, out canLeft, out canRight, out canDown);
      if (!canUp && !canDown && !canLeft && !canRight)
        return -1;
      switch (alternate)
      {
        case 0:
          if (!canDown)
            return -1;
          break;
        case 1:
          if (!canUp)
            return -1;
          break;
        case 2:
          if (!canLeft)
            return -1;
          break;
        case 3:
          if (!canRight)
            return -1;
          break;
      }
      return style;
    }

    private static void CheckDoorOpen(int i, int j, Tile tileCache)
    {
      if (WorldGen.destroyObject)
        return;
      int num1 = 0;
      int index = i;
      int frameX = (int) tileCache.frameX;
      int frameY = (int) tileCache.frameY;
      int doorStyle = frameY / 54 + (int) tileCache.frameX / 72 * 36;
      int num2 = j - frameY % 54 / 18;
      bool flag = false;
      switch (frameX % 72)
      {
        case 0:
          index = i;
          num1 = 1;
          break;
        case 18:
          index = i - 1;
          num1 = 1;
          break;
        case 36:
          index = i + 1;
          num1 = -1;
          break;
        case 54:
          index = i;
          num1 = -1;
          break;
      }
      Tile testTile1 = Main.tile[index, num2 - 1];
      Tile testTile2 = Main.tile[index, num2 + 3];
      if (testTile1 == null)
      {
        testTile1 = new Tile();
        Main.tile[index, num2 - 1] = testTile1;
      }
      if (testTile2 == null)
      {
        testTile2 = new Tile();
        Main.tile[index, num2 + 3] = testTile2;
      }
      if (!WorldGen.SolidTile(testTile1) || !WorldGen.SolidTile(testTile2))
      {
        flag = true;
        WorldGen.destroyObject = true;
        WorldGen.DropDoorItem(i, j, doorStyle);
      }
      int num3 = index;
      if (num1 == -1)
        num3 = index - 1;
      for (int i1 = num3; i1 < num3 + 2; ++i1)
      {
        for (int j1 = num2; j1 < num2 + 3; ++j1)
        {
          if (!flag)
          {
            Tile tile = Main.tile[i1, j1];
            if (!tile.active() || tile.type != (ushort) 11)
            {
              WorldGen.destroyObject = true;
              WorldGen.DropDoorItem(i, j, doorStyle);
              flag = true;
              i1 = num3;
              j1 = num2;
            }
          }
          if (flag)
            WorldGen.KillTile(i1, j1);
        }
      }
      WorldGen.destroyObject = false;
    }

    private static void CheckDoorClosed(int i, int j, Tile tileCache, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int frameY = (int) tileCache.frameY;
      int doorStyle = frameY / 54 + (int) tileCache.frameX / 54 * 36;
      int j1 = j - frameY % 54 / 18;
      Tile testTile1 = Main.tile[i, j1 - 1];
      Tile tile1 = Main.tile[i, j1];
      Tile tile2 = Main.tile[i, j1 + 1];
      Tile tile3 = Main.tile[i, j1 + 2];
      Tile testTile2 = Main.tile[i, j1 + 3];
      if (testTile1 == null)
      {
        testTile1 = new Tile();
        Main.tile[i, j1 - 1] = testTile1;
      }
      if (tile1 == null)
      {
        tile1 = new Tile();
        Main.tile[i, j1] = tile1;
      }
      if (tile2 == null)
      {
        tile2 = new Tile();
        Main.tile[i, j1 + 1] = tile2;
      }
      if (tile3 == null)
      {
        tile3 = new Tile();
        Main.tile[i, j1 + 2] = tile3;
      }
      if (testTile2 == null)
      {
        testTile2 = new Tile();
        Main.tile[i, j1 + 3] = testTile2;
      }
      if (!WorldGen.SolidTile(testTile1))
        flag = true;
      if (!WorldGen.SolidTile(testTile2))
        flag = true;
      if (!tile1.active() || (int) tile1.type != type)
        flag = true;
      if (!tile2.active() || (int) tile2.type != type)
        flag = true;
      if (!tile3.active() || (int) tile3.type != type)
        flag = true;
      if (flag)
      {
        WorldGen.destroyObject = true;
        WorldGen.KillTile(i, j1);
        WorldGen.KillTile(i, j1 + 1);
        WorldGen.KillTile(i, j1 + 2);
        WorldGen.DropDoorItem(i, j, doorStyle);
      }
      WorldGen.destroyObject = false;
    }

    private static void GetSandfallProjData(int type, out int projType, out int dmg)
    {
      dmg = 10;
      switch (type)
      {
        case 59:
          projType = 39;
          break;
        case 112:
          projType = 56;
          break;
        case 116:
          projType = 67;
          break;
        case 123:
          projType = 71;
          break;
        case 224:
          projType = 179;
          break;
        case 234:
          projType = 241;
          break;
        case 330:
          projType = 411;
          dmg = 0;
          break;
        case 331:
          projType = 412;
          dmg = 0;
          break;
        case 332:
          projType = 413;
          dmg = 0;
          break;
        case 333:
          projType = 414;
          dmg = 0;
          break;
        case 495:
          projType = 812;
          break;
        default:
          projType = 31;
          break;
      }
    }

    public static bool BlockBelowMakesSandConvertIntoHardenedSand(int i, int j)
    {
      bool flag = false;
      if (j >= Main.maxTilesY - 1)
        return false;
      Tile tile = Main.tile[i, j + 1];
      if (tile == null)
        return false;
      if (!tile.nactive())
        flag = true;
      else if (tile.type >= (ushort) 0 && (int) tile.type < (int) TileID.Count && !Main.tileSolid[(int) tile.type])
        flag = true;
      return flag;
    }

    public static bool BlockBelowMakesSandFall(int i, int j)
    {
      bool flag = false;
      if (j >= Main.maxTilesY - 1)
        return false;
      Tile tile = Main.tile[i, j + 1];
      if (tile == null)
        return false;
      if (!tile.nactive())
        flag = true;
      else if (!Main.tile[i, j + 2].nactive() && (!tile.active() || !Main.tileSolid[(int) tile.type]))
        flag = true;
      else if (tile.active() && tile.type == (ushort) 165)
        flag = true;
      return flag;
    }

    public static bool AllowsSandfall(Tile tileTopCache)
    {
      if (tileTopCache == null)
        return false;
      bool flag = true;
      if (tileTopCache.active() && (TileID.Sets.BasicChest[(int) tileTopCache.type] || TileID.Sets.BasicChestFake[(int) tileTopCache.type] || tileTopCache.type == (ushort) 323 || tileTopCache.type == (ushort) 88 || tileTopCache.type == (ushort) 80 || tileTopCache.type == (ushort) 77 || tileTopCache.type == (ushort) 26 || tileTopCache.type == (ushort) 475 || tileTopCache.type == (ushort) 470 || tileTopCache.type == (ushort) 597))
        flag = false;
      return flag;
    }

    public static void TriggerLunarApocalypse()
    {
      List<int> intList = new List<int>()
      {
        517,
        422,
        507,
        493
      };
      int[] numArray = new int[4];
      for (int index = 0; index < 4; ++index)
      {
        numArray[index] = intList[Main.rand.Next(intList.Count)];
        intList.Remove(numArray[index]);
      }
      int num1 = Main.maxTilesX / 5;
      int worldSurface = (int) Main.worldSurface;
      for (int index1 = 0; index1 < 4; ++index1)
      {
        int num2 = num1 * (1 + index1);
        bool flag = false;
        for (int index2 = 0; index2 < 30; ++index2)
        {
          int num3 = Main.rand.Next(-100, 101);
          if (Main.remixWorld && Main.getGoodWorld)
          {
            int y = Main.rand.Next((int) Main.worldSurface, Main.maxTilesY - 350);
            if (!WorldGen.PlayerLOS(num2 + num3 - 10, y) && !WorldGen.PlayerLOS(num2 + num3 + 10, y) && !WorldGen.PlayerLOS(num2 + num3 - 10, y - 20) && !WorldGen.PlayerLOS(num2 + num3 + 10, y - 20))
            {
              int number = NPC.NewNPC((IEntitySource) new EntitySource_WorldEvent(), (num2 + num3) * 16, y * 16, numArray[index1]);
              if (Main.netMode == 2 && number < 200)
                NetMessage.SendData(23, number: number);
              flag = true;
              break;
            }
          }
          else
          {
            for (int y = worldSurface; y > 100; --y)
            {
              if (!Collision.SolidTiles(num2 + num3 - 10, num2 + num3 + 10, y - 20, y + 15) && !WorldGen.PlayerLOS(num2 + num3 - 10, y) && !WorldGen.PlayerLOS(num2 + num3 + 10, y) && !WorldGen.PlayerLOS(num2 + num3 - 10, y - 20) && !WorldGen.PlayerLOS(num2 + num3 + 10, y - 20))
              {
                int number = NPC.NewNPC((IEntitySource) new EntitySource_WorldEvent(), (num2 + num3) * 16, y * 16, numArray[index1]);
                if (Main.netMode == 2 && number < 200)
                  NetMessage.SendData(23, number: number);
                flag = true;
                break;
              }
            }
            if (flag)
              break;
          }
        }
        if (!flag)
          NPC.NewNPC((IEntitySource) new EntitySource_WorldEvent(), num2 * 16, (worldSurface - 40) * 16, numArray[index1]);
      }
      int num4;
      NPC.TowerActiveStardust = (num4 = 1) != 0;
      NPC.TowerActiveSolar = num4 != 0;
      NPC.TowerActiveNebula = num4 != 0;
      NPC.TowerActiveVortex = num4 != 0;
      NPC.LunarApocalypseIsUp = true;
      int strengthTowerMax;
      NPC.ShieldStrengthTowerStardust = strengthTowerMax = NPC.ShieldStrengthTowerMax;
      NPC.ShieldStrengthTowerNebula = strengthTowerMax;
      NPC.ShieldStrengthTowerVortex = strengthTowerMax;
      NPC.ShieldStrengthTowerSolar = strengthTowerMax;
      NetMessage.SendData(101);
      WorldGen.MessageLunarApocalypse();
    }

    public static void UpdateLunarApocalypse()
    {
      if (!NPC.LunarApocalypseIsUp)
        return;
      bool flag1 = false;
      bool flag2 = false;
      bool flag3 = false;
      bool flag4 = false;
      bool flag5 = false;
      for (int index = 0; index < 200; ++index)
      {
        if (Main.npc[index].active)
        {
          switch (Main.npc[index].type)
          {
            case 398:
              flag1 = true;
              continue;
            case 422:
              flag3 = true;
              continue;
            case 493:
              flag5 = true;
              continue;
            case 507:
              flag4 = true;
              continue;
            case 517:
              flag2 = true;
              continue;
            default:
              continue;
          }
        }
      }
      if (!flag2)
        NPC.TowerActiveSolar = false;
      if (!flag3)
        NPC.TowerActiveVortex = false;
      if (!flag4)
        NPC.TowerActiveNebula = false;
      if (!flag5)
        NPC.TowerActiveStardust = false;
      if (NPC.TowerActiveSolar || NPC.TowerActiveVortex || NPC.TowerActiveNebula || NPC.TowerActiveStardust || flag1)
        return;
      WorldGen.StartImpendingDoom(3600);
    }

    public static void StartImpendingDoom(int countdownTime)
    {
      NPC.LunarApocalypseIsUp = false;
      NPC.MaxMoonLordCountdown = countdownTime;
      NPC.MoonLordCountdown = NPC.MaxMoonLordCountdown;
      NetMessage.SendData(103);
      WorldGen.BroadcastText(NetworkText.FromKey(Lang.misc[52].Key), 50, (int) byte.MaxValue, 130);
      if (Main.netMode == 1)
        return;
      WorldGen.GetRidOfCultists();
    }

    public static void GetRidOfCultists()
    {
      for (int number = 0; number < 200; ++number)
      {
        if (Main.npc[number].active && (Main.npc[number].type == 437 || Main.npc[number].type == 438 || Main.npc[number].type == 379))
        {
          Main.npc[number].active = false;
          if (Main.netMode != 1)
            NetMessage.SendData(23, number: number);
        }
      }
    }

    public static void MessageLunarApocalypse()
    {
      if (!NPC.LunarApocalypseIsUp)
        return;
      int num = 0;
      if (!NPC.TowerActiveSolar)
        ++num;
      if (!NPC.TowerActiveVortex)
        ++num;
      if (!NPC.TowerActiveNebula)
        ++num;
      if (!NPC.TowerActiveStardust)
        ++num;
      WorldGen.BroadcastText(NetworkText.FromKey(Lang.misc[43 + num].Key), 175, 75, (int) byte.MaxValue);
    }

    public static void BroadcastText(NetworkText text, Vector4 color) => WorldGen.BroadcastText(text, new Color(color));

    public static void BroadcastText(NetworkText text, Vector3 color) => WorldGen.BroadcastText(text, new Color(color));

    public static void BroadcastText(NetworkText text, int r, int g, int b) => WorldGen.BroadcastText(text, new Color(r, g, b));

    public static void BroadcastText(NetworkText text, byte r, byte g, byte b) => WorldGen.BroadcastText(text, new Color((int) r, (int) g, (int) b));

    public static void BroadcastText(NetworkText text, Color color)
    {
      if (Main.netMode == 0)
      {
        Main.NewText(text.ToString(), color.R, color.G, color.B);
      }
      else
      {
        if (Main.netMode != 2)
          return;
        ChatHelper.BroadcastChatMessage(text, color);
      }
    }

    public static bool CanCutTile(int x, int y, TileCuttingContext context)
    {
      if (Main.tile[x, y + 1] == null || Main.tile[x, y + 1].type == (ushort) 78 || Main.tile[x, y + 1].type == (ushort) 380 || Main.tile[x, y + 1].type == (ushort) 579)
        return false;
      return Main.tile[x, y].type != (ushort) 254 || Main.tile[x, y].frameX >= (short) 144;
    }

    public static bool InAPlaceWithWind(Vector2 position, int width, int height)
    {
      Point tileCoordinates1 = position.ToTileCoordinates();
      Point tileCoordinates2 = (position + new Vector2((float) width, (float) height)).ToTileCoordinates();
      return WorldGen.InAPlaceWithWind(tileCoordinates1.X, tileCoordinates1.Y, 1 + tileCoordinates2.X - tileCoordinates1.X, 1 + tileCoordinates2.Y - tileCoordinates1.Y);
    }

    public static bool DoesWindBlowAtThisHeight(int tileY)
    {
      bool flag = (double) tileY < Main.worldSurface;
      if (Main.remixWorld)
        flag = !flag;
      return flag;
    }

    public static bool InAPlaceWithWind(int x, int y, int width, int height)
    {
      if (!WorldGen.DoesWindBlowAtThisHeight(y))
        return false;
      for (int index1 = 0; index1 < width; ++index1)
      {
        for (int index2 = 0; index2 < height; ++index2)
        {
          Tile tile = Main.tile[x + index1, y + index2];
          if (tile == null || tile.liquid > (byte) 0 || tile.wall > (ushort) 0 && !WallID.Sets.AllowsWind[(int) tile.wall])
            return false;
        }
      }
      return true;
    }

    public static int[] CountTileTypesInWorld(params int[] oreTypes)
    {
      int[] numArray = new int[oreTypes.Length];
      for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
      {
        for (int index2 = 0; index2 < Main.maxTilesY; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile.active())
          {
            for (int index3 = 0; index3 < oreTypes.Length; ++index3)
            {
              if (oreTypes[index3] == (int) tile.type)
              {
                ++numArray[index3];
                break;
              }
            }
          }
        }
      }
      return numArray;
    }

    public static class WorldSize
    {
      public const int Small = 0;
      public const int Medium = 1;
      public const int Large = 2;
    }

    public static class SavedOreTiers
    {
      public static int Copper = 7;
      public static int Iron = 6;
      public static int Silver = 9;
      public static int Gold = 8;
      public static int Cobalt = 107;
      public static int Mythril = 108;
      public static int Adamantite = 111;
    }

    public static class Hooks
    {
      public static event WorldGen.Hooks.WorldGenConfigProcessEvent OnWorldGenConfigProcess;

      public static event Action OnWorldLoad;

      public static void Initialize()
      {
        Player.Hooks.OnEnterWorld += (Action<Player>) (player =>
        {
          if (player.whoAmI != Main.myPlayer)
            return;
          WorldGen.Hooks.WorldLoaded();
          if (Main.netMode == 1)
            return;
          Main.FixUIScale();
        });
        WorldGen.Hooks.OnWorldLoad += new Action(WorldGen.mysticLogsEvent.StartWorld);
        WorldGen.Hooks.OnWorldLoad += new Action(Main.checkHalloween);
        WorldGen.Hooks.OnWorldLoad += new Action(Main.checkXMas);
      }

      public static void WorldLoaded()
      {
        if (WorldGen.Hooks.OnWorldLoad == null)
          return;
        WorldGen.Hooks.OnWorldLoad();
      }

      public static void ProcessWorldGenConfig(ref WorldGenConfiguration config)
      {
        if (WorldGen.Hooks.OnWorldGenConfigProcess == null)
          return;
        WorldGen.Hooks.OnWorldGenConfigProcess(ref config);
      }

      public delegate void WorldGenConfigProcessEvent(ref WorldGenConfiguration config);
    }

    public static class Spread
    {
      public static void Wall(int x, int y, int wallType)
      {
        if (!WorldGen.InWorld(x, y))
          return;
        ushort num = (ushort) wallType;
        List<Point> pointList = new List<Point>();
        List<Point> collection = new List<Point>();
        HashSet<Point> pointSet = new HashSet<Point>();
        collection.Add(new Point(x, y));
        while (collection.Count > 0)
        {
          pointList.Clear();
          pointList.AddRange((IEnumerable<Point>) collection);
          collection.Clear();
          while (pointList.Count > 0)
          {
            Point point1 = pointList[0];
            if (!WorldGen.InWorld(point1.X, point1.Y, 1))
            {
              pointList.Remove(point1);
            }
            else
            {
              pointSet.Add(point1);
              pointList.Remove(point1);
              Tile tile = Main.tile[point1.X, point1.Y];
              if (WorldGen.SolidTile(point1.X, point1.Y) || tile.wall != (ushort) 0)
              {
                if (tile.active() && tile.wall == (ushort) 0)
                  tile.wall = num;
              }
              else
              {
                tile.wall = num;
                Point point2 = new Point(point1.X - 1, point1.Y);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X + 1, point1.Y);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X, point1.Y - 1);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X, point1.Y + 1);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
              }
            }
          }
        }
      }

      public static void Wall2(int x, int y, int wallType)
      {
        if (!WorldGen.InWorld(x, y))
          return;
        ushort index = (ushort) wallType;
        int num = 0;
        int maxWallOut2 = WorldGen.maxWallOut2;
        List<Point> pointList = new List<Point>();
        List<Point> collection = new List<Point>();
        HashSet<Point> pointSet = new HashSet<Point>();
        collection.Add(new Point(x, y));
        while (collection.Count > 0)
        {
          pointList.Clear();
          pointList.AddRange((IEnumerable<Point>) collection);
          collection.Clear();
          while (pointList.Count > 0)
          {
            Point point1 = pointList[0];
            if (!WorldGen.InWorld(point1.X, point1.Y, 1))
            {
              pointList.Remove(point1);
            }
            else
            {
              pointSet.Add(point1);
              pointList.Remove(point1);
              Tile tile = Main.tile[point1.X, point1.Y];
              if ((int) tile.wall != (int) index && !WallID.Sets.CannotBeReplacedByWallSpread[(int) tile.wall])
              {
                if (!WorldGen.SolidTile(point1.X, point1.Y))
                {
                  bool flag = WallID.Sets.WallSpreadStopsAtAir[(int) index];
                  if (flag && tile.wall == (ushort) 0)
                  {
                    pointList.Remove(point1);
                  }
                  else
                  {
                    ++num;
                    if (num >= maxWallOut2)
                    {
                      pointList.Remove(point1);
                    }
                    else
                    {
                      tile.wall = index;
                      Point point2 = new Point(point1.X - 1, point1.Y);
                      if (!pointSet.Contains(point2))
                        collection.Add(point2);
                      point2 = new Point(point1.X + 1, point1.Y);
                      if (!pointSet.Contains(point2))
                        collection.Add(point2);
                      point2 = new Point(point1.X, point1.Y - 1);
                      if (!pointSet.Contains(point2))
                        collection.Add(point2);
                      point2 = new Point(point1.X, point1.Y + 1);
                      if (!pointSet.Contains(point2))
                        collection.Add(point2);
                      if (flag)
                      {
                        point2 = new Point(point1.X - 1, point1.Y - 1);
                        if (!pointSet.Contains(point2))
                          collection.Add(point2);
                        point2 = new Point(point1.X + 1, point1.Y - 1);
                        if (!pointSet.Contains(point2))
                          collection.Add(point2);
                        point2 = new Point(point1.X - 1, point1.Y + 1);
                        if (!pointSet.Contains(point2))
                          collection.Add(point2);
                        point2 = new Point(point1.X + 1, point1.Y + 1);
                        if (!pointSet.Contains(point2))
                          collection.Add(point2);
                        point2 = new Point(point1.X - 2, point1.Y);
                        if (!pointSet.Contains(point2))
                          collection.Add(point2);
                        point2 = new Point(point1.X + 2, point1.Y);
                        if (!pointSet.Contains(point2))
                          collection.Add(point2);
                      }
                    }
                  }
                }
                else if (tile.active())
                  tile.wall = index;
              }
            }
          }
        }
      }

      public static void Moss(int x, int y)
      {
        if (!WorldGen.InWorld(x, y))
          return;
        ushort mossWall = GenVars.mossWall;
        ushort mossTile = GenVars.mossTile;
        List<Point> pointList = new List<Point>();
        List<Point> collection = new List<Point>();
        HashSet<Point> pointSet = new HashSet<Point>();
        collection.Add(new Point(x, y));
        while (collection.Count > 0)
        {
          pointList.Clear();
          pointList.AddRange((IEnumerable<Point>) collection);
          collection.Clear();
          while (pointList.Count > 0)
          {
            Point point1 = pointList[0];
            if (!WorldGen.InWorld(point1.X, point1.Y, 1))
            {
              pointList.Remove(point1);
            }
            else
            {
              pointSet.Add(point1);
              pointList.Remove(point1);
              Tile tile = Main.tile[point1.X, point1.Y];
              if (WorldGen.SolidTile(point1.X, point1.Y) || tile.wall != (ushort) 0)
              {
                if (tile.active())
                {
                  if (tile.wall == (ushort) 0)
                    tile.wall = mossWall;
                  if (tile.type == (ushort) 1)
                    tile.type = mossTile;
                }
              }
              else
              {
                tile.wall = mossWall;
                Point point2 = new Point(point1.X - 1, point1.Y);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X + 1, point1.Y);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X, point1.Y - 1);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X, point1.Y + 1);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
              }
            }
          }
        }
      }

      public static void Gem(int x, int y)
      {
        if (!WorldGen.InWorld(x, y))
          return;
        List<Point> pointList = new List<Point>();
        List<Point> collection = new List<Point>();
        HashSet<Point> pointSet = new HashSet<Point>();
        collection.Add(new Point(x, y));
        while (collection.Count > 0)
        {
          pointList.Clear();
          pointList.AddRange((IEnumerable<Point>) collection);
          collection.Clear();
          while (pointList.Count > 0)
          {
            Point point1 = pointList[0];
            if (!WorldGen.InWorld(point1.X, point1.Y, 1))
            {
              pointList.Remove(point1);
            }
            else
            {
              pointSet.Add(point1);
              pointList.Remove(point1);
              Tile tile1 = Main.tile[point1.X, point1.Y];
              if (WorldGen.SolidTile(point1.X, point1.Y) || tile1.wall != (ushort) 0)
              {
                if (tile1.active())
                {
                  if (WorldGen.Spread.Gemmable((int) tile1.type))
                    tile1.type = WorldGen.randGemTile();
                  Tile tile2 = Main.tile[point1.X - 1, point1.Y];
                  if (WorldGen.Spread.Gemmable((int) tile2.type))
                    tile2.type = WorldGen.randGemTile();
                  Tile tile3 = Main.tile[point1.X + 1, point1.Y];
                  if (WorldGen.Spread.Gemmable((int) tile3.type))
                    tile3.type = WorldGen.randGemTile();
                  Tile tile4 = Main.tile[point1.X, point1.Y - 1];
                  if (WorldGen.Spread.Gemmable((int) tile4.type))
                    tile4.type = WorldGen.randGemTile();
                  Tile tile5 = Main.tile[point1.X, point1.Y + 1];
                  if (WorldGen.Spread.Gemmable((int) tile5.type))
                    tile5.type = WorldGen.randGemTile();
                }
              }
              else
              {
                tile1.wall = (ushort) (48 + WorldGen.randGem());
                if (!tile1.active() && WorldGen.genRand.Next(2) == 0)
                  WorldGen.PlaceTile(point1.X, point1.Y, 178, true, style: WorldGen.randGem());
                Point point2 = new Point(point1.X - 1, point1.Y);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X + 1, point1.Y);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X, point1.Y - 1);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X, point1.Y + 1);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
              }
            }
          }
        }
      }

      public static void Spider(int x, int y)
      {
        if (!WorldGen.InWorld(x, y))
          return;
        byte num = 62;
        List<Point> pointList = new List<Point>();
        List<Point> collection = new List<Point>();
        HashSet<Point> pointSet = new HashSet<Point>();
        collection.Add(new Point(x, y));
        while (collection.Count > 0)
        {
          pointList.Clear();
          pointList.AddRange((IEnumerable<Point>) collection);
          collection.Clear();
          while (pointList.Count > 0)
          {
            Point point1 = pointList[0];
            if (!WorldGen.InWorld(point1.X, point1.Y, 1))
            {
              pointList.Remove(point1);
            }
            else
            {
              pointSet.Add(point1);
              pointList.Remove(point1);
              Tile tile = Main.tile[point1.X, point1.Y];
              if (WorldGen.SolidTile(point1.X, point1.Y) || tile.wall != (ushort) 0)
              {
                if (tile.active() && tile.wall == (ushort) 0)
                  tile.wall = (ushort) num;
              }
              else
              {
                tile.wall = (ushort) num;
                WorldGen.SquareWallFrame(point1.X, point1.Y);
                if (!tile.active())
                {
                  tile.liquid = (byte) 0;
                  tile.lava(false);
                  if (WorldGen.SolidTile(point1.X, point1.Y + 1) && WorldGen.genRand.Next(3) == 0)
                  {
                    if (WorldGen.genRand.Next(15) == 0)
                      WorldGen.AddBuriedChest(point1.X, point1.Y, 939, true, 15);
                    else
                      WorldGen.PlacePot(point1.X, point1.Y, style: WorldGen.genRand.Next(19, 21));
                  }
                  if (!tile.active())
                  {
                    if (WorldGen.SolidTile(point1.X, point1.Y - 1) && WorldGen.genRand.Next(3) == 0)
                      WorldGen.PlaceTight(point1.X, point1.Y, true);
                    else if (WorldGen.SolidTile(point1.X, point1.Y + 1))
                    {
                      WorldGen.PlaceTile(point1.X, point1.Y, 187, true, style: (9 + WorldGen.genRand.Next(5)));
                      if (WorldGen.genRand.Next(3) == 0)
                      {
                        if (!tile.active())
                          WorldGen.PlaceSmallPile(point1.X, point1.Y, 34 + WorldGen.genRand.Next(4), 1);
                        if (!tile.active())
                          WorldGen.PlaceSmallPile(point1.X, point1.Y, 48 + WorldGen.genRand.Next(6), 0);
                      }
                    }
                  }
                }
                Point point2 = new Point(point1.X - 1, point1.Y);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X + 1, point1.Y);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X, point1.Y - 1);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X, point1.Y + 1);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
              }
            }
          }
        }
      }

      public static void WallDungeon(int x, int y, int wallType)
      {
        if (!WorldGen.InWorld(x, y))
          return;
        ushort num = (ushort) wallType;
        List<Point> pointList = new List<Point>();
        List<Point> collection = new List<Point>();
        HashSet<Point> pointSet = new HashSet<Point>();
        collection.Add(new Point(x, y));
        while (collection.Count > 0)
        {
          pointList.Clear();
          pointList.AddRange((IEnumerable<Point>) collection);
          collection.Clear();
          while (pointList.Count > 0)
          {
            Point point1 = pointList[0];
            if (!WorldGen.InWorld(point1.X, point1.Y, 1))
            {
              pointList.Remove(point1);
            }
            else
            {
              pointSet.Add(point1);
              pointList.Remove(point1);
              Tile tile = Main.tile[point1.X, point1.Y];
              if (!WorldGen.SolidTile(point1.X, point1.Y) && (int) tile.wall != (int) num && tile.wall > (ushort) 0 && tile.wall != (ushort) 244)
              {
                tile.wall = num;
                Point point2 = new Point(point1.X - 1, point1.Y);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X + 1, point1.Y);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X, point1.Y - 1);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
                point2 = new Point(point1.X, point1.Y + 1);
                if (!pointSet.Contains(point2))
                  collection.Add(point2);
              }
              else if (tile.active())
                tile.wall = num;
            }
          }
        }
      }

      private static bool Gemmable(int type) => type == 0 || type == 1 || type == 40 || type == 59 || type == 60 || type == 70 || type == 147 || type == 161;
    }

    public static class TenthAnniversaryWorldInfo
    {
      public static int[] GoodPrefixIdsForAccessory = new int[4]
      {
        65,
        68,
        72,
        76
      };
      public static int[] GoodPrefixIdsForMeleeWeapon = new int[3]
      {
        81,
        59,
        57
      };
      public static int[] GoodPrefixIdsForRangedWeapon = new int[3]
      {
        82,
        57,
        60
      };
      public static int[] GoodPrefixIdsForMagicWeapon = new int[3]
      {
        83,
        57,
        60
      };
      public static int[] GoodPrefixIdsForSummonerWeapon = new int[3]
      {
        83,
        57,
        60
      };
    }

    public struct GrowTreeSettings
    {
      public ushort TreeTileType;
      public int TreeHeightMin;
      public int TreeHeightMax;
      public int TreeTopPaddingNeeded;
      public WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest GroundTest;
      public WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack WallTest;
      public ushort SaplingTileType;

      public delegate bool IsTileFitForTreeGroundTest(int tileType);

      public delegate bool IsWallTypeFitForTreeBack(int wallType);

      public static class Profiles
      {
        public static WorldGen.GrowTreeSettings GemTree_Ruby = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.GemTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.GemTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 587,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 590
        };
        public static WorldGen.GrowTreeSettings GemTree_Diamond = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.GemTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.GemTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 588,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 590
        };
        public static WorldGen.GrowTreeSettings GemTree_Topaz = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.GemTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.GemTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 583,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 590
        };
        public static WorldGen.GrowTreeSettings GemTree_Amethyst = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.GemTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.GemTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 584,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 590
        };
        public static WorldGen.GrowTreeSettings GemTree_Sappphire = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.GemTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.GemTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 585,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 590
        };
        public static WorldGen.GrowTreeSettings GemTree_Emerald = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.GemTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.GemTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 586,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 590
        };
        public static WorldGen.GrowTreeSettings GemTree_Amber = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.GemTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.GemTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 589,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 590
        };
        public static WorldGen.GrowTreeSettings VanityTree_Sakura = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.VanityTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.DefaultTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 596,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 595
        };
        public static WorldGen.GrowTreeSettings VanityTree_Willow = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.VanityTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.DefaultTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 616,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 615
        };
        public static WorldGen.GrowTreeSettings Tree_Ash = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.AshTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.DefaultTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 634,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 20
        };

        public static bool TryGetFromItemId(int itemType, out WorldGen.GrowTreeSettings profile)
        {
          switch (itemType)
          {
            case 4851:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Topaz;
              return true;
            case 4852:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Amethyst;
              return true;
            case 4853:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Sappphire;
              return true;
            case 4854:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Emerald;
              return true;
            case 4855:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Ruby;
              return true;
            case 4856:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Diamond;
              return true;
            case 4857:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Amber;
              return true;
            case 4871:
              profile = WorldGen.GrowTreeSettings.Profiles.VanityTree_Sakura;
              return true;
            case 4907:
              profile = WorldGen.GrowTreeSettings.Profiles.VanityTree_Willow;
              return true;
            default:
              profile = new WorldGen.GrowTreeSettings();
              return false;
          }
        }

        public static bool TryGetFromTreeId(int tileType, out WorldGen.GrowTreeSettings profile)
        {
          switch (tileType)
          {
            case 583:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Topaz;
              return true;
            case 584:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Amethyst;
              return true;
            case 585:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Sappphire;
              return true;
            case 586:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Emerald;
              return true;
            case 587:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Ruby;
              return true;
            case 588:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Diamond;
              return true;
            case 589:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Amber;
              return true;
            case 596:
              profile = WorldGen.GrowTreeSettings.Profiles.VanityTree_Sakura;
              return true;
            case 616:
              profile = WorldGen.GrowTreeSettings.Profiles.VanityTree_Willow;
              return true;
            case 634:
              profile = WorldGen.GrowTreeSettings.Profiles.Tree_Ash;
              return true;
            default:
              profile = new WorldGen.GrowTreeSettings();
              return false;
          }
        }
      }
    }

    public struct CheckTreeSettings
    {
      public WorldGen.CheckTreeSettings.GroundValidTest IsGroundValid;

      public delegate bool GroundValidTest(int groundTileType);
    }

    public enum SpecialKillTileContext
    {
      None,
      MowingTheGrass,
    }

    public delegate bool GetTreeFoliageDataMethod(
      int i,
      int j,
      int xoffset,
      ref int treeFrame,
      ref int treeStyle,
      out int floorY,
      out int topTextureFrameWidth,
      out int topTextureFrameHeight);

    public struct TileMergeCullCache
    {
      public bool CullTop;
      public bool CullBottom;
      public bool CullLeft;
      public bool CullRight;
      public bool CullTopLeft;
      public bool CullTopRight;
      public bool CullBottomLeft;
      public bool CullBottomRight;

      public void Cull(
        ref int up,
        ref int down,
        ref int left,
        ref int right,
        ref int upLeft,
        ref int upRight,
        ref int downLeft,
        ref int downRight)
      {
        if (this.CullTop)
          up = -1;
        if (this.CullBottom)
          down = -1;
        if (this.CullLeft)
          left = -1;
        if (this.CullRight)
          right = -1;
        if (this.CullTopLeft)
          upLeft = -1;
        if (this.CullTopRight)
          upRight = -1;
        if (this.CullBottomLeft)
          downLeft = -1;
        if (!this.CullBottomRight)
          return;
        downRight = -1;
      }
    }
  }
}
